@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    addPreferencesFromResource(getPreferencesResourceId())    final Preference adFreePreference=findPreference(getAdFreePreferenceId())    adFreePreference.setEnabled(false)    BillingController.registerObserver(defaultBillingObserver)    BillingController.checkBillingSupported(AbstractAdFreePreferenceActivity.this)    final String clearBillingDataPreferenceId=getClearBillingDataPreferenceId()    if (clearBillingDataPreferenceId != null) {     final Preference clearBillingInfoPreference=findPreference(clearBillingDataPreferenceId)      if (clearBillingInfoPreference != null) {       clearBillingInfoPreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){         @Override public boolean onPreferenceClick(        Preference preference){           Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_clearing,Toast.LENGTH_SHORT).show()            removeBillingInformation(AbstractAdFreePreferenceActivity.this,PreferenceManager.getDefaultSharedPreferences(AbstractAdFreePreferenceActivity.this))            return true          }       } )      }   } } 
@Override public boolean onPreferenceClick(Preference preference){   Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_clearing,Toast.LENGTH_SHORT).show()    removeBillingInformation(AbstractAdFreePreferenceActivity.this,PreferenceManager.getDefaultSharedPreferences(AbstractAdFreePreferenceActivity.this))    return true  } 
protected abstract int getPreferencesResourceId()  
@Nullable protected abstract String getClearBillingDataPreferenceId()  
@Nonnull protected abstract String getAdFreeProductId()  
@Nonnull protected abstract String getAdFreePreferenceId()  
public static void removeBillingInformation(@Nonnull Context context,@Nonnull SharedPreferences preferences){   final SharedPreferences.Editor editor=preferences.edit()    editor.putBoolean(AbstractBillingObserver.KEY_TRANSACTIONS_RESTORED,false)    editor.commit()    BillingController.dropBillingData(context)  } 
private void setAdFreeAction(){   final Preference adFreePreference=findPreference(getAdFreePreferenceId())    if (!AdsController.getInstance().isAdFree(this)) {     Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Ad free is not purchased - enable preference!")      adFreePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){       public boolean onPreferenceClick(      Preference preference){         if (BillingController.checkBillingSupported(AbstractAdFreePreferenceActivity.this) != BillingController.BillingStatus.SUPPORTED) {           Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Billing is not supported - warn user!")            Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_error,Toast.LENGTH_LONG).show()          }  else {           Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Billing is supported - continue!")            if (!AdsController.getInstance().isAdFree(AbstractAdFreePreferenceActivity.this)) {             Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Item not purchased - try to purchase!")              Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_purchasing,Toast.LENGTH_SHORT).show()              BillingController.requestPurchase(AbstractAdFreePreferenceActivity.this,getAdFreeProductId(),true)            }  else {             adFreePreference.setEnabled(false)              Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_already_purchased,Toast.LENGTH_SHORT).show()            }         }         return true        }     } )      adFreePreference.setEnabled(true)    }  else {     Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Ad free is not purchased - disable preference!")      adFreePreference.setEnabled(false)    } } 
public boolean onPreferenceClick(Preference preference){   if (BillingController.checkBillingSupported(AbstractAdFreePreferenceActivity.this) != BillingController.BillingStatus.SUPPORTED) {     Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Billing is not supported - warn user!")      Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_error,Toast.LENGTH_LONG).show()    }  else {     Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Billing is supported - continue!")      if (!AdsController.getInstance().isAdFree(AbstractAdFreePreferenceActivity.this)) {       Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Item not purchased - try to purchase!")        Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_purchasing,Toast.LENGTH_SHORT).show()        BillingController.requestPurchase(AbstractAdFreePreferenceActivity.this,getAdFreeProductId(),true)      }  else {       adFreePreference.setEnabled(false)        Toast.makeText(AbstractAdFreePreferenceActivity.this,R.string.c_billing_already_purchased,Toast.LENGTH_SHORT).show()      }   }   return true  } 
@Override protected void onDestroy(){   BillingController.unregisterObserver(defaultBillingObserver)    super.onDestroy()  } 
@Override public void onCheckBillingSupportedResponse(boolean supported){   if (supported) {     setAdFreeAction()    }  else {     final Preference adFreePreference=findPreference(getAdFreePreferenceId())      adFreePreference.setEnabled(false)      Log.d(AbstractAdFreePreferenceActivity.class.getName(),"Billing is not supported!")    } } 
@Override public void onPurchaseIntentOK(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){ } 
@Override public void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){ } 
@Override public void onPurchaseStateChanged(@Nonnull String itemId,@Nonnull Transaction.PurchaseState state){   if (getAdFreeProductId().equals(itemId)) {     final Preference adFreePreference=findPreference(getAdFreePreferenceId())      if (adFreePreference != null) { switch (state) { case PURCHASED:         adFreePreference.setEnabled(false)        Activities.restartActivity(this)      break  case CANCELLED:   adFreePreference.setEnabled(true)  break  case REFUNDED: adFreePreference.setEnabled(true)  break  } }  else { } } } 
@Override public void onRequestPurchaseResponse(@Nonnull String itemId,@Nonnull ResponseCode response){ } 
@Override public void onTransactionsRestored(){ } 
@Override public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode){ } 
private AdsController(){ } 
@Nonnull public static AdsController getInstance(){   return instance  } 
@Nonnull public AdView createAndInflateAdView(@Nonnull Activity activity,@Nonnull String admobAccountId,@Nullable ViewGroup parentView,int layoutId,@Nonnull List<String> keywords){   final ViewGroup layout=parentView != null ? parentView : (ViewGroup)activity.findViewById(layoutId)    final AdView adView=new AdView(activity,AdSize.SMART_BANNER,admobAccountId)    layout.addView(adView)    final AdRequest adRequest=new AdRequest()    for (  String keyword : keywords) {     adRequest.addKeyword(keyword)    }   adView.loadAd(adRequest)    return adView  } 
public void init(@Nonnull Application application,@Nonnull String admobUserId,@Nonnull String adFreeProductId,@Nonnull BillingController.IConfiguration configuration){   this.admobUserId=admobUserId    this.adFreeProductId=adFreeProductId    BillingDB.init(application)    BillingController.setConfiguration(configuration)    this.initialized=true  } 
private boolean isAdFreePurchased(@Nonnull Context context){   return BillingController.isPurchased(context.getApplicationContext(),adFreeProductId)  } 
public boolean isAdFree(@Nonnull Context context){   boolean purchased=isAdFreePurchased(context)    if (!purchased) {     if (!AbstractBillingObserver.isTransactionsRestored(context)) {       BillingController.restoreTransactions(context)        purchased=isAdFreePurchased(context)      }   }   return purchased  } 
@Nullable public AdView inflateAd(@Nonnull Activity activity,@Nullable ViewGroup parentView,int parentViewId){   AdView result=null    if (!isAdFree(activity)) {     Log.d(activity.getClass().getName(),"Application is not ad free - inflating ad!")      final List<String> keywords=Collections.emptyList()      result=createAndInflateAdView(activity,admobUserId,parentView,parentViewId,keywords)    }  else {     Log.d(activity.getClass().getName(),"Application is ad free - no ads!")    }   return result  } 
@Nullable public AdView inflateAd(@Nonnull Activity activity){   return inflateAd(activity,null,R.id.ad_parent_view)  } 
private void checkState(){   if (!initialized) {     throw new IllegalStateException(AdsController.class.getName() + " must be initialized before usage!")    } } 
public AdViewPreference(Context context){   super(context,null)  } 
public AdViewPreference(Context context,AttributeSet attrs){   super(context,attrs)  } 
@Override protected View onCreateView(ViewGroup parent){   View view=super.onCreateView(parent)    if (view instanceof ViewGroup) {     adView=AdsController.getInstance().inflateAd((Activity)getContext(),((ViewGroup)view),0)    }   return view  } 
private App(){   throw new AssertionError()  } 
public static <A extends Application & ServiceLocator>void init(@Nonnull A application){   init(application,new UiThreadExecutor(),Listeners.newEventBus(),application)  } 
public static void init(@Nonnull Application application,@Nullable ServiceLocator serviceLocator){   init(application,new UiThreadExecutor(),Listeners.newEventBus(),serviceLocator)  } 
public static void init(@Nonnull Application application,@Nonnull UiThreadExecutor uiThreadExecutor,@Nonnull JEventListeners<JEventListener<? extends JEvent>,JEvent> eventBus,@Nullable ServiceLocator serviceLocator){   if (!initialized) {     App.application=application      App.uiThreadExecutor=uiThreadExecutor      App.eventBus=eventBus      if (serviceLocator != null) {       App.locator=serviceLocator      }  else {       App.locator=new ServiceLocator(){       }       }     App.initialized=true    }  else {     throw new IllegalStateException("Already initialized!")    } } 
private static void checkInit(){   if (!initialized) {     throw new IllegalStateException("App should be initialized!")    } } 
/**   * @return if App has already been initialized, false otherwise  */ public static boolean isInitialized(){   return initialized  } 
/**   * @param < A > real type of application  * @return application instance which was provided in {@link App#init(android.app.Application)} method  */ @Nonnull public static <A extends Application>A getApplication(){   checkInit()    return (A)application  } 
/**   * @param < L > real type of service locator  * @return instance of service locator user in application  */ @Nonnull public static <L extends ServiceLocator>L getLocator(){   checkInit()    return (L)locator  } 
/**   * Method returns executor which runs on Main Application's thread. It's safe to do all UI work on this executor  * @return UI thread executor  */ @Nonnull public static DelayedExecutor getUiThreadExecutor(){   checkInit()    return uiThreadExecutor  } 
/**   * @return application's event bus  */ @Nonnull public static JEventListeners<JEventListener<? extends JEvent>,JEvent> getEventBus(){   checkInit()    return eventBus  } 
@Nonnull public static SecretKey getSecretKey(@Nonnull Context context) throws CiphererException {   if (secretKey == null) {     final byte[] salt=getSalt()      final String password=BillingSecurity.generatePassword(context)      secretKey=getTransactionObfuscator().getSecretKeyProvider().getSecretKey(password,salt)    }   return secretKey  } 
/**   * Returns a salt for the obfuscation of purchases in local memory. NOTE: this array must be the same during different application starts or user must call the net.robotmedia.billing.BillingController#restoreTransactions(android.content.Context) method to get all transaction from market  * @return array of 20 random bytes.  */ public byte[] getObfuscationSalt()  
/**   * Returns the public key used to verify the signature of responses of the Market Billing service.  * @return Base64 encoded public key.  */ public String getPublicKey()  
/**   * Adds the specified notification to the set of manual confirmations of the specified item.  * @param productId      id of the item.  * @param notificationId id of the notification.  */ private static void addManualConfirmation(@Nonnull String productId,@Nonnull String notificationId){ synchronized (manualConfirmations) {     Set<String> notifications=manualConfirmations.get(productId)      if (notifications == null) {       notifications=new HashSet<String>()        manualConfirmations.put(productId,notifications)      }     notifications.add(notificationId)    } } 
/**   * Returns the current billing status. NOTE: current billing status may be not the same as the actual status needs some time to update (but nevertheless it can be used as first approach) This method calls billing service to determine the exact status and notify listeners through IBillingObserver#onCheckBillingSupportedResponse(boolean) method  * @param context context  * @return the current billing status (unknown, supported or unsupported)  * @see IBillingObserver#onCheckBillingSupportedResponse(boolean)  */ @Nonnull public static BillingStatus checkBillingSupported(@Nonnull Context context){   BillingService.checkBillingSupported(context)    return status  } 
/**   * Called after the response to a {@link net.robotmedia.billing.BillingRequest.CheckBillingSupported} request isreceived.  * @param supported billing supported  */ static void onCheckBillingSupportedResponse(boolean supported){   status=supported ? BillingStatus.SUPPORTED : BillingStatus.UNSUPPORTED    BillingObserverRegistry.onCheckBillingSupportedResponse(supported)  } 
/**   * Requests to confirm all pending MANUAL notifications for the specified item.  * @param context   context  * @param productId id of the item whose purchase must be confirmed.  * @return true if pending notifications for this item were found, falseotherwise.  */ public static boolean confirmNotifications(@Nonnull Context context,@Nonnull String productId){ synchronized (manualConfirmations) {     final Set<String> notifications=manualConfirmations.get(productId)      if (notifications != null) {       confirmNotifications(context,notifications)        return true      }  else {       return false      }   } } 
/**   * Requests to confirm all specified notifications.  * @param context   context  * @param notifyIds array with the ids of all the notifications to confirm.  */ private static void confirmNotifications(@Nonnull Context context,@Nonnull String[] notifyIds){   BillingService.confirmNotifications(context,notifyIds)  } 
/**   * Requests to confirm all specified notifications.  * @param context   context  * @param notifyIds array with the ids of all the notifications to confirm.  */ private static void confirmNotifications(@Nonnull Context context,@Nonnull Collection<String> notifyIds){   BillingService.confirmNotifications(context,notifyIds)  } 
/**   * Returns the number of purchases for the specified item. Only transactions with state PURCHASED are counted  * @param context   context  * @param productId id of the item whose purchases will be counted.  * @return number of purchases for the specified item.  */ public static int countPurchases(@Nonnull Context context,@Nonnull String productId){ } 
protected static void debug(@Nullable String message){   if (debug && message != null) {     Log.d(LOG_TAG,message)    } } 
/**   * Requests purchase information for the specified notification. Immediately followed by a call to {@link #onPurchaseStateChanged(android.content.Context,String,String)}, if the request is successful.  * @param context  context  * @param notifyId id of the notification whose purchase information isrequested.  */ private static void getPurchaseInformation(@Nonnull Context context,@Nonnull String notifyId){   final long nonce=Security.generateNonce()    BillingService.getPurchaseInformation(context,new String[]{notifyId},nonce)  } 
/**   * Gets the salt from the configuration and logs a warning if it's null.  * @return salt.  */ @Nullable private static byte[] getSalt(){   byte[] salt=null    if (configuration == null || ((salt=configuration.getObfuscationSalt()) == null)) {     Log.w(LOG_TAG,"Can't (un)obfuscate purchases without salt")    }   return salt  } 
/**   * Lists all transactions stored locally, including cancellations and refunds.  * @param context context  * @return list of transactions.  */ @Nonnull public static List<Transaction> getTransactions(@Nonnull Context context){   final List<Transaction> transactions=TransactionManager.getTransactions()    ObfuscateUtils.unobfuscate(context,transactions,getSalt())    return transactions  } 
/**   * Lists all transactions of the specified item, stored locally.  * @param context   context  * @param productId id of the item whose transactions will be returned.  * @return list of transactions.  */ @Nonnull public static List<Transaction> getTransactions(@Nonnull Context context,@Nonnull String productId){ } 
/**   * Returns true if the specified item has been registered as purchased in local memory. Note that if the item was later canceled or refunded this will still return true. Also note that the item might have been purchased in another installation, but not yet registered in this one.  * @param context   context  * @param productId item id.  * @return true if the specified item is purchased, false otherwise.  */ public static boolean isPurchased(@Nonnull Context context,@Nonnull String productId){ } 
/**   * Called when an IN_APP_NOTIFY message is received.  * @param context  context  * @param notifyId notification id.  */ protected static void onNotify(@Nonnull Context context,@Nonnull String notifyId){   debug("Notification " + notifyId + " available")    getPurchaseInformation(context,notifyId)  } 
/**   * Called after the response to a {@link net.robotmedia.billing.BillingRequest.GetPurchaseInformation} request isreceived. Registers all transactions in local memory and confirms those who can be confirmed automatically.  * @param context    context  * @param signedData signed JSON data received from the Market Billing service.  * @param signature  data signature.  */ protected static void onPurchaseStateChanged(@Nonnull Context context,@Nullable String signedData,@Nullable String signature){   debug("Purchase state changed")    if (TextUtils.isEmpty(signedData)) {     Log.w(LOG_TAG,"Signed data is empty")      return    }   if (!debug) {     if (TextUtils.isEmpty(signature)) {       Log.w(LOG_TAG,"Empty signature requires debug mode")        return      }     final ISignatureValidator validator=getSignatureValidator()      if (!validator.validate(signedData,signature)) {       Log.w(LOG_TAG,"Signature does not match data.")        return      }   }   List<Transaction> transactions    try {     final JSONObject jObject=new JSONObject(signedData)      if (!verifyNonce(jObject)) {       Log.w(LOG_TAG,"Invalid nonce")        return      }     transactions=parseTransactions(jObject)    }  catch (  JSONException e) {     Log.e(LOG_TAG,"JSON exception: ",e)      return    }   final List<String> confirmations=new ArrayList<String>()    for (  Transaction transaction : transactions) {     if (transaction.notificationId != null) { synchronized (automaticConfirmations) {         if (automaticConfirmations.contains(transaction.productId)) {           confirmations.add(transaction.notificationId)          }  else {           addManualConfirmation(transaction.productId,transaction.notificationId)          }       }     }     storeTransaction(context,transaction)      BillingObserverRegistry.notifyPurchaseStateChange(transaction.productId,transaction.purchaseState)    }   if (!confirmations.isEmpty()) {     final String[] notifyIds=confirmations.toArray(new String[confirmations.size()])      confirmNotifications(context,notifyIds)    } } 
/**   * Called after a  {@link BillingRequest} issent.  * @param requestId the id the request.  * @param request   the billing request.  */ protected static void onRequestSent(long requestId,@Nonnull IBillingRequest request){   debug("Request " + requestId + " of type "+ request.getRequestType()+ " sent")    if (request.isSuccess()) { synchronized (pendingRequests) {       pendingRequests.put(requestId,request)      }   }  else   if (request.hasNonce()) {     Security.removeNonce(request.getNonce())    } } 
/**   * Called after a  {@link BillingRequest} issent.  * @param requestId    the id of the request.  * @param responseCode the response code.  * @see ResponseCode  */ protected static void onResponseCode(long requestId,int responseCode){   final ResponseCode response=ResponseCode.valueOf(responseCode)    debug("Request " + requestId + " received response "+ response)  synchronized (pendingRequests) {     final IBillingRequest request=pendingRequests.get(requestId)      if (request != null) {       pendingRequests.remove(requestId)        request.onResponseCode(response)      }   } } 
/**   * Parse all purchases from the JSON data received from the Market Billing service.  * @param data JSON data received from the Market Billing service.  * @return list of purchases.  * @throws org.json.JSONException if the data couldn't be properly parsed.  */ @Nonnull private static List<Transaction> parseTransactions(@Nonnull JSONObject data) throws JSONException {   final List<Transaction> result=new ArrayList<Transaction>()    final JSONArray orders=data.optJSONArray(JSON_ORDERS)    if (orders != null) {     for (int i=0  i < orders.length()  i++) {       final JSONObject jElement=orders.getJSONObject(i)        result.add(Transaction.newInstance(jElement))      }   }   return result  } 
/**   * Requests the purchase of the specified item. The transaction will not be confirmed automatically.  * @param context   context  * @param productId id of the item to be purchased.  * @see #requestPurchase(android.content.Context,String,boolean)  */ public static void requestPurchase(@Nonnull Context context,@Nonnull String productId){   requestPurchase(context,productId,false)  } 
/**   * Requests the purchase of the specified item with optional automatic confirmation.  * @param context          context  * @param productId        id of the item to be purchased.  * @param autoConfirmation if true, the transaction will be confirmed automatically. Iffalse, the transaction will have to be confirmed with a call to  {@link #confirmNotifications(android.content.Context,String)}.  * @see IBillingObserver#onPurchaseIntentOK(String,android.app.PendingIntent)  */ public static void requestPurchase(@Nonnull Context context,@Nonnull String productId,boolean autoConfirmation){   if (autoConfirmation) { synchronized (automaticConfirmations) {       automaticConfirmations.add(productId)      }   }   BillingService.requestPurchase(context,productId,null)  } 
/**   * Requests to restore all transactions.  * @param context context  */ public static void restoreTransactions(@Nonnull Context context){   Log.d(BillingController.class.getSimpleName(),"Restoring transactions...")    final long nonce=Security.generateNonce()    BillingService.restoreTransactions(context,nonce)  } 
/**   * Sets the configuration instance of the controller.  * @param config configuration instance.  */ public static void setConfiguration(IConfiguration config){   configuration=config  } 
/**   * Sets debug mode.  * @param debug debug  */ public static void setDebug(boolean debug){   BillingController.debug=debug  } 
public static boolean isDebug(){   return debug  } 
@SuppressWarnings({"UnusedDeclaration"}) public static void setSignatureValidator(ISignatureValidator validator){   BillingController.validator=validator  } 
@Nonnull static ISignatureValidator getSignatureValidator(){   return BillingController.validator != null ? BillingController.validator : new DefaultSignatureValidator(BillingController.configuration)  } 
/**   * Starts the specified purchase intent with the specified activity.  * @param context        context  * @param purchaseIntent purchase intent.  * @param intent         intent  */ public static void startPurchaseIntent(@Nonnull Context context,@Nonnull PendingIntent purchaseIntent,@Nullable Intent intent){   if (Compatibility.isStartIntentSenderSupported(context)) {     Compatibility.startIntentSender(context,purchaseIntent.getIntentSender(),intent)    }  else {     try {       purchaseIntent.send(context,0,intent)      }  catch (    CanceledException e) {       Log.e(LOG_TAG,"Error starting purchase intent",e)      }   } } 
static void storeTransaction(@Nonnull Context context,@Nonnull Transaction t){   final Transaction clone=t.clone()    ObfuscateUtils.obfuscate(context,clone,getSalt())    TransactionManager.addTransaction(clone)  } 
private static boolean verifyNonce(@Nonnull JSONObject data){   long nonce=data.optLong(JSON_NONCE)    if (Security.isNonceKnown(nonce)) {     Security.removeNonce(nonce)      return true    }  else {     return false    } } 
public static void dropBillingData(@Nonnull Context context){   Log.d(BillingController.class.getSimpleName(),"Dropping billing database...")    TransactionManager.dropDatabase(context)  } 
static void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response){   BillingObserverRegistry.onRequestPurchaseResponse(productId,response)  } 
static void onPurchaseIntent(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){   BillingObserverRegistry.onPurchaseIntent(productId,purchaseIntent)  } 
static void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){   BillingObserverRegistry.onPurchaseIntentFailure(productId,responseCode)  } 
static void onTransactionsRestored(){   BillingObserverRegistry.onTransactionsRestored()  } 
static void onErrorRestoreTransactions(@Nonnull ResponseCode response){   BillingObserverRegistry.onErrorRestoreTransactions(response)  } 
public static void registerObserver(@Nonnull IBillingObserver billingObserver){   BillingObserverRegistry.registerObserver(billingObserver)  } 
public static void unregisterObserver(@Nonnull IBillingObserver billingObserver){   BillingObserverRegistry.unregisterObserver(billingObserver)  } 
@Nonnull static SecurityService<Transaction,Transaction,byte[]> getTransactionObfuscator(){   if (transactionObfuscator == null) {     transactionObfuscator=BillingSecurity.getObfuscationSecurityService(AESObfuscator.IV,AESObfuscator.SECURITY_PREFIX)    }   return transactionObfuscator  } 
static void onCheckBillingSupportedResponse(boolean supported){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onCheckBillingSupportedResponse(supported)    } } 
/**   * Called after the response to a {@link net.robotmedia.billing.BillingRequest.Purchase} request isreceived.  * @param productId      id of the item whose purchase was requested.  * @param purchaseIntent intent to purchase the item.  */ static void onPurchaseIntent(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onPurchaseIntentOK(productId,purchaseIntent)    } } 
static void onTransactionsRestored(){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onTransactionsRestored()    } } 
/**   * Registers the specified billing observer.  * @param observer the billing observer to add.  * @return true if the observer wasn't previously registered, falseotherwise.  * @see #unregisterObserver(IBillingObserver)  */ static boolean registerObserver(@Nonnull IBillingObserver observer){ synchronized (observers) {     return observers.add(observer)    } } 
/**   * Unregisters the specified billing observer.  * @param observer the billing observer to unregister.  * @return true if the billing observer was unregistered, false otherwise.  * @see #registerObserver(IBillingObserver)  */ static boolean unregisterObserver(@Nonnull IBillingObserver observer){ synchronized (observers) {     return observers.remove(observer)    } } 
/**   * Notifies observers of the purchase state change of the specified item.  * @param productId id of the item whose purchase state has changed.  * @param state     new purchase state of the item.  */ static void notifyPurchaseStateChange(@Nonnull String productId,@Nonnull Transaction.PurchaseState state){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onPurchaseStateChanged(productId,state)    } } 
@Nonnull private static List<IBillingObserver> getSynchronizedObservers(){   final List<IBillingObserver> result  synchronized (observers) {     result=new ArrayList<IBillingObserver>(observers)    }   return result  } 
static void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onRequestPurchaseResponse(productId,response)    } } 
public static void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onPurchaseIntentFailure(productId,responseCode)    } } 
public static void onErrorRestoreTransactions(@Nonnull ResponseCode response){   for (  IBillingObserver o : getSynchronizedObservers()) {     o.onErrorRestoreTransactions(response)    } } 
@Override public void onReceive(@Nonnull Context context,@Nonnull Intent intent){   final String action=intent.getAction()    BillingController.debug("Received " + action)    final BillingResponseType responseType=BillingResponseType.fromIntentAction(intent)    if (responseType != null) {     responseType.doAction(context,intent)    }  else {     Log.w(this.getClass().getSimpleName(),"Unexpected action: " + action)    } } 
public BillingRequest(@Nonnull String packageName,int startId){   this.packageName=packageName    this.startId=startId  } 
public BillingRequest(@Nonnull String packageName,int startId,long nonce){   this.packageName=packageName    this.startId=startId    this.nonce=nonce  } 
protected void addParams(@Nonnull Bundle request){ } 
@Override public long getNonce(){   return nonce  } 
@Override public boolean hasNonce(){   return false  } 
@Override public boolean isSuccess(){   return success  } 
@Nonnull private Bundle makeRequestBundle(){   final Bundle request=new Bundle()    request.putString(KEY_BILLING_REQUEST,getRequestType().name())    request.putInt(KEY_API_VERSION,1)    request.putString(KEY_PACKAGE_NAME,packageName)    if (hasNonce()) {     request.putLong(KEY_NONCE,nonce)    }   return request  } 
@Override public void onResponseCode(@Nonnull ResponseCode response){ } 
protected void processOkResponse(@Nonnull Bundle response){ } 
protected void processNotOkResponse(@Nonnull Bundle response,@Nonnull ResponseCode responseCode){ } 
@Override public final long run(@Nonnull IMarketBillingService service) throws RemoteException {   final Bundle request=makeRequestBundle()    addParams(request)    final Bundle response=service.sendBillingRequest(request)    if (validateResponse(response)) {     processOkResponse(response)      return response.getLong(KEY_REQUEST_ID,IGNORE_REQUEST_ID)    }  else {     processNotOkResponse(response,ResponseCode.valueOf(response.getInt(KEY_RESPONSE_CODE)))      return IGNORE_REQUEST_ID    } } 
public void setNonce(long nonce){   this.nonce=nonce  } 
private boolean validateResponse(@Nonnull Bundle response){   final int responseCode=response.getInt(KEY_RESPONSE_CODE)    success=ResponseCode.isOk(responseCode)    if (!success) {     Log.w(this.getClass().getSimpleName(),"Error with response code " + ResponseCode.valueOf(responseCode))    }   return success  } 
@Override public int getStartId(){   return startId  } 
public CheckBillingSupported(String packageName,int startId){   super(packageName,startId)  } 
@Nonnull @Override public BillingRequestType getRequestType(){   return BillingRequestType.CHECK_BILLING_SUPPORTED  } 
@Override protected void processOkResponse(@Nonnull Bundle response){   final boolean supported=this.isSuccess()    BillingController.onCheckBillingSupportedResponse(supported)  } 
public ConfirmNotifications(@Nonnull String packageName,int startId,@Nonnull String[] notifyIds){   super(packageName,startId)    this.notifyIds=notifyIds  } 
@Override protected void addParams(@Nonnull Bundle request){   request.putStringArray(KEY_NOTIFY_IDS,notifyIds)  } 
@Nonnull @Override public BillingRequestType getRequestType(){   return BillingRequestType.CONFIRM_NOTIFICATIONS  } 
public GetPurchaseInformation(String packageName,int startId,String[] notifyIds,long nonce){   super(packageName,startId,nonce)    this.notifyIds=notifyIds  } 
@Override protected void addParams(@Nonnull Bundle request){   request.putStringArray(KEY_NOTIFY_IDS,notifyIds)  } 
@Nonnull @Override public BillingRequestType getRequestType(){   return BillingRequestType.GET_PURCHASE_INFORMATION  } 
@Override public boolean hasNonce(){   return true  } 
public Purchase(String packageName,int startId,String productId,String developerPayload){   super(packageName,startId)    this.productId=productId    this.developerPayload=developerPayload  } 
@Override protected void addParams(@Nonnull Bundle request){   request.putString(KEY_ITEM_ID,productId)    if (developerPayload != null) {     request.putString(KEY_DEVELOPER_PAYLOAD,developerPayload)    } } 
@Nonnull @Override public BillingRequestType getRequestType(){   return BillingRequestType.REQUEST_PURCHASE  } 
@Override public void onResponseCode(@Nonnull ResponseCode response){   super.onResponseCode(response)    BillingController.onRequestPurchaseResponse(productId,response)  } 
@Override protected void processOkResponse(@Nonnull Bundle response){   final PendingIntent purchaseIntent=response.getParcelable(KEY_PURCHASE_INTENT)    BillingController.onPurchaseIntent(productId,purchaseIntent)  } 
@Override protected void processNotOkResponse(@Nonnull Bundle response,@Nonnull ResponseCode responseCode){   BillingController.onPurchaseIntentFailure(productId,responseCode)  } 
public RestoreTransactions(String packageName,int startId,long nonce){   super(packageName,startId,nonce)  } 
@Nonnull @Override public BillingRequestType getRequestType(){   return BillingRequestType.RESTORE_TRANSACTIONS  } 
@Override public boolean hasNonce(){   return true  } 
@Override public void onResponseCode(@Nonnull ResponseCode response){   super.onResponseCode(response)    if (response == ResponseCode.RESULT_OK) {     BillingController.onTransactionsRestored()    }  else {     BillingController.onErrorRestoreTransactions(response)    } } 
static void checkBillingSupported(@Nonnull Context context){   context.startService(createIntent(context,BillingRequestType.CHECK_BILLING_SUPPORTED))  } 
static void confirmNotifications(@Nonnull Context context,@Nonnull String[] notifyIds){   final Intent intent=createIntent(context,BillingRequestType.CONFIRM_NOTIFICATIONS)    intent.putExtra(BillingRequestType.EXTRA_NOTIFY_IDS,notifyIds)    context.startService(intent)  } 
static void confirmNotifications(@Nonnull Context context,@Nonnull Collection<String> notifyIds){   confirmNotifications(context,notifyIds.toArray(new String[notifyIds.size()]))  } 
static void getPurchaseInformation(@Nonnull Context context,@Nonnull Collection<String> notifyIds,long nonce){   getPurchaseInformation(context,notifyIds.toArray(new String[notifyIds.size()]),nonce)  } 
static void getPurchaseInformation(@Nonnull Context context,@Nonnull String[] notifyIds,long nonce){   final Intent intent=createIntent(context,BillingRequestType.GET_PURCHASE_INFORMATION)    intent.putExtra(BillingRequestType.EXTRA_NOTIFY_IDS,notifyIds)    intent.putExtra(BillingRequestType.EXTRA_NONCE,nonce)    context.startService(intent)  } 
static void requestPurchase(@Nonnull Context context,@Nonnull String productId,@Nullable String developerPayload){   final Intent intent=createIntent(context,BillingRequestType.REQUEST_PURCHASE)    intent.putExtra(BillingRequestType.EXTRA_ITEM_ID,productId)    intent.putExtra(BillingRequestType.EXTRA_DEVELOPER_PAYLOAD,developerPayload)    context.startService(intent)  } 
static void restoreTransactions(@Nonnull Context context,long nonce){   final Intent intent=createIntent(context,BillingRequestType.RESTORE_TRANSACTIONS)    intent.setClass(context,BillingService.class)    intent.putExtra(BillingRequestType.EXTRA_NONCE,nonce)    context.startService(intent)  } 
@Nonnull private static Intent createIntent(@Nonnull Context context,@Nonnull BillingRequestType action){   final Intent result=new Intent(action.toIntentAction(context))    result.setClass(context,BillingService.class)    return result  } 
private void bindMarketBillingService(){   try {     final boolean bindResult=bindService(new Intent(ACTION_MARKET_BILLING_SERVICE),this,Context.BIND_AUTO_CREATE)      if (!bindResult) {       Log.e(this.getClass().getSimpleName(),"Could not bind to MarketBillingService")      }   }  catch (  SecurityException e) {     Log.e(this.getClass().getSimpleName(),"Could not bind to MarketBillingService",e)    } } 
@Override public IBinder onBind(Intent intent){   return null  } 
@Override public void onServiceConnected(ComponentName name,IBinder service){   BillingService.service=IMarketBillingService.Stub.asInterface(service)    runPendingRequests()  } 
@Override public void onServiceDisconnected(ComponentName name){   service=null  } 
@Override public void onStart(Intent intent,int startId){   handleCommand(intent,startId)  } 
public int onStartCommand(Intent intent,int flags,int startId){   handleCommand(intent,startId)    return Compatibility.START_NOT_STICKY  } 
private void handleCommand(@Nonnull Intent intent,int startId){   final BillingRequestType action=BillingRequestType.fromIntentAction(intent)    if (action != null) {     action.doAction(this,intent,startId)    } } 
/**   * @return 'true' if all requests (on the moment of start) were processed during current procedure. False is possible only if service was disconnected during processing  */ private boolean runPendingRequests(){   int maxStartId=-1  synchronized (pendingRequests) {     for (Iterator<IBillingRequest> it=pendingRequests.iterator()  it.hasNext()  ) {       final IBillingRequest request=it.next()        if (service != null) {         runRequest(service,request,1)          it.remove()          maxStartId=Math.max(maxStartId,request.getStartId())        }  else {         bindMarketBillingService()          return false        }     }   }   if (maxStartId >= 0) {     stopSelf(maxStartId)    }   return true  } 
private boolean runRequest(@Nonnull IMarketBillingService service,@Nonnull IBillingRequest request,int counter){   try {     BillingController.debug("Running request: " + request.getRequestType())      final long requestId=request.run(service)      BillingController.onRequestSent(requestId,request)      return true    }  catch (  RemoteException e) {     BillingController.debug("Remote exception: " + e.getMessage())      Log.w(this.getClass().getSimpleName(),"Remote billing service crashed")      if (counter < MAX_RETRIES) {       return runRequest(service,request,counter + 1)      }  else {       return false      }   } } 
@Override public void runRequestOrQueue(@Nonnull IBillingRequest request){ synchronized (pendingRequests) {     pendingRequests.add(request)    }   if (service == null) {     bindMarketBillingService()    }  else {     runPendingRequests()    } } 
@Override public void onDestroy(){   super.onDestroy()    if (service != null) {     try {       unbindService(this)      }  catch (    IllegalArgumentException e) {     }   } } 
/**   * Returns the billing status. If it's currently unknown, requests to check if billing is supported and {@link net.robotmedia.billing.helper.AbstractBillingActivity#onBillingChecked(boolean)} should becalled later with the result.  * @return the current billing status (unknown, supported or unsupported).  * @see net.robotmedia.billing.helper.AbstractBillingActivity#onBillingChecked(boolean)  */ public BillingStatus checkBillingSupported(){   return BillingController.checkBillingSupported(this)  } 
public abstract void onBillingChecked(boolean supported)  
@Override protected void onCreate(android.os.Bundle savedInstanceState){   super.onCreate(savedInstanceState)    mBillingObserver=new AbstractBillingObserver(this){     @Override public void onCheckBillingSupportedResponse(    boolean supported){       AbstractBillingActivity.this.onBillingChecked(supported)      }     @Override public void onPurchaseIntentFailure(    @Nonnull String productId,    @Nonnull ResponseCode responseCode){     }     @Override public void onPurchaseStateChanged(    @Nonnull String productId,    @Nonnull PurchaseState state){       AbstractBillingActivity.this.onPurchaseStateChanged(productId,state)      }     @Override public void onRequestPurchaseResponse(    @Nonnull String productId,    @Nonnull ResponseCode response){       AbstractBillingActivity.this.onRequestPurchaseResponse(productId,response)      }     @Override public void onErrorRestoreTransactions(    @Nonnull ResponseCode responseCode){     }   }     BillingController.registerObserver(mBillingObserver)    BillingController.setConfiguration(this)    this.checkBillingSupported()    if (!mBillingObserver.isTransactionsRestored()) {     BillingController.restoreTransactions(this)    } } 
@Override public void onCheckBillingSupportedResponse(boolean supported){   AbstractBillingActivity.this.onBillingChecked(supported)  } 
@Override public void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){ } 
@Override public void onPurchaseStateChanged(@Nonnull String productId,@Nonnull PurchaseState state){   AbstractBillingActivity.this.onPurchaseStateChanged(productId,state)  } 
@Override public void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response){   AbstractBillingActivity.this.onRequestPurchaseResponse(productId,response)  } 
@Override public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode){ } 
@Override protected void onDestroy(){   super.onDestroy()    BillingController.unregisterObserver(mBillingObserver)    BillingController.setConfiguration(null)  } 
public abstract void onPurchaseStateChanged(String productId,PurchaseState state)  
public abstract void onRequestPurchaseResponse(String productId,ResponseCode response)  
/**   * Requests the purchase of the specified item. The transaction will not be confirmed automatically  such confirmation could be handled in {@link net.robotmedia.billing.helper.AbstractBillingActivity#onPurchaseExecuted(String)}. If automatic confirmation is preferred use {@link BillingController#requestPurchase(android.content.Context,String,boolean)}instead.  * @param productId id of the item to be purchased.  */ public void requestPurchase(String productId){   BillingController.requestPurchase(this,productId)  } 
/**   * Requests to restore all transactions.  */ public void restoreTransactions(){   BillingController.restoreTransactions(this)  } 
public AbstractBillingObserver(Context context){   this.context=context  } 
public boolean isTransactionsRestored(){   return isTransactionsRestored(context)  } 
public static boolean isTransactionsRestored(@Nonnull Context context){   final SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(context)    return preferences.getBoolean(KEY_TRANSACTIONS_RESTORED,false)  } 
/**   * Called after requesting the purchase of the specified item. The default implementation simply starts the pending intent.  * @param productId      id of the item whose purchase was requested.  * @param purchaseIntent a purchase pending intent for the specified item.  */ @Override public void onPurchaseIntentOK(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){   BillingController.startPurchaseIntent(context,purchaseIntent,null)  } 
@Override public void onTransactionsRestored(){   final SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(context)    final Editor editor=preferences.edit()    editor.putBoolean(KEY_TRANSACTIONS_RESTORED,true)    editor.commit()  } 
@Override public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode){ } 
public DefaultBillingObserver(@Nonnull Context context,@Nullable IBillingObserver nestedBillingObserver){   super(context)    this.nestedBillingObserver=nestedBillingObserver  } 
@Override public void onCheckBillingSupportedResponse(boolean supported){   if (nestedBillingObserver != null) {     nestedBillingObserver.onCheckBillingSupportedResponse(supported)    } } 
@Override public void onPurchaseIntentOK(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){   super.onPurchaseIntentOK(productId,purchaseIntent)    if (nestedBillingObserver != null) {     nestedBillingObserver.onPurchaseIntentOK(productId,purchaseIntent)    } } 
@Override public void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){   if (nestedBillingObserver != null) {     nestedBillingObserver.onPurchaseIntentFailure(productId,responseCode)    } } 
@Override public void onPurchaseStateChanged(@Nonnull String productId,@Nonnull Transaction.PurchaseState state){   if (nestedBillingObserver != null) {     nestedBillingObserver.onPurchaseStateChanged(productId,state)    } } 
@Override public void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response){   if (nestedBillingObserver != null) {     nestedBillingObserver.onRequestPurchaseResponse(productId,response)    } } 
@Override public void onTransactionsRestored(){   super.onTransactionsRestored()    if (nestedBillingObserver != null) {     nestedBillingObserver.onTransactionsRestored()    } } 
@Override public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode){   super.onErrorRestoreTransactions(responseCode)    if (nestedBillingObserver != null) {     nestedBillingObserver.onErrorRestoreTransactions(responseCode)    } } 
/**   * Called each time  * @param supported if true, in-app billing is supported. Otherwise, it isn't.  * @see BillingController#checkBillingSupported(android.content.Context)  */ public void onCheckBillingSupportedResponse(boolean supported)  
/**   * Called after requesting the purchase of the specified item.  * @param productId      id of the item whose purchase was requested.  * @param purchaseIntent a purchase pending intent for the specified item.  * @see BillingController#requestPurchase(android.content.Context,String,boolean)  */ public void onPurchaseIntentOK(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent)  
/**   * Called when purchase intent was not sent due to billing service error  * @param productId    id of the item whose purchase was requested  * @param responseCode one of the failures response codes from billing service  */ void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode)  
/**   * Called when the specified item is purchased, cancelled or refunded.  * @param productId id of the item whose purchase state has changed.  * @param state     purchase state of the specified item.  */ public void onPurchaseStateChanged(@Nonnull String productId,@Nonnull PurchaseState state)  
/**   * Called with the response for the purchase request of the specified item. This is used for reporting various errors, or if the user backed out and didn't purchase the item.  * @param productId id of the item whose purchase was requested  * @param response  response of the purchase request  */ public void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response)  
/**   * Called when a restore transactions request has been successfully received by the server.  */ public void onTransactionsRestored()  
/**   * Called when a restore transactions request ended with a server error.  * @param responseCode response code  */ public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode)  
long run(@Nonnull IMarketBillingService service) throws RemoteException   
@Nonnull BillingRequestType getRequestType()  
boolean hasNonce()  
boolean isSuccess()  
long getNonce()  
void onResponseCode(@Nonnull ResponseCode response)  
int getStartId()  
void runRequestOrQueue(@Nonnull IBillingRequest request)  
@Nonnull String getPackageName()  
private BillingDB(@Nonnull Context context){   databaseHelper=new DatabaseHelper(context)    db=databaseHelper.getWritableDatabase()  } 
public static void init(@Nonnull Application application){   instance=new BillingDB(application)  } 
@Nonnull public static BillingDB getInstance(){   return instance  } 
@Nonnull private static List<Transaction> getTransactionsFromCursor(@Nonnull final Cursor cursor){   final List<Transaction> result=new ArrayList<Transaction>()    while (cursor.moveToNext()) {     result.add(createTransaction(cursor))    }   return result  } 
public void close(){ } 
public void insert(@Nonnull Transaction transaction){   AndroidDbUtils.doDbExec(this.getDatabaseHelper(),new InsertTransaction(transaction))  } 
@Nonnull protected static Transaction createTransaction(@Nonnull Cursor cursor){   final Transaction purchase=new Transaction()    purchase.orderId=cursor.getString(0)    purchase.productId=cursor.getString(1)    purchase.purchaseState=PurchaseState.valueOf(cursor.getInt(2))    purchase.purchaseTime=cursor.getLong(3)    purchase.developerPayload=cursor.getString(4)    return purchase  } 
public CountPurchases(@Nonnull String productId){   this.productId=productId  } 
@Nonnull @Override public Cursor createCursor(@Nonnull SQLiteDatabase db){   return db.query(TABLE_TRANSACTIONS,TABLE_TRANSACTIONS_COLUMNS,COLUMN_PRODUCT_ID + " = ? AND " + COLUMN_STATE+ " = ?",new String[]{productId,String.valueOf(PurchaseState.PURCHASED.ordinal())},null,null,null)  } 
@Nonnull @Override public Integer retrieveData(@Nonnull Cursor cursor){   return cursor.getCount()  } 
public TransactionsByProductId(@Nullable String productId){   this.productId=productId  } 
@Nonnull @Override public Cursor createCursor(@Nonnull SQLiteDatabase db){   if (productId != null) {     return db.query(TABLE_TRANSACTIONS,TABLE_TRANSACTIONS_COLUMNS,COLUMN_PRODUCT_ID + " = ?",new String[]{productId},null,null,null)    }  else {     return db.query(TABLE_TRANSACTIONS,TABLE_TRANSACTIONS_COLUMNS,null,null,null,null,null)    } } 
@Nonnull @Override public List<Transaction> retrieveData(@Nonnull Cursor cursor){   return getTransactionsFromCursor(cursor)  } 
public DatabaseHelper(@Nonnull Context context){   super(context,DATABASE_NAME,null,DATABASE_VERSION)  } 
@Override public void onCreate(@Nonnull SQLiteDatabase db){   createTransactionsTable(db)  } 
private void createTransactionsTable(@Nonnull SQLiteDatabase db){   db.execSQL("CREATE TABLE " + TABLE_TRANSACTIONS + "("+ COLUMN_ID+ " TEXT PRIMARY KEY, "+ COLUMN_PRODUCT_ID+ " INTEGER, "+ COLUMN_STATE+ " TEXT, "+ COLUMN_PURCHASE_TIME+ " TEXT, "+ COLUMN_DEVELOPER_PAYLOAD+ " INTEGER)")  } 
@Override public void onUpgrade(@Nonnull SQLiteDatabase db,int oldVersion,int newVersion){ } 
@Nonnull public DatabaseHelper getDatabaseHelper(){   return databaseHelper  } 
InsertTransaction(@Nonnull Transaction transaction){   this.transaction=transaction  } 
@Override public long exec(@Nonnull SQLiteDatabase db){   final ContentValues values=new ContentValues()    values.put(COLUMN_ID,transaction.orderId)    values.put(COLUMN_PRODUCT_ID,transaction.productId)    values.put(COLUMN_STATE,transaction.purchaseState.ordinal())    values.put(COLUMN_PURCHASE_TIME,transaction.purchaseTime)    values.put(COLUMN_DEVELOPER_PAYLOAD,transaction.developerPayload)    return db.replace(TABLE_TRANSACTIONS,null,values)  } 
void PurchaseState(int id){   this.id=id  } 
public static PurchaseState valueOf(int id){   for (  PurchaseState purchaseState : values()) {     if (purchaseState.id == id) {       return purchaseState      }   }   return CANCELLED  } 
@Nonnull public static Transaction newInstance(@Nonnull JSONObject json) throws JSONException {   final Transaction transaction=new Transaction()    final int response=json.getInt(PURCHASE_STATE)    transaction.purchaseState=PurchaseState.valueOf(response)    transaction.productId=json.getString(PRODUCT_ID)    transaction.packageName=json.getString(PACKAGE_NAME)    transaction.purchaseTime=json.getLong(PURCHASE_TIME)    transaction.orderId=json.optString(ORDER_ID,null)    transaction.notificationId=json.optString(NOTIFICATION_ID,null)    transaction.developerPayload=json.optString(DEVELOPER_PAYLOAD,null)    return transaction  } 
public Transaction(){ } 
public Transaction(String orderId,String productId,String packageName,PurchaseState purchaseState,String notificationId,long purchaseTime,String developerPayload){   this.orderId=orderId    this.productId=productId    this.packageName=packageName    this.purchaseState=purchaseState    this.notificationId=notificationId    this.purchaseTime=purchaseTime    this.developerPayload=developerPayload  } 
@Nonnull public JSONObject toJson() throws JSONException {   final JSONObject json=new JSONObject()    json.put(PURCHASE_STATE,this.purchaseState.id)    json.put(PRODUCT_ID,this.productId)    json.put(PACKAGE_NAME,this.packageName)    json.put(PURCHASE_TIME,this.purchaseTime)    json.put(ORDER_ID,this.orderId)    json.put(NOTIFICATION_ID,this.notificationId)    json.put(DEVELOPER_PAYLOAD,this.developerPayload)    return json  } 
@Nonnull @Override public Transaction clone(){   return (Transaction)super.clone()  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    Transaction that=(Transaction)o    if (purchaseTime != that.purchaseTime)   return false    if (developerPayload != null ? !developerPayload.equals(that.developerPayload) : that.developerPayload != null)   return false    if (notificationId != null ? !notificationId.equals(that.notificationId) : that.notificationId != null)   return false    if (orderId != null ? !orderId.equals(that.orderId) : that.orderId != null)   return false    if (packageName != null ? !packageName.equals(that.packageName) : that.packageName != null)   return false    if (productId != null ? !productId.equals(that.productId) : that.productId != null)   return false    if (purchaseState != that.purchaseState)   return false    return true  } 
@Override public int hashCode(){   int result=developerPayload != null ? developerPayload.hashCode() : 0    result=31 * result + (notificationId != null ? notificationId.hashCode() : 0)    result=31 * result + (orderId != null ? orderId.hashCode() : 0)    result=31 * result + (packageName != null ? packageName.hashCode() : 0)    result=31 * result + (productId != null ? productId.hashCode() : 0)    result=31 * result + (purchaseState != null ? purchaseState.hashCode() : 0)    result=31 * result + (int)(purchaseTime ^ (purchaseTime >>> 32))    return result  } 
@Override public String toString(){   return "Transaction{" + "orderId='" + orderId + '\''+ ", productId='"+ productId+ '\''+ ", purchaseTime="+ new Date(purchaseTime)+ ", purchaseState="+ purchaseState+ '}'  } 
public synchronized static void dropDatabase(@Nonnull Context context){   context.deleteDatabase(BillingDB.DATABASE_NAME)  } 
public synchronized static void addTransaction(@Nonnull Transaction transaction){   BillingDB.getInstance().insert(transaction)  } 
public synchronized static boolean isPurchased(@Nonnull String productId){   return countPurchases(productId) > 0  } 
public synchronized static int countPurchases(@Nonnull String productId){   return AndroidDbUtils.doDbQuery(BillingDB.getInstance().getDatabaseHelper(),new BillingDB.CountPurchases(productId))  } 
@Nonnull public synchronized static List<Transaction> getTransactions(){   return AndroidDbUtils.doDbQuery(BillingDB.getInstance().getDatabaseHelper(),new BillingDB.TransactionsByProductId(null))  } 
@Nonnull public synchronized static List<Transaction> getTransactions(@Nonnull String productId){   return AndroidDbUtils.doDbQuery(BillingDB.getInstance().getDatabaseHelper(),new BillingDB.TransactionsByProductId(productId))  } 
private BillingSecurity(){   throw new AssertionError()  } 
@Nonnull private static Cipherer<Transaction,Transaction> newTransactionObfuscator(@Nonnull byte[] initialVector,@Nullable String securityPrefix){   final Cipherer<byte[],byte[]> byteCipherer=Security.newAndroidAesByteCipherer(initialVector)    Cipherer<String,String> stringCipherer=TypedCipherer.newInstance(byteCipherer,StringDecoder.getInstance(),StringEncoder.getInstance(),BillingBase64StringDecoder.getInstance(),BillingBase64StringEncoder.getInstance())    if (securityPrefix != null) {     stringCipherer=PrefixStringObfuscator.newInstance(securityPrefix,stringCipherer)    }   return TransactionObfuscator.newInstance(stringCipherer)  } 
@Nonnull public static SecurityService<Transaction,Transaction,byte[]> getObfuscationSecurityService(byte[] initialVector,@Nullable String securityPrefix){   return Security.newSecurityService(newTransactionObfuscator(initialVector,securityPrefix),Security.newAndroidAesSecretKeyProvider(),Security.newAndroidSaltGenerator(),getHashProvider())  } 
@Nonnull private static HashProvider<Transaction,byte[]> getHashProvider(){   final HashProvider<byte[],byte[]> hashProvider=org.solovyev.android.security.Security.newAndroidSha512ByteHashProvider()    return TypedHashProvider.newByteHashCodeInstance(hashProvider)  } 
@Nonnull public static String generatePassword(@Nonnull Context context){   final String installationId=Installation.id(context)    final String deviceId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID)    return installationId + deviceId + context.getPackageName()  } 
/**   * Generates a PublicKey instance from a string containing the Base64-encoded public key.  * @param encodedPublicKey Base64-encoded public key  * @throws IllegalArgumentException if encodedPublicKey is invalid  */ protected PublicKey generatePublicKey(String encodedPublicKey){   try {     byte[] decodedKey=Base64.decode(encodedPublicKey)      KeyFactory keyFactory=KeyFactory.getInstance(KEY_FACTORY_ALGORITHM)      return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey))    }  catch (  NoSuchAlgorithmException e) {     throw new RuntimeException(e)    } catch (  InvalidKeySpecException e) {     Log.e(BillingController.LOG_TAG,"Invalid key specification.")      throw new IllegalArgumentException(e)    } catch (  Base64DecoderException e) {     Log.e(BillingController.LOG_TAG,"Base64 decoding failed.")      throw new IllegalArgumentException(e)    } } 
public DefaultSignatureValidator(BillingController.IConfiguration configuration){   this.configuration=configuration  } 
protected boolean validate(PublicKey publicKey,String signedData,String signature){   Signature sig    try {     sig=Signature.getInstance(SIGNATURE_ALGORITHM)      sig.initVerify(publicKey)      sig.update(signedData.getBytes())      if (!sig.verify(Base64.decode(signature))) {       Log.e(BillingController.LOG_TAG,"Signature verification failed.")        return false      }     return true    }  catch (  NoSuchAlgorithmException e) {     Log.e(BillingController.LOG_TAG,"NoSuchAlgorithmException")    } catch (  InvalidKeyException e) {     Log.e(BillingController.LOG_TAG,"Invalid key specification")    } catch (  SignatureException e) {     Log.e(BillingController.LOG_TAG,"Signature exception")    } catch (  Base64DecoderException e) {     Log.e(BillingController.LOG_TAG,"Base64 decoding failed")    }   return false  } 
@Override public boolean validate(String signedData,String signature){   final String publicKey    if (configuration == null || TextUtils.isEmpty(publicKey=configuration.getPublicKey())) {     Log.w(BillingController.LOG_TAG,"Please set the public key or turn on debug mode")      return false    }   if (signedData == null) {     Log.e(BillingController.LOG_TAG,"Data is null")      return false    }   PublicKey key=generatePublicKey(publicKey)    return validate(key,signedData,signature)  } 
/**   * Validates that the specified signature matches the computed signature on the specified signed data. Returns true if the data is correctly signed.  * @param signedData signed data  * @param signature  signature  * @return true if the data and signature match, false otherwise.  */ public boolean validate(String signedData,String signature)  
private PrefixStringObfuscator(@Nonnull String securityPrefix,@Nonnull Cipherer<String,String> stringCipherer){   this.securityPrefix=securityPrefix    this.stringCipherer=stringCipherer  } 
@Nonnull static Cipherer<String,String> newInstance(@Nonnull String prefix,@Nonnull Cipherer<String,String> stringCipherer){   return new PrefixStringObfuscator(prefix,stringCipherer)  } 
@Nonnull @Override public String encrypt(@Nonnull SecretKey secret,@Nonnull String decrypted) throws CiphererException {   return stringCipherer.encrypt(secret,securityPrefix + decrypted)  } 
@Nonnull @Override public String decrypt(@Nonnull SecretKey secret,@Nonnull String encrypted) throws CiphererException {   String decrypted=stringCipherer.decrypt(secret,encrypted)    final int securityIndex=decrypted.indexOf(securityPrefix)    if (securityIndex != 0) {     throw new CiphererException("Security prefix not found (invalid data or key), prefix:" + securityPrefix)    }   return decrypted.substring(securityPrefix.length(),decrypted.length())  } 
private TransactionObfuscator(@Nonnull Cipherer<String,String> stringCipherer){   this.stringCipherer=stringCipherer  } 
@Nonnull static Cipherer<Transaction,Transaction> newInstance(@Nonnull Cipherer<String,String> stringCipherer){   return new TransactionObfuscator(stringCipherer)  } 
@Nonnull @Override public Transaction encrypt(@Nonnull SecretKey secret,@Nonnull Transaction decrypted) throws CiphererException {   decrypted.orderId=stringCipherer.encrypt(secret,decrypted.orderId)    decrypted.productId=stringCipherer.encrypt(secret,decrypted.productId)    decrypted.developerPayload=stringCipherer.encrypt(secret,decrypted.developerPayload)    return decrypted  } 
@Nonnull @Override public Transaction decrypt(@Nonnull SecretKey secret,@Nonnull Transaction encrypted) throws CiphererException {   encrypted.orderId=stringCipherer.decrypt(secret,encrypted.orderId)    encrypted.productId=stringCipherer.decrypt(secret,encrypted.productId)    encrypted.developerPayload=stringCipherer.decrypt(secret,encrypted.developerPayload)    return encrypted  } 
public AESObfuscator(@Nonnull byte[] salt,String password){   try {     final SecretKeyFactory factory=SecretKeyFactory.getInstance(KEYGEN_ALGORITHM)      final KeySpec publicKeySpec=new PBEKeySpec(password.toCharArray(),salt,1024,256)      final SecretKey tmp=factory.generateSecret(publicKeySpec)      final SecretKey secretKeySpec=new SecretKeySpec(tmp.getEncoded(),"AES")      encryptor=Cipher.getInstance(CIPHER_ALGORITHM)      encryptor.init(Cipher.ENCRYPT_MODE,secretKeySpec,new IvParameterSpec(IV))      decryptor=Cipher.getInstance(CIPHER_ALGORITHM)      decryptor.init(Cipher.DECRYPT_MODE,secretKeySpec,new IvParameterSpec(IV))    }  catch (  GeneralSecurityException e) {     throw new RuntimeException("Invalid environment",e)    } } 
@Nullable public String obfuscate(@Nullable String source){   if (source == null) {     return null    }   try {     final String in=SECURITY_PREFIX + source      byte[] inBytes=in.getBytes(UTF8)      byte[] encrypted=encryptor.doFinal(inBytes)      return Base64.encode(encrypted)    }  catch (  UnsupportedEncodingException e) {     throw new RuntimeException("Invalid environment",e)    } catch (  GeneralSecurityException e) {     throw new RuntimeException("Invalid environment",e)    } } 
public String unobfuscate(String obfuscated) throws ValidationException {   if (obfuscated == null) {     return null    }   try {     final byte[] encryptedBytes=Base64.decode(obfuscated)      final byte[] decryptedBytes=decryptor.doFinal(encryptedBytes)      String result=new String(decryptedBytes,UTF8)      int headerIndex=result.indexOf(SECURITY_PREFIX)      if (headerIndex != 0) {       throw new ValidationException("Header not found (invalid data or key)" + ":" + obfuscated)      }     return result.substring(SECURITY_PREFIX.length(),result.length())    }  catch (  Base64DecoderException e) {     throw new ValidationException(e.getMessage() + ":" + obfuscated)    } catch (  IllegalBlockSizeException e) {     throw new ValidationException(e.getMessage() + ":" + obfuscated)    } catch (  BadPaddingException e) {     throw new ValidationException(e.getMessage() + ":" + obfuscated)    } catch (  UnsupportedEncodingException e) {     throw new RuntimeException("Invalid environment",e)    } } 
public ValidationException(){   super()  } 
public ValidationException(String s){   super(s)  } 
/**   * Defeats instantiation.  */ private Base64(){ } 
/**   * Encodes up to three bytes of the array <var>source</var> and writes the resulting four Base64 bytes to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accommodate <var>srcOffset</var> + 3 for the <var>source</var> array or <var>destOffset</var> + 4 for the <var>destination</var> array. The actual number of significant bytes in your array is given by <var>numSigBytes</var>.  * @param source      the array to convert  * @param srcOffset   the index where conversion begins  * @param numSigBytes the number of significant bytes in your array  * @param destination the array to hold the conversion  * @param destOffset  the index where output will be put  * @param alphabet    is the encoding alphabet  * @return the <var>destination</var> array  * @since 1.3  */ private static byte[] encode3to4(byte[] source,int srcOffset,int numSigBytes,byte[] destination,int destOffset,byte[] alphabet){   int inBuff=(numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0)  switch (numSigBytes) { case 3:     destination[destOffset]=alphabet[(inBuff >>> 18)]    destination[destOffset + 1]=alphabet[(inBuff >>> 12) & 0x3f]  destination[destOffset + 2]=alphabet[(inBuff >>> 6) & 0x3f]  destination[destOffset + 3]=alphabet[(inBuff) & 0x3f]  return destination  case 2: destination[destOffset]=alphabet[(inBuff >>> 18)]  destination[destOffset + 1]=alphabet[(inBuff >>> 12) & 0x3f]  destination[destOffset + 2]=alphabet[(inBuff >>> 6) & 0x3f]  destination[destOffset + 3]=EQUALS_SIGN  return destination  case 1: destination[destOffset]=alphabet[(inBuff >>> 18)]  destination[destOffset + 1]=alphabet[(inBuff >>> 12) & 0x3f]  destination[destOffset + 2]=EQUALS_SIGN  destination[destOffset + 3]=EQUALS_SIGN  return destination  default : return destination  } } 
/**   * Encodes a byte array into Base64 notation. Equivalent to calling {@code encodeBytes(source, 0, source.length)}  * @param source The data to convert  * @since 1.4  */ public static String encode(byte[] source){   return encode(source,0,source.length,ALPHABET,true)  } 
/**   * Encodes a byte array into web safe Base64 notation.  * @param source    The data to convert  * @param doPadding is {@code true} to pad result with '=' charsif it does not fall on 3 byte boundaries  */ public static String encodeWebSafe(byte[] source,boolean doPadding){   return encode(source,0,source.length,WEBSAFE_ALPHABET,doPadding)  } 
/**   * Encodes a byte array into Base64 notation.  * @param source    the data to convert  * @param off       offset in array where conversion should begin  * @param len       length of data to convert  * @param alphabet  the encoding alphabet  * @param doPadding is {@code true} to pad result with '=' charsif it does not fall on 3 byte boundaries  * @since 1.4  */ public static String encode(byte[] source,int off,int len,byte[] alphabet,boolean doPadding){   byte[] outBuff=encode(source,off,len,alphabet,Integer.MAX_VALUE)    int outLen=outBuff.length    while (!doPadding && outLen > 0) {     if (outBuff[outLen - 1] != '=') {       break      }     outLen-=1    }   return new String(outBuff,0,outLen)  } 
/**   * Encodes a byte array into Base64 notation.  * @param source        the data to convert  * @param off           offset in array where conversion should begin  * @param len           length of data to convert  * @param alphabet      is the encoding alphabet  * @param maxLineLength maximum length of one line.  * @return the BASE64-encoded byte array  */ public static byte[] encode(byte[] source,int off,int len,byte[] alphabet,int maxLineLength){   int lenDiv3=(len + 2) / 3    int len43=lenDiv3 * 4    byte[] outBuff=new byte[len43 + (len43 / maxLineLength)]    int d=0    int e=0    int len2=len - 2    int lineLength=0    for (  d < len2  d+=3, e+=4) {     int inBuff=((source[d + off] << 24) >>> 8) | ((source[d + 1 + off] << 24) >>> 16) | ((source[d + 2 + off] << 24) >>> 24)      outBuff[e]=alphabet[(inBuff >>> 18)]      outBuff[e + 1]=alphabet[(inBuff >>> 12) & 0x3f]      outBuff[e + 2]=alphabet[(inBuff >>> 6) & 0x3f]      outBuff[e + 3]=alphabet[(inBuff) & 0x3f]      lineLength+=4      if (lineLength == maxLineLength) {       outBuff[e + 4]=NEW_LINE        e++        lineLength=0      }   }   if (d < len) {     encode3to4(source,d + off,len - d,outBuff,e,alphabet)      lineLength+=4      if (lineLength == maxLineLength) {       outBuff[e + 4]=NEW_LINE        e++      }     e+=4    }   assert(e == outBuff.length)    return outBuff  } 
/**   * Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accommodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the <var>destination</var> array. This method returns the actual number of bytes that were converted from the Base64 encoding.  * @param source      the array to convert  * @param srcOffset   the index where conversion begins  * @param destination the array to hold the conversion  * @param destOffset  the index where output will be put  * @param decodabet   the decodabet for decoding Base64 content  * @return the number of decoded bytes converted  * @since 1.3  */ private static int decode4to3(byte[] source,int srcOffset,byte[] destination,int destOffset,byte[] decodabet){   if (source[srcOffset + 2] == EQUALS_SIGN) {     int outBuff=((decodabet[source[srcOffset]] << 24) >>> 6) | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)      destination[destOffset]=(byte)(outBuff >>> 16)      return 1    }  else   if (source[srcOffset + 3] == EQUALS_SIGN) {     int outBuff=((decodabet[source[srcOffset]] << 24) >>> 6) | ((decodabet[source[srcOffset + 1]] << 24) >>> 12) | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)      destination[destOffset]=(byte)(outBuff >>> 16)      destination[destOffset + 1]=(byte)(outBuff >>> 8)      return 2    }  else {     int outBuff=((decodabet[source[srcOffset]] << 24) >>> 6) | ((decodabet[source[srcOffset + 1]] << 24) >>> 12) | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)| ((decodabet[source[srcOffset + 3]] << 24) >>> 24)      destination[destOffset]=(byte)(outBuff >> 16)      destination[destOffset + 1]=(byte)(outBuff >> 8)      destination[destOffset + 2]=(byte)(outBuff)      return 3    } } 
/**   * Decodes data from Base64 notation.  * @param s the string to decode (decoded in default encoding)  * @return the decoded data  * @since 1.4  */ public static byte[] decode(String s) throws Base64DecoderException {   byte[] bytes=s.getBytes()    return decode(bytes,0,bytes.length)  } 
/**   * Decodes data from web safe Base64 notation. Web safe encoding uses '-' instead of '+', '_' instead of '/'  * @param s the string to decode (decoded in default encoding)  * @return the decoded data  */ public static byte[] decodeWebSafe(String s) throws Base64DecoderException {   byte[] bytes=s.getBytes()    return decodeWebSafe(bytes,0,bytes.length)  } 
/**   * Decodes Base64 content in byte array format and returns the decoded byte array.  * @param source The Base64 encoded data  * @return decoded data  * @throws Base64DecoderException  * @since 1.3  */ public static byte[] decode(byte[] source) throws Base64DecoderException {   return decode(source,0,source.length)  } 
/**   * Decodes web safe Base64 content in byte array format and returns the decoded data. Web safe encoding uses '-' instead of '+', '_' instead of '/'  * @param source the string to decode (decoded in default encoding)  * @return the decoded data  */ public static byte[] decodeWebSafe(byte[] source) throws Base64DecoderException {   return decodeWebSafe(source,0,source.length)  } 
/**   * Decodes Base64 content in byte array format and returns the decoded byte array.  * @param source the Base64 encoded data  * @param off    the offset of where to begin decoding  * @param len    the length of characters to decode  * @return decoded data  * @throws Base64DecoderException  * @since 1.3  */ public static byte[] decode(byte[] source,int off,int len) throws Base64DecoderException {   return decode(source,off,len,DECODABET)  } 
/**   * Decodes web safe Base64 content in byte array format and returns the decoded byte array. Web safe encoding uses '-' instead of '+', '_' instead of '/'  * @param source the Base64 encoded data  * @param off    the offset of where to begin decoding  * @param len    the length of characters to decode  * @return decoded data  */ public static byte[] decodeWebSafe(byte[] source,int off,int len) throws Base64DecoderException {   return decode(source,off,len,WEBSAFE_DECODABET)  } 
/**   * Decodes Base64 content using the supplied decodabet and returns the decoded byte array.  * @param source    the Base64 encoded data  * @param off       the offset of where to begin decoding  * @param len       the length of characters to decode  * @param decodabet the decodabet for decoding Base64 content  * @return decoded data  */ public static byte[] decode(byte[] source,int off,int len,byte[] decodabet) throws Base64DecoderException {   int len34=len * 3 / 4    byte[] outBuff=new byte[2 + len34]    int outBuffPos=0    byte[] b4=new byte[4]    int b4Pos=0    int i=0    byte sbiCrop=0    byte sbiDecode=0    for (i=0  i < len  i++) {     sbiCrop=(byte)(source[i + off] & 0x7f)      sbiDecode=decodabet[sbiCrop]      if (sbiDecode >= WHITE_SPACE_ENC) {       if (sbiDecode >= EQUALS_SIGN_ENC) {         if (sbiCrop == EQUALS_SIGN) {           int bytesLeft=len - i            byte lastByte=(byte)(source[len - 1 + off] & 0x7f)            if (b4Pos == 0 || b4Pos == 1) {             throw new Base64DecoderException("invalid padding byte '=' at byte offset " + i)            }  else           if ((b4Pos == 3 && bytesLeft > 2) || (b4Pos == 4 && bytesLeft > 1)) {             throw new Base64DecoderException("padding byte '=' falsely signals end of encoded value at offset " + i)            }  else           if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {             throw new Base64DecoderException("encoded value has invalid trailing byte")            }           break          }         b4[b4Pos++]=sbiCrop          if (b4Pos == 4) {           outBuffPos+=decode4to3(b4,0,outBuff,outBuffPos,decodabet)            b4Pos=0          }       }     }  else {       throw new Base64DecoderException("Bad Base64 input character at " + i + ": "+ source[i + off]+ "(decimal)")      }   }   if (b4Pos != 0) {     if (b4Pos == 1) {       throw new Base64DecoderException("single trailing character at offset " + (len - 1))      }     b4[b4Pos++]=EQUALS_SIGN      outBuffPos+=decode4to3(b4,0,outBuff,outBuffPos,decodabet)    }   byte[] out=new byte[outBuffPos]    System.arraycopy(outBuff,0,out,0,outBuffPos)    return out  } 
public Base64DecoderException(){   super()  } 
public Base64DecoderException(String s){   super(s)  } 
private BillingBase64StringDecoder(){ } 
@Nonnull public static Converter<String,byte[]> getInstance(){   return instance  } 
@Nonnull @Override public byte[] convert(@Nonnull String s){   try {     return Base64.decode(s)    }  catch (  Base64DecoderException e) {     throw new RuntimeException(e)    } } 
private BillingBase64StringEncoder(){ } 
@Nonnull public static Converter<byte[],String> getInstance(){   return instance  } 
@Nonnull @Override public String convert(@Nonnull byte[] bytes){   return Base64.encode(bytes)  } 
private static void initCompatibility(){   try {     final Field field=Service.class.getField("START_NOT_STICKY")      START_NOT_STICKY=field.getInt(null)    }  catch (  Exception e) {     Log.e(TAG,e.getMessage(),e)      START_NOT_STICKY=2    }   activityMethod=initMethod(Activity.class)    contextMethod=initMethod(Context.class)  } 
@Nullable private static Method initMethod(@Nonnull Class<? extends Context> clazz){   Method result    try {     result=clazz.getMethod("startIntentSender",START_INTENT_SENDER_SIGNATURE)    }  catch (  SecurityException e) {     Log.e(TAG,e.getMessage(),e)      result=null    } catch (  NoSuchMethodException e) {     Log.e(TAG,e.getMessage(),e)      result=null    }   return result  } 
public static void startIntentSender(@Nonnull Context context,@Nonnull IntentSender intentSender,@Nullable Intent intent){   if (context instanceof Activity) {     startIntentSender0(context,intentSender,intent,activityMethod)    }  else {     startIntentSender0(context,intentSender,intent,contextMethod)    } } 
private static void startIntentSender0(@Nonnull Context context,@Nonnull IntentSender intentSender,@Nullable Intent intent,@Nullable Method method){   if (method != null) {     final Object[] args=new Object[5]      args[0]=intentSender      args[1]=intent      args[2]=0      args[3]=0      args[4]=0      try {       method.invoke(context,args)      }  catch (    Exception e) {       Log.e(TAG,"startIntentSender",e)      }   } } 
public static boolean isStartIntentSenderSupported(@Nonnull Context context){   if (context instanceof Activity) {     return activityMethod != null    }  else {     return contextMethod != null    } } 
public synchronized static String id(@Nonnull Context context){   if (sID == null) { synchronized (lock) {       final File installation=new File(context.getFilesDir(),INSTALLATION)        try {         if (!installation.exists()) {           sID=writeInstallationFile(installation)          }  else {           sID=readInstallationFile(installation)          }       }  catch (      Exception e) {         throw new RuntimeException(e)        }     }   }   return sID  } 
@Nonnull private static String readInstallationFile(@Nonnull File installation) throws IOException {   byte[] bytes=null    RandomAccessFile in=null    try {     in=new RandomAccessFile(installation,"r")      bytes=new byte[(int)in.length()]      in.readFully(bytes)    }  catch (  IOException e) {     if (in != null) {       in.close()      }   }   return new String(bytes)  } 
@Nonnull private static String writeInstallationFile(@Nonnull File installation) throws IOException {   final String id=UUID.randomUUID().toString()    FileOutputStream out=null    try {     out=new FileOutputStream(installation)      out.write(id.getBytes())    }   finally {     if (out != null) {       out.close()      }   }   return id  } 
private ObfuscateUtils(){   throw new AssertionError()  } 
public static void unobfuscate(@Nonnull Context context,@Nonnull List<Transaction> transactions,@Nullable byte[] salt){   for (  Transaction p : transactions) {     unobfuscate(context,p,salt)    } } 
/**   * Obfuscates the specified purchase. Only the order id, product id and developer payload are obfuscated.  * @param context context  * @param t       purchase to be obfuscated.  * @param salt    salt  * @see #unobfuscate(android.content.Context,net.robotmedia.billing.model.Transaction,byte[])  */ public static void obfuscate(@Nonnull Context context,@Nonnull Transaction t,@Nullable byte[] salt){   if (salt == null) {     return    }   t.orderId=Security.obfuscate(context,salt,t.orderId)    t.productId=Security.obfuscate(context,salt,t.productId)    t.developerPayload=Security.obfuscate(context,salt,t.developerPayload)  } 
/**   * Unobfuscate the specified purchase.  * @param context context  * @param t       purchase to unobfuscate.  * @param salt    salt  * @see #obfuscate(android.content.Context,net.robotmedia.billing.model.Transaction,byte[])  */ public static void unobfuscate(@Nonnull Context context,@Nonnull Transaction t,@Nullable byte[] salt){   t.orderId=Security.unobfuscate(context,salt,t.orderId)    t.productId=Security.unobfuscate(context,salt,t.productId)    t.developerPayload=Security.unobfuscate(context,salt,t.developerPayload)  } 
/**   * Generate and register nonce  * @return nonce. This method guarantees that created nonce will be unique (i.e. there is only one instance of registered nonce)  */ public static long generateNonce(){   long nonce  synchronized (knownNonces) {     do {       nonce=RANDOM.nextLong()      }  while (knownNonces.contains(nonce))      knownNonces.add(nonce)    }   return nonce  } 
public static boolean isNonceKnown(long nonce){ synchronized (knownNonces) {     return knownNonces.contains(nonce)    } } 
public static void removeNonce(long nonce){ synchronized (knownNonces) {     knownNonces.remove(nonce)    } } 
/**   * Obfuscates the source string using AES algorithm with specified salt  * @param context context  * @param salt    salt to beb used for obfuscation  * @param source  string to be obfuscated  * @return obfuscated string. Null can be returned only if source string is null  */ @Nullable public static String obfuscate(@Nonnull Context context,@Nullable byte[] salt,@Nullable String source){   return salt == null ? source : getObfuscator(context,salt).obfuscate(source)  } 
@Nonnull private static AESObfuscator getObfuscator(@Nonnull Context context,@Nonnull byte[] salt){ synchronized (obfuscatorLock) {     if (obfuscator == null) {       final String password=BillingSecurity.generatePassword(context)        obfuscator=new AESObfuscator(salt,password)      }     return obfuscator    } } 
/**   * Method unobfuscates the string using AES algorithm with specified salt.  * @param context    context  * @param salt       unobfuscation salt (must be provided the same as was used in obfuscation)  * @param obfuscated string to be unobfuscated  * @return unobfuscated string. Null returned in two cases: either obfuscated string is null or unobfuscation failed due to some errors  */ @Nullable public static String unobfuscate(@Nonnull Context context,@Nullable byte[] salt,@Nullable String obfuscated){   if (salt != null) {     final AESObfuscator obfuscator=getObfuscator(context,salt)      try {       return obfuscator.unobfuscate(obfuscated)      }  catch (    ValidationException e) {       Log.w(TAG,"Invalid obfuscated data or key")      }     return null    }  else {     return obfuscated    } } 
private Activities(){   throw new AssertionError()  } 
/**   * Method restarts activity  * @param activity to be restarted activity  */ public static void restartActivity(@Nonnull Activity activity){   final Intent intent=activity.getIntent()    Log.d(TAG,"Restarting activity: " + activity.getClass().getSimpleName())    activity.finish()    activity.startActivity(intent)  } 
public static void startActivity(@Nonnull Intent intent,@Nonnull Context context){   addIntentFlags(intent,false,context)    context.startActivity(intent)  } 
public static void addIntentFlags(@Nonnull Intent intent,boolean detached,@Nonnull Context context){   int flags=0    if (!(context instanceof Activity)) {     flags=flags | Intent.FLAG_ACTIVITY_NEW_TASK    }   if (detached) {     flags=flags | Intent.FLAG_ACTIVITY_NO_HISTORY    }   intent.setFlags(flags)  } 
private Android(){   throw new AssertionError()  } 
@Nonnull public static String newTag(@Nonnull String tag){   return newSubTag(TAG,tag)  } 
@Nonnull public static String newSubTag(@Nonnull String tag,@Nonnull String subTag){   return tag + "/" + subTag  } 
/**   * Method returns version of application identified by it's package name.  * @param context        context  * @param appPackageName full name of the package of an app, 'com.example.app' for example.  * @return version number of application  * @throws PackageManager.NameNotFoundException if application is not found  */ public static int getAppVersionCode(@Nonnull Context context,@Nonnull String appPackageName) throws PackageManager.NameNotFoundException {   return context.getPackageManager().getPackageInfo(appPackageName,0).versionCode  } 
/**   * @param context context  * @return version number of current application  */ public static int getAppVersionCode(@Nonnull Context context){   try {     return getAppVersionCode(context,context.getPackageName())    }  catch (  PackageManager.NameNotFoundException e) {     throw new AssertionError(e)    } } 
public static boolean isPhoneModel(@Nonnull DeviceModel phoneModel){   final String model=Build.MODEL    return model != null && phoneModel.getModels().contains(model)  } 
public static boolean isDebuggable(@Nonnull Context context){   if (debug == null) {     debug=0 != (context.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)    }   return debug  } 
@Nonnull public static Parcelable.Creator<String> getStringParcelableCreator(){   return StringParcelableCreator.getInstance()  } 
@Deprecated public static void addIntentFlags(@Nonnull Intent intent,boolean detached,@Nonnull Context context){   Activities.addIntentFlags(intent,detached,context)  } 
@Deprecated public static void toggleComponent(@Nonnull Context context,@Nonnull Class<?> componentClass,boolean enable){   enableComponent(context,componentClass,enable)  } 
public static void enableComponent(@Nonnull Context context,@Nonnull Class<?> componentClass,boolean enable){   final PackageManager pm=context.getPackageManager()    final int componentState    if (enable) {     componentState=PackageManager.COMPONENT_ENABLED_STATE_ENABLED    }  else {     componentState=PackageManager.COMPONENT_ENABLED_STATE_DISABLED    }   pm.setComponentEnabledSetting(new ComponentName(context,componentClass),componentState,PackageManager.DONT_KILL_APP)  } 
public static boolean isComponentEnabled(@Nonnull Context context,@Nonnull Class<? extends Context> componentClass){   final PackageManager pm=context.getPackageManager()    int componentEnabledSetting=pm.getComponentEnabledSetting(new ComponentName(context,componentClass))    return componentEnabledSetting == PackageManager.COMPONENT_ENABLED_STATE_ENABLED || componentEnabledSetting == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT  } 
public static String saveBitmap(@Nonnull Bitmap bitmap,@Nonnull String path,@Nonnull String fileName){   final File filePath=new File(path)    filePath.mkdirs()    final File file=new File(path,fileName)    if (!file.exists()) {     final String name=file.getAbsolutePath()      FileOutputStream fos=null      try {       fos=new FileOutputStream(name)        bitmap.compress(Bitmap.CompressFormat.PNG,100,fos)        fos.flush()      }  catch (    FileNotFoundException e) {       Log.e(TAG,e.getMessage(),e)      } catch (    IOException e) {       Log.e(TAG,e.getMessage(),e)      }  finally {       if (fos != null) {         try {           fos.close()          }  catch (        IOException e) {           Log.e(TAG,e.getMessage(),e)          }       }     }     return name    }   return null  } 
protected CommonAsyncTask(){   this.contextRef=new WeakReference<Context>(null)  } 
protected CommonAsyncTask(@Nonnull Context context){   this.contextRef=new WeakReference<Context>(context)  } 
@Override protected void onPreExecute(){   super.onPreExecute()  } 
@Override protected final Result<RESULT> doInBackground(PARAM... params){   try {     return new CommonResult<RESULT>(doWork(Collections.asList(params)))    }  catch (  CommonAsyncTaskRuntimeException e) {     return new CommonResult<RESULT>(e.getException())    } catch (  Exception e) {     return new CommonResult<RESULT>(e)    } } 
protected abstract RESULT doWork(@Nonnull List<PARAM> params)  
@Override protected void onPostExecute(@Nonnull Result<RESULT> r){   super.onPostExecute(r)    if (r.isFailure()) {     onFailurePostExecute(r.getFailureResult())    }  else {     onSuccessPostExecute(r.getSuccessResult())    } } 
@Nullable protected Context getContext(){   return contextRef.get()  } 
protected abstract void onSuccessPostExecute(@Nullable RESULT result)  
protected abstract void onFailurePostExecute(@Nonnull Exception e)  
public CommonResult(@Nullable SR result){   this.successResult=result  } 
public CommonResult(@Nonnull Exception e){   this.failureResult=e  } 
@Override @Nullable public SR getSuccessResult(){   return successResult  } 
@Nullable @Override public Exception getFailureResult(){   return this.failureResult  } 
@Override public boolean isFailure(){   return this.failureResult != null  } 
boolean isFailure()  
@Nullable Exception getFailureResult()  
@Nullable SR getSuccessResult()  
protected void throwException(@Nonnull Exception e){   throw new CommonAsyncTaskRuntimeException(e)  } 
protected void defaultOnFailurePostExecute(@Nonnull Exception e){   if (e instanceof RuntimeException) {     throw (RuntimeException)e    }  else {     Log.e(TAG,e.getMessage(),e)    } } 
public CommonAsyncTaskRuntimeException(@Nonnull Exception exception){   this.exception=exception  } 
@Nonnull public Exception getException(){   return exception  } 
public Captcha(@Nonnull String captchaSid,@Nonnull String captchaImage){   this.captchaSid=captchaSid    this.captchaImage=captchaImage  } 
@Nonnull public String getCaptchaSid(){   return captchaSid  } 
@Nonnull public String getCaptchaImage(){   return captchaImage  } 
@Override public int describeContents(){   return 0  } 
@Override public void writeToParcel(Parcel out,int i){   out.writeString(captchaSid)    out.writeString(captchaImage)  } 
@Nonnull public ResolvedCaptcha resolve(@Nonnull String captchaKey){   return new ResolvedCaptcha(captchaSid,captchaKey)  } 
public ResolvedCaptcha(@Nonnull String captchaSid,@Nonnull String captchaKey){   this.captchaSid=captchaSid    this.captchaKey=captchaKey  } 
@Nonnull public String getCaptchaSid(){   return captchaSid  } 
@Nonnull public String getCaptchaKey(){   return captchaKey  } 
public DialogFragmentShower(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,@Nonnull AlertDialog.Builder menuBuilder){   this.fragmentActivity=fragmentActivity    this.fragmentTag=fragmentTag    this.menuBuilder=menuBuilder  } 
public void show(){   show(false)  } 
public void show(boolean addToBackStack){   if (addToBackStack) {     Fragments.showDialog(new AlertDialogFragment(menuBuilder),fragmentTag,fragmentActivity.getSupportFragmentManager())    }  else {     final FragmentManager fm=fragmentActivity.getSupportFragmentManager()      final AlertDialogFragment fragment=new AlertDialogFragment(menuBuilder)      fragment.show(fm,fragmentTag)    } } 
private AlertDialogFragment(@Nonnull AlertDialog.Builder menuBuilder){   this.menuBuilder=menuBuilder  } 
public AlertDialogFragment(){   this.menuBuilder=null  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    if (menuBuilder == null) {     dismiss()    } } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   if (menuBuilder != null) {     return menuBuilder.create()    }  else {     return super.onCreateDialog(savedInstanceState)    } } 
public FileCache(@Nonnull Context context,@Nonnull String cacheFileName){   if (getExternalStorageState().equals(MEDIA_MOUNTED)) {     cacheDir=new File(createExternalCachePath(context),cacheFileName)    }  else {     cacheDir=new File(createInternalCachePath(context),cacheFileName)    }   if (!cacheDir.exists()) {     cacheDir.mkdirs()    } } 
@Nullable private String createExternalCachePath(@Nonnull Context context){   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) {     final File cacheDir=context.getExternalCacheDir()      return cacheDir != null ? cacheDir.getPath() : createInternalCachePath(context)    }  else {     return getExternalStorageDirectory().getPath() + "/Android/data/" + context.getPackageName()+ "/cache"    } } 
@Nullable private String createInternalCachePath(@Nonnull Context context){   final File cacheDir=context.getCacheDir()    return cacheDir != null ? cacheDir.getPath() : null  } 
@Nonnull public File getFile(@Nonnull String filename){   return new File(cacheDir,filename)  } 
public void clear(){   final File[] files=cacheDir.listFiles()    if (files != null) {     for (    File file : files) {       file.delete()      }   } } 
protected Fragments(){   throw new AssertionError()  } 
public static void showDialog(@Nonnull DialogFragment dialogFragment,@Nonnull String fragmentTag,@Nonnull FragmentManager fm){   final FragmentTransaction ft=fm.beginTransaction()    Fragment prev=fm.findFragmentByTag(fragmentTag)    if (prev != null) {     ft.remove(prev)    }   ft.addToBackStack(null)    dialogFragment.show(ft,fragmentTag)  } 
public static void showDialog(@Nonnull android.support.v4.app.DialogFragment dialogFragment,@Nonnull String fragmentTag,@Nonnull android.support.v4.app.FragmentManager fm){   final android.support.v4.app.FragmentTransaction ft=fm.beginTransaction()    android.support.v4.app.Fragment prev=fm.findFragmentByTag(fragmentTag)    if (prev != null) {     ft.remove(prev)    }   ft.addToBackStack(null)    dialogFragment.show(ft,fragmentTag)  } 
public static void createFragment(@Nonnull FragmentActivity activity,@Nonnull Class<? extends android.support.v4.app.Fragment> fragmentClass,int parentViewId,@Nonnull String tag){   createFragment(activity,fragmentClass,parentViewId,tag,null)  } 
public static void createFragment(@Nonnull FragmentActivity activity,@Nonnull Class<? extends android.support.v4.app.Fragment> fragmentClass,int parentViewId,@Nonnull String tag,@Nullable Bundle args){   final android.support.v4.app.FragmentManager fm=activity.getSupportFragmentManager()    android.support.v4.app.Fragment messagesFragment=fm.findFragmentByTag(tag)    final android.support.v4.app.FragmentTransaction ft=fm.beginTransaction()    try {     if (messagesFragment == null) {       messagesFragment=android.support.v4.app.Fragment.instantiate(activity,fragmentClass.getName(),args)        ft.add(parentViewId,messagesFragment,tag)      }  else {       if (messagesFragment.isDetached()) {         ft.attach(messagesFragment)        }     }   }   finally {     ft.commit()    } } 
/**   * @return string resource ID  */ int getCaptionResId()  
public LabeledFormatter(@Nonnull Context context){   this.context=context  } 
@Override public String formatValue(@Nullable T value) throws IllegalArgumentException { } 
protected AbstractUiThreadJEventListener(@Nonnull Class<E> eventType){   super(eventType)    uiHandler=Threads.newUiHandler()  } 
@Override public void onEvent(@Nonnull final E event){   uiHandler.post(new Runnable(){     @Override public void run(){       handleEvent(event)      }   } )  } 
@Override public void run(){   handleEvent(event)  } 
/**   * Called on UI thread  * @param event event to be processed  */ protected abstract void handleEvent(@Nonnull E event)  
@Nonnull AProperties clone()  
@Nullable AProperty getProperty(@Nonnull String name)  
@Nullable String getPropertyValue(@Nonnull String name)  
@Nonnull Collection<AProperty> getPropertiesCollection()  
@Nonnull String getName()  
@Nullable String getValue()  
boolean equals(Object o)  
int hashCode()  
@Override public APropertyImpl createFromParcel(@Nonnull Parcel in){   return fromParcel(in)  } 
@Override public APropertyImpl[] newArray(int size){   return new APropertyImpl[size]  } 
private APropertyImpl(){ } 
private APropertyImpl(@Nonnull String name,@Nullable String value){   this.name=name    this.value=value  } 
@Nonnull private static APropertyImpl fromParcel(@Nonnull Parcel in){   final String name=in.readString()    final String value=in.readString()    return (APropertyImpl)newInstance(name,value)  } 
@Nonnull public static AProperty newInstance(@Nonnull String name,@Nullable String value){   return new APropertyImpl(name,value)  } 
@Nonnull @Override public String getName(){   return this.name  } 
@Nullable @Override public String getValue(){   return this.value  } 
@Override public int describeContents(){   return 0  } 
@Override public void writeToParcel(@Nonnull Parcel out,int flags){   out.writeString(name)    out.writeString(value)  } 
@Nonnull @Override public APropertyImpl clone(){   return (APropertyImpl)super.clone()  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    final APropertyImpl that=(APropertyImpl)o    if (!name.equals(that.name))   return false    if (value != null ? !value.equals(that.value) : that.value != null)   return false    return true  } 
@Override public int hashCode(){   int result=name.hashCode()    result=31 * result + (value != null ? value.hashCode() : 0)    return result  } 
@Nonnull @Override MutableAProperties clone()  
@Nonnull AProperty setProperty(@Nonnull String name,@Nonnull String value)  
void setProperty(@Nonnull AProperty property)  
@Nullable AProperty removeProperty(@Nonnull String name)  
void clearProperties()  
@Nonnull Map<String,AProperty> getProperties()  
void setPropertiesFrom(@Nonnull MutableAProperties that)  
void setPropertiesFrom(@Nonnull Collection<AProperty> properties)  
public MutableAPropertiesImpl(){ } 
@Nonnull static MutableAProperties copyOf(@Nonnull MutableAProperties propertiesContainer){   return propertiesContainer.clone()  } 
@Nonnull static MutableAProperties newInstance(@Nonnull Collection<AProperty> properties){   final MutableAPropertiesImpl result=new MutableAPropertiesImpl()    for (  AProperty property : properties) {     result.setProperty(property)    }   return result  } 
@Nonnull static MutableAProperties newInstance(@Nonnull Map<String,AProperty> properties){   final MutableAPropertiesImpl result=new MutableAPropertiesImpl()    for (  AProperty property : properties.values()) {     result.setProperty(property)    }   return result  } 
@Nonnull @Override public MutableAPropertiesImpl clone(){   final MutableAPropertiesImpl clone=(MutableAPropertiesImpl)super.clone()    clone.properties=Cloneables.cloneMap(this.properties)    return clone  } 
@Override @Nonnull public AProperty setProperty(@Nonnull String name,@Nonnull String value){   final AProperty property=APropertyImpl.newInstance(name,value)    properties.put(name,property)    return property  } 
@Override public void setProperty(@Nonnull AProperty property){   properties.put(property.getName(),property)  } 
@Override public void setPropertiesFrom(@Nonnull MutableAProperties that){   for (  AProperty property : that.getProperties().values()) {     setProperty(property)    } } 
@Override public void setPropertiesFrom(@Nonnull Collection<AProperty> properties){   for (  AProperty property : properties) {     setProperty(property)    } } 
@Override @Nullable public AProperty removeProperty(@Nonnull String name){   return properties.remove(name)  } 
@Override @Nullable public AProperty getProperty(@Nonnull String name){   return properties.get(name)  } 
@Override public String getPropertyValue(@Nonnull String name){   final AProperty property=properties.get(name)    return property == null ? null : property.getValue()  } 
@Override public void clearProperties(){   properties.clear()  } 
@Override @Nonnull public Map<String,AProperty> getProperties(){   return Collections.unmodifiableMap(this.properties)  } 
@Override @Nonnull public Collection<AProperty> getPropertiesCollection(){   return Collections.unmodifiableCollection(this.properties.values())  } 
private Properties(){   throw new AssertionError()  } 
@Nonnull public static AProperty newProperty(@Nonnull String name,@Nullable String value){   return APropertyImpl.newInstance(name,value)  } 
@Nonnull public static MutableAProperties newProperties(@Nonnull Collection<AProperty> properties){   return MutableAPropertiesImpl.newInstance(properties)  } 
@Nonnull public static MutableAProperties newProperties(@Nonnull Map<String,AProperty> properties){   return MutableAPropertiesImpl.newInstance(properties)  } 
@Nonnull public static MutableAProperties copyOf(@Nonnull MutableAProperties properties){   return MutableAPropertiesImpl.copyOf(properties)  } 
@Nonnull static Parcelable.Creator<String> getInstance(){   return instance  } 
private StringParcelableCreator(){ } 
@Override public String createFromParcel(Parcel in){   return in.readString()  } 
@Override public String[] newArray(int size){   return new String[size]  } 
private Threads(){   throw new AssertionError()  } 
/**   * Method tries to run <var>runnable</var> on UI thread. Run can be failed if: 1. Specified <var>activity</var> is null 2. Specified <var>activity</var> is finishing  * @param activity activity bound to runnable  * @param runnable runnable to bve executed  */ public static void tryRunOnUiThread(@Nullable final Activity activity,@Nonnull final Runnable runnable){   if (activity != null && !activity.isFinishing()) {     if (isUiThread()) {       runnable.run()      }  else {       activity.runOnUiThread(new Runnable(){         @Override public void run(){           if (!activity.isFinishing()) {             runnable.run()            }         }       } )      }   } } 
@Override public void run(){   if (!activity.isFinishing()) {     runnable.run()    } } 
public static void tryRunOnUiThread(@Nonnull final Fragment fragment,@Nonnull final Runnable runnable){   Threads.tryRunOnUiThread(fragment.getActivity(),new Runnable(){     @Override public void run(){       final FragmentActivity activity=fragment.getActivity()        if (activity != null) {         runnable.run()        }     }   } )  } 
@Override public void run(){   final FragmentActivity activity=fragment.getActivity()    if (activity != null) {     runnable.run()    } } 
/**   * @return true if current thread is UI thread (= main application thread)  */ public static boolean isUiThread(){   return Looper.myLooper() == Looper.getMainLooper()  } 
/**   * @return new instance of {@link Handler} which runs on UI thread  */ @Nonnull public static Handler newUiHandler(){   return new Handler(Looper.getMainLooper())  } 
public UiThreadExecutor(){   this.uiHandler=Threads.newUiHandler()  } 
@Override public void execute(@Nonnull Runnable command,long delay,@Nonnull TimeUnit delayUnit){   this.uiHandler.postDelayed(command,delayUnit.toMillis(delay))  } 
@Override public void execute(@Nonnull Runnable command){   this.uiHandler.post(command)  } 
public DrawableFromIsConverter(@Nonnull String name){   this(name,null)  } 
public DrawableFromIsConverter(@Nonnull String name,@Nullable Drawable defaultDrawable){   this.name=name    this.defaultDrawable=defaultDrawable  } 
@Nonnull public static DrawableFromIsConverter getInstance(){   return instance  } 
@Nonnull @Override public Drawable convert(@Nonnull InputStream inputStream){   Drawable result=Drawable.createFromStream(inputStream,name)    if (result == null) {     result=defaultDrawable    }   if (result == null) {     throw new DrawableConversionFailedException()    }   return result  } 
@Nonnull V updateView(@Nonnull Context context,@Nonnull View view)  
@Nonnull V build(@Nonnull Context context)  
private Views(){   throw new AssertionError()  } 
/**   * Method runs through view and all it's children recursively and process them via viewProcessor  * @param view          parent view to be processed, if view is ViewGroup then all it's children will be processed  * @param viewProcessor object which processes views  */ public static void processViews(@Nonnull View view,@Nonnull ViewProcessor<View> viewProcessor){   processViewsOfType0(view,null,viewProcessor)  } 
static <T>void processViewsOfType0(@Nonnull View view,@Nullable Class<T> viewClass,@Nonnull ViewProcessor<T> viewProcessor){   if (view instanceof ViewGroup) {     final ViewGroup viewGroup=(ViewGroup)view      if (viewClass == null || viewClass.isAssignableFrom(ViewGroup.class)) {       viewProcessor.process((T)viewGroup)      }     for (int index=0  index < viewGroup.getChildCount()  index++) {       processViewsOfType0(viewGroup.getChildAt(index),viewClass,viewProcessor)      }   }  else   if (viewClass == null || viewClass.isAssignableFrom(view.getClass())) {     viewProcessor.process((T)view)    } } 
/**   * Method runs through view and all it's children recursively and process all instances of viewClass via viewProcessor  * @param view          parent view to be processed, if view is ViewGroup then all it's children will be processed  * @param viewClass     only instances of specified class will be processed  * @param viewProcessor object which processes views  */ public static <T>void processViewsOfType(@Nonnull View view,@Nonnull Class<T> viewClass,@Nonnull ViewProcessor<T> viewProcessor){   processViewsOfType0(view,viewClass,viewProcessor)  } 
/**   * Method center the tabs' contents on specified tabHost elements. This method should be invoked only for tabs with only text on them (and no image) This method checks some known devices/android versions/builds which don't support tab centering and do nothing for them <p/> NOTE: be aware that this method doesn't cover all unsupported cases, for sure don't use this method  * @param tabHost tabHost element  */ public static void centerAndWrapTabsFor(@Nonnull TabHost tabHost){   if (allowCenterAndWrappingTabs()) {     int tabCount=tabHost.getTabWidget().getTabCount()      for (int i=0  i < tabCount  i++) {       final View view=tabHost.getTabWidget().getChildTabViewAt(i)        if (view != null) {         if (view.getLayoutParams().height > 0) {           view.getLayoutParams().height*=0.8          }         final View textView=view.findViewById(android.R.id.title)          if (textView instanceof TextView) {           ((TextView)textView).setGravity(Gravity.CENTER)            ((TextView)textView).setSingleLine(false)            textView.getLayoutParams().height=ViewGroup.LayoutParams.FILL_PARENT            textView.getLayoutParams().width=ViewGroup.LayoutParams.WRAP_CONTENT          }       }     }   } } 
/**   * Internal method where checking if device supports centering of text tabs  * @return true if centering of text tabs is supported for this device/build/OS version  */ private static boolean allowCenterAndWrappingTabs(){   boolean result=true    String deviceModel=Build.MODEL    if (deviceModel != null) {     deviceModel=deviceModel.toUpperCase()      if (deviceModel.contains("M1") || deviceModel.contains("MIONE") || deviceModel.contains("MI-ONE")) {       result=false        Log.i(Android.class.getName(),"Device model doesn't support center and wrap of tabs: " + Build.MODEL)      }   }   if (result) {     String buildId=Build.DISPLAY      if (buildId != null) {       buildId=buildId.toUpperCase()        if (buildId.contains("MIUI")) {         result=false          Log.i(Android.class.getName(),"Device build doesn't support center and wrap of tabs: " + Build.DISPLAY)        }     }   }   return result  } 
/**   * Method adds tab to the tabHost element  * @param context       activity which users tabHost  * @param tabHost       tabHost element  * @param tabId         id of tab to be added  * @param tabCaptionId  string id of tab to be added  * @param activityClass activity class to be invoked if the tab is pressed  */ public static void addTab(@Nonnull Context context,@Nonnull TabHost tabHost,@Nonnull String tabId,int tabCaptionId,@Nonnull Class<? extends Activity> activityClass){   final Intent intent=new Intent().setClass(context,activityClass)    final TabHost.TabSpec tabSpec=tabHost.newTabSpec(tabId).setIndicator(context.getString(tabCaptionId)).setContent(intent)    tabHost.addTab(tabSpec)  } 
public static int toPixels(@Nonnull DisplayMetrics dm,float dps){   final float scale=dm.density    return (int)(dps * scale + 0.5f)  } 
public static int getScreenOrientation(@Nonnull Activity activity){   final Display display=activity.getWindowManager().getDefaultDisplay()    final int result    if (display.getWidth() <= display.getHeight()) {     result=Configuration.ORIENTATION_PORTRAIT    }  else {     result=Configuration.ORIENTATION_LANDSCAPE    }   return result  } 
public static boolean isLayoutSizeAtLeast(int size,@Nonnull Configuration configuration){   int cur=configuration.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK    if (cur == Configuration.SCREENLAYOUT_SIZE_UNDEFINED)   return false    return cur >= size  } 
public static int getPointerCountFromMotionEvent(@Nonnull MotionEvent event){   return AT_LEAST_API_5 ? event.getPointerCount() : 1  } 
public static float getXFromMotionEvent(@Nonnull MotionEvent event,int pointer){   return AT_LEAST_API_5 ? event.getX(pointer) : 0  } 
public static float getYFromMotionEvent(@Nonnull MotionEvent event,int pointer){   return AT_LEAST_API_5 ? event.getY(pointer) : 0  } 
void process(@Nonnull V view)  
protected AbstractDbQuery(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper){   this.context=context    this.sqliteOpenHelper=sqliteOpenHelper  } 
@Nonnull protected Context getContext(){   return context  } 
@Nonnull protected SQLiteOpenHelper getSqliteOpenHelper(){   return sqliteOpenHelper  } 
protected AbstractObjectDbExec(@Nullable T object){   this.object=object  } 
@Nullable protected T getObject(){   return object  } 
@Nonnull protected T getNotNullObject(){ } 
protected AbstractSQLiteHelper(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper){   this.context=context    this.sqliteOpenHelper=sqliteOpenHelper  } 
@Nonnull protected Context getContext(){   return context  } 
@Nonnull protected SQLiteOpenHelper getSqliteOpenHelper(){   return sqliteOpenHelper  } 
private AndroidDbUtils(){   throw new AssertionError()  } 
@Nonnull public static <R>R doDbQuery(@Nonnull SQLiteOpenHelper dbHelper,@Nonnull DbQuery<R> query){   final R result  synchronized (dbHelper) {     SQLiteDatabase db=null      boolean wasOpened=false      try {       db=dbCache.get(dbHelper)        if (db == null) {         db=dbHelper.getWritableDatabase()          dbCache.put(dbHelper,db)          wasOpened=true        }       Cursor cursor=null        try {         cursor=query.createCursor(db)          result=query.retrieveData(cursor)        }   finally {         if (cursor != null) {           cursor.close()          }       }     }   finally {       if (db != null && wasOpened) {         dbCache.remove(dbHelper)        }     }   }   return result  } 
@Nonnull public static Long doDbExec(@Nonnull SQLiteOpenHelper dbHelper,@Nonnull DbExec exec){   final List<Long> result=doDbExecs(dbHelper,Arrays.asList(exec))    if (!result.isEmpty()) {     return result.get(0)    }  else {     return DbExec.SQL_ERROR    } } 
public static List<Long> doDbExecs(@Nonnull SQLiteOpenHelper dbHelper,@Nonnull List<DbExec> execs){   final List<Long> result  synchronized (dbHelper) {     SQLiteDatabase db=null      boolean wasOpened=false      try {       db=dbCache.get(dbHelper)        if (db == null) {         db=dbHelper.getWritableDatabase()          dbCache.put(dbHelper,db)          wasOpened=true        }       result=doDbTransactions(db,execs)      }   finally {       if (db != null && wasOpened) {         dbCache.remove(dbHelper)        }     }   }   return result  } 
@Nonnull private static List<Long> doDbTransactions(@Nonnull SQLiteDatabase db,@Nonnull List<DbExec> execs){   final List<Long> result=new ArrayList<Long>(execs.size())    try {     db.beginTransaction()      for (    DbExec exec : execs) {       result.add(exec.exec(db))      }     db.setTransactionSuccessful()    }   finally {     db.endTransaction()    }   return result  } 
@Nonnull public static String[] inClauseValues(@Nonnull List<?> objects,@Nonnull String... beforeInValues){   final String[] result=new String[objects.size() + beforeInValues.length]    for (int i=0  i < result.length  i++) {     if (i < beforeInValues.length) {       result[i]=beforeInValues[i]      }  else {       result[i]=objects.get(i - beforeInValues.length).toString()      }   }   return result  } 
@Nonnull public static String inClause(@Nonnull List<?> objects){   final StringBuilder result=new StringBuilder(3 * objects.size())    result.append("(")    if (objects.size() == 1) {     result.append("?")    }  else   if (objects.size() > 1) {     result.append("?")      result.append(Strings.repeat(", ?",objects.size() - 1))    }  else {     result.append("'foo'")    }   result.append(")")    return result.toString()  } 
public BatchDbTransaction(@Nonnull String sqls,@Nonnull String delimiters){   this.sqls=sqls    this.delimiters=delimiters  } 
public void batchQuery(@Nonnull SQLiteDatabase db){   try {     db.beginTransaction()      final StringTokenizer st=new StringTokenizer(sqls,delimiters,false)      while (st.hasMoreTokens()) {       final String sql=st.nextToken()        if (sql.startsWith("--")) {         Log.d(TAG,"Comments: " + sql)          continue        }       Log.d(TAG,"Executing sql: " + sql)        db.execSQL(sql)      }     db.setTransactionSuccessful()    }   finally {     db.endTransaction()    } } 
public CommonSQLiteOpenHelper(@Nonnull Context context,@Nonnull SQLiteOpenHelperConfiguration configuration){   super(context.getApplicationContext(),configuration.getName(),configuration.getCursorFactory(),configuration.getVersion())    this.context=context.getApplicationContext()    this.databaseName=configuration.getName()    this.version=configuration.getVersion()  } 
@Override public void onCreate(@Nonnull SQLiteDatabase db){   onUpgrade(db,0,this.version)  } 
@Override public void onUpgrade(@Nonnull SQLiteDatabase db,int oldVersion,int newVersion){   Log.d(TAG,"Upgrading database, old version: " + oldVersion + ", new version: "+ newVersion)    final DecimalFormat decimalFormat=new DecimalFormat("000",new DecimalFormatSymbols(Locale.US))    for (int version=oldVersion + 1  version <= newVersion  version++) {     try {       final String fileVersionPostfix=decimalFormat.format(version)        final String fileName="db_" + databaseName + "_"+ fileVersionPostfix+ ".sql"        Log.d(TAG,"Reading " + fileName + "...")        final String sqls=convertStreamToString(context.getAssets().open(fileName))        Log.d(TAG,fileName + " successfully read, size: " + sqls.length())        new BatchDbTransaction(sqls," \n").batchQuery(db)      }  catch (    FileNotFoundException e) {       Log.d(TAG,e.getMessage())      } catch (    IOException e) {       Log.e(TAG,e.getMessage())        throw new RuntimeException(e)      }   } } 
@Nonnull public String convertStreamToString(java.io.InputStream is){   try {     return new Scanner(is,"UTF-8").useDelimiter("\\A").next()    }  catch (  java.util.NoSuchElementException e) {     return ""    } } 
/**   * Method executes database operation. If insert operation is done and error is occurred  {@link DbExec#SQL_ERROR} is returned.  * @param db sqlite database instance  * @return number of affected rows (for update or delete) or newly generated ID (for insert)  */ long exec(@Nonnull SQLiteDatabase db)  
@Nonnull Cursor createCursor(@Nonnull SQLiteDatabase db)  
@Nonnull R retrieveData(@Nonnull Cursor cursor)  
public ListMapper(@Nonnull Converter<Cursor,? extends T> elementMapper){   this.elementMapper=elementMapper  } 
@Nonnull @Override public List<T> convert(@Nonnull Cursor cursor){   final List<T> result=new ArrayList<T>()    if (cursor.moveToFirst()) {     while (!cursor.isAfterLast()) {       result.add(elementMapper.convert(cursor))        cursor.moveToNext()      }   }   return result  } 
public MaxIdLoader(@Nonnull String tableName,@Nonnull String columnName){   this.tableName=tableName    this.columnName=columnName  } 
@Nonnull @Override public Cursor createCursor(@Nonnull SQLiteDatabase db){   final StringBuilder query=new StringBuilder()    query.append("select max(").append(columnName).append(") from ").append(tableName)    return db.rawQuery(query.toString(),null)  } 
@Nonnull @Override public Integer retrieveData(@Nonnull Cursor cursor){   cursor.moveToNext()    return cursor.getInt(0)  } 
@Nonnull List<AProperty> loadPropertiesById(@Nonnull Object id)  
void removePropertiesById(@Nonnull Object id)  
void insertProperty(@Nonnull Object id,@Nonnull AProperty property)  
void insertProperties(@Nonnull Object id,@Nonnull Collection<AProperty> properties)  
private APropertyMapper(){ } 
@Nonnull public static APropertyMapper getInstance(){   return instance  } 
@Nonnull @Override public AProperty convert(@Nonnull Cursor cursor){   final String id=cursor.getString(0)    final String name=cursor.getString(1)    final String value=cursor.getString(2)    return Properties.newProperty(name,value)  } 
public InsertPropertyDbExec(@Nonnull Object id,@Nonnull AProperty property,@Nonnull String tableName,@Nonnull String idColumnName,@Nonnull String propertyNameColumnName,@Nonnull String propertyValueColumnName){   this.id=id    this.property=property    this.tableName=tableName    this.idColumnName=idColumnName    this.propertyNameColumnName=propertyNameColumnName    this.propertyValueColumnName=propertyValueColumnName  } 
@Override public long exec(@Nonnull SQLiteDatabase db){   final ContentValues values=new ContentValues()    values.put(idColumnName,String.valueOf(id))    values.put(propertyNameColumnName,property.getName())    values.put(propertyValueColumnName,property.getValue())    return db.insert(tableName,null,values)  } 
public PropertyByIdDbQuery(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper,@Nonnull String tableName,@Nonnull String idColumnName,@Nonnull Object id){   super(context,sqliteOpenHelper)    this.tableName=tableName    this.idColumnName=idColumnName    this.id=id  } 
@Nonnull @Override public Cursor createCursor(@Nonnull SQLiteDatabase db){   return db.query(tableName,null,idColumnName + " = ? ",new String[]{String.valueOf(id)},null,null,null)  } 
@Nonnull @Override public List<AProperty> retrieveData(@Nonnull Cursor cursor){   return new ListMapper<AProperty>(APropertyMapper.getInstance()).convert(cursor)  } 
public RemovePropertiesDbExec(@Nonnull Object id,@Nonnull String tableName,@Nonnull String idColumnName){   this.id=id    this.tableName=tableName    this.idColumnName=idColumnName  } 
@Override public long exec(@Nonnull SQLiteDatabase db){   return db.delete(tableName,idColumnName + " = ? ",new String[]{String.valueOf(id)})  } 
public SqliteAPropertyDao(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper,@Nonnull String tableName,@Nonnull String idColumnName,@Nonnull String propertyNameColumnName,@Nonnull String propertyValueColumnName){   super(context,sqliteOpenHelper)    this.tableName=tableName    this.idColumnName=idColumnName    this.propertyNameColumnName=propertyNameColumnName    this.propertyValueColumnName=propertyValueColumnName  } 
@Nonnull @Override public List<AProperty> loadPropertiesById(@Nonnull Object id){   return AndroidDbUtils.doDbQuery(getSqliteOpenHelper(),new PropertyByIdDbQuery(getContext(),getSqliteOpenHelper(),tableName,idColumnName,id))  } 
@Override public void removePropertiesById(@Nonnull Object id){   AndroidDbUtils.doDbExec(getSqliteOpenHelper(),new RemovePropertiesDbExec(id,tableName,idColumnName))  } 
@Override public void insertProperty(@Nonnull Object id,@Nonnull AProperty property){   AndroidDbUtils.doDbExec(getSqliteOpenHelper(),new InsertPropertyDbExec(id,property,tableName,idColumnName,propertyNameColumnName,propertyValueColumnName))  } 
@Override public void insertProperties(@Nonnull Object id,@Nonnull Collection<AProperty> properties){   final List<DbExec> execs=new ArrayList<DbExec>(properties.size())    for (  AProperty property : properties) {     execs.add(new InsertPropertyDbExec(id,property,tableName,idColumnName,propertyNameColumnName,propertyValueColumnName))    }   AndroidDbUtils.doDbExecs(getSqliteOpenHelper(),execs)  } 
@Nonnull String getName()  
@Nullable SQLiteDatabase.CursorFactory getCursorFactory()  
int getVersion()  
private StringVersionedEntityMapper(){ } 
@Nonnull public static Converter<Cursor,VersionedEntity<String>> getInstance(){   return instance  } 
@Nonnull @Override public VersionedEntity<String> convert(@Nonnull Cursor cursor){   final String id=cursor.getString(0)    final int version=cursor.getInt(1)    return newEntity(id,version)  } 
public AbstractFragmentReuseCondition(@Nonnull Class<F> fragmentClass){   this.fragmentClass=fragmentClass  } 
@Override public final boolean apply(@Nullable Fragment f){   if (f != null && fragmentClass.isAssignableFrom(f.getClass())) {     return canReuseFragment((F)f)    }  else {     return false    } } 
/**   * @param fragment typed for fragment on which reuse check must be done  * @return true if <var>fragment</var> can be reused  */ protected abstract boolean canReuseFragment(@Nonnull F fragment)  
@Nonnull String getFragmentTag()  
@Nonnull Class<? extends Fragment> getFragmentClass()  
boolean isAddToBackStack()  
private MultiPaneFragmentDef(@Nonnull String tag,boolean addToBackStack){   this.tag=tag    this.addToBackStack=addToBackStack  } 
@Nonnull public static MultiPaneFragmentDef forClass(@Nonnull String tag,boolean addToBackStack,@Nonnull Class<? extends Fragment> fragmentClass,@Nonnull Context context,@Nullable Bundle args){   return newInstance(tag,addToBackStack,ReflectionFragmentBuilder.forClass(context,fragmentClass,args),SimpleFragmentReuseCondition.forClass(fragmentClass))  } 
@Nonnull public static MultiPaneFragmentDef forClass(@Nonnull String tag,boolean addToBackStack,@Nonnull Class<? extends Fragment> fragmentClass,@Nonnull Context context,@Nullable Bundle args,@Nullable JPredicate<Fragment> reuseCondition){   return newInstance(tag,addToBackStack,ReflectionFragmentBuilder.forClass(context,fragmentClass,args),reuseCondition)  } 
@Nonnull public static MultiPaneFragmentDef newInstance(@Nonnull String tag,boolean addToBackStack,@Nonnull Builder<? extends Fragment> builder,@Nullable JPredicate<Fragment> reuseCondition){   final MultiPaneFragmentDef result=new MultiPaneFragmentDef(tag,addToBackStack)    result.builder=builder    result.reuseCondition=reuseCondition    return result  } 
@Nonnull public static MultiPaneFragmentDef fromFragmentDef(@Nonnull FragmentDef fragmentDef,@Nullable Bundle fragmentArgs,@Nonnull Context context){   final MultiPaneFragmentDef result=new MultiPaneFragmentDef(fragmentDef.getFragmentTag(),fragmentDef.isAddToBackStack())    final Class<? extends Fragment> fragmentClass=fragmentDef.getFragmentClass()    result.builder=ReflectionFragmentBuilder.forClass(context,fragmentClass,fragmentArgs)    result.reuseCondition=SimpleFragmentReuseCondition.forClass(fragmentClass)    return result  } 
public boolean isAddToBackStack(){   return addToBackStack  } 
@Nonnull public String getTag(){   return tag  } 
@Nonnull public Fragment build(){   return builder.build()  } 
public boolean canReuse(@Nonnull Fragment fragment){   return reuseCondition != null && reuseCondition.apply(fragment)  } 
public MultiPaneFragmentManager(@Nonnull FragmentActivity activity,int mainPaneViewId,@Nonnull Class<? extends Fragment> emptyFragmentClass,@Nonnull String emptyFragmentTag){   this.activity=activity    this.mainPaneViewId=mainPaneViewId    this.emptyFragmentClass=emptyFragmentClass    this.emptyFragmentTag=emptyFragmentTag  } 
public MultiPaneFragmentManager(@Nonnull FragmentActivity activity,int mainPaneViewId,@Nonnull Class<? extends Fragment> emptyFragmentClass,@Nonnull String emptyFragmentTag,int startingAnimationResId,int endingAnimationResId){   this.activity=activity    this.mainPaneViewId=mainPaneViewId    this.emptyFragmentClass=emptyFragmentClass    this.emptyFragmentTag=emptyFragmentTag    this.startingAnimationResId=startingAnimationResId    this.endingAnimationResId=endingAnimationResId  } 
@Nonnull public FragmentActivity getActivity(){   return activity  } 
@Nonnull private MultiPaneFragmentDef createEmptyMultiPaneFragmentDef(int paneViewId){   return MultiPaneFragmentDef.forClass(getEmptyFragmentTag(paneViewId),false,emptyFragmentClass,activity,null)  } 
@Nonnull private String getEmptyFragmentTag(int paneViewId){   return emptyFragmentTag + "-" + paneViewId  } 
protected void setFragment(int fragmentViewId,@Nonnull MultiPaneFragmentDef mpfd){   final FragmentManager fm=activity.getSupportFragmentManager()    final FragmentTransaction ft=fm.beginTransaction()    setFragment(fragmentViewId,mpfd,fm,ft)    ft.commitAllowingStateLoss()    executePendingTransactions(fm)  } 
private void setFragment(final int fragmentViewId,@Nonnull final MultiPaneFragmentDef mpfd,@Nonnull final FragmentManager fm,@Nonnull final FragmentTransaction ft){   hideKeyboard()    boolean canContinue=executePendingTransactions(fm)    if (canContinue) {     if (startingAnimationResId != NO_ANIMATION && endingAnimationResId != NO_ANIMATION) {       ft.setCustomAnimations(startingAnimationResId,endingAnimationResId,startingAnimationResId,endingAnimationResId)      }     if (mpfd.isAddToBackStack()) {       ft.addToBackStack(mpfd.getTag())      }     final Fragment fragmentByTag=fm.findFragmentByTag(mpfd.getTag())      final Fragment fragmentById=fm.findFragmentById(fragmentViewId)      if (fragmentByTag != null) {       if (mpfd.canReuse(fragmentByTag)) {         if (fragmentByTag.isDetached()) {           if (fragmentById != null) {             tryRemoveFragment(ft,fragmentById)            }           ft.attach(fragmentByTag)          }  else {           if (fragmentByTag.equals(fragmentById)) {           }  else {             if (fragmentById != null) {               ft.remove(fragmentById)              }             final Fragment newFragment=mpfd.build()              copyState(fragmentByTag,newFragment,fm)              ft.remove(fragmentByTag)              ft.add(fragmentViewId,newFragment,mpfd.getTag())            }         }       }  else {         ft.remove(fragmentByTag)          if (fragmentById != null && fragmentById != fragmentByTag) {           tryRemoveFragment(ft,fragmentById)          }         ft.add(fragmentViewId,mpfd.build(),mpfd.getTag())        }     }  else {       if (fragmentById != null) {         tryRemoveFragment(ft,fragmentById)        }       ft.add(fragmentViewId,mpfd.build(),mpfd.getTag())      }   } } 
public void copyState(@Nonnull Fragment source,@Nonnull Fragment destination,@Nonnull FragmentManager fm){   final Fragment.SavedState savedState=fm.saveFragmentInstanceState(source)    destination.setInitialSavedState(savedState)  } 
public void hideKeyboard(){   final View focusedView=activity.getCurrentFocus()    if (focusedView != null) {     final InputMethodManager imm=(InputMethodManager)activity.getSystemService(Context.INPUT_METHOD_SERVICE)      imm.hideSoftInputFromWindow(focusedView.getWindowToken(),0)    } } 
/**   * Method executes all pending transactions in  {@link android.support.v4.app.FragmentManager}.  * @param fm fragment manager  * @return true if pending transactions were successfully executed, false otherwise  */ private boolean executePendingTransactions(@Nonnull FragmentManager fm){   boolean success    try {     fm.executePendingTransactions()      success=true    }  catch (  RuntimeException e) {     success=false      Log.e(TAG,e.getMessage(),e)      Activities.restartActivity(activity)    }   return success  } 
private void tryRemoveFragment(@Nonnull FragmentTransaction ft,@Nonnull Fragment fragment){   if (fragment instanceof DetachableFragment) {     if (!fragment.isDetached()) {       ft.detach(fragment)      }   }  else {     ft.remove(fragment)    } } 
public void removeFragment(int fragmentViewId){   final FragmentManager fm=activity.getSupportFragmentManager()    final FragmentTransaction ft=fm.beginTransaction()    final Fragment fragmentById=fm.findFragmentById(fragmentViewId)    if (fragmentById != null) {     tryRemoveFragment(ft,fragmentById)    }   ft.commitAllowingStateLoss()    executePendingTransactions(fm)  } 
public void goBack(){   hideKeyboard()    activity.getSupportFragmentManager().popBackStack()  } 
public boolean goBackImmediately(){   hideKeyboard()    return activity.getSupportFragmentManager().popBackStackImmediate()  } 
public void goBack(@Nonnull String tag){   hideKeyboard()    activity.getSupportFragmentManager().popBackStack(tag,FragmentManager.POP_BACK_STACK_INCLUSIVE)  } 
public boolean isFragmentShown(@Nonnull String fragmentTag){   final FragmentManager fm=activity.getSupportFragmentManager()    final Fragment fragment=fm.findFragmentByTag(fragmentTag)    if (fragment != null && fragment.isAdded() && !fragment.isDetached()) {     return true    }  else {     return false    } } 
@Nullable public <F extends Fragment>F getFragment(@Nonnull String fragmentTag){   final FragmentManager fm=activity.getSupportFragmentManager()    return (F)fm.findFragmentByTag(fragmentTag)  } 
protected void emptifyFragmentPane(int paneViewId){   setFragment(paneViewId,createEmptyMultiPaneFragmentDef(paneViewId))  } 
@Deprecated public void setMainFragment(@Nonnull Class<? extends Fragment> fragmentClass,@Nullable Bundle fragmentArgs,@Nullable JPredicate<Fragment> reuseCondition,@Nonnull String fragmentTag,boolean addToBackStack){   setMainFragment(MultiPaneFragmentDef.newInstance(fragmentTag,addToBackStack,ReflectionFragmentBuilder.forClass(activity,fragmentClass,fragmentArgs),reuseCondition))  } 
@Deprecated public void setMainFragment(@Nonnull Builder<Fragment> fragmentBuilder,@Nullable JPredicate<Fragment> reuseCondition,@Nonnull String fragmentTag){   setMainFragment(fragmentBuilder,reuseCondition,fragmentTag,false)  } 
@Deprecated public void setMainFragment(@Nonnull Builder<Fragment> fragmentBuilder,@Nullable JPredicate<Fragment> reuseCondition,@Nonnull String fragmentTag,boolean addToBackStack){   setMainFragment(MultiPaneFragmentDef.newInstance(fragmentTag,addToBackStack,fragmentBuilder,reuseCondition))  } 
public void setMainFragment(@Nonnull MultiPaneFragmentDef mpfd){   setFragment(mainPaneViewId,mpfd)  } 
protected void emptifyMainFragment(){   setMainFragment(createEmptyMultiPaneFragmentDef(mainPaneViewId))  } 
public void setMainFragment(@Nonnull FragmentDef fragmentDef,@Nonnull FragmentManager fm,@Nonnull FragmentTransaction ft){   setFragment(mainPaneViewId,MultiPaneFragmentDef.fromFragmentDef(fragmentDef,null,activity),fm,ft)  } 
public void setMainFragment(@Nonnull FragmentDef fragmentDef,@Nullable Bundle fragmentArgs){   setFragment(mainPaneViewId,MultiPaneFragmentDef.fromFragmentDef(fragmentDef,fragmentArgs,activity))  } 
public void setMainFragment(@Nonnull FragmentDef fragmentDef){   setMainFragment(fragmentDef,null)  } 
private ReflectionFragmentBuilder(@Nonnull Context context,@Nonnull Class<? extends F> fragmentClass,@Nullable Bundle fragmentArgs){   this.context=context    this.fragmentClass=fragmentClass    this.fragmentArgs=fragmentArgs  } 
@Nonnull public static <F extends Fragment>ReflectionFragmentBuilder<F> forClass(@Nonnull Context context,@Nonnull Class<? extends F> fragmentClass,@Nullable Bundle fragmentArgs){   return new ReflectionFragmentBuilder<F>(context,fragmentClass,fragmentArgs)  } 
@Nonnull @Override public F build(){   return (F)Fragment.instantiate(context,fragmentClass.getName(),fragmentArgs)  } 
private SimpleFragmentReuseCondition(@Nonnull Class<F> fragmentClass){   super(fragmentClass)  } 
@Nonnull public static <F extends Fragment>JPredicate<Fragment> forClass(@Nonnull Class<F> fragmentClass){   return new SimpleFragmentReuseCondition<F>(fragmentClass)  } 
@Override protected boolean canReuseFragment(@Nonnull F fragment){   return true  } 
public SimpleMultiPaneFragmentManager(@Nonnull FragmentActivity activity,@Nonnull Class<? extends Fragment> emptyFragmentClass){   super(activity,R.id.acl_content_first_pane,emptyFragmentClass,"empty-fragment")  } 
public void setSecondFragment(@Nonnull Class<? extends Fragment> fragmentClass,@Nullable Bundle fragmentArgs,@Nullable JPredicate<Fragment> reuseCondition,@Nonnull String fragmentTag,boolean addToBackStack){   setFragment(R.id.acl_content_second_pane,MultiPaneFragmentDef.newInstance(fragmentTag,addToBackStack,ReflectionFragmentBuilder.forClass(getActivity(),fragmentClass,fragmentArgs),reuseCondition))  } 
public void setSecondFragment(@Nonnull Builder<Fragment> fragmentBuilder,@Nullable JPredicate<Fragment> reuseCondition,@Nonnull String fragmentTag){   setFragment(R.id.acl_content_second_pane,MultiPaneFragmentDef.newInstance(fragmentTag,false,fragmentBuilder,reuseCondition))  } 
public void emptifySecondFragment(){   emptifyFragmentPane(R.id.acl_content_second_pane)  } 
public boolean isDualPane(){   return getActivity().findViewById(R.id.acl_content_second_pane) != null  } 
public boolean isTriplePane(){   return getActivity().findViewById(R.id.acl_content_third_pane) != null  } 
public boolean isFirstPane(@Nullable View parent){   return parent != null && parent.getId() == R.id.acl_content_first_pane  } 
public boolean isSecondPane(@Nullable View parent){   return parent != null && parent.getId() == R.id.acl_content_second_pane  } 
public boolean isThirdPane(@Nullable View parent){   return parent != null && parent.getId() == R.id.acl_content_third_pane  } 
public void onCreateView(@Nullable View paneParent,@Nonnull View pane){   final Activity activity=getActivity()    if (this.isDualPane()) {     if (this.isFirstPane(paneParent)) {       pane.setBackgroundDrawable(activity.getResources().getDrawable(R.drawable.acl_border_right))        pane.setPadding(0,0,0,0)      }  else     if (this.isSecondPane(paneParent)) {       pane.setBackgroundColor(activity.getResources().getColor(R.color.acl_bg))      }  else     if (this.isTriplePane() && this.isThirdPane(paneParent)) {       if (Views.getScreenOrientation(activity) == Configuration.ORIENTATION_LANDSCAPE) {         pane.setBackgroundDrawable(activity.getResources().getDrawable(R.drawable.acl_border_left))        }  else {         pane.setBackgroundColor(activity.getResources().getColor(R.color.acl_bg))        }     }   }  else {     pane.setBackgroundColor(activity.getResources().getColor(R.color.acl_bg))    }   final TextView fragmentTitleTextView=(TextView)pane.findViewById(R.id.acl_fragment_title)    if (fragmentTitleTextView != null) {     if (this.isDualPane()) {       final CharSequence fragmentTitle=fragmentTitleTextView.getText()        if (Strings.isEmpty(fragmentTitle)) {         fragmentTitleTextView.setVisibility(View.GONE)        }  else {         fragmentTitleTextView.setText(String.valueOf(fragmentTitle).toUpperCase())          fragmentTitleTextView.setVisibility(View.VISIBLE)        }     }  else {       fragmentTitleTextView.setVisibility(View.GONE)      }   } } 
public CustomExceptionHandler(@Nullable String localPath,@Nullable String url){   this.localPath=localPath    this.url=url    this.defaultUEH=Thread.getDefaultUncaughtExceptionHandler()  } 
public void uncaughtException(Thread t,Throwable e){   try {     final Date time=new Date()      final String stackTrace=getStackTrace(e)      if (stackTrace != null) {       if (localPath != null) {         writeToFile(stackTrace,String.valueOf(time.getTime()) + ".stacktrace")        }       if (url != null) {         sendToServer(stackTrace,time)        }     }   }  catch (  Throwable anyException) {     Log.e(TAG,Strings.fromStackTrace(anyException.getStackTrace()))    }  finally {     defaultUEH.uncaughtException(t,e)    } } 
@Nullable private String getStackTrace(@Nonnull Throwable e){   PrintWriter writer=null    String result    try {     final StringWriter sw=new StringWriter()      writer=new PrintWriter(sw)      e.printStackTrace(writer)      result=sw.toString()    }   finally {     if (writer != null) {       writer.close()      }   }   return result  } 
private void writeToFile(@Nonnull String stackTrace,@Nonnull String fileName){   try {     BufferedWriter bos=null      try {       bos=new BufferedWriter(new FileWriter(localPath + "/" + fileName))        bos.write(stackTrace)        bos.flush()      }   finally {       if (bos != null) {         bos.close()        }     }   }  catch (  Exception e) {     Log.e(TAG,Strings.fromStackTrace(e.getStackTrace()))    } } 
private void sendToServer(@Nonnull final String stackTrace,@Nonnull Date time){   final DefaultHttpClient httpClient=new DefaultHttpClient()    final HttpPost httpPost=new HttpPost(url)    httpPost.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE,false)    final List<NameValuePair> values=new ArrayList<NameValuePair>()    values.add(new BasicNameValuePair("timestamp",time.toString()))    values.add(new BasicNameValuePair("stacktrace",stackTrace))    try {     httpPost.setEntity(new UrlEncodedFormEntity(values,HTTP.UTF_8))      httpClient.execute(httpPost)    }  catch (  IOException e) {   } } 
protected AbstractHttpTransaction(@Nonnull String uri,@Nonnull HttpMethod httpMethod){   this(uri,httpMethod,HTTP.UTF_8)  } 
protected AbstractHttpTransaction(@Nonnull String uri,@Nonnull HttpMethod httpMethod,@Nullable String encoding){   this.encoding=encoding    this.uri=uri    this.httpMethod=httpMethod  } 
@Override @Nonnull public HttpMethod getHttpMethod(){   return httpMethod  } 
@Override @Nonnull public String getUri(){   return uri  } 
@Nullable public String getEncoding(){   return encoding  } 
@Nonnull @Override public HttpUriRequest createRequest(){   return httpMethod.createRequest(uri,getRequestParameters(),encoding)  } 
@Nonnull DefaultHttpClient getHttpClient()  
<R>R execute(@Nonnull HttpTransaction<R> httpTransaction) throws IOException   
@Nonnull <R>List<R> execute(@Nonnull List<? extends HttpTransaction<R>> httpTransactions) throws IOException   
@Nonnull @Override public DefaultHttpClient getHttpClient(){   return httpClient  } 
@Override public <R>R execute(@Nonnull HttpTransaction<R> httpTransaction) throws IOException {   return Collections.getFirstListElement(execute(asList(httpTransaction)))  } 
@Override @Nonnull public <R>List<R> execute(@Nonnull List<? extends HttpTransaction<R>> httpTransactions) throws IOException {   final List<R> result=new ArrayList<R>()    for (  HttpTransaction<R> httpTransaction : httpTransactions) {     final String transactionName=httpTransaction.getClass().getSimpleName()      Log.d(TAG,"Executing transaction: " + transactionName)      final HttpUriRequest request=httpTransaction.createRequest()      final HttpResponse httpResponse=httpClient.execute(request)      final R response=httpTransaction.getResponse(httpResponse)      result.add(response)      Log.d(TAG,"Execution finished: " + transactionName)    }   return result  } 
public CachingImageLoader(@Nonnull Context context,@Nonnull String cacheFileName,@Nonnull Handler handler){   this.fileCache=new FileCache(context,cacheFileName)    this.executorService=Executors.newFixedThreadPool(5)    this.handler=handler  } 
@Override public void loadImage(@Nonnull String url,@Nonnull ImageView imageView,@Nullable Integer defaultImageId){   loadImage(url,new ImageViewImageLoadedListener(imageView,defaultImageId,handler))  } 
@Override public void loadImage(@Nonnull String url,@Nonnull OnImageLoadedListener imageLoadedListener){   imageViews.put(imageLoadedListener,url)    final Bitmap bitmapFromMemory=memoryCache.get(url)    if (bitmapFromMemory != null) {     imageLoadedListener.onImageLoaded(bitmapFromMemory)    }  else {     imageLoadedListener.setDefaultImage()      queuePhoto(url,imageLoadedListener)    } } 
@Override public void loadImage(@Nonnull String url){   final Bitmap bitmapFromMemory=memoryCache.get(url)    if (bitmapFromMemory != null) {   }  else {     queuePhoto(url,EmptyImageLoadedListener.getInstance())    } } 
private void queuePhoto(@Nonnull String url,@Nonnull OnImageLoadedListener imageLoadedListener){   executorService.submit(new PhotosLoader(new PhotoToLoad(url,imageLoadedListener)))  } 
@Nullable private Bitmap getBitmap(@Nonnull String url){   final File cachedBitmapFile=fileCache.getFile(createFilename(url))    Bitmap result=decodeFile(cachedBitmapFile)    if (result == null) {     try {       final URL imageUrl=new URL(url)        final HttpURLConnection connection=(HttpURLConnection)imageUrl.openConnection()        connection.setConnectTimeout(30000)        connection.setReadTimeout(30000)        connection.setInstanceFollowRedirects(true)        final InputStream is=connection.getInputStream()        OutputStream os=null        try {         os=new FileOutputStream(cachedBitmapFile)          Utils.copyStream(is,os)        }   finally {         if (os != null) {           os.close()          }       }       result=decodeFile(cachedBitmapFile)      }  catch (    MalformedURLException e) {       Log.e(TAG,e.getMessage(),e)      } catch (    FileNotFoundException e) {       Log.e(TAG,e.getMessage(),e)      } catch (    IOException e) {       Log.e(TAG,e.getMessage(),e)      }   }   return result  } 
@Nonnull private String createFilename(String url){   try {     return URLEncoder.encode(url,"UTF-8")    }  catch (  UnsupportedEncodingException e) {     throw new AssertionError(e)    } } 
@Nullable private static Bitmap decodeFile(@Nonnull File file){   try {     final BitmapFactory.Options o=new BitmapFactory.Options()      final Bitmap bitmap=BitmapFactory.decodeStream(new FileInputStream(file),null,o)      int tmpWidth=o.outWidth      int tmpHeight=o.outHeight      int scale=1      while (true) {       if (tmpWidth < REQUIRED_SIZE || tmpHeight < REQUIRED_SIZE) {         break        }       tmpWidth/=2        tmpHeight/=2        scale*=2      }     if (scale == 1) {       return bitmap      }  else {       final BitmapFactory.Options o2=new BitmapFactory.Options()        o2.inSampleSize=scale        return BitmapFactory.decodeStream(new FileInputStream(file),null,o2)      }   }  catch (  FileNotFoundException e) {     return null    } } 
public PhotoToLoad(@Nonnull String url,@Nonnull OnImageLoadedListener imageLoadedListener){   this.url=url    this.imageLoadedListener=imageLoadedListener  } 
private PhotosLoader(@Nonnull PhotoToLoad photoToLoad){   this.photoToLoad=photoToLoad  } 
@Override public void run(){   if (!isNeedToLoad(photoToLoad)) {     final Bitmap bmp=getBitmap(photoToLoad.url)      if (bmp != null) {       memoryCache.put(photoToLoad.url,bmp)      }     if (!isNeedToLoad(photoToLoad)) {       photoToLoad.imageLoadedListener.onImageLoaded(bmp)      }   } } 
private boolean isNeedToLoad(@Nonnull PhotoToLoad photoToLoad){   final String url=imageViews.get(photoToLoad.imageLoadedListener)    if (url == null || !url.equals(photoToLoad.url)) {     return true    }  else {     return false    } } 
public void clearCache(){   memoryCache.clear()    fileCache.clear()  } 
private ImageViewImageLoadedListener(@Nonnull ImageView imageView,@Nullable Integer defaultImageId,@Nonnull Handler handler){   this.imageViewRef=new WeakReference<ImageView>(imageView)    this.defaultImageId=defaultImageId    this.handler=handler  } 
@Override public void onImageLoaded(@Nullable final Bitmap image){   final ImageView imageView=imageViewRef.get()    if (imageView != null) {     handler.post(new Runnable(){       @Override public void run(){         if (image != null) {           imageView.setImageBitmap(image)          }  else {           if (defaultImageId != null) {             imageView.setImageResource(defaultImageId)            }         }       }     } )    } } 
@Override public void run(){   if (image != null) {     imageView.setImageBitmap(image)    }  else {     if (defaultImageId != null) {       imageView.setImageResource(defaultImageId)      }   } } 
@Override public void setDefaultImage(){   final ImageView imageView=imageViewRef.get()    if (imageView != null) {     handler.post(new Runnable(){       @Override public void run(){         if (defaultImageId != null) {           imageView.setImageResource(defaultImageId)          }       }     } )    } } 
@Override public void run(){   if (defaultImageId != null) {     imageView.setImageResource(defaultImageId)    } } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof ImageViewImageLoadedListener))   return false    ImageViewImageLoadedListener that=(ImageViewImageLoadedListener)o    final ImageView thisImageView=this.imageViewRef.get()    final ImageView thatImageView=that.imageViewRef.get()    if (!Objects.areEqual(thisImageView,thatImageView))   return false    return true  } 
@Override public int hashCode(){   final ImageView imageView=imageViewRef.get()    return imageView == null ? 0 : imageView.hashCode()  } 
private EmptyImageLoadedListener(){ } 
@Nonnull public static OnImageLoadedListener getInstance(){   return instance  } 
@Override public void onImageLoaded(@Nullable Bitmap image){ } 
@Override public void setDefaultImage(){ } 
public DownloadFileAsyncTask(@Nonnull Context context){   super(context)  } 
public DownloadFileAsyncTask(@Nonnull Context context,@Nonnull OnPostExecute<List<Object>> onPostExecute){   super(context)    this.onPostExecute=onPostExecute  } 
@Nonnull @Override protected List<Object> doWork(@Nonnull List<Input> params){   final List<Object> result=new ArrayList<Object>()    for (  Input param : params) {     final DownloadFileHttpTransaction<?> downloadFileHttpTransaction=new DownloadFileHttpTransaction<Object>(param.getUri(),param.getMethod(),param.getFileConverter())      try {       result.add(HttpTransactions.execute(downloadFileHttpTransaction))      }  catch (    IOException e) {       throw new HttpRuntimeIoException(e)      }   }   return result  } 
@Override protected void onSuccessPostExecute(@Nullable List<Object> result){ } 
@Override protected void onFailurePostExecute(@Nonnull Exception e){   if (e instanceof HttpRuntimeIoException) {   }  else {     defaultOnFailurePostExecute(e)    } } 
void onPostExecute(@Nonnull R result)  
public Input(@Nonnull String uri,@Nonnull HttpMethod method,@Nonnull Converter<InputStream,?> fileConverter){   this.uri=uri    this.method=method    this.fileConverter=fileConverter  } 
@Nonnull public String getUri(){   return uri  } 
@Nonnull public HttpMethod getMethod(){   return method  } 
@Nonnull public Converter<InputStream,Object> getFileConverter(){   return (Converter<InputStream,Object>)fileConverter  } 
public DownloadFileHttpTransaction(@Nonnull String uri,@Nonnull HttpMethod httpMethod,@Nonnull Converter<InputStream,R> fileConverter){   super(uri,httpMethod)    this.fileConverter=fileConverter  } 
@Nonnull @Override public List<NameValuePair> getRequestParameters(){   return Collections.emptyList()  } 
@Override public R getResponse(@Nonnull HttpResponse response){   try {     return fileConverter.convert(response.getEntity().getContent())    }  catch (  IOException e) {     throw new RuntimeException(e)    } } 
public HttpRuntimeIoException(@Nonnull IOException e){   super(e)  } 
@Nonnull HttpUriRequest createRequest()  
R getResponse(@Nonnull HttpResponse response)  
@Nonnull HttpMethod getHttpMethod()  
@Nonnull String getUri()  
@Nonnull List<NameValuePair> getRequestParameters()  
private HttpTransactions(){   throw new AssertionError()  } 
@Nonnull public static AHttpClient newHttpClient(){   return new AHttpClientImpl()  } 
public static <R>R execute(@Nonnull HttpTransaction<R> httpTransaction) throws IOException {   return newHttpClient().execute(httpTransaction)  } 
@Nonnull public static <R>List<R> execute(@Nonnull List<? extends HttpTransaction<R>> httpTransactions) throws IOException {   return newHttpClient().execute(httpTransactions)  } 
void loadImage(@Nonnull String url,@Nonnull ImageView imageView,@Nullable Integer defaultImageId)  
void loadImage(@Nonnull String url,@Nonnull OnImageLoadedListener imageLoadedListener)  
void loadImage(@Nonnull String url)  
public MemoryCache(){   setLimit(Runtime.getRuntime().maxMemory() / 4)  } 
public void setLimit(long limit){   this.limit=limit    Log.i(TAG,"MemoryCache will use up to " + this.limit / 1024. / 1024. + "MB")  } 
public Bitmap get(@Nonnull String key){   return cache.get(key)  } 
public void put(@Nonnull String key,@Nonnull Bitmap value){   remove(key)    cache.put(key,value)    size+=getSizeInBytes(value)    checkSize()  } 
private void remove(@Nonnull String key){   final Bitmap value=cache.get(key)    if (value != null) {     size-=getSizeInBytes(value)    } } 
private void checkSize(){   Log.i(TAG,"Cache memory usage = " + size + " size = "+ cache.size())    if (size > limit) {     Log.i(TAG,"Cache cleaning started!")      for (final Iterator<Entry<String,Bitmap>> it=cache.entrySet().iterator()  it.hasNext() && size > limit  ) {       final Entry<String,Bitmap> entry=it.next()        size-=getSizeInBytes(entry.getValue())        it.remove()      }     Log.i(TAG,"New cache size " + cache.size())    } } 
public void clear(){   cache.clear()  } 
private static long getSizeInBytes(@Nonnull Bitmap bitmap){   return bitmap.getRowBytes() * bitmap.getHeight()  } 
void onImageLoaded(@Nullable Bitmap image)  
void setDefaultImage()  
public OnUiThreadImageLoadedListener(@Nonnull Activity activity){   this.activityRef=new WeakReference<Activity>(activity)  } 
@Override public void onImageLoaded(@Nullable final Bitmap image){   final Activity activity=this.activityRef.get()    if (activity != null) {     activity.runOnUiThread(new Runnable(){       @Override public void run(){         onImageLoadedOnUiThread(image)        }     } )    } } 
@Override public void run(){   onImageLoadedOnUiThread(image)  } 
protected abstract void onImageLoadedOnUiThread(@Nullable Bitmap image)  
@Override public void setDefaultImage(){   final Activity activity=this.activityRef.get()    if (activity != null) {     activity.runOnUiThread(new Runnable(){       @Override public void run(){         setDefaultImageOnUiThread()        }     } )    } } 
@Override public void run(){   setDefaultImageOnUiThread()  } 
protected abstract void setDefaultImageOnUiThread()  
public static void copyStream(@Nonnull InputStream is,@Nonnull OutputStream os) throws IOException {   final int bufferSize=1024    byte[] bytes=new byte[bufferSize]    while (true) {     int count=is.read(bytes,0,bufferSize)      if (count == -1) {       break      }     os.write(bytes,0,count)    } } 
@Test public void testShouldReturnUrlWithParams() throws Exception {   assertEquals("test",in_uri.prepareUri("test",Collections.<BasicNameValuePair>emptyList(),null))  } 
@Test public void testShouldAddParamToUrl() throws Exception {   assertEquals("test?param=value",in_uri.prepareUri("test",asList(new BasicNameValuePair("param","value")),null))  } 
@Test public void testShouldEncodeParamsInUrl() throws Exception {   assertEquals("test?param=%2C%2C%60%28%2F",in_uri.prepareUri("test",asList(new BasicNameValuePair("param",",,`(/")),null))  } 
protected AbstractAKeyboard(@Nonnull String keyboardId){   this.keyboardId=keyboardId  } 
@Override @Nonnull public String getKeyboardId(){   return keyboardId  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof AbstractAKeyboard))   return false    AbstractAKeyboard that=(AbstractAKeyboard)o    if (!keyboardId.equals(that.keyboardId))   return false    return true  } 
@Override public int hashCode(){   return keyboardId.hashCode()  } 
protected AbstractAKeyboardInputMethodService(@Nonnull AKeyboardController keyboardController){   this.keyboardController=keyboardController  } 
@Override public void onCreate(){   super.onCreate()    keyboardController.onCreate(this)  } 
@Override public void onInitializeInterface(){   keyboardController.onInitializeInterface(this)  } 
@Override public View onCreateInputView(){   return keyboardController.createKeyboardView(this,getLayoutInflater()).getAndroidKeyboardView()  } 
@Override public View onCreateCandidatesView(){   return keyboardController.onCreateCandidatesView()  } 
@Override public void onStartInput(@Nonnull EditorInfo attribute,boolean restarting){   super.onStartInput(attribute,restarting)    this.keyboardController.onStartInput(attribute,restarting)  } 
@Override public void onFinishInput(){   super.onFinishInput()    setCandidatesViewShown(false)    keyboardController.onFinishInput()  } 
@Override public void onStartInputView(EditorInfo attribute,boolean restarting){   super.onStartInputView(attribute,restarting)    keyboardController.onStartInputView(attribute,restarting)  } 
@Override public void onCurrentInputMethodSubtypeChanged(InputMethodSubtype subtype){   keyboardController.onCurrentInputMethodSubtypeChanged(subtype)  } 
@Override public void onUpdateSelection(int oldSelStart,int oldSelEnd,int newSelStart,int newSelEnd,int candidatesStart,int candidatesEnd){   super.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,candidatesStart,candidatesEnd)    keyboardController.onUpdateSelection(oldSelStart,oldSelEnd,newSelStart,newSelEnd,candidatesStart,candidatesEnd)  } 
@Override public void onDisplayCompletions(@Nullable CompletionInfo[] completions){   keyboardController.onDisplayCompletions(completions)  } 
@Override public boolean onKeyDown(int keyCode,KeyEvent event){   boolean consumed=keyboardController.onKeyDown(keyCode,event)    if (!consumed) {     return super.onKeyDown(keyCode,event)    }  else {     return consumed    } } 
@Override public boolean onKeyUp(int keyCode,KeyEvent event){   boolean consumed=keyboardController.onKeyUp(keyCode,event)    if (!consumed) {     return super.onKeyUp(keyCode,event)    }  else {     return consumed    } } 
@Override public void onStartInput(@Nonnull EditorInfo attribute,boolean restarting){   super.onStartInput(attribute,restarting)    updateCandidates()    getKeyboardView().setCompletions(Collections.<CompletionInfo>emptyList())  } 
@Nonnull @Override public AKeyboardViewWithSuggestions<K> getKeyboardView(){   return (AKeyboardViewWithSuggestions<K>)super.getKeyboardView()  } 
@Override public void onFinishInput(){   super.onFinishInput()    updateCandidates()  } 
@Override public boolean handleBackspace(){   boolean changed=super.handleBackspace()    if (changed) {     updateCandidates()    }   return changed  } 
@Nonnull @Override protected abstract AKeyboardViewWithSuggestions<K> createKeyboardView0(@Nonnull Context context)  
public void setSuggestions(@Nonnull List<String> suggestions,boolean completions,boolean typedWordValid){   final AKeyboardViewWithSuggestions keyboardView=getKeyboardView()    if (suggestions.size() > 0) {     keyboardView.setCandidatesViewShown(true)    }  else   if (keyboardView.isExtractViewShown()) {     keyboardView.setCandidatesViewShown(true)    }   keyboardView.setSuggestions(suggestions,completions,typedWordValid)  } 
@Override public void onDisplayCompletions(@Nullable CompletionInfo[] completions){   super.onDisplayCompletions(completions)    if (getState().isCompletion()) {     if (completions == null) {       setSuggestions(Collections.<String>emptyList(),false,false)      }  else {       final List<String> suggestions=new ArrayList<String>()        for (      CompletionInfo completion : Arrays.asList(completions)) {         if (completion != null) {           suggestions.add(completion.getText().toString())          }       }       setSuggestions(suggestions,true,true)      }   } } 
/**   * Update the list of available candidates from the current composing text.  This will need to be filled in by however you are determining candidates.  */ protected void updateCandidates(){   if (!getState().isCompletion()) {     final CharSequence text=getKeyboardInput().getTypedText()      if (!Strings.isEmpty(text)) {       final List<String> list=new ArrayList<String>()        list.add(text.toString())        setSuggestions(list,true,true)      }  else {       setSuggestions(Collections.<String>emptyList(),false,false)      }   } } 
@Override public void handleClose(){   super.handleClose()    updateCandidates()  } 
@Override public void pickSuggestionManually(int index){   super.pickSuggestionManually(index)    final AKeyboardViewWithSuggestions<K> keyboardView=getKeyboardView()    final AKeyboardInput keyboardInput=getKeyboardInput()    final List<CompletionInfo> completions=keyboardView.getCompletions()    final CharSequence text=keyboardInput.getTypedText()    if (getState().isCompletion() && index >= 0 && index < completions.size()) {     final CompletionInfo ci=completions.get(index)      keyboardInput.commitCompletion(ci)      keyboardView.clearCandidateView()      updateShiftKeyState(keyboardInput.getCurrentInputEditorInfo())    }  else   if (!Strings.isEmpty(text)) {     keyboardInput.commitTyped()    } } 
@Override public View onCreateCandidatesView(){   return this.getKeyboardView().onCreateCandidatesView()  } 
protected AbstractKeyboardController(){ } 
@Override public final void onCreate(@Nonnull Context context){   this.inputMethodManager=(InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE)    this.configuration=onCreate0(context)  } 
@Nonnull protected abstract AKeyboardConfiguration onCreate0(@Nonnull Context context)  
@Override public final void onInitializeInterface(@Nonnull InputMethodService inputMethodService){   this.inputMethodService=inputMethodService    this.state=onInitializeInterface0(inputMethodService)    this.keyboardInput=createKeyboardInput0(inputMethodService)    this.keyboardView=createKeyboardView0(inputMethodService)  } 
@Nonnull protected abstract AKeyboardControllerState<K> onInitializeInterface0(@Nonnull InputMethodService inputMethodService)  
@Nonnull protected DefaultKeyboardInput createKeyboardInput0(@Nonnull InputMethodService inputMethodService){   return new DefaultKeyboardInput(inputMethodService)  } 
@Nonnull protected abstract AKeyboardView<K> createKeyboardView0(@Nonnull Context context)  
@Nonnull @Override public final AKeyboardView createKeyboardView(@Nonnull Context context,@Nonnull LayoutInflater layoutInflater){   keyboardView.createAndroidKeyboardView(context,layoutInflater)    keyboardView.setKeyboard(getCurrentKeyboard())    keyboardView.setOnKeyboardActionListener(new DefaultKeyboardActionListener(this))    return keyboardView  } 
@Override public View onCreateCandidatesView(){   return null  } 
@Override public void onStartInput(@Nonnull EditorInfo attribute,boolean restarting){   if (!restarting) {     metaState=0    }   this.state=onStartInput0(attribute,restarting)    keyboardInput.clearTypedText()    getCurrentKeyboard().setImeOptions(inputMethodService.getResources(),attribute.imeOptions)  } 
@Override public void onFinishInput(){   keyboardInput.clearTypedText()    keyboardView.close()  } 
@Override public void onStartInputView(EditorInfo attribute,boolean restarting){   keyboardView.setKeyboard(getCurrentKeyboard())    keyboardView.close()    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {     final InputMethodSubtype subtype=inputMethodManager.getCurrentInputMethodSubtype()      keyboardView.setSubtypeOnSpaceKey(subtype)    } } 
@Nonnull protected InputMethodService getInputMethodService(){   return inputMethodService  } 
@Override public final boolean onKey(int primaryCode,@Nullable int[] keyCodes){   boolean consumed=handleSpecialKey(primaryCode)    if (!consumed) {     if (isWordSeparator(primaryCode)) {       if (!Strings.isEmpty(getKeyboardInput().getTypedText())) {         getKeyboardInput().commitTyped()        }       sendKey(primaryCode)        updateShiftKeyState(getInputMethodService().getCurrentInputEditorInfo())        consumed=true      }  else {       handleCharacter(primaryCode,keyCodes)      }   }   return consumed  } 
protected boolean handleSpecialKey(int primaryCode){   boolean consumed=false  switch (primaryCode) { case Keyboard.KEYCODE_MODE_CHANGE:     handleModeChange()    consumed=true  break  case Keyboard.KEYCODE_DELETE: handleBackspace()  consumed=true  break  case Keyboard.KEYCODE_CANCEL: handleClose()  consumed=true  break  case Keyboard.KEYCODE_SHIFT: handleShift()  consumed=true  break  case KEYCODE_COPY: getKeyboardInput().handleCopy()  consumed=true  break  case KEYCODE_PASTE: getKeyboardInput().handlePaste()  consumed=true  break  case KEYCODE_CLEAR: getKeyboardInput().handleClear()  consumed=true  break  case KEYCODE_CURSOR_LEFT: getKeyboardInput().handleCursorLeft()  consumed=true  break  case KEYCODE_CURSOR_RIGHT: getKeyboardInput().handleCursorRight()  consumed=true  break  case KEYCODE_PREV_KEYBOARD: handlePrevKeyboard()  consumed=true  break  case KEYCODE_NEXT_KEYBOARD: handleNextKeyboard()  consumed=true  break  case KEYCODE_UNDO: getKeyboardInput().undo()  consumed=true  break  case KEYCODE_REDO: getKeyboardInput().redo()  consumed=true  break  } return consumed  } 
protected void handleModeChange(){ } 
protected void handleNextKeyboard(){ } 
protected void handlePrevKeyboard(){ } 
private void handleShift(){   boolean newState=!this.state.isShifted()    setShifted(newState)  } 
protected final void setShifted(boolean shifted){   if (shifted != this.state.isShifted()) {     this.state=this.state.copyForNewShift(shifted)      this.state.getKeyboard().setShifted(shifted)      this.keyboardView.reloadAndroidKeyboardView()      this.setShifted0(shifted)    } } 
protected void setShifted0(boolean shifted){ } 
@Nonnull protected K getCurrentKeyboard(){   return state.getKeyboard()  } 
protected void setCurrentKeyboard(@Nonnull K keyboard){   this.state=this.state.copyForNewKeyboard(keyboard)    this.keyboardView.setKeyboard(keyboard)  } 
@Nonnull protected AKeyboardControllerState<K> getState(){   return state  } 
protected void setState(@Nonnull AKeyboardControllerState<K> state){   this.state=state  } 
@Nonnull protected AKeyboardView<K> getKeyboardView(){   return keyboardView  } 
@Nonnull protected AKeyboardInput getKeyboardInput(){   return keyboardInput  } 
@Override public void handleClose(){   keyboardInput.commitTyped()    inputMethodService.requestHideSelf(0)    keyboardView.close()  } 
@Nonnull public abstract AKeyboardControllerState<K> onStartInput0(@Nonnull EditorInfo attribute,boolean restarting)  
@Override public void onText(@Nullable CharSequence text){   keyboardInput.onText(text)    updateShiftKeyState(keyboardInput.getCurrentInputEditorInfo())  } 
@Override public void onDisplayCompletions(@Nullable CompletionInfo[] completions){ } 
/**   * Helper to update the shift state of our keyboard based on the initial editor state.  */ public void updateShiftKeyState(@Nullable EditorInfo attr){   if (attr != null) {     final EditorInfo editorInfo=keyboardInput.getCurrentInputEditorInfo()      int caps=0      if (editorInfo.inputType != InputType.TYPE_NULL) {       caps=keyboardInput.getCursorCapsMode(attr.inputType)      }     boolean shifted=state.isCapsLock() || caps != 0      setShifted(shifted)    } } 
@Override public void onUpdateSelection(int oldSelStart,int oldSelEnd,int newSelStart,int newSelEnd,int candidatesStart,int candidatesEnd){   final CharSequence text=keyboardInput.getTypedText()    if (!Strings.isEmpty(text) && (newSelStart != candidatesEnd || newSelEnd != candidatesEnd)) {     keyboardInput.clearTypedText()      updateCandidates()      keyboardInput.finishComposingText()    } } 
protected void updateCandidates(){ } 
@Override public boolean onKeyDown(int keyCode,@Nonnull KeyEvent event){ switch (keyCode) { case KeyEvent.KEYCODE_BACK:     if (event.getRepeatCount() == 0) {       keyboardView.dismiss()        return true      }   break  case KeyEvent.KEYCODE_DEL: final CharSequence text=keyboardInput.getTypedText()  if (!Strings.isEmpty(text)) { onKey(Keyboard.KEYCODE_DELETE,null)  return true  } break  case KeyEvent.KEYCODE_ENTER: return false  default : if (PROCESS_HARD_KEYS) { if (keyCode == KeyEvent.KEYCODE_SPACE && (event.getMetaState() & KeyEvent.META_ALT_ON) != 0) { keyboardInput.clearMetaKeyStates(KeyEvent.META_ALT_ON)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_A)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_N)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_D)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_R)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_O)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_I)  keyboardInput.keyDownUp(KeyEvent.KEYCODE_D)  return true  } if (state.isPrediction() && translateKeyDown(keyCode,event)) { return true  } } } return false  } 
public boolean handleBackspace(){   boolean changed=keyboardInput.handleBackspace()    if (!changed) {     keyDownUp(KeyEvent.KEYCODE_DEL)    }   updateShiftKeyState(keyboardInput.getCurrentInputEditorInfo())    return changed  } 
/**   * Helper to send a key down / key up pair to the current editor.  */ public void keyDownUp(int keyEventCode){   keyboardInput.keyDownUp(keyEventCode)  } 
/**   * This translates incoming hard key events in to edit operations on an InputConnection.  It is only needed when using the PROCESS_HARD_KEYS option.  */ private boolean translateKeyDown(int keyCode,@Nonnull KeyEvent event){   metaState=MetaKeyKeyListener.handleKeyDown(metaState,keyCode,event)    int unicodeChar=event.getUnicodeChar(MetaKeyKeyListener.getMetaState(metaState))    metaState=MetaKeyKeyListener.adjustMetaAfterKeypress(metaState)    if (unicodeChar == 0 || !keyboardInput.isInputConnected()) {     return false    }   if ((unicodeChar & KeyCharacterMap.COMBINING_ACCENT) != 0) {     unicodeChar=unicodeChar & KeyCharacterMap.COMBINING_ACCENT_MASK    }   unicodeChar=keyboardInput.translateKeyDown(unicodeChar)    onKey(unicodeChar,null)    return true  } 
@Override public boolean onKeyUp(int keyCode,KeyEvent event){   if (PROCESS_HARD_KEYS) {     if (state.isPrediction()) {       metaState=MetaKeyKeyListener.handleKeyUp(metaState,keyCode,event)      }   }   return false  } 
/**   * Helper to send a character to the editor as raw key events.  */ public void sendKey(int keyCode){ switch (keyCode) { case '\n':     keyDownUp(KeyEvent.KEYCODE_ENTER)    break  default : if (keyCode >= '0' && keyCode <= '9') {   keyDownUp(keyCode - '0' + KeyEvent.KEYCODE_0)  }  else {   keyboardInput.commitText(String.valueOf((char)keyCode),1)  } break  } } 
public void pickDefaultCandidate(){   if (state.isCompletion()) {     pickSuggestionManually(0)    } } 
public void pickSuggestionManually(int index){ } 
protected void handleCharacter(int primaryCode,int[] keyCodes){   if (inputMethodService.isInputViewShown()) {     if (state.isShifted()) {       primaryCode=Character.toUpperCase(primaryCode)      }   }   if (isAlphabet(primaryCode) && state.isPrediction()) {     keyboardInput.append((char)primaryCode)      updateShiftKeyState(keyboardInput.getCurrentInputEditorInfo())      updateCandidates()    }  else {     keyboardInput.commitText(String.valueOf((char)primaryCode),1)    } } 
/**   * Helper to determine if a given character code is alphabetic.  */ private boolean isAlphabet(int code){   return Character.isLetter(code)  } 
@Override public void onCurrentInputMethodSubtypeChanged(@Nonnull InputMethodSubtype subtype){   keyboardView.setSubtypeOnSpaceKey(subtype)  } 
public boolean isWordSeparator(int code){   final String separators=configuration.getWordSeparators()    return separators.contains(String.valueOf((char)code))  } 
void setImeOptions(@Nonnull Resources resources,int imeOptions)  
void setShifted(boolean shifted)  
@Nonnull String getKeyboardId()  
@Override public void handleMessage(Message msg){ switch (msg.what) { case MSG_SHOW_PREVIEW:     Log.d(TAG,"Show preview for " + msg.obj)    showText0((PreviewParams)msg.obj)  break  case MSG_REMOVE_PREVIEW: Log.d(TAG,"Hide preview for " + msg.obj)  hide()  break  } } 
public AKeyboardButtonPreview(@Nonnull View popupParent){   this.popupParent=popupParent  } 
public void createPreviewView(@Nonnull LayoutInflater layoutInflater){   Log.d(TAG,"Creating preview view and popup window...")    previewView=layoutInflater.inflate(R.layout.drag_keyboard_preview,null)    previewView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT))    popup=new PopupWindow(previewView)  } 
public void showPreview(@Nonnull View view,@Nullable CharSequence text,@Nullable Integer drawableResId){   final int[] location=new int[2]    view.getLocationInWindow(location)    int x=location[0] + view.getWidth() / 2    int y=location[1]    final PreviewParams previewParams    if (text == null) {     if (drawableResId != null) {       previewParams=PreviewParams.newDrawableInstance(x,y,drawableResId)      }  else {       previewParams=PreviewParams.newTextInstance(x,y,"")        Log.e(AKeyboardButtonPreview.class.getSimpleName(),"For view: " + view + " neither text nor drawable resource is specified!")      }   }  else {     previewParams=PreviewParams.newTextInstance(x,y,text.toString())    } synchronized (handler) {     handler.removeMessages(MSG_REMOVE_PREVIEW,previewParams)      handler.removeMessages(MSG_SHOW_PREVIEW,previewParams)      handler.sendMessageDelayed(handler.obtainMessage(MSG_SHOW_PREVIEW,previewParams),DELAY_BEFORE_PREVIEW)    } } 
private void showText0(@Nonnull PreviewParams previewParams){ synchronized (handler) {     handler.removeMessages(MSG_REMOVE_PREVIEW,previewParams)    }   final PopupWindow popup=this.popup    boolean image=false    final TextView previewTextView=(TextView)previewView.findViewById(R.id.preview_text_view)    previewTextView.setText(previewParams.getText())    final Integer drawableResId=previewParams.getDrawableResId()    final ImageView previewImageView=(ImageView)previewView.findViewById(R.id.preview_image_view)    if (drawableResId != null) {     final Drawable drawable=previewView.getContext().getResources().getDrawable(drawableResId)      previewImageView.setImageDrawable(drawable)      if (drawable != null) {       image=true      }   }  else {     previewImageView.setImageDrawable(null)    }   if (image) {     previewTextView.setVisibility(View.GONE)      previewImageView.setVisibility(View.VISIBLE)    }  else {     previewImageView.setVisibility(View.GONE)      previewTextView.setVisibility(View.VISIBLE)    }   previewView.measure(View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED),View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED))    final int popupWidth=previewView.getMeasuredWidth()    final int popupHeight=previewView.getMeasuredHeight()    final int popupMargin=Views.toPixels(popupParent.getContext().getResources().getDisplayMetrics(),10)    int popupX=previewParams.getX() - popupWidth / 2    int popupY=previewParams.getY() - popupHeight - popupMargin    if (popup.isShowing()) {     popup.update(popupX,popupY,popupWidth,popupHeight)    }  else {     popup.setWidth(popupWidth)      popup.setHeight(popupHeight)      popup.showAtLocation(popupParent,Gravity.NO_GRAVITY,popupX,popupY)    }   previewView.setVisibility(View.VISIBLE)  synchronized (handler) {     handler.sendMessageDelayed(handler.obtainMessage(MSG_REMOVE_PREVIEW,previewParams),DELAY_AFTER_PREVIEW)    } } 
public void hide(){   if (previewView != null) {     previewView.setVisibility(View.INVISIBLE)    } } 
@Nonnull String getWordSeparators()  
public AKeyboardConfigurationImpl(@Nonnull String wordSeparators){   this.wordSeparators=wordSeparators  } 
@Nonnull @Override public String getWordSeparators(){   return wordSeparators  } 
/**   * Main initialization of the input method component.  Be sure to call to super class.  */ void onCreate(@Nonnull Context context)  
/**   * This is the point where you can do all of your UI initialization.  It is called after creation and any configuration change.  */ void onInitializeInterface(@Nonnull InputMethodService inputMethodService)  
/**   * Called by the framework when your view for creating input needs to be generated.  This will be called the first time your input method is displayed, and every time it needs to be re-created such as due to a configuration change.  */ @Nonnull AKeyboardView createKeyboardView(@Nonnull Context context,@Nonnull LayoutInflater layoutInflater)  
/**   * Called by the framework when your view for showing candidates needs to be generated, like  {@link #createKeyboardView}.  */ @Nullable View onCreateCandidatesView()  
/**   * This is the main point where we do our initialization of the input method to begin operating on an application.  At this point we have been bound to the client, and are now receiving all of the detailed information about the target of our edits.  */ void onStartInput(@Nonnull EditorInfo attribute,boolean restarting)  
/**   * This is called when the user is done editing a field.  We can use this to reset our state.  */ void onFinishInput()  
/**   * Deal with the editor reporting movement of its cursor.  */ void onUpdateSelection(int oldSelStart,int oldSelEnd,int newSelStart,int newSelEnd,int candidatesStart,int candidatesEnd)  
/**   * This tells us about completions that the editor has determined based on the current text in it.  We want to use this in fullscreen mode to show the completions ourself, since the editor can not be seen in that situation.  */ void onDisplayCompletions(@Nullable CompletionInfo[] completions)  
/**   * Use this to monitor key events being delivered to the application. We get first crack at them, and can either resume them or let them continue to the app.  */ boolean onKeyDown(int keyCode,KeyEvent event)  
/**   * Use this to monitor key events being delivered to the application. We get first crack at them, and can either resume them or let them continue to the app.  */ boolean onKeyUp(int keyCode,KeyEvent event)  
void onCurrentInputMethodSubtypeChanged(@Nonnull InputMethodSubtype subtype)  
void onStartInputView(EditorInfo attribute,boolean restarting)  
boolean onKey(int primaryCode,@Nullable int[] keyCodes)  
void handleClose()  
boolean handleBackspace()  
void onText(@Nullable CharSequence text)  
void pickDefaultCandidate()  
void pickSuggestionManually(int index)  
boolean isShifted()  
boolean isCapsLock()  
boolean isCompletion()  
boolean isPrediction()  
@Nonnull K getKeyboard()  
@Nonnull AKeyboardControllerState<K> copyForNewKeyboard(@Nonnull K keyboard)  
@Nonnull AKeyboardControllerState<K> copyForNewCapsLock(boolean capsLock)  
@Nonnull AKeyboardControllerState<K> copyForNewShift(boolean newState)  
private AKeyboardControllerStateImpl(){ } 
@Nonnull public static <K extends AKeyboard>AKeyboardControllerState<K> newDefaultState(@Nonnull K keyboard){   final AKeyboardControllerStateImpl<K> result=new AKeyboardControllerStateImpl<K>()    result.shifted=false    result.capsLock=false    result.completion=false    result.prediction=false    result.keyboard=keyboard    return result  } 
@Nonnull public static <K extends AKeyboard>AKeyboardControllerState<K> newInstance(boolean prediction,boolean completion,@Nonnull K keyboard){   final AKeyboardControllerStateImpl<K> result=new AKeyboardControllerStateImpl<K>()    result.shifted=false    result.capsLock=false    result.completion=completion    result.prediction=prediction    result.keyboard=keyboard    return result  } 
@Override public boolean isShifted(){   return shifted  } 
@Override public boolean isCapsLock(){   return capsLock  } 
@Override public boolean isCompletion(){   return completion  } 
@Override public boolean isPrediction(){   return prediction  } 
@Override @Nonnull public K getKeyboard(){   return keyboard  } 
@Nonnull @Override public AKeyboardControllerState<K> copyForNewKeyboard(@Nonnull K keyboard){   final AKeyboardControllerStateImpl<K> result=copy()    result.keyboard=keyboard    return result  } 
private AKeyboardControllerStateImpl<K> copy(){   final AKeyboardControllerStateImpl<K> result=new AKeyboardControllerStateImpl<K>()    result.capsLock=this.capsLock    result.prediction=this.prediction    result.shifted=this.shifted    result.completion=this.completion    result.keyboard=this.keyboard    return result  } 
@Nonnull @Override public AKeyboardControllerState<K> copyForNewCapsLock(boolean capsLock){   final AKeyboardControllerStateImpl<K> result=copy()    result.capsLock=capsLock    return result  } 
@Nonnull @Override public AKeyboardControllerState<K> copyForNewShift(boolean shifted){   final AKeyboardControllerStateImpl<K> result=copy()    result.shifted=shifted    return result  } 
void commitTyped()  
void onText(@Nullable CharSequence text)  
@Nonnull EditorInfo getCurrentInputEditorInfo()  
@Nullable CharSequence getTypedText()  
boolean handleBackspace()  
void sendKeyEvent(@Nonnull KeyEvent keyEvent)  
int translateKeyDown(int unicodeChar)  
void commitCompletion(@Nonnull CompletionInfo completionInfo)  
void append(char primaryCode)  
void commitText(@Nullable String text,int i)  
void handleCursorRight()  
void handleCursorLeft()  
void handleClear()  
void handlePaste()  
void handleCopy()  
void clearMetaKeyStates(int flags)  
void keyDownUp(int keyEventCode)  
void finishComposingText()  
boolean isInputConnected()  
int getCursorCapsMode(int inputType)  
void clearTypedText()  
void undo()  
void redo()  
void setKeyboard(@Nonnull K keyboard)  
void setOnKeyboardActionListener(@Nonnull KeyboardView.OnKeyboardActionListener keyboardActionListener)  
void close()  
void dismiss()  
void setSubtypeOnSpaceKey(@Nonnull InputMethodSubtype subtype)  
boolean isExtractViewShown()  
void createAndroidKeyboardView(@Nonnull Context context,@Nonnull LayoutInflater layoutInflater)  
@Nonnull View getAndroidKeyboardView()  
void reloadAndroidKeyboardView()  
public AKeyboardViewImpl(int keyboardLayoutResId,@Nonnull AKeyboardController keyboardController,@Nonnull InputMethodService inputMethodService){   this.keyboardLayoutResId=keyboardLayoutResId    this.keyboardController=keyboardController    this.inputMethodService=inputMethodService  } 
@Nullable protected KeyboardView.OnKeyboardActionListener getKeyboardActionListener(){   return keyboardActionListener  } 
@Override public boolean isExtractViewShown(){   return inputMethodService.isExtractViewShown()  } 
public void setCandidatesViewShown(boolean shown){   inputMethodService.setCandidatesViewShown(shown)  } 
@Nonnull public AKeyboardController getKeyboardController(){   return keyboardController  } 
@Nonnull public InputMethodService getInputMethodService(){   return inputMethodService  } 
@Override public void setOnKeyboardActionListener(@Nonnull KeyboardView.OnKeyboardActionListener keyboardActionListener){   this.keyboardActionListener=keyboardActionListener    if (this.keyboardView != null) {     this.keyboardView.setOnKeyboardActionListener(keyboardActionListener)    } } 
@Override public void createAndroidKeyboardView(@Nonnull Context context,@Nonnull LayoutInflater layoutInflater){   this.keyboardView=(KV)layoutInflater.inflate(keyboardLayoutResId,null)    final KeyboardView.OnKeyboardActionListener keyboardActionListener=this.getKeyboardActionListener()    if (keyboardActionListener != null) {     this.keyboardView.setOnKeyboardActionListener(keyboardActionListener)    } } 
@Override public void setKeyboard(@Nonnull K keyboard){   if (this.keyboardView != null) {     this.keyboardView.setKeyboard(keyboard)    } } 
@Override public void close(){   if (this.keyboardView != null) {     this.keyboardView.close()    } } 
@Override public void setSubtypeOnSpaceKey(@Nonnull InputMethodSubtype subtype){ } 
@Override public void dismiss(){   if (this.keyboardView != null) {     this.keyboardView.dismiss()    } } 
@Nonnull public View getAndroidKeyboardView(){ } 
@Override public void reloadAndroidKeyboardView(){   if (this.keyboardView != null) {     this.keyboardView.reload()    } } 
void setCandidatesViewShown(boolean shown)  
void setSuggestions(@Nonnull List<String> suggestions,boolean completions,boolean typedWordValid)  
void setCompletions(@Nonnull List<CompletionInfo> completions)  
@Nonnull List<CompletionInfo> getCompletions()  
void clearCandidateView()  
View onCreateCandidatesView()  
public AKeyboardViewWithSuggestionsImpl(int keyboardLayoutResId,@Nonnull AKeyboardController keyboardController,@Nonnull InputMethodService inputMethodService){   super(keyboardLayoutResId,keyboardController,inputMethodService)  } 
@Override public void setSubtypeOnSpaceKey(@Nonnull InputMethodSubtype subtype){   super.setSubtypeOnSpaceKey(subtype)    final View keyboardView=getAndroidKeyboardView()    if (keyboardView instanceof KeyboardViewAKeyboardView) {     ((KeyboardViewAKeyboardView)keyboardView).setSubtypeOnSpaceKey(subtype)    } } 
@Override public void setSuggestions(@Nonnull List<String> suggestions,boolean completions,boolean typedWordValid){   if (candidateView != null) {     candidateView.setSuggestions(suggestions,completions,typedWordValid)    } } 
@Override public void setCompletions(@Nonnull List<CompletionInfo> completions){   this.completions=completions  } 
@Nonnull @Override public List<CompletionInfo> getCompletions(){   return this.completions  } 
@Override public void clearCandidateView(){   if (candidateView != null) {     candidateView.clear()    } } 
@Override public View onCreateCandidatesView(){   candidateView=new CandidateView(getInputMethodService())    candidateView.setKeyboardController(getKeyboardController())    return candidateView  } 
private AndroidAKeyboard(@Nonnull String keyboardId){   super(keyboardId)  } 
@Nonnull public static AndroidAKeyboard newInstance(@Nonnull String keyboardId,@Nonnull Keyboard keyboard){   final AndroidAKeyboard result=new AndroidAKeyboard(keyboardId)    result.keyboard=keyboard    return result  } 
@Nonnull public Keyboard getKeyboard(){   return keyboard  } 
@Override public void setImeOptions(@Nonnull Resources resources,int imeOptions){   if (keyboard instanceof LatinKeyboard) {     ((LatinKeyboard)keyboard).setImeOptions(resources,imeOptions)    } } 
@Override public void setShifted(boolean shiftState){   keyboard.setShifted(shiftState)  } 
private AndroidKeyboardUtils(){   throw new AssertionError()  } 
public static void copyWholeTextFromInputConnection(@Nonnull InputConnection ic,@Nonnull Context context){   String text=getTextFromInputConnection(ic)    if (!Strings.isEmpty(text)) {     final ClipboardManager clipboardManager=(ClipboardManager)context.getSystemService(Context.CLIPBOARD_SERVICE)      clipboardManager.setText(text)    } } 
@Nonnull public static String getTextFromInputConnection(@Nonnull InputConnection ic){   final CharSequence textAfter=ic.getTextAfterCursor(DefaultKeyboardInput.MAX_INT,0)    final CharSequence textBefore=ic.getTextBeforeCursor(DefaultKeyboardInput.MAX_INT,0)    String text=""    if (textBefore != null) {     text+=textBefore.toString()    }   if (textAfter != null) {     text+=textAfter.toString()    }   return text  } 
static void copyTextFromInputConnection(@Nonnull InputConnection ic,@Nonnull Context context){   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {     CharSequence text=ic.getSelectedText(0)      if (!Strings.isEmpty(text)) {       final ClipboardManager clipboardManager=(ClipboardManager)context.getSystemService(Context.CLIPBOARD_SERVICE)        clipboardManager.setText(text)      }  else {       copyWholeTextFromInputConnection(ic,context)      }   }  else {     copyWholeTextFromInputConnection(ic,context)    } } 
void setOnKeyboardActionListener(@Nonnull KeyboardView.OnKeyboardActionListener keyboardActionListener)  
void setKeyboard(@Nonnull K keyboard)  
void close()  
void dismiss()  
void reload()  
public CalculatorDragInputMethodService(){   super(new CalculatorKeyboardController())  } 
@Override protected DragAKeyboard createKeyboardDef(@Nonnull Context context){   final int operatorButtonColor=R.drawable.metro_dark_button    final DragAKeyboard.KeyboardDef result=new DragAKeyboard.KeyboardDef()    final DragAKeyboard.RowDef firstRow=new DragAKeyboard.RowDef()    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("7","i",null,"!","ob:"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("8","ln",null,"lg","od:"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("9","PI",null,"e","ox:"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("*","^",null,"^2",null,operatorButtonColor))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("C",CalculatorKeyboardController.KEYCODE_CLEAR))    result.add(firstRow)    final DragAKeyboard.RowDef secondRow=new DragAKeyboard.RowDef()    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("4","x",null,"y","D"))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("5","t",null,"j","E"))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("6",null,null,null,"F"))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("/","%",null,null,null,operatorButtonColor))    secondRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_delete,Keyboard.KEYCODE_DELETE))    result.add(secondRow)    final DragAKeyboard.RowDef thirdRow=new DragAKeyboard.RowDef()    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("1","sin",null,"asin","A"))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("2","cos",null,"acos","B"))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("3","tan",null,"atan","C"))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("+",null,null,"E",null,operatorButtonColor))    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_copy,CalculatorKeyboardController.KEYCODE_COPY))    result.add(thirdRow)    final DragAKeyboard.RowDef fourthRow=new DragAKeyboard.RowDef()    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("()","(",null,")",null))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("0","00",null,"000",null))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance(".",",",null,null,null))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("-",null,null,null,null,operatorButtonColor))    fourthRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_paste,CalculatorKeyboardController.KEYCODE_PASTE))    result.add(fourthRow)    return new DragAKeyboard("calculator",result)  } 
/**   * Construct a CandidateView for showing suggested words for completion.  * @param context  */ public CandidateView(@Nonnull Context context){   super(context)    mSelectionHighlight=context.getResources().getDrawable(android.R.drawable.list_selector_background)    mSelectionHighlight.setState(new int[]{android.R.attr.state_enabled,android.R.attr.state_focused,android.R.attr.state_window_focused,android.R.attr.state_pressed})    Resources r=context.getResources()    setBackgroundColor(r.getColor(R.color.candidate_background))    mColorNormal=r.getColor(R.color.candidate_normal)    mColorRecommended=r.getColor(R.color.candidate_recommended)    mColorOther=r.getColor(R.color.candidate_other)    mVerticalPadding=r.getDimensionPixelSize(R.dimen.candidate_vertical_padding)    mPaint=new Paint()    mPaint.setColor(mColorNormal)    mPaint.setAntiAlias(true)    mPaint.setTextSize(r.getDimensionPixelSize(R.dimen.candidate_font_height))    mPaint.setStrokeWidth(0)    mGestureDetector=new GestureDetector(new GestureDetector.SimpleOnGestureListener(){     @Override public boolean onScroll(    MotionEvent e1,    MotionEvent e2,    float distanceX,    float distanceY){       mScrolled=true        int sx=getScrollX()        sx+=distanceX        if (sx < 0) {         sx=0        }       if (sx + getWidth() > mTotalWidth) {         sx-=distanceX        }       mTargetScrollX=sx        scrollTo(sx,getScrollY())        invalidate()        return true      }   } )    setHorizontalFadingEdgeEnabled(true)    setWillNotDraw(false)    setHorizontalScrollBarEnabled(false)    setVerticalScrollBarEnabled(false)  } 
@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){   mScrolled=true    int sx=getScrollX()    sx+=distanceX    if (sx < 0) {     sx=0    }   if (sx + getWidth() > mTotalWidth) {     sx-=distanceX    }   mTargetScrollX=sx    scrollTo(sx,getScrollY())    invalidate()    return true  } 
public void setKeyboardController(@Nonnull AKeyboardController keyboardController){   this.keyboardController=keyboardController  } 
@Override public int computeHorizontalScrollRange(){   return mTotalWidth  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   int measuredWidth=resolveSize(50,widthMeasureSpec)    Rect padding=new Rect()    mSelectionHighlight.getPadding(padding)    final int desiredHeight=((int)mPaint.getTextSize()) + mVerticalPadding + padding.top+ padding.bottom    setMeasuredDimension(measuredWidth,resolveSize(desiredHeight,heightMeasureSpec))  } 
/**   * If the canvas is null, then only touch calculations are performed to pick the target candidate.  */ @Override protected void onDraw(Canvas canvas){   if (canvas != null) {     super.onDraw(canvas)    }   mTotalWidth=0    if (mSuggestions == null)   return    if (mBgPadding == null) {     mBgPadding=new Rect(0,0,0,0)      if (getBackground() != null) {       getBackground().getPadding(mBgPadding)      }   }   int x=0    final int count=mSuggestions.size()    final int height=getHeight()    final Rect bgPadding=mBgPadding    final Paint paint=mPaint    final int touchX=mTouchX    final int scrollX=getScrollX()    final boolean scrolled=mScrolled    final boolean typedWordValid=mTypedWordValid    final int y=(int)(((height - mPaint.getTextSize()) / 2) - mPaint.ascent())    for (int i=0  i < count  i++) {     String suggestion=mSuggestions.get(i)      float textWidth=paint.measureText(suggestion)      final int wordWidth=(int)textWidth + X_GAP * 2      mWordX[i]=x      mWordWidth[i]=wordWidth      paint.setColor(mColorNormal)      if (touchX + scrollX >= x && touchX + scrollX < x + wordWidth && !scrolled) {       if (canvas != null) {         canvas.translate(x,0)          mSelectionHighlight.setBounds(0,bgPadding.top,wordWidth,height)          mSelectionHighlight.draw(canvas)          canvas.translate(-x,0)        }       mSelectedIndex=i      }     if (canvas != null) {       if ((i == 1 && !typedWordValid) || (i == 0 && typedWordValid)) {         paint.setFakeBoldText(true)          paint.setColor(mColorRecommended)        }  else       if (i != 0) {         paint.setColor(mColorOther)        }       canvas.drawText(suggestion,x + X_GAP,y,paint)        paint.setColor(mColorOther)        canvas.drawLine(x + wordWidth + 0.5f,bgPadding.top,x + wordWidth + 0.5f,height + 1,paint)        paint.setFakeBoldText(false)      }     x+=wordWidth    }   mTotalWidth=x    if (mTargetScrollX != getScrollX()) {     scrollToTarget()    } } 
private void scrollToTarget(){   int sx=getScrollX()    if (mTargetScrollX > sx) {     sx+=SCROLL_PIXELS      if (sx >= mTargetScrollX) {       sx=mTargetScrollX        requestLayout()      }   }  else {     sx-=SCROLL_PIXELS      if (sx <= mTargetScrollX) {       sx=mTargetScrollX        requestLayout()      }   }   scrollTo(sx,getScrollY())    invalidate()  } 
public void setSuggestions(List<String> suggestions,boolean completions,boolean typedWordValid){   clear()    if (suggestions != null) {     mSuggestions=new ArrayList<String>(suggestions)    }   mTypedWordValid=typedWordValid    scrollTo(0,0)    mTargetScrollX=0    onDraw(null)    invalidate()    requestLayout()  } 
public void clear(){   mSuggestions=EMPTY_LIST    mTouchX=OUT_OF_BOUNDS    mSelectedIndex=-1    invalidate()  } 
@Override public boolean onTouchEvent(MotionEvent me){   if (mGestureDetector.onTouchEvent(me)) {     return true    }   int action=me.getAction()    int x=(int)me.getX()    int y=(int)me.getY()    mTouchX=x  switch (action) { case MotionEvent.ACTION_DOWN:     mScrolled=false    invalidate()  break  case MotionEvent.ACTION_MOVE: if (y <= 0) { if (mSelectedIndex >= 0) {   keyboardController.pickSuggestionManually(mSelectedIndex)    mSelectedIndex=-1  } } invalidate()  break  case MotionEvent.ACTION_UP: if (!mScrolled) { if (mSelectedIndex >= 0) { keyboardController.pickSuggestionManually(mSelectedIndex)  } } mSelectedIndex=-1  removeHighlight()  requestLayout()  break  } return true  } 
/**   * For flick through from keyboard, call this method with the x coordinate of the flick gesture.  * @param x  */ public void takeSuggestionAt(float x){   mTouchX=(int)x    onDraw(null)    if (mSelectedIndex >= 0) {     keyboardController.pickSuggestionManually(mSelectedIndex)    }   invalidate()  } 
private void removeHighlight(){   mTouchX=OUT_OF_BOUNDS    invalidate()  } 
public DefaultKeyboardActionListener(@Nonnull AKeyboardController keyboardController){   this.keyboardController=keyboardController  } 
@Override public void onPress(int primaryCode){ } 
@Override public void onRelease(int primaryCode){ } 
@Override public void onKey(int primaryCode,int[] keyCodes){   keyboardController.onKey(primaryCode,keyCodes)  } 
@Override public void onText(CharSequence text){   keyboardController.onText(text)  } 
@Override public void swipeLeft(){   keyboardController.handleBackspace()  } 
@Override public void swipeRight(){   keyboardController.pickDefaultCandidate()  } 
@Override public void swipeDown(){   keyboardController.handleClose()  } 
@Override public void swipeUp(){ } 
public DefaultKeyboardInput(@Nonnull InputMethodService inputMethodService){   this.inputMethodService=inputMethodService  } 
@Override public void commitTyped(){   if (typedText.length() > 0) {     commitText(typedText,typedText.length())      clearTypedText()    } } 
@Override public void onText(@Nullable CharSequence text){   final InputConnection ic=getCurrentInputConnection()    ic.beginBatchEdit()    commitTyped()    commitText(ic,text,0)    ic.endBatchEdit()  } 
public void commitText(@Nullable CharSequence text,int position){   final InputConnection ic=getCurrentInputConnection()    commitText(ic,text,position)  } 
@Override public void commitText(@Nullable String text,int position){   final InputConnection ic=getCurrentInputConnection()    commitText(ic,text,position)  } 
private void commitText(@Nonnull InputConnection ic,@Nullable CharSequence text,int position){   ic.commitText(text,position)    if (!Strings.isEmpty(text)) {     history.addState(new KeyboardInputHistoryState(AndroidKeyboardUtils.getTextFromInputConnection(ic),0))    } } 
@Nonnull @Override public EditorInfo getCurrentInputEditorInfo(){   return inputMethodService.getCurrentInputEditorInfo()  } 
@Nonnull private InputConnection getCurrentInputConnection(){   InputConnection result=this.inputMethodService.getCurrentInputConnection()    if (result == null) {     result=NoInputConnection.getInstance()    }   return result  } 
@Override public CharSequence getTypedText(){   return typedText  } 
@Override public void clearTypedText(){   this.typedText.setLength(0)  } 
@Override public void undo(){   if (this.history.isUndoAvailable()) {     final KeyboardInputHistoryState state=this.history.undo(null)      restoreFromHistory(state)    } } 
private void restoreFromHistory(@Nullable KeyboardInputHistoryState state){   if (state != null) {     final InputConnection ic=getCurrentInputConnection()      ic.deleteSurroundingText(MAX_INT,MAX_INT)      ic.commitText(state.getCharSequence(),1)    } } 
@Override public void redo(){   if (this.history.isRedoAvailable()) {     final KeyboardInputHistoryState state=this.history.redo(null)      restoreFromHistory(state)    } } 
@Override public boolean handleBackspace(){   boolean changed=false    int length=typedText.length()    final InputConnection ic=getCurrentInputConnection()    if (length > 1) {     typedText.delete(length - 1,length)      ic.setComposingText(typedText,1)      changed=true    }  else   if (length > 0) {     clearTypedText()      commitText(ic,"",0)      changed=true    }   return changed  } 
@Override public void sendKeyEvent(@Nonnull KeyEvent keyEvent){   getCurrentInputConnection().sendKeyEvent(keyEvent)  } 
@Override public int translateKeyDown(int unicodeChar){   if (!Strings.isEmpty(typedText)) {     char accent=typedText.charAt(typedText.length() - 1)      int composed=KeyEvent.getDeadChar(accent,unicodeChar)      if (composed != 0) {       unicodeChar=composed        typedText.setLength(typedText.length() - 1)      }   }   return unicodeChar  } 
@Override public void commitCompletion(@Nonnull CompletionInfo completionInfo){   getCurrentInputConnection().commitCompletion(completionInfo)  } 
@Override public void append(char primaryCode){   typedText.append(primaryCode)    getCurrentInputConnection().setComposingText(typedText,1)  } 
@Override public void handleCursorRight(){   final InputConnection ic=getCurrentInputConnection()    int selectionStart=getSelectionStart(ic)    int selectionEnd=getSelectionEnd(ic,selectionStart)    if (selectionStart > 0) {     selectionStart=selectionStart - 1      ic.setSelection(selectionStart,selectionEnd)    } } 
private int getSelectionEnd(@Nonnull InputConnection ic,int selectionStart){   final CharSequence selectedText=ic.getSelectedText(0)    return selectionStart + (selectedText == null ? 0 : selectedText.length())  } 
private int getSelectionStart(@Nonnull InputConnection ic){   return ic.getTextBeforeCursor(MAX_INT,0).length()  } 
@Override public void handleCursorLeft(){   final InputConnection ic=getCurrentInputConnection()    int selectionStart=getSelectionStart(ic)    int selectionEnd=getSelectionEnd(ic,selectionStart)    if (selectionStart < 0) {     selectionStart=selectionStart - 1      ic.setSelection(selectionStart,selectionEnd)    } } 
@Override public void handleClear(){   typedText.setLength(0)    final InputConnection ic=getCurrentInputConnection()    ic.setSelection(0,0)    ic.deleteSurroundingText(MAX_INT,MAX_INT)  } 
@Override public void handlePaste(){   final ClipboardManager clipboardManager=(ClipboardManager)inputMethodService.getSystemService(Context.CLIPBOARD_SERVICE)    final CharSequence text=clipboardManager.getText()    if (!Strings.isEmpty(text)) {     commitText(text,1)    } } 
@Override public void handleCopy(){   final InputConnection ic=getCurrentInputConnection()    AndroidKeyboardUtils.copyTextFromInputConnection(ic,inputMethodService)  } 
@Override public void clearMetaKeyStates(int flags){   getCurrentInputConnection().clearMetaKeyStates(flags)  } 
@Override public void keyDownUp(int keyEventCode){   sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN,keyEventCode))    sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP,keyEventCode))  } 
@Override public void finishComposingText(){   getCurrentInputConnection().finishComposingText()  } 
@Override public boolean isInputConnected(){   return this.inputMethodService.getCurrentInputConnection() != null  } 
@Override public int getCursorCapsMode(int inputType){   return getCurrentInputConnection().getCursorCapsMode(inputType)  } 
@Nonnull public static InputConnection getInstance(){   return instance  } 
private NoInputConnection(){ } 
@Override public CharSequence getTextBeforeCursor(int n,int flags){   return ""  } 
@Override public CharSequence getTextAfterCursor(int n,int flags){   return ""  } 
@Override public CharSequence getSelectedText(int flags){   return ""  } 
@Override public int getCursorCapsMode(int reqModes){   return 0  } 
@Override public ExtractedText getExtractedText(ExtractedTextRequest request,int flags){   return new ExtractedText()  } 
@Override public boolean deleteSurroundingText(int beforeLength,int afterLength){   return false  } 
@Override public boolean setComposingText(CharSequence text,int newCursorPosition){   return false  } 
@Override public boolean setComposingRegion(int start,int end){   return false  } 
@Override public boolean finishComposingText(){   return false  } 
@Override public boolean commitText(CharSequence text,int newCursorPosition){   return false  } 
@Override public boolean commitCompletion(CompletionInfo text){   return false  } 
@Override public boolean commitCorrection(CorrectionInfo correctionInfo){   return false  } 
@Override public boolean setSelection(int start,int end){   return false  } 
@Override public boolean performEditorAction(int editorAction){   return false  } 
@Override public boolean performContextMenuAction(int id){   return false  } 
@Override public boolean beginBatchEdit(){   return false  } 
@Override public boolean endBatchEdit(){   return false  } 
@Override public boolean sendKeyEvent(KeyEvent event){   return false  } 
@Override public boolean clearMetaKeyStates(int states){   return false  } 
@Override public boolean reportFullscreenMode(boolean enabled){   return false  } 
@Override public boolean performPrivateCommand(String action,Bundle data){   return false  } 
public DragAKeyboard(@Nonnull String keyboardId,@Nonnull KeyboardDef keyboardDef){   super(keyboardId)    this.keyboardDef=keyboardDef  } 
@Override public void setImeOptions(@Nonnull Resources resources,int imeOptions){   keyboardDef.setImeOptions(resources,imeOptions)  } 
@Override public void setShifted(boolean shifted){   keyboardDef.setShifted(shifted)  } 
@Nonnull public KeyboardDef getKeyboardDef(){   return keyboardDef  } 
public KeyboardDef(){ } 
public boolean add(RowDef object){   return rowDefs.add(object)  } 
private void clear(){   rowDefs.clear()  } 
@Nonnull public List<RowDef> getRowDefs(){   return Collections.unmodifiableList(rowDefs)  } 
public void setImeOptions(@Nonnull Resources resources,int imeOptions){   for (  RowDef rowDef : rowDefs) {     rowDef.setImeOptions(resources,imeOptions)    } } 
public void setShifted(boolean shifted){   for (  RowDef rowDef : rowDefs) {     rowDef.setShifted(shifted)    } } 
public RowDef(){ } 
public boolean add(@Nonnull DragAKeyboardButtonDef dragButtonDef){   return buttonDefs.add(dragButtonDef)  } 
private void clear(){   buttonDefs.clear()  } 
@Nonnull public List<DragAKeyboardButtonDef> getButtonDefs(){   return Collections.unmodifiableList(buttonDefs)  } 
public void setImeOptions(@Nonnull Resources resources,int imeOptions){   for (  DragAKeyboardButtonDef buttonDef : buttonDefs) {     buttonDef.setImeOptions(resources,imeOptions)    } } 
public void setShifted(boolean shifted){   for (  DragAKeyboardButtonDef buttonDef : buttonDefs) {     buttonDef.setShifted(shifted)    } } 
boolean allowRepeat()  
@Nullable Integer getKeycode()  
@Nullable Integer getPreviewDrawableResId()  
@Nullable Integer getDirectionKeycode(@Nonnull DragDirection dragDirection)  
void setImeOptions(@Nonnull Resources resources,int imeOptions)  
void setShifted(boolean shifted)  
@Nullable CharSequence getPreviewText()  
@Nullable CharSequence getPreviewDirectionText(@Nonnull DragDirection direction)  
@Override @Nullable public CharSequence getText(@Nonnull DragDirection dragDirection){   return directionDragButtonDef.getText(dragDirection)  } 
@Override @Nullable public Integer getDrawableResId(){   return directionDragButtonDef.getDrawableResId()  } 
@Override @Nullable public CharSequence getText(){   return directionDragButtonDef.getText()  } 
@Override @Nullable public Float getLayoutWeight(){   return directionDragButtonDef.getLayoutWeight()  } 
@Override @Nullable public Integer getLayoutMarginLeft(){   return directionDragButtonDef.getLayoutMarginLeft()  } 
@Override @Nullable public Integer getLayoutMarginRight(){   return directionDragButtonDef.getLayoutMarginRight()  } 
@Override @Nullable public String getTag(){   return directionDragButtonDef.getTag()  } 
@Override @Nullable public Integer getBackgroundResId(){   return directionDragButtonDef.getBackgroundResId()  } 
@Override public boolean allowRepeat(){   return this.allowRepeat  } 
@Nullable @Override public Integer getKeycode(){   return this.keycode  } 
@Nullable @Override public Integer getPreviewDrawableResId(){   return this.previewDrawableResId  } 
public void setKeycode(@Nullable Integer actionCode){   this.keycode=actionCode  } 
@Override public Integer getDirectionKeycode(@Nonnull DragDirection dragDirection){   return this.directionKeycodes.get(dragDirection)  } 
public void setDirectionKeycode(@Nonnull DragDirection direction,@Nullable Integer actionCode){   directionKeycodes.put(direction,actionCode)  } 
public void setAllowRepeat(boolean allowRepeat){   this.allowRepeat=allowRepeat  } 
@Nonnull public static DragAKeyboardButtonDefImpl newInstance(@Nullable CharSequence text,@Nullable CharSequence up,@Nullable CharSequence right,@Nullable CharSequence down,@Nullable CharSequence left){   final DragAKeyboardButtonDefImpl result=new DragAKeyboardButtonDefImpl()    result.directionDragButtonDef=DirectionDragButtonDefImpl.newInstance(text,up,right,down,left)    return result  } 
public static DragAKeyboardButtonDefImpl newInstance(@Nullable CharSequence text,@Nullable CharSequence up,@Nullable CharSequence right,@Nullable CharSequence down,@Nullable CharSequence left,int drawableResId){   final DragAKeyboardButtonDefImpl result=new DragAKeyboardButtonDefImpl()    result.directionDragButtonDef=DirectionDragButtonDefImpl.newInstance(text,up,right,down,left,drawableResId)    return result  } 
public static DragAKeyboardButtonDefImpl newInstance(@Nullable CharSequence text,@Nullable Integer keycode){   final DragAKeyboardButtonDefImpl result=new DragAKeyboardButtonDefImpl()    result.directionDragButtonDef=DirectionDragButtonDefImpl.newInstance(text)    result.keycode=keycode    return result  } 
public static DragAKeyboardButtonDefImpl newDrawableInstance(int drawableResId,int keycode){   final DragAKeyboardButtonDefImpl result=new DragAKeyboardButtonDefImpl()    result.directionDragButtonDef=DirectionDragButtonDefImpl.newDrawableInstance(drawableResId)    result.keycode=keycode    return result  } 
public static DragAKeyboardButtonDefImpl newDrawableInstance(int drawableResId,int keycode,int backgroundResId){   final DragAKeyboardButtonDefImpl result=new DragAKeyboardButtonDefImpl()    result.directionDragButtonDef=DirectionDragButtonDefImpl.newDrawableInstance(drawableResId,backgroundResId)    result.keycode=keycode    return result  } 
public void setWeight(@Nullable Float weight){   directionDragButtonDef.setWeight(weight)  } 
public void setLayoutMarginRight(@Nullable Integer layoutMarginRight){   directionDragButtonDef.setLayoutMarginRight(layoutMarginRight)  } 
public void setLayoutMarginLeft(@Nullable Integer layoutMarginLeft){   directionDragButtonDef.setLayoutMarginLeft(layoutMarginLeft)  } 
public void setBackgroundResId(int backgroundResId){   directionDragButtonDef.setBackgroundResId(backgroundResId)  } 
public void setTag(@Nullable String tag){   directionDragButtonDef.setTag(tag)  } 
public void setText(@Nullable CharSequence text){   directionDragButtonDef.setText(text)  } 
public void setBackgroundResId(@Nullable Integer backgroundResId){   directionDragButtonDef.setBackgroundResId(backgroundResId)  } 
public void setDrawableResId(@Nullable Integer drawableResId){   directionDragButtonDef.setDrawableResId(drawableResId)  } 
public void setDirectionText(@Nonnull DragDirection key,@Nullable CharSequence text){   directionDragButtonDef.setDirectionText(key,text)  } 
public void setPreviewText(@Nullable CharSequence previewText){   this.previewText=previewText  } 
public void setPreviewDirectionText(@Nonnull DragDirection direction,@Nullable CharSequence charSequence){   previewDirectionTexts.put(direction,charSequence)  } 
@Override public void setImeOptions(@Nonnull Resources resources,int imeOptions){ } 
@Override public void setShifted(boolean shifted){ } 
@Nullable @Override public CharSequence getPreviewText(){   return this.previewText  } 
@Nullable @Override public CharSequence getPreviewDirectionText(@Nonnull DragDirection direction){   return this.previewDirectionTexts.get(direction)  } 
public void setPreviewDrawableResId(@Nullable Integer previewDrawableResId){   this.previewDrawableResId=previewDrawableResId  } 
public DragAndroidKeyboardView(Context context){   super(context)    preview=new AKeyboardButtonPreview(this)    vibrator=new VibratorContainer((Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE),PreferenceManager.getDefaultSharedPreferences(context),1f)  } 
public DragAndroidKeyboardView(Context context,AttributeSet attrs){   super(context,attrs)    preview=new AKeyboardButtonPreview(this)    vibrator=new VibratorContainer((Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE),PreferenceManager.getDefaultSharedPreferences(context),1f)  } 
public DragAndroidKeyboardView(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)    preview=new AKeyboardButtonPreview(this)    vibrator=new VibratorContainer((Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE),PreferenceManager.getDefaultSharedPreferences(context),1f)  } 
@Override public void setOnKeyboardActionListener(@Nonnull KeyboardView.OnKeyboardActionListener keyboardActionListener){   this.keyboardActionListener=keyboardActionListener  } 
@Override public void setKeyboard(@Nonnull DragAKeyboard keyboard){   setKeyboard(keyboard,null)  } 
@Override public void close(){   this.preview.hide()  } 
@Override public void dismiss(){   this.preview.hide()  } 
@Override public void reload(){   if (keyboard != null) {     reloadView(keyboard,null)    } } 
private void setKeyboard(@Nullable DragAKeyboard keyboard,@Nullable LayoutInflater layoutInflater){   if (keyboard != null) {     this.keyboard=keyboard      reloadView(keyboard,layoutInflater)    } } 
private void reloadView(@Nonnull DragAKeyboard keyboard,@Nullable LayoutInflater layoutInflater){   dismiss()    final DragAKeyboard.KeyboardDef keyboardDef=keyboard.getKeyboardDef()    final Context context=this.getContext()    int buttonMargin=Views.toPixels(context.getResources().getDisplayMetrics(),0.5f)    if (layoutInflater == null) {     layoutInflater=(LayoutInflater)context.getSystemService(Activity.LAYOUT_INFLATER_SERVICE)    }   preview.createPreviewView(layoutInflater)    final SimpleOnDragListener.Preferences defaultPreferences=SimpleOnDragListener.getDefaultPreferences(context)    this.removeAllViews()    this.defs.clear()    for (  DragAKeyboard.RowDef rowDef : keyboardDef.getRowDefs()) {     final LinearLayout rowLayout=new LinearLayout(context)      rowLayout.setOrientation(LinearLayout.HORIZONTAL)      for (    DragAKeyboardButtonDef buttonDef : rowDef.getButtonDefs()) {       Float weight=buttonDef.getLayoutWeight()        if (weight == null) {         weight=1f        }       final LayoutParams params=new LayoutParams(0,ViewGroup.LayoutParams.MATCH_PARENT,weight)        Integer layoutMarginLeft=buttonDef.getLayoutMarginLeft()        if (layoutMarginLeft != null) {         params.leftMargin=layoutMarginLeft        }  else {         params.leftMargin=buttonMargin        }       Integer layoutMarginRight=buttonDef.getLayoutMarginRight()        if (layoutMarginRight != null) {         params.rightMargin=layoutMarginRight        }  else {         params.rightMargin=buttonMargin        }       params.topMargin=buttonMargin        params.bottomMargin=buttonMargin        final Integer drawableResId=buttonDef.getDrawableResId()        if (drawableResId == null) {         final DirectionDragButton directionDragButton=(DirectionDragButton)layoutInflater.inflate(R.layout.drag_keyboard_drag_button,null)          directionDragButton.applyDef(buttonDef)          directionDragButton.setOnDragListener(new SimpleOnDragListener(this,defaultPreferences))          directionDragButton.setOnClickListener(this)          defs.put(directionDragButton,buttonDef)          rowLayout.addView(directionDragButton,params)        }  else {         final ImageButton imageButton=(ImageButton)layoutInflater.inflate(R.layout.drag_keyboard_image_button,null)          AndroidViewUtils.applyButtonDef(imageButton,buttonDef)          imageButton.setOnTouchListener(this)          defs.put(imageButton,buttonDef)          rowLayout.addView(imageButton,params)        }     }     final LayoutParams params=new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,0,1)      params.gravity=Gravity.CENTER_HORIZONTAL      this.addView(rowLayout,params)    } } 
@Override public boolean processDragEvent(@Nonnull DragDirection dragDirection,@Nonnull DragButton dragButton,@Nonnull Point2d startPoint2d,@Nonnull MotionEvent motionEvent){   if (dragButton instanceof DirectionDragButton) {     final DirectionDragButton directionDragButton=(DirectionDragButton)dragButton      vibrator.vibrate()      final Integer keycode=getKeycode(dragDirection,dragButton)      return handleTextOrCode(dragButton,directionDragButton.getText(dragDirection),keycode,true,dragDirection)    }   return false  } 
private Integer getKeycode(@Nullable DragDirection dragDirection,@Nonnull View view){   Integer keycode=null    final DragAKeyboardButtonDef buttonDef=this.defs.get(view)    if (buttonDef != null) {     if (dragDirection != null) {       keycode=buttonDef.getDirectionKeycode(dragDirection)      }  else {       keycode=buttonDef.getKeycode()      }   }   return keycode  } 
private boolean handleTextOrCode(@Nonnull View view,@Nullable CharSequence text,@Nullable Integer keycode,boolean withPreview,@Nullable DragDirection dragDirection){   if (keycode != null) {     return handleKeycode(view,text,keycode,withPreview,dragDirection)    }  else {     return handleText(view,text,withPreview,dragDirection)    } } 
private boolean handleKeycode(@Nonnull View view,@Nullable CharSequence text,@Nonnull Integer keycode,boolean withPreview,@Nullable DragDirection dragDirection){   if (withPreview) {     showPreview(view,text,dragDirection)    }   if (keyboardActionListener != null) {     keyboardActionListener.onKey(keycode,null)    }   return true  } 
private boolean handleText(@Nonnull View view,@Nullable CharSequence text,boolean withPreview,@Nullable DragDirection dragDirection){   if (!Strings.isEmpty(text)) {     if (withPreview) {       showPreview(view,text,dragDirection)      }     if (keyboardActionListener != null) {       keyboardActionListener.onText(text)      }     return true    }   return false  } 
private void showPreview(@Nonnull View view,@Nullable CharSequence text,@Nullable DragDirection direction){   final DragAKeyboardButtonDef buttonDef=defs.get(view)    if (buttonDef != null) {     CharSequence previewText      if (direction != null) {       previewText=buttonDef.getPreviewDirectionText(direction)      }  else {       previewText=buttonDef.getPreviewText()      }     Integer previewDrawableResId=null      if (direction == null) {       previewDrawableResId=buttonDef.getPreviewDrawableResId()      }     if (previewDrawableResId == null) {       previewDrawableResId=buttonDef.getDrawableResId()      }     if (previewText == null && previewDrawableResId == null) {       previewText=text      }     preview.showPreview(view,previewText,previewDrawableResId)    }  else {     preview.showPreview(view,text,null)    } } 
@Override public boolean onTouch(@Nonnull final View v,@Nonnull MotionEvent event){ switch (event.getAction()) { case MotionEvent.ACTION_DOWN:     if (isRepeatAllowed(v)) {       repeatHelper.keyDown(v,new RepeatKeydownRunnable(v))      }  else {       repeatHelper.keyDown(v,null)        doKeydown(v)      }   return true  case MotionEvent.ACTION_UP: repeatHelper.keyUp(v)  return true  } return false  } 
private boolean isRepeatAllowed(View v){   boolean allowRepeat=false    final DragAKeyboardButtonDef buttonDef=defs.get(v)    if (buttonDef != null) {     allowRepeat=buttonDef.allowRepeat()    }   return allowRepeat  } 
@Override public void onClick(View v){   vibrator.vibrate()    final Integer keycode=getKeycode(null,v)    if (v instanceof TextView) {     handleTextOrCode(v,((TextView)v).getText(),keycode,true,null)    }  else {     handleTextOrCode(v,null,keycode,true,null)    } } 
public RepeatKeydownRunnable(@Nonnull View view){   this.view=view  } 
@Override public void run(){   doKeydown(view)  } 
private void doKeydown(@Nonnull View view){   final Integer keycode=getKeycode(null,view)    if (view instanceof TextView) {     handleTextOrCode(view,((TextView)view).getText(),keycode,true,null)    }  else {     handleTextOrCode(view,null,keycode,true,null)    } } 
@Nonnull @Override protected AKeyboardViewWithSuggestions<DragAKeyboard> createKeyboardView0(@Nonnull Context context){   return new AKeyboardViewWithSuggestionsImpl<DragAKeyboard,DragAndroidKeyboardView>(R.layout.drag_keyboard,this,getInputMethodService())  } 
@Nonnull @Override protected AKeyboardControllerState<DragAKeyboard> onInitializeInterface0(@Nonnull InputMethodService inputMethodService){   return AKeyboardControllerStateImpl.newDefaultState(createKeyboardDef(inputMethodService))  } 
protected abstract DragAKeyboard createKeyboardDef(@Nonnull Context context)  
@Nonnull @Override public AKeyboardControllerState<DragAKeyboard> onStartInput0(@Nonnull EditorInfo attribute,boolean restarting){   return getState()  } 
@Nonnull @Override protected AKeyboardConfiguration onCreate0(@Nonnull Context context){   return new AKeyboardConfigurationImpl(context.getResources().getString(R.string.word_separators))  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    final Context context=getActivity()    setPreferenceScreen(getPreferenceManager().createPreferenceScreen(context))    mSettings.init(context,getPreferenceScreen())  } 
/**   * {@inheritDoc}  */ @Override public void setInputMethodSettingsCategoryTitle(int resId){   mSettings.setInputMethodSettingsCategoryTitle(resId)  } 
/**   * {@inheritDoc}  */ @Override public void setInputMethodSettingsCategoryTitle(CharSequence title){   mSettings.setInputMethodSettingsCategoryTitle(title)  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerTitle(int resId){   mSettings.setSubtypeEnablerTitle(resId)  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerTitle(CharSequence title){   mSettings.setSubtypeEnablerTitle(title)  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerIcon(int resId){   mSettings.setSubtypeEnablerIcon(resId)  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerIcon(Drawable drawable){   mSettings.setSubtypeEnablerIcon(drawable)  } 
/**   * {@inheritDoc}  */ @Override public void onResume(){   super.onResume()    mSettings.updateSubtypeEnabler()  } 
/**   * Initialize internal states of this object.  * @param context    the context for this application.  * @param prefScreen a PreferenceScreen of PreferenceActivity or PreferenceFragment.  * @return true if this application is an IME and has two or more subtypes, false otherwise.  */ public boolean init(final Context context,final PreferenceScreen prefScreen){   mContext=context    mImm=(InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE)    mImi=getMyImi(context,mImm)    if (mImi == null || mImi.getSubtypeCount() <= 1) {     return false    }   mSubtypeEnablerPreference=new Preference(context)    mSubtypeEnablerPreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       final CharSequence title=getSubtypeEnablerTitle(context)        final Intent intent=new Intent(Settings.ACTION_INPUT_METHOD_SUBTYPE_SETTINGS)        intent.putExtra(Settings.EXTRA_INPUT_METHOD_ID,mImi.getId())        if (!TextUtils.isEmpty(title)) {         intent.putExtra(Intent.EXTRA_TITLE,title)        }       intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_CLEAR_TOP)        context.startActivity(intent)        return true      }   } )    prefScreen.addPreference(mSubtypeEnablerPreference)    updateSubtypeEnabler()    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   final CharSequence title=getSubtypeEnablerTitle(context)    final Intent intent=new Intent(Settings.ACTION_INPUT_METHOD_SUBTYPE_SETTINGS)    intent.putExtra(Settings.EXTRA_INPUT_METHOD_ID,mImi.getId())    if (!TextUtils.isEmpty(title)) {     intent.putExtra(Intent.EXTRA_TITLE,title)    }   intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_CLEAR_TOP)    context.startActivity(intent)    return true  } 
private static InputMethodInfo getMyImi(Context context,InputMethodManager imm){   final List<InputMethodInfo> imis=imm.getInputMethodList()    for (int i=0  i < imis.size()  ++i) {     final InputMethodInfo imi=imis.get(i)      if (imis.get(i).getPackageName().equals(context.getPackageName())) {       return imi      }   }   return null  } 
private static String getEnabledSubtypesLabel(Context context,InputMethodManager imm,InputMethodInfo imi){   if (context == null || imm == null || imi == null)   return null    final List<InputMethodSubtype> subtypes=imm.getEnabledInputMethodSubtypeList(imi,true)    final StringBuilder sb=new StringBuilder()    final int N=subtypes.size()    for (int i=0  i < N  ++i) {     final InputMethodSubtype subtype=subtypes.get(i)      if (sb.length() > 0) {       sb.append(", ")      }     sb.append(subtype.getDisplayName(context,imi.getPackageName(),imi.getServiceInfo().applicationInfo))    }   return sb.toString()  } 
/**   * {@inheritDoc}  */ @Override public void setInputMethodSettingsCategoryTitle(int resId){   mInputMethodSettingsCategoryTitleRes=resId    updateSubtypeEnabler()  } 
/**   * {@inheritDoc}  */ @Override public void setInputMethodSettingsCategoryTitle(CharSequence title){   mInputMethodSettingsCategoryTitleRes=0    mInputMethodSettingsCategoryTitle=title    updateSubtypeEnabler()  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerTitle(int resId){   mSubtypeEnablerTitleRes=resId    updateSubtypeEnabler()  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerTitle(CharSequence title){   mSubtypeEnablerTitleRes=0    mSubtypeEnablerTitle=title    updateSubtypeEnabler()  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerIcon(int resId){   mSubtypeEnablerIconRes=resId    updateSubtypeEnabler()  } 
/**   * {@inheritDoc}  */ @Override public void setSubtypeEnablerIcon(Drawable drawable){   mSubtypeEnablerIconRes=0    mSubtypeEnablerIcon=drawable    updateSubtypeEnabler()  } 
private CharSequence getSubtypeEnablerTitle(Context context){   if (mSubtypeEnablerTitleRes != 0) {     return context.getString(mSubtypeEnablerTitleRes)    }  else {     return mSubtypeEnablerTitle    } } 
public void updateSubtypeEnabler(){   if (mSubtypeEnablerPreference != null) {     if (mSubtypeEnablerTitleRes != 0) {       mSubtypeEnablerPreference.setTitle(mSubtypeEnablerTitleRes)      }  else     if (!TextUtils.isEmpty(mSubtypeEnablerTitle)) {       mSubtypeEnablerPreference.setTitle(mSubtypeEnablerTitle)      }     final String summary=getEnabledSubtypesLabel(mContext,mImm,mImi)      if (!TextUtils.isEmpty(summary)) {       mSubtypeEnablerPreference.setSummary(summary)      }     if (mSubtypeEnablerIconRes != 0) {       mSubtypeEnablerPreference.setIcon(mSubtypeEnablerIconRes)      }  else     if (mSubtypeEnablerIcon != null) {       mSubtypeEnablerPreference.setIcon(mSubtypeEnablerIcon)      }   } } 
/**   * Sets the title for the input method settings category with a resource ID.  * @param resId The resource ID of the title.  */ public void setInputMethodSettingsCategoryTitle(int resId)  
/**   * Sets the title for the input method settings category with a CharSequence.  * @param title The title for this preference.  */ public void setInputMethodSettingsCategoryTitle(CharSequence title)  
/**   * Sets the title for the input method enabler preference for launching subtype enabler with a resource ID.  * @param resId The resource ID of the title.  */ public void setSubtypeEnablerTitle(int resId)  
/**   * Sets the title for the input method enabler preference for launching subtype enabler with a CharSequence.  * @param title The title for this preference.  */ public void setSubtypeEnablerTitle(CharSequence title)  
/**   * Sets the icon for the preference for launching subtype enabler with a resource ID.  * @param resId The resource id of an optional icon for the preference.  */ public void setSubtypeEnablerIcon(int resId)  
/**   * Sets the icon for the Preference for launching subtype enabler with a Drawable.  * @param drawable The drawable of an optional icon for the preference.  */ public void setSubtypeEnablerIcon(Drawable drawable)  
public KeyboardInputHistoryState(CharSequence charSequence,int selection){   this.charSequence=charSequence    this.selection=selection  } 
@Nullable public CharSequence getCharSequence(){   return charSequence  } 
public int getSelection(){   return selection  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof KeyboardInputHistoryState))   return false    KeyboardInputHistoryState that=(KeyboardInputHistoryState)o    if (selection != that.selection)   return false    if (charSequence != null ? !charSequence.equals(that.charSequence) : that.charSequence != null)   return false    return true  } 
@Override public int hashCode(){   int result=charSequence != null ? charSequence.hashCode() : 0    result=31 * result + selection    return result  } 
public KeyboardViewAKeyboardView(Context context,AttributeSet attrs){   super(context,attrs)  } 
public KeyboardViewAKeyboardView(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)  } 
@Override public void setOnKeyboardActionListener(@Nonnull KeyboardView.OnKeyboardActionListener keyboardActionListener){   super.setOnKeyboardActionListener(keyboardActionListener)  } 
@Override public void setKeyboard(@Nonnull AndroidAKeyboard keyboard){   super.setKeyboard(keyboard.getKeyboard())  } 
@Override public void close(){   super.closing()  } 
@Override public void dismiss(){   super.handleBack()  } 
@Override public void reload(){   setKeyboard(getKeyboard())  } 
@Override protected boolean onLongPress(Keyboard.Key key){   if (key.codes[0] == Keyboard.KEYCODE_CANCEL) {     getOnKeyboardActionListener().onKey(KEYCODE_OPTIONS,null)      return true    }  else {     return super.onLongPress(key)    } } 
void setSubtypeOnSpaceKey(final InputMethodSubtype subtype){   final LatinKeyboard keyboard=(LatinKeyboard)getKeyboard()    keyboard.setSpaceIcon(getResources().getDrawable(subtype.getIconResId()))    invalidateAllKeys()  } 
public LatinDragInputMethodService(){   super(new LatinDragKeyboardController())  } 
@Nonnull @Override protected AKeyboardControllerState<DragAKeyboard> onInitializeInterface0(@Nonnull InputMethodService inputMethodService){   languageKeyboardDefs.add(createKeyboard("en",createEnglishKeyboard(inputMethodService)))    languageKeyboardDefs.add(createKeyboard("ru",createRussianKeyboard(inputMethodService)))    digitsKeyboard=createDigitsKeyboard(inputMethodService)    return super.onInitializeInterface0(inputMethodService)  } 
@Override protected DragAKeyboard createKeyboardDef(@Nonnull Context context){   return languageKeyboardDefs.get(currentKeyboard)  } 
@Nonnull private DragAKeyboard.KeyboardDef createRussianKeyboard(@Nonnull Context context){   final int notLetterBackgroundResId=R.drawable.metro_dark_button_gray    final DragAKeyboard.KeyboardDef result=new DragAKeyboard.KeyboardDef()    final DragAKeyboard.RowDef firstRow=new DragAKeyboard.RowDef()    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"1","!"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"2","@"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"3","#"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"4","$"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"5","%"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"6","^"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"7","&"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"8","*"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"9","("))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"0",")"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"0",")"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,"0",")"))    result.add(firstRow)    final DragAKeyboard.RowDef secondRow=new DragAKeyboard.RowDef()    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_delete,Keyboard.KEYCODE_DELETE,notLetterBackgroundResId))    result.add(secondRow)    final DragAKeyboard.RowDef thirdRow=new DragAKeyboard.RowDef()    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_copy,DragKeyboardController.KEYCODE_COPY,notLetterBackgroundResId))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("","",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance(",",".",null,"!","?",notLetterBackgroundResId))    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_enter,DragKeyboardController.KEYCODE_ENTER,notLetterBackgroundResId))    result.add(thirdRow)    final DragAKeyboard.RowDef fourthRow=new DragAKeyboard.RowDef()    fourthRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_paste,DragKeyboardController.KEYCODE_PASTE,notLetterBackgroundResId))    int spaceMargin=Views.toPixels(context.getResources().getDisplayMetrics(),((6 - 1) * 1f + 1f) / 2f)    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("-",null,null,null,null,notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("-",null,null,null,null,notLetterBackgroundResId))    final DragAKeyboardButtonDefImpl spaceButtonDef=DragAKeyboardButtonDefImpl.newInstance(context.getText(R.string.ru),null,">",null,"<",notLetterBackgroundResId)    spaceButtonDef.setKeycode((int)' ')    spaceButtonDef.setDirectionKeycode(DragDirection.left,DragKeyboardController.KEYCODE_PREV_KEYBOARD)    spaceButtonDef.setDirectionKeycode(DragDirection.right,DragKeyboardController.KEYCODE_NEXT_KEYBOARD)    spaceButtonDef.setLayoutMarginLeft(spaceMargin)    spaceButtonDef.setLayoutMarginRight(spaceMargin)    spaceButtonDef.setWeight(6f)    fourthRow.add(spaceButtonDef)    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance(".",",",null,null,null,notLetterBackgroundResId))    fourthRow.add(createHistoryButtonDef(notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("0","(",null,")",null,notLetterBackgroundResId))    result.add(fourthRow)    return result  } 
@Nonnull private DragAKeyboardButtonDefImpl createHistoryButtonDef(int notLetterBackgroundResId){   final DragAKeyboardButtonDefImpl historyButtonDef=DragAKeyboardButtonDefImpl.newInstance(null,null,"",null,"",notLetterBackgroundResId)    historyButtonDef.setDirectionKeycode(DragDirection.left,AbstractKeyboardController.KEYCODE_UNDO)    historyButtonDef.setDirectionKeycode(DragDirection.right,AbstractKeyboardController.KEYCODE_REDO)    return historyButtonDef  } 
@Nonnull private DragAKeyboard.KeyboardDef createEnglishKeyboard(@Nonnull Context context){   final int notLetterBackgroundResId=R.drawable.metro_dark_button_gray    final DragAKeyboard.KeyboardDef result=new DragAKeyboard.KeyboardDef()    final DragAKeyboard.RowDef firstRow=new DragAKeyboard.RowDef()    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("q","Q",null,"1","!"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("w","W",null,"2","@"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("e","E",null,"3","#"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("r","R",null,"4","$"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("t","T",null,"5","%"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("y","Y",null,"6","^"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("u","U",null,"7","&"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("i","I",null,"8","*"))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("o","O",null,"9","("))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("p","P",null,"0",")"))    result.add(firstRow)    final DragAKeyboard.RowDef secondRow=new DragAKeyboard.RowDef()    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("a","A",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("s","S",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("d","D",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("f","F",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("g","G",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("h","H",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("j","J",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("k","K",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("l","L",null,null,null))    secondRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_delete,Keyboard.KEYCODE_DELETE,notLetterBackgroundResId))    result.add(secondRow)    final DragAKeyboard.RowDef thirdRow=new DragAKeyboard.RowDef()    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_copy,DragKeyboardController.KEYCODE_COPY,notLetterBackgroundResId))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("z","Z",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("x","X",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("c","C",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("v","V",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("b","B",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("n","N",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("m","M",null,null,null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance(",",".",null,"!","?",notLetterBackgroundResId))    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_enter,DragKeyboardController.KEYCODE_ENTER,notLetterBackgroundResId))    result.add(thirdRow)    final DragAKeyboard.RowDef fourthRow=new DragAKeyboard.RowDef()    fourthRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_paste,DragKeyboardController.KEYCODE_PASTE,notLetterBackgroundResId))    int spaceMargin=Views.toPixels(context.getResources().getDisplayMetrics(),((4 - 1) * 1f + 1f) / 2f)    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("-",null,null,null,null,notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("-",null,null,null,null,notLetterBackgroundResId))    final DragAKeyboardButtonDefImpl spaceButtonDef=DragAKeyboardButtonDefImpl.newInstance(context.getText(R.string.en),null,">",null,"<",notLetterBackgroundResId)    spaceButtonDef.setKeycode((int)' ')    spaceButtonDef.setDirectionKeycode(DragDirection.left,DragKeyboardController.KEYCODE_PREV_KEYBOARD)    spaceButtonDef.setDirectionKeycode(DragDirection.right,DragKeyboardController.KEYCODE_NEXT_KEYBOARD)    spaceButtonDef.setLayoutMarginLeft(spaceMargin)    spaceButtonDef.setLayoutMarginRight(spaceMargin)    spaceButtonDef.setWeight(4f)    fourthRow.add(spaceButtonDef)    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance(".",",",null,null,null,notLetterBackgroundResId))    fourthRow.add(createHistoryButtonDef(notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("0","(",null,")",null,notLetterBackgroundResId))    result.add(fourthRow)    return result  } 
@Nonnull private DragAKeyboard.KeyboardDef createDigitsKeyboard(@Nonnull Context context){   final int notLetterBackgroundResId=R.drawable.metro_dark_button_gray    final DragAKeyboard.KeyboardDef result=new DragAKeyboard.KeyboardDef()    final DragAKeyboard.RowDef firstRow=new DragAKeyboard.RowDef()    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("1",null))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("2",null))    firstRow.add(DragAKeyboardButtonDefImpl.newInstance("3",null))    firstRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_delete,Keyboard.KEYCODE_DELETE,notLetterBackgroundResId))    result.add(firstRow)    final DragAKeyboard.RowDef secondRow=new DragAKeyboard.RowDef()    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("4",null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("5",null))    secondRow.add(DragAKeyboardButtonDefImpl.newInstance("6",null))    secondRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_copy,DragKeyboardController.KEYCODE_COPY,notLetterBackgroundResId))    result.add(secondRow)    final DragAKeyboard.RowDef thirdRow=new DragAKeyboard.RowDef()    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("7",null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("8",null))    thirdRow.add(DragAKeyboardButtonDefImpl.newInstance("9",null))    thirdRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_paste,DragKeyboardController.KEYCODE_PASTE,notLetterBackgroundResId))    result.add(thirdRow)    final DragAKeyboard.RowDef fourthRow=new DragAKeyboard.RowDef()    fourthRow.add(createHistoryButtonDef(notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance("0","(",null,")",null,notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newInstance(".",",",null,null,null,notLetterBackgroundResId))    fourthRow.add(DragAKeyboardButtonDefImpl.newDrawableInstance(R.drawable.kb_enter,DragKeyboardController.KEYCODE_ENTER,notLetterBackgroundResId))    result.add(fourthRow)    return result  } 
@Override protected void handlePrevKeyboard(){   super.handlePrevKeyboard()    currentKeyboard-=1    if (currentKeyboard < 0) {     currentKeyboard=languageKeyboardDefs.size() - 1    }   setCurrentKeyboard(getCurrentLanguageKeyboard())  } 
@Override protected void handleNextKeyboard(){   super.handleNextKeyboard()    currentKeyboard+=1    if (currentKeyboard >= languageKeyboardDefs.size()) {     currentKeyboard=0    }   setCurrentKeyboard(getCurrentLanguageKeyboard())  } 
private DragAKeyboard getCurrentLanguageKeyboard(){   return languageKeyboardDefs.get(currentKeyboard)  } 
@Nonnull private DragAKeyboard createKeyboard(@Nonnull String keyboardId,@Nonnull DragAKeyboard.KeyboardDef keyboardDef){   return new DragAKeyboard(keyboardId,keyboardDef)  } 
@Nonnull @Override public AKeyboardControllerState<DragAKeyboard> onStartInput0(@Nonnull EditorInfo attribute,boolean restarting){   final AKeyboardControllerState<DragAKeyboard> result  switch (attribute.inputType & InputType.TYPE_MASK_CLASS) { case InputType.TYPE_CLASS_NUMBER: case InputType.TYPE_CLASS_DATETIME:     result=AKeyboardControllerStateImpl.newDefaultState(createKeyboard("digits",digitsKeyboard))    break  case InputType.TYPE_CLASS_PHONE: result=AKeyboardControllerStateImpl.newDefaultState(createKeyboard("digits",digitsKeyboard))  break  case InputType.TYPE_CLASS_TEXT: boolean prediction=true  boolean completion=false  int variation=attribute.inputType & InputType.TYPE_MASK_VARIATION  if (variation == InputType.TYPE_TEXT_VARIATION_PASSWORD || variation == InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD) { prediction=false  } if (variation == InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS || variation == InputType.TYPE_TEXT_VARIATION_URI || variation == InputType.TYPE_TEXT_VARIATION_FILTER) { prediction=false  } if ((attribute.inputType & InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE) != 0) { prediction=false  completion=getInputMethodService().isFullscreenMode()  } result=AKeyboardControllerStateImpl.newInstance(prediction,completion,getCurrentLanguageKeyboard())  updateShiftKeyState(attribute)  break  default : updateShiftKeyState(attribute)  result=AKeyboardControllerStateImpl.newDefaultState(getCurrentLanguageKeyboard())  } return result  } 
public LatinInputMethodService(){   super(new LatinKeyboardController())  } 
public LatinKeyboard(Context context,int xmlLayoutResId){   super(context,xmlLayoutResId)  } 
public LatinKeyboard(Context context,int layoutTemplateResId,CharSequence characters,int columns,int horizontalPadding){   super(context,layoutTemplateResId,characters,columns,horizontalPadding)  } 
@Override protected Key createKeyFromXml(Resources res,Row parent,int x,int y,XmlResourceParser parser){   Key key=new LatinKey(res,parent,x,y,parser)    if (key.codes[0] == 10) {     mEnterKey=key    }  else   if (key.codes[0] == ' ') {     mSpaceKey=key    }   return key  } 
/**   * This looks at the ime options given by the current editor, to set the appropriate label on the keyboard's enter key (if it has one).  */ void setImeOptions(Resources res,int options){   if (mEnterKey == null) {     return    } switch (options & (EditorInfo.IME_MASK_ACTION | EditorInfo.IME_FLAG_NO_ENTER_ACTION)) { case EditorInfo.IME_ACTION_GO:     mEnterKey.iconPreview=null    mEnterKey.icon=null  mEnterKey.label=res.getText(R.string.label_go_key)  break  case EditorInfo.IME_ACTION_NEXT: mEnterKey.iconPreview=null  mEnterKey.icon=null  mEnterKey.label=res.getText(R.string.label_next_key)  break  case EditorInfo.IME_ACTION_SEARCH: mEnterKey.icon=res.getDrawable(R.drawable.sym_keyboard_search)  mEnterKey.label=null  break  case EditorInfo.IME_ACTION_SEND: mEnterKey.iconPreview=null  mEnterKey.icon=null  mEnterKey.label=res.getText(R.string.label_send_key)  break  default : mEnterKey.icon=res.getDrawable(R.drawable.sym_keyboard_return)  mEnterKey.label=null  break  } } 
void setSpaceIcon(final Drawable icon){   if (mSpaceKey != null) {     mSpaceKey.icon=icon    } } 
public LatinKey(Resources res,Keyboard.Row parent,int x,int y,XmlResourceParser parser){   super(res,parent,x,y,parser)  } 
/**   * Overriding this method so that we can reduce the target area for the key that closes the keyboard.  */ @Override public boolean isInside(int x,int y){   return super.isInside(x,codes[0] == KEYCODE_CANCEL ? y - 10 : y)  } 
@Nonnull @Override protected AKeyboardControllerState<AndroidAKeyboard> onInitializeInterface0(@Nonnull InputMethodService inputMethodService){   qwertyKeyboard=AndroidAKeyboard.newInstance(String.valueOf(R.xml.qwerty),new LatinKeyboard(inputMethodService,R.xml.qwerty))    symbolsKeyboard=AndroidAKeyboard.newInstance(String.valueOf(R.xml.qwerty),new LatinKeyboard(inputMethodService,R.xml.symbols))    symbolsShiftedKeyboard=AndroidAKeyboard.newInstance(String.valueOf(R.xml.qwerty),new LatinKeyboard(inputMethodService,R.xml.symbols_shift))    return AKeyboardControllerStateImpl.newDefaultState(qwertyKeyboard)  } 
@Nonnull @Override public AKeyboardControllerState<AndroidAKeyboard> onStartInput0(@Nonnull EditorInfo attribute,boolean restarting){   final AKeyboardControllerState<AndroidAKeyboard> result  switch (attribute.inputType & InputType.TYPE_MASK_CLASS) { case InputType.TYPE_CLASS_NUMBER: case InputType.TYPE_CLASS_DATETIME:     result=AKeyboardControllerStateImpl.newDefaultState(symbolsKeyboard)    break  case InputType.TYPE_CLASS_PHONE: result=AKeyboardControllerStateImpl.newDefaultState(symbolsKeyboard)  break  case InputType.TYPE_CLASS_TEXT: boolean prediction=true  boolean completion=false  int variation=attribute.inputType & InputType.TYPE_MASK_VARIATION  if (variation == InputType.TYPE_TEXT_VARIATION_PASSWORD || variation == InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD) { prediction=false  } if (variation == InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS || variation == InputType.TYPE_TEXT_VARIATION_URI || variation == InputType.TYPE_TEXT_VARIATION_FILTER) { prediction=false  } if ((attribute.inputType & InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE) != 0) { prediction=false  completion=getInputMethodService().isFullscreenMode()  } result=AKeyboardControllerStateImpl.newInstance(prediction,completion,qwertyKeyboard)  updateShiftKeyState(attribute)  break  default : updateShiftKeyState(attribute)  result=AKeyboardControllerStateImpl.newDefaultState(qwertyKeyboard)  } return result  } 
@Override public void onFinishInput(){   super.onFinishInput()    setCurrentKeyboard(qwertyKeyboard)  } 
@Override protected void handleModeChange(){   super.handleModeChange()    AndroidAKeyboard current=getCurrentKeyboard()    if (current == symbolsKeyboard || current == symbolsShiftedKeyboard) {     current=qwertyKeyboard    }  else {     current=symbolsKeyboard    }   setCurrentKeyboard(current)    if (current == symbolsKeyboard) {     current.setShifted(false)    } } 
@Nonnull @Override protected AKeyboardConfiguration onCreate0(@Nonnull Context context){   return new AKeyboardConfigurationImpl(context.getResources().getString(R.string.word_separators))  } 
@Nonnull @Override public AKeyboardViewWithSuggestions<AndroidAKeyboard> createKeyboardView0(@Nonnull Context context){   return new AKeyboardViewWithSuggestionsImpl<AndroidAKeyboard,KeyboardViewAKeyboardView>(R.layout.latin_keyboard,this,getInputMethodService())  } 
private void checkToggleCapsLock(){   long now=System.currentTimeMillis()    if (lastShiftTime + 800 > now) {     setState(getState().copyForNewCapsLock(!getState().isCapsLock()))      lastShiftTime=0    }  else {     lastShiftTime=now    } } 
@Nonnull @Override protected AKeyboardControllerState onInitializeInterface0(@Nonnull InputMethodService inputMethodService){ synchronized (this.keyboards) {     this.keyboards.clear()      final List<AKeyboard> keyboards=createKeyboard(inputMethodService)      for (    AKeyboard keyboard : keyboards) {       this.keyboards.put(keyboard.getKeyboardId(),keyboard)      }     return AKeyboardControllerStateImpl.newDefaultState(this.keyboards.get(getDefaultKeyboardId()))    } } 
@Nonnull protected abstract List<AKeyboard> createKeyboard(@Nonnull Context context)  
@Nonnull protected abstract String getDefaultKeyboardId()  
@Override public PreviewParams createFromParcel(@Nonnull Parcel in){   return fromParcel(in)  } 
@Override public PreviewParams[] newArray(int size){   return new PreviewParams[size]  } 
private PreviewParams(@Nonnull Parcel in){   this.x=in.readInt()    this.y=in.readInt()    this.text=in.readString()    this.drawableResId=in.readInt()  } 
private PreviewParams(int x,int y,@Nullable String text,@Nullable Integer drawableResId){   this.x=x    this.y=y    this.text=text    this.drawableResId=drawableResId  } 
@Nonnull public static PreviewParams newTextInstance(int x,int y,@Nonnull String text){   return fromCache(new PreviewParams(x,y,text,null))  } 
@Nonnull public static PreviewParams newDrawableInstance(int x,int y,@Nonnull Integer drawableResId){   return fromCache(new PreviewParams(x,y,null,drawableResId))  } 
@Nonnull private static PreviewParams fromParcel(@Nonnull Parcel in){   return fromCache(new PreviewParams(in))  } 
@Nonnull private static PreviewParams fromCache(@Nonnull PreviewParams previewParams){ synchronized (cache) {     final PreviewParams fromCache=cache.get(previewParams)      if (fromCache != null) { synchronized (fromCache) {         fromCache.x=previewParams.x          fromCache.y=previewParams.y        }       return fromCache      }  else {       cache.put(previewParams,previewParams)        return previewParams      }   } } 
public int getX(){ synchronized (this) {     return x    } } 
public int getY(){ synchronized (this) {     return y    } } 
@Nullable public String getText(){   return text  } 
@Nullable public Integer getDrawableResId(){   return drawableResId  } 
@Override public int describeContents(){   return 0  } 
@Override public void writeToParcel(@Nonnull Parcel out,int flags){   out.writeInt(x)    out.writeInt(y)    out.writeString(text)    out.writeInt(drawableResId == null ? 0 : drawableResId)  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof PreviewParams))   return false    PreviewParams previewParams=(PreviewParams)o    if (drawableResId != null ? !drawableResId.equals(previewParams.drawableResId) : previewParams.drawableResId != null)   return false    if (text != null ? !text.equals(previewParams.text) : previewParams.text != null)   return false    return true  } 
@Override public int hashCode(){   int result=text != null ? text.hashCode() : 0    result=31 * result + (drawableResId != null ? drawableResId.hashCode() : 0)    return result  } 
@Override public String toString(){   return "PreviewParams{" + "x=" + x + ", y="+ y+ ", text='"+ text+ '\''+ ", drawableResId="+ drawableResId+ '}'  } 
public synchronized void keyUp(@Nonnull View v){   if (this.repeatView == v) {     clean(null)    } } 
public synchronized void keyDown(@Nonnull View v,@Nullable final Runnable repeatRunnable){   clean(v)    if (repeatRunnable != null) {     this.repeatRunnable=new Runnable(){       @Override public void run(){         repeatRunnable.run()          if (repeatCounter < REPEAT_INTERVALS.length) {           repeatInterval=REPEAT_INTERVALS[repeatCounter]          }         repeatCounter++          uiHandler.postDelayed(this,repeatInterval)        }     }       this.uiHandler.postDelayed(this.repeatRunnable,1)    } } 
@Override public void run(){   repeatRunnable.run()    if (repeatCounter < REPEAT_INTERVALS.length) {     repeatInterval=REPEAT_INTERVALS[repeatCounter]    }   repeatCounter++    uiHandler.postDelayed(this,repeatInterval)  } 
private void clean(@Nullable View v){   this.repeatView=v    this.repeatCounter=0    if (this.repeatRunnable != null) {     this.uiHandler.removeCallbacks(this.repeatRunnable)      this.repeatRunnable=null    } } 
protected AbstractListItem(int textViewLayoutId,@Nonnull String tag){   this.textViewCreator=TextViewBuilder.newInstance(textViewLayoutId,tag)  } 
protected AbstractListItem(int textViewLayoutId){   this.textViewCreator=TextViewBuilder.newInstance(textViewLayoutId,null)  } 
@Override @Nonnull public TextView updateView(@Nonnull Context context,@Nonnull View view){   return fillView(context,textViewCreator.updateView(context,view))  } 
@Override @Nonnull public TextView build(@Nonnull Context context){   return fillView(context,textViewCreator.build(context))  } 
@Nonnull private TextView fillView(@Nonnull Context context,@Nonnull TextView textView){   textView.setText(getText(context))    return textView  } 
@Nullable protected abstract CharSequence getText(@Nonnull Context context)  
public AdapterFilter(@Nonnull Helper<T> helper){   this.helper=helper  } 
@Nonnull @Override protected FilterResults performFiltering(@Nullable CharSequence prefix){   final FilterResults results=new FilterResults()    final List<T> allElements    final List<T> filteredElements    if ((prefix == null || prefix.length() == 0) && !doFilterOnEmptyString()) {     filteredElements=getAllElements()      allElements=null    }  else {     final JPredicate<T> filter=getFilter(prefix)  synchronized (helper.getLock()) {       allElements=new ArrayList<T>(getAllElements())      }     filteredElements=new ArrayList<T>(allElements.size())      for (    T element : allElements) {       if (filter.apply(element)) {         filteredElements.add(element)        }     }   }   results.values=filteredElements    results.allElements=allElements    results.count=filteredElements.size()    return results  } 
@Nonnull private List<T> getAllElements(){   List<T> result=helper.getAllElements()    if (result == null) {     result=helper.getShownElements()    }   return result  } 
protected boolean doFilterOnEmptyString(){   return false  } 
protected abstract JPredicate<T> getFilter(@Nullable CharSequence prefix)  
@Override protected void publishResults(CharSequence constraint,Filter.FilterResults results){   boolean changed=false  synchronized (helper.getLock()) {     if (results.values != helper.getShownElements()) {       helper.setShownElements((List<T>)results.values)        changed=true      }     if (((FilterResults)results).allElements != helper.getAllElements()) {       helper.setAllElements((List<T>)((FilterResults)results).allElements)        changed=true      }   }   if (changed) {     helper.notifyDataSetChanged()    } } 
@Nonnull Object getLock()  
@Nonnull List<T> getShownElements()  
void setShownElements(@Nonnull List<T> shownElements)  
@Nullable List<T> getAllElements()  
void setAllElements(@Nullable List<T> allElements)  
void notifyDataSetChanged()  
private LabeledEnum(){ } 
@Nonnull public static <E>LabeledEnum<E> newInstance(@Nonnull E enumConstant,@Nonnull String label){   final LabeledEnum<E> result=new LabeledEnum<E>()    result.enumConstant=enumConstant    result.label=label    return result  } 
@Nonnull public static <E extends Enum & Labeled>LabeledEnum<E> newInstance(@Nonnull E enumConstant,@Nonnull Context context){   return LabeledEnum.newInstance(enumConstant,context.getString(enumConstant.getCaptionResId()))  } 
@Nonnull public static <E extends Enum & Labeled>List<LabeledEnum<E>> toLabeledEnums(@Nonnull Class<E> enumClass,@Nonnull Context context){   final E[] enumConstants=enumClass.getEnumConstants()    final List<LabeledEnum<E>> result=new ArrayList<LabeledEnum<E>>(enumConstants.length)    for (  E enumConstant : enumConstants) {     result.add(LabeledEnum.newInstance(enumConstant,context))    }   return result  } 
@Nonnull public E getEnumConstant(){   return enumConstant  } 
@Nonnull public String getLabel(){   return label  } 
@Override public String toString(){   return label  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof LabeledEnum))   return false    LabeledEnum that=(LabeledEnum)o    if (!enumConstant.equals(that.enumConstant))   return false    return true  } 
@Override public int hashCode(){   return enumConstant.hashCode()  } 
/**   * Constructor  * @param context            The current context.  * @param textViewResourceId The resource ID for a layout file containing a TextView to use wheninstantiating views.  */ public ListAdapter(@Nonnull Context context,int textViewResourceId){   this(context,textViewResourceId,0,new ArrayList<T>())  } 
/**   * Constructor  * @param context            The current context.  * @param resource           The resource ID for a layout file containing a layout to use wheninstantiating views.  * @param textViewResourceId The id of the TextView within the layout resource to be populated  */ public ListAdapter(Context context,int resource,int textViewResourceId){   this(context,resource,textViewResourceId,new ArrayList<T>())  } 
/**   * Constructor  * @param context            The current context.  * @param textViewResourceId The resource ID for a layout file containing a TextView to use wheninstantiating views.  * @param elements           The objects to represent in the ListView.  */ public ListAdapter(@Nonnull Context context,int textViewResourceId,@Nonnull T[] elements){   this(context,textViewResourceId,0,Arrays.asList(elements))  } 
/**   * Constructor  * @param context            The current context.  * @param resource           The resource ID for a layout file containing a layout to use wheninstantiating views.  * @param textViewResourceId The id of the TextView within the layout resource to be populated  * @param elements           The objects to represent in the ListView.  */ public ListAdapter(@Nonnull Context context,int resource,int textViewResourceId,@Nonnull T[] elements){   this(context,resource,textViewResourceId,Arrays.asList(elements))  } 
/**   * Constructor  * @param context            The current context.  * @param textViewResourceId The resource ID for a layout file containing a TextView to use wheninstantiating views.  * @param elements           The objects to represent in the ListView.  */ public ListAdapter(@Nonnull Context context,int textViewResourceId,@Nonnull List<T> elements){   this(context,textViewResourceId,0,elements)  } 
/**   * Constructor  * @param context            The current context.  * @param resource           The resource ID for a layout file containing a layout to use wheninstantiating views.  * @param textViewResourceId The id of the TextView within the layout resource to be populated  * @param elements           The objects to represent in the ListView.  */ public ListAdapter(@Nonnull Context context,int resource,int textViewResourceId,@Nonnull List<T> elements){   this.context=context    this.inflater=LayoutInflater.from(context)    this.resources=this.dropDownResource=resource    this.shownElements=elements    this.fieldId=textViewResourceId    this.adapterHelper=new AdapterHelper()  } 
/**   * Adds the specified object at the end of the array.  * @param object The object to add at the end of the array.  */ public void add(T object){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=allElements.add(object)      }  else {       changed=shownElements.add(object)      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
protected final void onDataSetChanged(boolean resortAndRefilter){   if (resortAndRefilter) { synchronized (lock) {       tryResortAndRefilter(true)      }   }   tryNotifyDataSetChanged(true)  } 
protected final void onDataSetChanged(){   onDataSetChanged(true)  } 
private void tryResortAndRefilter(boolean changed){   if (changed && resortAndRefilter) {     resort()      refilter()    } } 
private void resort(){ } 
private void tryNotifyDataSetChanged(boolean changed){ } 
/**   * Adds the specified Collection at the end of the array.  * @param collection The Collection to add at the end of the array.  */ public void addAll(Collection<? extends T> collection){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=allElements.addAll(collection)      }  else {       changed=shownElements.addAll(collection)      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
/**   * Adds the specified items at the end of the array.  * @param items The items to add at the end of the array.  */ public void addAll(T... items){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=Collections.addAll(allElements,items)      }  else {       changed=Collections.addAll(shownElements,items)      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
/**   * Inserts the specified object at the specified index in the array.  * @param object The object to insert into the array.  * @param index  The index at which the object must be inserted.  */ public void insert(T object,int index){ synchronized (lock) {     if (allElements != null) {       allElements.add(index,object)      }  else {       shownElements.add(index,object)      }     tryResortAndRefilter(true)    }   tryNotifyDataSetChanged(true)  } 
/**   * Removes the specified object from the array.  * @param object The object to remove.  */ public void remove(T object){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=allElements.remove(object)      }  else {       changed=shownElements.remove(object)      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
public void removeAt(int position){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=allElements.remove(position) != null      }  else {       changed=shownElements.remove(position) != null      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
/**   * Remove all elements from the list.  */ public void clear(){   boolean changed  synchronized (lock) {     if (allElements != null) {       changed=!allElements.isEmpty()        allElements.clear()      }  else {       changed=!shownElements.isEmpty()        shownElements.clear()      }     tryResortAndRefilter(changed)    }   tryNotifyDataSetChanged(changed)  } 
/**   * Sorts the content of this adapter using the specified comparator.  * @param comparator The comparator used to sort the objects containedin this adapter.  */ public void sort(Comparator<? super T> comparator){   sort(comparator,true)  } 
private void sort(Comparator<? super T> comparator,boolean notify){ synchronized (lock) {     Collections.sort(shownElements,comparator)      if (allElements != null) {       Collections.sort(allElements,comparator)      }   }   if (notify) {     tryNotifyDataSetChanged(true)    } } 
/**   * {@inheritDoc}  */ @Override public void notifyDataSetChanged(){   super.notifyDataSetChanged()    notifyOnChange=true  } 
/**   * Control whether methods that change the list ( {@link #add}, {@link #insert},  {@link #remove},  {@link #clear}) automatically call {@link #notifyDataSetChanged}.  If set to false, caller must manually call notifyDataSetChanged() to have the changes reflected in the attached view. <p/> The default is true, and calling notifyDataSetChanged() resets the flag to true.  * @param notifyOnChange if true, modifications to the list willautomatically call  {@link #notifyDataSetChanged}  */ public void setNotifyOnChange(boolean notifyOnChange){   this.notifyOnChange=notifyOnChange  } 
/**   * Returns the context associated with this array adapter. The context is used to create views from the resource passed to the constructor.  * @return The Context associated with this adapter.  */ @Nonnull public Context getContext(){   return context  } 
/**   * {@inheritDoc}  */ public int getCount(){ synchronized (lock) {     return shownElements.size()    } } 
/**   * {@inheritDoc}  */ public T getItem(int position){ synchronized (lock) {     return shownElements.get(position)    } } 
/**   * Returns the position of the specified item in the array.  * @param item The item to retrieve the position of.  * @return The position of the specified item.  */ public int getPosition(T item){ synchronized (lock) {     return shownElements.indexOf(item)    } } 
public boolean containsInShown(@Nonnull T element){ synchronized (lock) {     return this.shownElements.contains(element)    } } 
public boolean containsInAll(@Nonnull T element){   return getAllElements().contains(element)  } 
/**   * {@inheritDoc}  */ public long getItemId(int position){   return position  } 
/**   * {@inheritDoc}  */ public View getView(int position,View convertView,ViewGroup parent){   return createViewFromResource(position,convertView,parent,resources)  } 
public void doWork(@Nonnull Runnable runnable){   final boolean notifyOnChange  synchronized (lock) {     notifyOnChange=isNotifyOnChange()      try {       resortAndRefilter=false        setNotifyOnChange(false)        runnable.run()      }   finally {       setNotifyOnChange(notifyOnChange)        resortAndRefilter=true      }     tryResortAndRefilter(true)    }   if (notifyOnChange) {     notifyDataSetChanged()    } } 
private View createViewFromResource(int position,@Nullable View convertView,ViewGroup parent,int resource){   final View view    if (convertView != null) {     view=convertView    }  else {     view=inflater.inflate(resource,parent,false)    }   TextView text    try {     if (fieldId == 0) {       text=(TextView)view      }  else {       text=(TextView)view.findViewById(fieldId)      }   }  catch (  ClassCastException e) {     Log.e("ListAdapter","You must supply a resource ID for a TextView")      throw new IllegalStateException("ListAdapter requires the resource ID to be a TextView",e)    }   T item=getItem(position)    if (item instanceof CharSequence) {     text.setText((CharSequence)item)    }  else {     text.setText(item.toString())    }   return view  } 
/**   * <p>Sets the layout resource to create the drop down views.</p>  * @param resource the layout resource defining the drop down views  * @see #getDropDownView(int,android.view.View,android.view.ViewGroup)  */ public void setDropDownViewResource(int resource){   this.dropDownResource=resource  } 
/**   * {@inheritDoc}  */ @Override public View getDropDownView(int position,View convertView,ViewGroup parent){   return createViewFromResource(position,convertView,parent,dropDownResource)  } 
/**   * Creates a new ListAdapter from external resources. The content of the array is obtained through  {@link android.content.res.Resources#getTextArray(int)}.  * @param context        The application's environment.  * @param textArrayResId The identifier of the array to use as the data source.  * @param textViewResId  The identifier of the layout used to create views.  * @return An ListAdapter<CharSequence>.  */ public static ListAdapter<CharSequence> createFromResource(Context context,int textArrayResId,int textViewResId){   CharSequence[] strings=context.getResources().getTextArray(textArrayResId)    return new ListAdapter<CharSequence>(context,textViewResId,strings)  } 
/**   * {@inheritDoc}  */ public final Filter getFilter(){   if (filter == null) {     filter=createFilter()    }   return filter  } 
@Nonnull protected Filter createFilter(){   return new PrefixAdapterFilter<T>(adapterHelper)  } 
@Nonnull protected List<T> getShownElements(){ synchronized (lock) {     return unmodifiableList(shownElements)    } } 
@Nonnull protected List<T> getAllElements(){ synchronized (lock) {     return unmodifiableList(allElements == null ? shownElements : allElements)    } } 
@Nullable protected Comparator<? super T> getComparator(){   return null  } 
public void saveState(@Nonnull Bundle outState){   if (filterText != null) {     outState.putString(FILTER_TEXT,filterText.toString())    } } 
public void restoreState(@Nonnull Bundle savedInstanceState){   filterText=savedInstanceState.getString(FILTER_TEXT)  } 
@Nonnull protected AdapterHelper getAdapterHelper(){   return adapterHelper  } 
public boolean isNotifyOnChange(){   return notifyOnChange  } 
public void filter(@Nullable String filterText){   filter(filterText,null)  } 
private boolean isSameFilterText(@Nullable String filterText){   if (Objects.areEqual(this.filterText,filterText)) {     return true    }  else {     if (Strings.isEmpty(this.filterText) && Strings.isEmpty(filterText)) {       return true      }   }   return false  } 
public void filter(@Nullable String filterText,@Nullable Filter.FilterListener listener){   if (!isSameFilterText(filterText)) {     this.filterText=filterText      this.getFilter().filter(filterText,listener)    }  else {     if (listener != null) {       listener.onFilterComplete(getCount())      }   } } 
public void refilter(){   this.getFilter().filter(filterText)  } 
@Nullable public CharSequence getFilterText(){   return filterText  } 
@Nonnull @Override public Object getLock(){   return lock  } 
@Nonnull @Override public List<T> getShownElements(){   return shownElements  } 
@Override public void setShownElements(@Nonnull List<T> shownElements){   ListAdapter.this.shownElements=shownElements  } 
@Nullable @Override public List<T> getAllElements(){   return allElements  } 
@Override public void setAllElements(@Nullable List<T> allElements){   ListAdapter.this.allElements=allElements  } 
@Override public void notifyDataSetChanged(){   if (notifyOnChange) {     ListAdapter.this.notifyDataSetChanged()    } } 
private ListAdapterUtils(){   throw new AssertionError()  } 
@Nonnull public static <E extends Enum & Labeled>ListAdapter<LabeledEnum<E>> newDefaultAdapterForEnum(@Nonnull Context context,@Nonnull Class<E> enumClass){   final List<LabeledEnum<E>> labeledEnums=LabeledEnum.toLabeledEnums(enumClass,context)    return newDefaultAdapter(context,labeledEnums)  } 
@Nonnull public static <T>ListAdapter<T> newDefaultAdapter(@Nonnull Context context,@Nonnull List<T> items){   final ListAdapter<T> result=new ListAdapter<T>(context,android.R.layout.simple_spinner_item,items)    result.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)    return result  } 
@Nonnull @Override public Animation create(){   return new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,-1.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f)  } 
@Nonnull @Override public Animation create(){   return new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,1.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f)  } 
@Nonnull @Override public Animation create(){   return new TranslateAnimation(Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,0.0f,Animation.RELATIVE_TO_SELF,1.0f)  } 
@Nonnull public abstract Animation create()  
public ListAnimator(@Nonnull ListView listView,@Nonnull AnimationType animationType,@Nullable Runnable postAction){   this.listView=listView    this.animationType=animationType    this.postAction=postAction  } 
public void animate(){   final AnimationSet animationSet=new AnimationSet(false)    final AlphaAnimation alphaAnimation=new AlphaAnimation(1,0.25f)    alphaAnimation.setDuration(350)    animationSet.addAnimation(alphaAnimation)    final Animation moveAnimation=animationType.create()    moveAnimation.setDuration(500)    animationSet.addAnimation(moveAnimation)    animationSet.setRepeatCount(0)    if (postAction != null) {     animationSet.setAnimationListener(new Animation.AnimationListener(){       @Override public void onAnimationStart(      Animation animation){       }       @Override public void onAnimationEnd(      Animation animation){         postAction.run()        }       @Override public void onAnimationRepeat(      Animation animation){       }     } )    }   listView.startAnimation(animationSet)  } 
@Override public void onAnimationStart(Animation animation){ } 
@Override public void onAnimationEnd(Animation animation){   postAction.run()  } 
@Override public void onAnimationRepeat(Animation animation){ } 
@Nullable OnClickAction getOnClickAction()  
@Nullable OnClickAction getOnLongClickAction()  
void onClick(@Nonnull Context context,@Nonnull ListAdapter<? extends ListItem> adapter)  
protected ListItemAdapter(@Nonnull Context context,@Nonnull List<? extends LI> listItems){   super(context,0,0,castList(listItems))  } 
@SuppressWarnings("unchecked") @Nonnull private static <LI>List<LI> castList(List<? extends LI> listItems){   return (List<LI>)listItems  } 
@Nonnull public static <LI extends ListItem>ListItemAdapter<LI> createAndAttach(@Nonnull final ListActivity listActivity,@Nonnull List<? extends LI> listItems){   final ListItemAdapter<LI> result=newInstance(listActivity,listItems)    attach(listActivity,result)    return result  } 
public static <LI extends ListItem>void attach(@Nonnull ListActivity listActivity,@Nonnull ListItemAdapter<? extends LI> adapter){   listActivity.setListAdapter(adapter)    fillListView(listActivity.getListView(),adapter,listActivity)  } 
@Nonnull public static <LI extends ListItem>ListItemAdapter<LI> createAndAttach(@Nonnull final ListFragment listFragment,@Nonnull List<? extends LI> listItems){   final ListItemAdapter<LI> result=newInstance(listFragment.getActivity(),listItems)    attach(listFragment,result)    return result  } 
public static <LI extends ListItem>void attach(@Nonnull ListFragment listFragment,@Nonnull ListItemAdapter<? extends LI> adapter){   listFragment.setListAdapter(adapter)    fillListView(listFragment.getListView(),adapter,listFragment.getActivity())  } 
@Nonnull public static <LI extends ListItem>ListItemAdapter<LI> createAndAttach(@Nonnull final ListView listView,@Nonnull List<? extends LI> listItems,@Nonnull Context context){   final ListItemAdapter<LI> result=newInstance(context,listItems)    attach(listView,result,context)    return result  } 
public static <LI extends ListItem>void attach(@Nonnull ListView listView,@Nonnull ListItemAdapter<? extends LI> adapter,@Nonnull Context context){   listView.setAdapter(adapter)    fillListView(listView,adapter,context)  } 
@Nonnull public static <LI extends ListItem>ListItemAdapter<LI> createAndAttach(@Nonnull final android.app.ListFragment listFragment,@Nonnull List<? extends LI> listItems){   final ListItemAdapter<LI> result=newInstance(listFragment.getActivity(),listItems)    attach(listFragment,result)    return result  } 
public static <LI extends ListItem>void attach(@Nonnull android.app.ListFragment listFragment,@Nonnull ListItemAdapter<? extends LI> adapter){   listFragment.setListAdapter(adapter)    fillListView(listFragment.getListView(),adapter,listFragment.getActivity())  } 
private static <LI extends ListItem>void fillListView(@Nonnull final ListView lv,@Nonnull final ListItemAdapter<? extends LI> adapter,@Nonnull final Context context){   lv.setOnItemClickListener(new AdapterView.OnItemClickListener(){     @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){       final ListItem listItem=(ListItem)lv.getItemAtPosition(position)        ListItem.OnClickAction onClickAction=listItem.getOnClickAction()        if (onClickAction != null) {         onClickAction.onClick(context,adapter)        }     }   } )    lv.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){     @Override public boolean onItemLongClick(    AdapterView<?> parent,    View view,    int position,    long id){       final ListItem listItem=(ListItem)lv.getItemAtPosition(position)        ListItem.OnClickAction onLongClickAction=listItem.getOnLongClickAction()        if (onLongClickAction != null) {         onLongClickAction.onClick(context,adapter)          return true        }  else {         return false        }     }   } )  } 
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){   final ListItem listItem=(ListItem)lv.getItemAtPosition(position)    ListItem.OnClickAction onClickAction=listItem.getOnClickAction()    if (onClickAction != null) {     onClickAction.onClick(context,adapter)    } } 
@Override public boolean onItemLongClick(AdapterView<?> parent,View view,int position,long id){   final ListItem listItem=(ListItem)lv.getItemAtPosition(position)    ListItem.OnClickAction onLongClickAction=listItem.getOnLongClickAction()    if (onLongClickAction != null) {     onLongClickAction.onClick(context,adapter)      return true    }  else {     return false    } } 
@Nonnull public static <LI extends ListItem>ListItemAdapter<LI> newInstance(@Nonnull Context context,@Nonnull List<? extends LI> listItems){   return new ListItemAdapter<LI>(context,listItems)  } 
@Override public View getView(int position,View convertView,ViewGroup parent){   final ListItem listItem=getItem(position)    if (convertView == null) {     return listItem.build(getContext())    }  else {     return listItem.updateView(getContext(),convertView)    } } 
@Override public View getDropDownView(int position,View convertView,ViewGroup parent){   return getView(position,convertView,parent)  } 
@Nonnull T getDataObject()  
@Nonnull ListAdapter<? extends ListItem> getAdapter()  
public ListItemOnClickDataImpl(@Nonnull T dataObject,@Nonnull ListAdapter<? extends ListItem> adapter){   this.dataObject=dataObject    this.adapter=adapter  } 
@Nonnull @Override public T getDataObject(){   return this.dataObject  } 
@Nonnull @Override public ListAdapter<? extends ListItem> getAdapter(){   return this.adapter  } 
protected MenuOnClick(@Nonnull List<? extends LabeledMenuItem<ListItemOnClickData<T>>> menuItems,@Nonnull String menuName){   this.menuItems=menuItems    this.menuName=menuName  } 
@Override public void onClick(@Nonnull Context context,@Nonnull ListAdapter<? extends ListItem> adapter){   if (!menuItems.isEmpty()) {     ContextMenuBuilder.newInstance((FragmentActivity)context,menuName,ListContextMenu.newInstance(menuItems)).build(new ListItemOnClickDataImpl<T>(getData(),adapter)).show()    } } 
@Nonnull protected abstract T getData()  
@Override protected JPredicate<T> getFilter(@Nullable CharSequence prefix){   return new PrefixFilter<T>(prefix == null ? "" : prefix.toString().toLowerCase())  } 
public PrefixAdapterFilter(@Nonnull Helper<T> helper){   super(helper)  } 
public PrefixFilter(@Nonnull String prefix){   this.prefix=prefix  } 
@Override public boolean apply(@Nullable T input){   boolean shown=false    if (input != null) {     final String valueText=input.toString().toLowerCase()      if (valueText.startsWith(prefix)) {       shown=true      }  else {       final String[] words=valueText.split(" ")        for (      String word : words) {         if (word.startsWith(prefix)) {           shown=true            break          }       }     }   }   return shown  } 
@Override public boolean equals(@Nullable Object o){   if (o == this) {     return true    }   if (o instanceof PrefixFilter) {     final PrefixFilter that=(PrefixFilter)o      if (this.prefix.equals(that.prefix)) {       return true      }   }   return false  } 
@Override public int hashCode(){   return prefix.hashCode()  } 
public SimpleMenuOnClick(@Nonnull List<? extends LabeledMenuItem<ListItemOnClickData<T>>> labeledMenuItems,@Nonnull T data,@Nonnull String menuName){   super(labeledMenuItems,menuName)    this.data=data  } 
@Nonnull @Override protected T getData(){   return this.data  } 
protected AbstractLabeledMenuItem(int captionResId){   this.captionResId=captionResId  } 
@Nonnull @Override public String getCaption(@Nonnull Context context){   return context.getString(captionResId)  } 
boolean onCreateOptionsMenu(@Nonnull Activity activity,@Nonnull M menu)  
boolean onPrepareOptionsMenu(@Nonnull Activity activity,@Nonnull M menu)  
boolean onOptionsItemSelected(@Nonnull Activity activity,@Nonnull MI item)  
void onClick(@Nonnull T data,@Nonnull Context context)  
@Nonnull public static MenuHelper<Menu,MenuItem> getInstance(){   return instance  } 
private AndroidMenuHelper(){ } 
@Override public int size(@Nonnull Menu menu){   return menu.size()  } 
@Nonnull @Override public MenuItem add(@Nonnull Menu menu,int groupId,int itemId,int orderId,@Nonnull String caption){   return menu.add(groupId,itemId,orderId,caption)  } 
@Override public void setOnMenuItemClickListener(@Nonnull final MenuItem menuItem,@Nonnull final AMenuItem<MenuItem> onMenuItemClick,@Nonnull final Activity activity){   menuItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){     @Override public boolean onMenuItemClick(    MenuItem item){       onMenuItemClick.onClick(menuItem,activity)        return true      }   } )  } 
@Override public boolean onMenuItemClick(MenuItem item){   onMenuItemClick.onClick(menuItem,activity)    return true  } 
@Override public void removeItem(@Nonnull Menu menu,@Nonnull Integer menuItemId){   menu.removeItem(menuItemId)  } 
@Override public void inflateMenu(@Nonnull Activity activity,int layoutId,@Nonnull Menu menu){   activity.getMenuInflater().inflate(layoutId,menu)  } 
@Nonnull @Override public Integer getItemId(@Nonnull MenuItem item){   return item.getItemId()  } 
@Nullable MI itemAt(int i)  
@Nonnull CharSequence[] getMenuCaptions(@Nonnull final Context context)  
@Nonnull public static <T extends Enum & LabeledMenuItem<D>,D>ContextMenuBuilder<T,D> newInstance(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,@Nonnull Class<T> enumClass){   return new ContextMenuBuilder<T,D>(fragmentActivity,fragmentTag,EnumContextMenu.<T,D>newInstance(enumClass))  } 
@Nonnull public static <T extends LabeledMenuItem<D>,D>ContextMenuBuilder<T,D> newInstance(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,@Nonnull ContextMenu<T,D> menu){   return new ContextMenuBuilder<T,D>(fragmentActivity,fragmentTag,menu)  } 
private ContextMenuBuilder(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,@Nonnull ContextMenu<T,D> menu){   this.fragmentActivity=fragmentActivity    this.fragmentTag=fragmentTag    this.menuBuilder=new AlertDialog.Builder(fragmentActivity)    this.menu=menu  } 
@Nonnull public AlertDialog.Builder getMenuBuilder(){   return menuBuilder  } 
@Nonnull public DialogFragmentShower build(@Nonnull final D data){   menuBuilder.setItems(menu.getMenuCaptions(fragmentActivity),new DialogInterface.OnClickListener(){     public void onClick(    DialogInterface dialog,    int item){       final LabeledMenuItem<D> menuItem=menu.itemAt(item)        if (menuItem != null) {         menuItem.onClick(data,fragmentActivity)        }     }   } )    return new DialogFragmentShower(fragmentActivity,fragmentTag,menuBuilder)  } 
public void onClick(DialogInterface dialog,int item){   final LabeledMenuItem<D> menuItem=menu.itemAt(item)    if (menuItem != null) {     menuItem.onClick(data,fragmentActivity)    } } 
@Nonnull public static <T extends Enum & LabeledMenuItem<D>,D>ContextMenu<T,D> newInstance(@Nonnull Class<T> enumClass){   return new EnumContextMenu<T,D>(enumClass)  } 
private EnumContextMenu(Class<T> enumClass){   this.menu=ListContextMenu.newInstance(enumClass.getEnumConstants())  } 
@Override public T itemAt(int i){   return this.menu.itemAt(i)  } 
@Nonnull @Override public CharSequence[] getMenuCaptions(@Nonnull final Context context){   return this.menu.getMenuCaptions(context)  } 
@Nonnull Integer getItemId()  
@Nonnull String getCaption(@Nonnull Context context)  
private ListActivityMenu(@Nullable JPredicate<AMenuItem<MI>> filter,@Nonnull MenuHelper<M,MI> menuHelper){   this(NO_MENU_RES_ID,filter,menuHelper)  } 
private ListActivityMenu(int menuResId,@Nullable JPredicate<AMenuItem<MI>> filter,@Nonnull MenuHelper<M,MI> menuHelper){   this.menuResId=menuResId    this.filter=filter    this.menuHelper=menuHelper  } 
/**   * Creates simple menu from list of menu items. Note: you need to add method calls of  {@link ActivityMenu} in your Activity or Fragment  * @param menuItems  menu items  * @param menuHelper menu helper. See {@link AndroidMenuHelper}  * @param < M >        menu type  * @param < MI >       menu item type  * @return constructed menu  */ @Nonnull public static <M,MI>ActivityMenu<M,MI> fromList(@Nonnull List<? extends LabeledMenuItem<MI>> menuItems,@Nonnull MenuHelper<M,MI> menuHelper){   final ListActivityMenu<M,MI> result=new ListActivityMenu<M,MI>(null,menuHelper)    for (  LabeledMenuItem<MI> menuItem : menuItems) {     result.menuItems.add(new MenuItemWrapper<MI>(menuItem))    }   return result  } 
/**   * Creates simple menu from list of menu items which can be filtered before displaying on screen. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or FragmentNote 2: filter is applied only in  {@link ListActivityMenu#onPrepareOptionsMenu(android.app.Activity,M)} method.{@link ListActivityMenu#onCreateOptionsMenu(android.app.Activity,M)} does nothing in that case.Note 3: filter should be persistent, i.e. should always return same values for same objects (as filtering might be called at any point in time)  * @param menuItems  menu items  * @param menuHelper menu helper. See {@link AndroidMenuHelper}  * @param < M >        menu type  * @param < MI >       menu item type  * @return constructed menu  */ @Nonnull public static <M,MI>ActivityMenu<M,MI> fromList(@Nonnull List<? extends LabeledMenuItem<MI>> menuItems,@Nonnull MenuHelper<M,MI> menuHelper,@Nonnull JPredicate<AMenuItem<MI>> filter){   final ListActivityMenu<M,MI> result=new ListActivityMenu<M,MI>(filter,menuHelper)    for (  LabeledMenuItem<MI> menuItem : menuItems) {     result.menuItems.add(new MenuItemWrapper<MI>(menuItem))    }   return result  } 
/**   * Creates simple menu from enum class which can be filtered before displaying on screen. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or FragmentNote 2: filter is applied only in  {@link ListActivityMenu#onPrepareOptionsMenu(android.app.Activity,M)} method.{@link ListActivityMenu#onCreateOptionsMenu(android.app.Activity,M)} does nothing in that case.Note 3: filter should be persistent, i.e. should always return same values for same objects (as filtering might be called at any point in time)  * @param enumMenuClass enum class representing menu. Should implement {@link LabeledMenuItem} interface  * @param menuHelper    menu helper. See {@link AndroidMenuHelper}  * @param < M >           menu type  * @param < MI >          menu item type  * @return constructed menu  */ @Nonnull public static <M,MI,E extends Enum & LabeledMenuItem<MI>>ActivityMenu<M,MI> fromEnum(@Nonnull Class<E> enumMenuClass,@Nonnull MenuHelper<M,MI> menuHelper,@Nonnull JPredicate<AMenuItem<MI>> filter){   return fromList(toList(enumMenuClass),menuHelper,filter)  } 
/**   * Creates simple menu from enum class. Note: you need to add method calls of  {@link ActivityMenu} in your Activity or Fragment  * @param enumMenuClass enum class representing menu. Should implement {@link LabeledMenuItem} interface  * @param menuHelper    menu helper. See {@link AndroidMenuHelper}  * @param < M >           menu type  * @param < MI >          menu item type  * @return constructed menu  */ @Nonnull public static <M,MI,E extends Enum & LabeledMenuItem<MI>>ActivityMenu<M,MI> fromEnum(@Nonnull Class<E> enumMenuClass,@Nonnull MenuHelper<M,MI> menuHelper){   return fromList(toList(enumMenuClass),menuHelper)  } 
/**   * Creates simple menu from Android resource which can be filtered before displaying on screen. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or FragmentNote 2: filter is applied only in  {@link ListActivityMenu#onPrepareOptionsMenu(android.app.Activity,M)} method.{@link ListActivityMenu#onCreateOptionsMenu(android.app.Activity,M)} does nothing in that case.Note 3: filter should be persistent, i.e. should always return same values for same objects (as filtering might be called at any point in time)  * @param menuResId  id of android resource menu  * @param menuItems  menu items which are bound by identifiers to menu items from resource and handle clicks on them  * @param menuHelper menu helper. See {@link AndroidMenuHelper}  * @param filter     applied filter  * @param < M >        menu type  * @param < MI >       menu item type  * @return constructed menu  */ @Nonnull public static <M,MI>ActivityMenu<M,MI> fromResource(int menuResId,@Nonnull List<? extends IdentifiableMenuItem<MI>> menuItems,@Nonnull MenuHelper<M,MI> menuHelper,@Nonnull JPredicate<AMenuItem<MI>> filter){   final ListActivityMenu<M,MI> result=new ListActivityMenu<M,MI>(menuResId,filter,menuHelper)    for (  IdentifiableMenuItem<MI> menuItem : menuItems) {     result.menuItems.add(new MenuItemWrapper<MI>(menuItem))    }   return result  } 
/**   * Creates simple menu from Android resource. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or Fragment  * @param menuResId  id of android resource menu  * @param menuItems  menu items which are bound by identifiers to menu items from resource and handle clicks on them  * @param menuHelper menu helper. See {@link AndroidMenuHelper}  * @param < M >        menu type  * @param < MI >       menu item type  * @return constructed menu  */ @Nonnull public static <M,MI>ListActivityMenu<M,MI> fromResource(int menuResId,@Nonnull List<? extends IdentifiableMenuItem<MI>> menuItems,@Nonnull MenuHelper<M,MI> menuHelper){   final ListActivityMenu<M,MI> result=new ListActivityMenu<M,MI>(menuResId,null,menuHelper)    for (  IdentifiableMenuItem<MI> menuItem : menuItems) {     result.menuItems.add(new MenuItemWrapper<MI>(menuItem))    }   return result  } 
/**   * Creates simple menu from Android resource which can be filtered before displaying on screen. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or FragmentNote 2: filter is applied only in  {@link ListActivityMenu#onPrepareOptionsMenu(android.app.Activity,M)} method.{@link ListActivityMenu#onCreateOptionsMenu(android.app.Activity,M)} does nothing in that case.Note 3: filter should be persistent, i.e. should always return same values for same objects (as filtering might be called at any point in time)  * @param menuResId     id of android resource menu  * @param enumMenuClass enum class representing menu. Should implement {@link IdentifiableMenuItem} interface in order to handle clicks  * @param menuHelper    menu helper. See {@link AndroidMenuHelper}  * @param filter        applied filter  * @param < M >           menu type  * @param < MI >          menu item type  * @return constructed menu  */ @Nonnull public static <M,MI,E extends Enum & IdentifiableMenuItem<MI>>ActivityMenu<M,MI> fromResource(int menuResId,@Nonnull Class<? extends E> enumMenuClass,@Nonnull MenuHelper<M,MI> menuHelper,@Nonnull JPredicate<AMenuItem<MI>> filter){   return fromResource(menuResId,toList(enumMenuClass),menuHelper,filter)  } 
/**   * Creates simple menu from Android resource. <p/> Note: you need to add method calls of  {@link ActivityMenu} in your Activity or Fragment  * @param menuResId     id of android resource menu  * @param enumMenuClass enum class representing menu. Should implement {@link IdentifiableMenuItem} interface in order to handle clicks  * @param menuHelper    menu helper. See {@link AndroidMenuHelper}  * @param < M >           menu type  * @param < MI >          menu item type  * @return constructed menu  */ @Nonnull public static <M,MI,E extends Enum & IdentifiableMenuItem<MI>>ActivityMenu<M,MI> fromResource(int menuResId,@Nonnull Class<? extends E> enumMenuClass,@Nonnull MenuHelper<M,MI> menuHelper){   return fromResource(menuResId,toList(enumMenuClass),menuHelper)  } 
@Nonnull private static <E extends Enum>List<E> toList(@Nonnull Class<E> enumMenuClass){   final List<E> result=new ArrayList<E>()    Collections.addAll(result,enumMenuClass.getEnumConstants())    return result  } 
@Override public boolean onCreateOptionsMenu(@Nonnull final Activity activity,@Nonnull M menu){   if (filter == null) {     if (isFromMenuRes()) {       this.menuHelper.inflateMenu(activity,menuResId,menu)      }  else {       for (      final MenuItemWrapper<MI> menuItem : this.menuItems) {         addMenuItem(activity,menu,menuItem)        }     }   }   return true  } 
private boolean isFromMenuRes(){   return menuResId != NO_MENU_RES_ID  } 
private void addMenuItem(@Nonnull final Activity activity,@Nonnull final M menu,@Nonnull final MenuItemWrapper<MI> menuItemWrapper){   final int size=menuHelper.size(menu)    final int menuItemId=size + 1    final MI aMenuItem=menuHelper.add(menu,0,menuItemId,0,menuItemWrapper.getCaption(activity))    menuItemWrapper.setMenuItemId(menuItemId)    menuHelper.setOnMenuItemClickListener(aMenuItem,menuItemWrapper.getMenuItem(),activity)  } 
@Override public boolean onPrepareOptionsMenu(@Nonnull Activity activity,@Nonnull M menu){   if (filter != null) {     if (isFromMenuRes()) {       for (      MenuItemWrapper<MI> menuItemWrapper : menuItems) {         final Integer menuItemId=menuItemWrapper.getMenuItemId()          if (menuItemId != null) {           menuHelper.removeItem(menu,menuItemId)          }       }       this.menuHelper.inflateMenu(activity,menuResId,menu)        for (      MenuItemWrapper<MI> menuItemWrapper : menuItems) {         if (filter.apply(menuItemWrapper.getMenuItem())) {           menuHelper.removeItem(menu,menuItemWrapper.getMenuItemId())          }       }     }  else {       for (      MenuItemWrapper<MI> menuItemWrapper : menuItems) {         final Integer menuItemId=menuItemWrapper.getMenuItemId()          if (menuItemId != null) {           menuHelper.removeItem(menu,menuItemId)          }         if (!filter.apply(menuItemWrapper.getMenuItem())) {           addMenuItem(activity,menu,menuItemWrapper)          }       }     }   }   return true  } 
@Override public boolean onOptionsItemSelected(@Nonnull Activity activity,@Nonnull MI item){   if (isFromMenuRes()) {     for (    MenuItemWrapper<MI> menuItem : menuItems) {       if (menuHelper.getItemId(item).equals(menuItem.getMenuItemId())) {         menuItem.getMenuItem().onClick(item,activity)          return true        }     }   }   return false  } 
@Nullable public AMenuItem<MI> findMenuItemById(int menuItemId){   for (  MenuItemWrapper<MI> menuItem : menuItems) {     if (Integer.valueOf(menuItemId).equals(menuItem.getMenuItemId())) {       return menuItem.getMenuItem()      }   }   return null  } 
@Nonnull public static <T extends LabeledMenuItem<D>,D>ContextMenu<T,D> newInstance(T... menuItems){   return new ListContextMenu<T,D>(menuItems)  } 
@Nonnull public static <T extends LabeledMenuItem<D>,D>ContextMenu<T,D> newInstance(@Nonnull List<? extends T> menuItems){   return new ListContextMenu<T,D>(menuItems)  } 
private ListContextMenu(T... menuItems){   this(Collections.asList(menuItems))  } 
private ListContextMenu(@Nonnull List<? extends T> menuItems){   this.menuItems=new ArrayList<T>(menuItems)  } 
@Override @Nullable public T itemAt(int i){   if (i >= 0 && i < menuItems.size()) {     return menuItems.get(i)    }  else {     return null    } } 
@Override @Nonnull public CharSequence[] getMenuCaptions(@Nonnull final Context context){   final CharSequence[] result=new CharSequence[this.menuItems.size()]    for (int i=0  i < this.menuItems.size()  i++) {     result[i]=this.menuItems.get(i).getCaption(context)    }   return result  } 
int size(@Nonnull M menu)  
@Nonnull MI add(@Nonnull M menu,int groupId,int itemId,int orderId,@Nonnull String caption)  
public void setOnMenuItemClickListener(@Nonnull MI menuItem,@Nonnull AMenuItem<MI> onMenuItemClick,@Nonnull Activity activity)  
void removeItem(@Nonnull M menu,@Nonnull Integer menuItemId)  
void inflateMenu(@Nonnull Activity activity,int layoutId,@Nonnull M menu)  
@Nonnull Integer getItemId(@Nonnull MI item)  
MenuItemWrapper(@Nonnull LabeledMenuItem<MI> labeledMenuItem){   this.labeledMenuItem=labeledMenuItem    this.identifiableMenuItem=null  } 
MenuItemWrapper(@Nonnull IdentifiableMenuItem<MI> identifiableMenuItem){   this.identifiableMenuItem=identifiableMenuItem    this.labeledMenuItem=null  } 
@Nonnull public AMenuItem<MI> getMenuItem(){   return labeledMenuItem != null ? labeledMenuItem : identifiableMenuItem  } 
@Nullable public Integer getMenuItemId(){   return identifiableMenuItem == null ? menuItemId : identifiableMenuItem.getItemId()  } 
public void setMenuItemId(@Nullable Integer menuItemId){ } 
@Nonnull public String getCaption(@Nonnull Activity activity){ } 
@Nonnull NetworkState getState()  
/**   * An optional reason for the connectivity state change may have been supplied.  * @return the reason for the state change, if available, or {@code null}otherwise.  */ @Nullable String getReason()  
/**   * Returns true if the most recent event was for an attempt to switch over to a new network following loss of connectivity on another network.  * @return {@code true} if this was a failover attempt, {@code false} otherwise.  */ boolean isFailover()  
/**   * Network connectivity information  */ @Nullable NetworkInfo getNetworkInfo()  
/**   * In case of a Disconnect, the connectivity manager may have already established, or may be attempting to establish, connectivity with another network. If so,  {@code mOtherNetworkInfo} will be non-null.  */ @Nullable NetworkInfo getOtherNetworkInfo()  
private NetworkDataImpl(){ } 
@Nonnull static NetworkData newUnknownNetworkData(){   return new NetworkDataImpl()  } 
@Nonnull static NetworkData fromIntent(@Nonnull Intent intent){ } 
@Nonnull @Override public NetworkState getState(){   return this.state  } 
@Nullable @Override public String getReason(){   return this.reason  } 
@Override public boolean isFailover(){   return this.failover  } 
@Nullable @Override public NetworkInfo getNetworkInfo(){   return this.networkInfo  } 
@Nullable @Override public NetworkInfo getOtherNetworkInfo(){   return this.otherNetworkInfo  } 
@Override public String toString(){   return "NetworkDataImpl{" + "state=" + state + ", reason='"+ reason+ '\''+ ", failover="+ failover+ ", networkInfo="+ networkInfo+ ", otherNetworkInfo="+ otherNetworkInfo+ '}'  } 
void onNetworkEvent(@Nonnull NetworkData networkData)  
/**   * This method starts listening for network connectivity state changes.  * @param context context  */ void startListening(@Nonnull Context context)  
/**   * This method stops this class from listening for network changes.  */ void stopListening()  
boolean addListener(@Nonnull NetworkStateListener listener)  
boolean removeListener(@Nonnull NetworkStateListener listener)  
@Nonnull NetworkData getNetworkData()  
@Override public void onReceive(@Nonnull Context context,@Nonnull Intent intent){   final String action=intent.getAction()    if (!action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {     return    }   final NetworkData localNetworkData=NetworkDataImpl.fromIntent(intent)    networkData=localNetworkData    if (DEBUG) {     Log.d(TAG,"onReceive(): " + localNetworkData)    }   for (  NetworkStateListener localListener : listeners.getListeners()) {     localListener.onNetworkEvent(localNetworkData)    } } 
public NetworkStateServiceImpl(){   networkData=NetworkDataImpl.newUnknownNetworkData()    receiver=new ConnectivityBroadcastReceiver()  } 
@Override public synchronized void startListening(@Nonnull Context context){   this.context=context.getApplicationContext()    final IntentFilter filter=new IntentFilter()    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION)    context.registerReceiver(receiver,filter)  } 
@Override public boolean addListener(@Nonnull NetworkStateListener listener){   return listeners.addListener(listener)  } 
@Override public boolean removeListener(@Nonnull NetworkStateListener listener){   return listeners.removeListener(listener)  } 
@Override public synchronized void stopListening(){   if (context != null) {     context.unregisterReceiver(receiver)    }   context=null    networkData=NetworkDataImpl.newUnknownNetworkData()  } 
@Override @Nonnull public NetworkData getNetworkData(){   return networkData  } 
public AndroidMessage(@Nonnull Integer messageCodeId,@Nonnull MessageType messageType,@Nonnull Application application,@javax.annotation.Nullable Object... arguments){   super(String.valueOf(messageCodeId),messageType,arguments)    this.messageCodeId=messageCodeId    this.application=application    this.javaFormat=false  } 
public AndroidMessage(@Nonnull Integer messageCodeId,@Nonnull MessageType messageType,@Nonnull Application application,@Nonnull List<?> arguments){   this(messageCodeId,messageType,application,arguments,false)  } 
public AndroidMessage(@Nonnull Integer messageCodeId,@Nonnull MessageType messageType,@Nonnull Application application,@Nonnull List<?> arguments,boolean javaFormat){   super(String.valueOf(messageCodeId),messageType,arguments)    this.messageCodeId=messageCodeId    this.application=application    this.javaFormat=javaFormat  } 
@Nonnull @Override public String getLocalizedMessage(@Nonnull Locale locale){   if (javaFormat) {     return super.getLocalizedMessage(locale)    }  else {     final List<Object> parameters=getParameters()      final Object[] parametersArray=parameters.toArray(new Object[parameters.size()])      return application.getResources().getString(messageCodeId,(Object[])parametersArray)    } } 
@Override protected String getMessagePattern(@Nonnull Locale locale){   return application.getResources().getString(messageCodeId)  } 
public AbstractDialogPreference(Context context,AttributeSet attrs,@Nullable String defaultStringValue,boolean needValueText,@Nonnull Mapper<T> mapper){   super(context,attrs)    this.context=context    this.defaultStringValue=defaultStringValue    this.needValueText=needValueText    this.mapper=mapper    final String defaultValueFromAttrs=attrs.getAttributeValue(androidns,"defaultValue")    if (defaultValueFromAttrs != null) {     defaultValue=getMapper().parseValue(defaultValueFromAttrs)    }  else   if (defaultStringValue != null) {     defaultValue=getMapper().parseValue(defaultStringValue)    }  else {     throw new IllegalArgumentException()    }   description=attrs.getAttributeValue(androidns,"dialogMessage")    valueText=attrs.getAttributeValue(androidns,"text")  } 
@Nullable protected View getPreferenceView(){   return preferenceView  } 
@Nullable public T getValue(){   return value  } 
public void setValue(@Nullable T value){   this.value=value  } 
@Override @Nonnull protected final LinearLayout onCreateDialogView(){   if (shouldPersist()) {     value=getPersistedValue()    }   final LinearLayout result=new LinearLayout(context)    result.setOrientation(LinearLayout.VERTICAL)    result.setPadding(6,6,6,6)    if (description != null) {     final TextView splashText=new TextView(context)      splashText.setText(description)      result.addView(splashText)    }   if (needValueText) {     valueTextView=new TextView(context)      valueTextView.setGravity(Gravity.CENTER_HORIZONTAL)      valueTextView.setTextSize(32)      final LinearLayout.LayoutParams params=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT)      result.addView(valueTextView,params)    }   preferenceView=createPreferenceView(context)    initPreferenceView(preferenceView,value)    final LinearLayout.LayoutParams params=getParams()    if (params != null) {     result.addView(preferenceView,params)    }  else {     result.addView(preferenceView)    }   return result  } 
@Nullable protected abstract LinearLayout.LayoutParams getParams()  
@Override protected void onSetInitialValue(boolean restore,Object defaultValue){   super.onSetInitialValue(restore,defaultValue)    if (restore) {     if (shouldPersist()) {       value=getPersistedValue()      }  else {       value=this.defaultValue      }   }  else {     value=(T)defaultValue      if (shouldPersist()) {       persist(this.value)      }   } } 
@Override protected void onBindDialogView(View v){   super.onBindDialogView(v)    if (this.preferenceView != null) {     initPreferenceView(this.preferenceView,value)    } } 
/**   * Creates view which is responsible for changing preference value (for example, Spinner or EditText)  * @param context context  * @return view which changes the preference value  */ @Nonnull protected abstract View createPreferenceView(@Nonnull Context context)  
/**   * @param v     view to be filled with initial data (the one which has been created with {@link #createPreferenceView} method)  * @param value current preference value  */ protected abstract void initPreferenceView(@Nonnull View v,@Nullable T value)  
@Nullable private T getPersistedValue(){   String persistedString=getPersistedString(defaultStringValue)    if (Objects.areEqual(persistedString,defaultStringValue)) {     return defaultValue    }  else {     return getMapper().parseValue(persistedString)    } } 
protected void persistValue(@Nullable T value){   Log.d(TAG,"Trying to persist value: " + value)    this.value=value    Log.d(TAG,"android.preference.Preference.callChangeListener()")    if (callChangeListener(value)) {     Log.d(TAG,"android.preference.Preference.shouldPersist()")      if (shouldPersist()) {       Log.d(TAG,"AbstractDialogPreference.persist()")        persist(value)      }   } } 
private void persist(@Nullable T value){   if (value != null) {     final String toBePersistedString=getMapper().formatValue(value)      if (toBePersistedString != null) {       if (callChangeListener(toBePersistedString)) {         persistString(toBePersistedString)        }     }   } } 
@Nullable public String getValueText(){   return valueText  } 
protected void updateValueText(@Nonnull String text){   if (valueTextView != null) {     valueTextView.setText(text)    } } 
@Nonnull private Mapper<T> getMapper(){   return this.mapper  } 
protected AbstractPreference(@Nonnull String key,@Nullable T defaultValue){   this.key=key    this.defaultValue=defaultValue  } 
@Nonnull public String getKey(){   return key  } 
public T getDefaultValue(){   return defaultValue  } 
@Override public final T getPreference(@Nonnull SharedPreferences preferences){   if (isSet(preferences)) {     return getPersistedValue(preferences)    }  else {     return this.defaultValue    } } 
@Override public T getPreferenceNoError(@Nonnull SharedPreferences preferences){   if (isSet(preferences)) {     try {       return getPersistedValue(preferences)      }  catch (    RuntimeException e) {       return this.defaultValue      }   }  else {     return this.defaultValue    } } 
@Override public void putDefault(@Nonnull SharedPreferences preferences){   putPreference(preferences,this.defaultValue)  } 
@Override public void putPreference(@Nonnull SharedPreferences preferences,@Nullable T value){   if (value != null) {     final SharedPreferences.Editor editor=preferences.edit()      putPersistedValue(editor,value)      editor.commit()    } } 
@Override public boolean isSet(@Nonnull SharedPreferences preferences){   return preferences.contains(this.key)  } 
@Override public final boolean tryPutDefault(@Nonnull SharedPreferences preferences){   final boolean result    if (isSet(preferences)) {     result=false    }  else {     putDefault(preferences)      result=true    }   return result  } 
@Override public final boolean isSameKey(@Nonnull String key){   return this.key.equals(key)  } 
/**   * @param preferences preferences container  * @return preference value from preferences with key defined by {@link #getKey()} method  */ @Nullable protected abstract T getPersistedValue(@Nonnull SharedPreferences preferences)  
/**   * Method saved preference to preferences container editor  * @param editor editor in which value must be saved  * @param value  value to be saved  */ protected abstract void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull T value)  
private BooleanPreference(@Nonnull String key,@Nullable Boolean defaultValue){   super(key,defaultValue)  } 
@Nonnull public static BooleanPreference of(@Nonnull String key,@Nullable Boolean defaultValue){   return new BooleanPreference(key,defaultValue)  } 
@Override protected Boolean getPersistedValue(@Nonnull SharedPreferences preferences){   return preferences.getBoolean(getKey(),false)  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull Boolean value){   editor.putBoolean(getKey(),value)  } 
protected CollectionSetPreference(@Nonnull String id,@Nonnull C defaultValue,@Nonnull Mapper<T> mapper){   super(id,defaultValue)    this.mapper=mapper  } 
@Override protected C getPersistedValue(@Nonnull SharedPreferences preferences){   final Set<String> stringValues=preferences.getStringSet(getKey(),null)    final C result=createCollection(stringValues.size())    for (  String stringValue : stringValues) {     result.add(mapper.parseValue(stringValue))    }   return result  } 
@Nonnull protected abstract C createCollection(int size)  
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull C values){   final Set<String> result=new HashSet<String>(values.size())    for (  T value : values) {     result.add(mapper.formatValue(value))    }   editor.putStringSet(getKey(),result)  } 
private CollectionToStringPreference(@Nonnull String key,@Nullable C defaultValue,@Nonnull Mapper<C> mapper){   super(key,defaultValue)    this.mapper=mapper  } 
@Nonnull public static <T>CollectionToStringPreference<List<T>,T> forList(@Nonnull String key,@Nullable List<T> defaultValue,@Nonnull Mapper<List<T>> mapper){   return new CollectionToStringPreference<List<T>,T>(key,defaultValue,mapper)  } 
@Nonnull public static <T>CollectionToStringPreference<List<T>,T> forTypedList(@Nonnull String key,@Nullable List<T> defaultValue,@Nonnull Mapper<T> mapper){   return new CollectionToStringPreference<List<T>,T>(key,defaultValue,ListMapper.newInstance(mapper))  } 
@Nonnull public static CollectionToStringPreference<List<String>,String> forStringList(@Nonnull String key,@Nullable List<String> defaultValue){   return new CollectionToStringPreference<List<String>,String>(key,defaultValue,ListMapper.newInstance(StringMapper.getInstance()))  } 
@Override protected C getPersistedValue(@Nonnull SharedPreferences preferences){   return mapper.parseValue(preferences.getString(getKey(),null))  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull C values){   editor.putString(getKey(),mapper.formatValue(values))  } 
private FloatPreference(@Nonnull String key,@Nullable Float defaultValue){   super(key,defaultValue)  } 
@Nonnull public static FloatPreference of(@Nonnull String key,@Nullable Float defaultValue){   return new FloatPreference(key,defaultValue)  } 
@Override protected Float getPersistedValue(@Nonnull SharedPreferences preferences){   return preferences.getFloat(getKey(),-1f)  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull Float value){   editor.putFloat(getKey(),value)  } 
private HashSetPreference(@Nonnull String id,@Nonnull Set<T> defaultValue,@Nonnull Mapper<T> mapper){   super(id,defaultValue,mapper)  } 
@Nonnull public static HashSetPreference<String> ofStrings(@Nonnull String key,@Nonnull Set<String> defaultValue){   return new HashSetPreference<String>(key,defaultValue,StringMapper.getInstance())  } 
@Nonnull public static <T>HashSetPreference<T> ofTypedValues(@Nonnull String key,@Nonnull Set<T> defaultValue,@Nonnull Mapper<T> parser){   return new HashSetPreference<T>(key,defaultValue,parser)  } 
@Nonnull public static <T extends Enum>HashSetPreference<T> ofEnums(@Nonnull String id,@Nonnull Set<T> defaultValue,@Nonnull Class<T> enumType){   return new HashSetPreference<T>(id,defaultValue,EnumMapper.of(enumType))  } 
@Nonnull @Override protected Set<T> createCollection(int size){   return new HashSet<T>(size)  } 
private IntegerPreference(@Nonnull String key,@Nullable Integer defaultValue){   super(key,defaultValue)  } 
@Nonnull public static IntegerPreference of(@Nonnull String key,@Nullable Integer defaultValue){   return new IntegerPreference(key,defaultValue)  } 
@Override protected Integer getPersistedValue(@Nonnull SharedPreferences preferences){   return preferences.getInt(getKey(),-1)  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull Integer value){   editor.putInt(getKey(),value)  } 
private LocalePreference(@Nonnull String id,@Nullable Locale defaultValue,@Nonnull Mapper<Locale> localeMapper){   this.stringPreference=new StringPreference<Locale>(id,defaultValue,localeMapper)  } 
private LocalePreference(@Nonnull String id,@Nullable Locale defaultValue){   this.stringPreference=new StringPreference<Locale>(id,defaultValue,DefaultLocaleMapper.getInstance())  } 
@Nonnull public static LocalePreference of(@Nonnull String id,@Nullable Locale defaultValue,@Nonnull Mapper<Locale> localeMapper){   return new LocalePreference(id,defaultValue,localeMapper)  } 
@Nonnull public static LocalePreference of(@Nonnull String id,@Nullable Locale defaultValue){   return new LocalePreference(id,defaultValue)  } 
@Override @Nonnull public String getKey(){   return stringPreference.getKey()  } 
@Override public Locale getDefaultValue(){   return stringPreference.getDefaultValue()  } 
@Override public Locale getPreference(@Nonnull SharedPreferences preferences){   return stringPreference.getPreference(preferences)  } 
@Override public Locale getPreferenceNoError(@Nonnull SharedPreferences preferences){   return stringPreference.getPreferenceNoError(preferences)  } 
@Override public void putDefault(@Nonnull SharedPreferences preferences){   stringPreference.putDefault(preferences)  } 
@Override public void putPreference(@Nonnull SharedPreferences preferences,@Nullable Locale value){   stringPreference.putPreference(preferences,value)  } 
@Override public boolean isSet(@Nonnull SharedPreferences preferences){   return stringPreference.isSet(preferences)  } 
@Override public boolean tryPutDefault(@Nonnull SharedPreferences preferences){   return stringPreference.tryPutDefault(preferences)  } 
@Override public boolean isSameKey(@Nonnull String key){   return stringPreference.isSameKey(key)  } 
private DefaultLocaleMapper(){ } 
@Nonnull public static Mapper<Locale> getInstance(){   return instance  } 
@Override public String formatValue(@Nullable Locale locale) throws IllegalArgumentException { } 
@Override public Locale parseValue(@Nullable String s) throws IllegalArgumentException {   final StringTokenizer st=new StringTokenizer(s,delimiter,false)    final String language=st.nextToken()    final String country    if (st.hasMoreTokens()) {     country=st.nextToken()    }  else {     country=""    }   final String variant    if (st.hasMoreTokens()) {     variant=st.nextToken()    }  else {     variant=""    }   return new Locale(language,country,variant)  } 
private LongPreference(@Nonnull String key,@Nullable Long defaultValue){   super(key,defaultValue)  } 
@Nonnull public static LongPreference of(@Nonnull String key,@Nullable Long defaultValue){   return new LongPreference(key,defaultValue)  } 
@Override protected Long getPersistedValue(@Nonnull SharedPreferences preferences){   return preferences.getLong(getKey(),-1)  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull Long value){   editor.putLong(getKey(),value)  } 
private NumberIntervalPreference(@Nonnull String key,@Nullable Interval<N> defaultValue,@Nonnull Class<N> clazz){   super(key,defaultValue)    this.mapper=NumberIntervalMapper.of(clazz)  } 
@Nonnull public static <N extends Number & Comparable<N>>NumberIntervalPreference<N> of(@Nonnull String key,@Nullable Interval<N> defaultValue,@Nonnull Class<N> clazz){   return new NumberIntervalPreference<N>(key,defaultValue,clazz)  } 
@Override protected Interval<N> getPersistedValue(@Nonnull SharedPreferences preferences){   final String result=preferences.getString(getKey(),null)    if (result == null) {     return null    }  else {     return mapper.parseValue(result)    } } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull Interval<N> value){   editor.putString(getKey(),mapper.formatValue(value))  } 
private NumberToStringPreference(@Nonnull String key,@Nullable N defaultValue,@Nonnull Class<N> clazz){   super(key,defaultValue)    this.mapper=NumberMapper.of(clazz)  } 
@Nonnull public static <N extends Number>NumberToStringPreference<N> of(@Nonnull String key,@Nullable N defaultValue,@Nonnull Class<N> clazz){   return new NumberToStringPreference<N>(key,defaultValue,clazz)  } 
@Override protected N getPersistedValue(@Nonnull SharedPreferences preferences){   return mapper.parseValue(preferences.getString(getKey(),"0"))  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull N value){   editor.putString(getKey(),mapper.formatValue(value))  } 
/**   * Method returns key of preference used in android: the key with which current preference is saved in persistence  * @return android preference key  */ @Nonnull String getKey()  
/**   * @return default preference value, may be null  */ T getDefaultValue()  
/**   * NOTE: this method can throw runtime exceptions if errors occurred while extracting preferences values  * @param preferences application preferences  * @return value from preference, default value if no value in preference was found  */ T getPreference(@Nonnull SharedPreferences preferences)  
/**   * NOTE: this method SHOULD not throw any runtime exceptions BUT return default value if any error occurred  * @param preferences application preferences  * @return value from preference, default value if no value in preference was found or error occurred  */ T getPreferenceNoError(@Nonnull SharedPreferences preferences)  
/**   * Method puts (saves) preference represented by <code>value</code> in <code>preferences</code> container  * @param preferences preferences container  * @param value       value to be saved  */ void putPreference(@Nonnull SharedPreferences preferences,@Nullable T value)  
/**   * Method saves default value in <code>preferences</code> container. Should behave exactly as <code>p.putPreference(preferences, p.getDefaultValue())</code>  * @param preferences preferences container  */ void putDefault(@Nonnull SharedPreferences preferences)  
/**   * @param preferences preferences container  * @return true if any value is saved in preferences container, false - otherwise  */ boolean isSet(@Nonnull SharedPreferences preferences)  
/**   * Method applies default value to preference only if explicit value is not set  * @param preferences preferences container  * @return true if default values have been applied, false otherwise  */ boolean tryPutDefault(@Nonnull SharedPreferences preferences)  
/**   * @param key preference key  * @return true if current preferences has the same key  */ boolean isSameKey(@Nonnull String key)  
public SeekBarPreference(Context context,AttributeSet attrs){   super(context,attrs,"50",true,NumberMapper.of(Integer.class))    max=attrs.getAttributeIntValue(androidns,"max",100)  } 
@Override protected LinearLayout.LayoutParams getParams(){   return new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,LinearLayout.LayoutParams.WRAP_CONTENT)  } 
@Nonnull @Override protected View createPreferenceView(@Nonnull Context context){   final SeekBar result=new SeekBar(context)    result.setOnSeekBarChangeListener(this)    return result  } 
@Override protected void initPreferenceView(@Nonnull View v,Integer value){   ((SeekBar)v).setMax(max)    if (value != null) {     ((SeekBar)v).setProgress(value)      setValueText(value)    } } 
public void onProgressChanged(SeekBar seek,int value,boolean fromTouch){   setValueText(value)    persistValue(value)  } 
private void setValueText(int value){   String t=String.valueOf(value)    final String valueText=getValueText()    updateValueText(valueText == null ? t : t.concat(valueText))  } 
public void onStartTrackingTouch(SeekBar seek){ } 
public void onStopTrackingTouch(SeekBar seek){ } 
public void setMax(int max){   this.max=max  } 
public int getMax(){   return max  } 
public void setProgress(int progress){   setValue(progress)    final View preferenceView=getPreferenceView()    if (preferenceView != null) {     ((SeekBar)preferenceView).setProgress(progress)    } } 
public int getProgress(){   final Integer value=getValue()    return value == null ? 0 : value  } 
public StringPreference(@Nonnull String key,@Nullable T defaultValue,@Nonnull Mapper<T> mapper){   super(key,defaultValue)    this.mapper=mapper  } 
@Nonnull public static StringPreference<String> of(@Nonnull String key,@Nullable String defaultValue){   return new StringPreference<String>(key,defaultValue,StringMapper.getInstance())  } 
@Nonnull public static <T>StringPreference<T> ofTypedValue(@Nonnull String key,@Nullable String defaultValue,@Nonnull Mapper<T> mapper){   return new StringPreference<T>(key,mapper.parseValue(defaultValue),mapper)  } 
@Nonnull public static <T extends Enum>StringPreference<T> ofEnum(@Nonnull String key,@Nullable T defaultValue,@Nonnull Class<T> enumType){   return new StringPreference<T>(key,defaultValue,EnumMapper.of(enumType))  } 
@Override protected T getPersistedValue(@Nonnull SharedPreferences preferences){   return mapper.parseValue(preferences.getString(getKey(),null))  } 
@Override protected void putPersistedValue(@Nonnull SharedPreferences.Editor editor,@Nonnull T value){   editor.putString(getKey(),mapper.formatValue(value))  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    adapter=new Adapter(this,generateItems(100))    ListItemAdapter.attach(this,adapter)  } 
@Override protected void onSaveInstanceState(Bundle outState){   super.onSaveInstanceState(outState)    adapter.saveState(outState)  } 
@Override protected void onRestoreInstanceState(Bundle state){   adapter.restoreState(state)    super.onRestoreInstanceState(state)  } 
void addItems(int size){   adapter.addAll(generateItems(size))  } 
void addItemsViaRunnable(final int size){   adapter.doWork(new Runnable(){     @Override public void run(){       for (      TestListItem listItem : generateItems(size)) {         adapter.add(listItem)        }     }   } )  } 
@Override public void run(){   for (  TestListItem listItem : generateItems(size)) {     adapter.add(listItem)    } } 
@Nonnull private List<TestListItem> generateItems(int size){   final List<TestListItem> result=new ArrayList<TestListItem>()    for (int i=0  i < size  i++) {     result.add(new TestListItem())    }   return result  } 
public void removeItems(int size){   final Random random=new Random(new Date().getTime())    int i=size    while (i > 0) {     final int position=random.nextInt(adapter.getCount())      adapter.removeAt(position)      i--    } } 
public TestListItem(){ } 
@Nullable @Override public OnClickAction getOnClickAction(){   return null  } 
@Nullable @Override public OnClickAction getOnLongClickAction(){   return null  } 
@Nonnull @Override public View updateView(@Nonnull Context context,@Nonnull View view){   return build(context)  } 
@Override public String toString(){   return String.valueOf(index)  } 
@Nonnull @Override public View build(@Nonnull Context context){   return new View(context)  } 
public ListItemAdapter<TestListItem> getAdapter(){   return adapter  } 
protected Adapter(@Nonnull Context context,@Nonnull List<? extends TestListItem> listItems){   super(context,listItems)  } 
@Nullable @Override protected Comparator<? super TestListItem> getComparator(){   return new Comparator<TestListItem>(){     @Override public int compare(    TestListItem lhs,    TestListItem rhs){       return lhs.toString().compareTo(rhs.toString())      }   }   } 
@Override public int compare(TestListItem lhs,TestListItem rhs){   return lhs.toString().compareTo(rhs.toString())  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_ads_layout)    final ViewGroup views=(ViewGroup)findViewById(R.id.acl_ads_linearlayout)    AdsController.getInstance().inflateAd(this,views,R.id.acl_ads_advertisement_framelayout)    BillingController.registerObserver(billingObserver)    final View removeAdsButton=views.findViewById(R.id.acl_ads_remove_advertisement_button)    if (AdsController.getInstance().isAdFree(this)) {     removeAdsButton.setEnabled(false)    }   removeAdsButton.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View view){       BillingController.requestPurchase(SamplesAdsActivity.this,ADS_FREE_PRODUCT)      }   } )  } 
@Override public void onClick(View view){   BillingController.requestPurchase(SamplesAdsActivity.this,ADS_FREE_PRODUCT)  } 
@Override protected void onDestroy(){   BillingController.unregisterObserver(billingObserver)    super.onDestroy()  } 
@Override public void onCheckBillingSupportedResponse(boolean supported){ } 
@Override public void onPurchaseIntentOK(@Nonnull String productId,@Nonnull PendingIntent purchaseIntent){ } 
@Override public void onPurchaseIntentFailure(@Nonnull String productId,@Nonnull ResponseCode responseCode){ } 
@Override public void onPurchaseStateChanged(@Nonnull String productId,@Nonnull Transaction.PurchaseState state){   if (ADS_FREE_PRODUCT.equals(productId)) { switch (state) { case PURCHASED: case CANCELLED: case REFUNDED:       Activities.restartActivity(SamplesAdsActivity.this)      break  } } } 
@Override public void onRequestPurchaseResponse(@Nonnull String productId,@Nonnull ResponseCode response){ } 
@Override public void onTransactionsRestored(){ } 
@Override public void onErrorRestoreTransactions(@Nonnull ResponseCode responseCode){ } 
@Nonnull String getName()  
@Nonnull List<DbItem> loadAll()  
void insert(@Nonnull DbItem dbItem)  
void removeByName(@Nonnull String name)  
public DbItemImpl(@Nonnull String name){   this.name=name  } 
@Nonnull @Override public String getName(){   return this.name  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof DbItemImpl))   return false    DbItemImpl dbItem=(DbItemImpl)o    if (!name.equals(dbItem.name))   return false    return true  } 
@Override public int hashCode(){   return name.hashCode()  } 
public DbItemListItem(@Nonnull DbItem dbItem){   this.dbItem=dbItem  } 
@Override public OnClickAction getOnClickAction(){   return null  } 
@Override public OnClickAction getOnLongClickAction(){   return null  } 
@Nonnull @Override public View updateView(@Nonnull Context context,@Nonnull View view){   if (this.getTag().equals(view.getTag())) {     fillView(context,(TextView)view)      return view    }  else {     return build(context)    } } 
@Nonnull @Override public View build(@Nonnull Context context){   final TextView view=TextViewBuilder.newInstance(R.layout.acl_db_list_item,getTag()).build(context)    fillView(context,view)    return view  } 
@Nonnull private String getTag(){   return "db_list_item"  } 
private void fillView(@Nonnull Context context,@Nonnull TextView view){   view.setText(dbItem.getName())  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (!(o instanceof DbItemListItem))   return false    DbItemListItem that=(DbItemListItem)o    if (!dbItem.equals(that.dbItem))   return false    return true  } 
@Override public int hashCode(){   return dbItem.hashCode()  } 
@Nonnull List<DbItem> getAllDbItems(@Nonnull Context context)  
@Nonnull List<DbItem> getAllStartsWith(@Nonnull String prefix,@Nonnull Context context)  
void addItem(@Nonnull DbItem dbItem,@Nonnull Context context)  
@Nonnull List<DbItem> removeItemByName(@Nonnull String name,@Nonnull Context context)  
@Nonnull @Override public List<DbItem> getAllDbItems(@Nonnull Context context){ synchronized (items) {     if (items.isEmpty()) {       items.addAll(getDbItemDao().loadAll())      }     return Collections.unmodifiableList(items)    } } 
@Nonnull @Override public List<DbItem> getAllStartsWith(@Nonnull String prefix,@Nonnull Context context){   final List<DbItem> result  synchronized (items) {     result=new ArrayList<DbItem>(getAllDbItems(context))    }   prefix=prefix.toLowerCase()    for (Iterator<DbItem> it=result.iterator()  it.hasNext()  ) {     final DbItem notFilteredItem=it.next()      if (!notFilteredItem.getName().toLowerCase().startsWith(prefix)) {       it.remove()      }   }   return result  } 
@Override public void addItem(@Nonnull DbItem dbItem,@Nonnull Context context){ synchronized (items) {     getDbItemDao().insert(dbItem)      items.add(dbItem)    } } 
@Nonnull @Override public List<DbItem> removeItemByName(@Nonnull String name,@Nonnull Context context){ synchronized (items) {     final List<DbItem> removedItems=new ArrayList<DbItem>()      getDbItemDao().removeByName(name)      for (Iterator<DbItem> it=items.iterator()  it.hasNext()  ) {       final DbItem dbItem=it.next()        if (name.equals(dbItem.getName())) {         it.remove()          removedItems.add(dbItem)        }     }     return removedItems    } } 
@Nonnull private DbItemDao getDbItemDao(){   return ((Locator)App.getLocator()).getDbItemDao()  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_db_layout)    addItemButton=(Button)findViewById(R.id.add_item_button)    addButtonName=(EditText)findViewById(R.id.add_item_name)    removeItemButton=(Button)findViewById(R.id.remove_item_button)    removeItemName=(EditText)findViewById(R.id.remove_item_name)    itemFilter=(EditText)findViewById(R.id.item_filter)    addItemButton.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       final String itemName=addButtonName.getText().toString()        if (Strings.isEmpty(itemName)) {         Toast.makeText(SamplesDbActivity.this,getString(R.string.name_is_empty),Toast.LENGTH_SHORT).show()        }  else {         addItem(itemName)        }     }   } )    removeItemButton.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       final String itemName=removeItemName.getText().toString()        if (Strings.isEmpty(itemName)) {         Toast.makeText(SamplesDbActivity.this,getString(R.string.name_is_empty),Toast.LENGTH_SHORT).show()        }  else {         removeItem(itemName)        }     }   } )    itemFilter.addTextChangedListener(new TextWatcher(){     @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){     }     @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){     }     @Override public void afterTextChanged(    Editable s){       final String filter=s.toString()        final ListItemAdapter adapter=getListItemAdapter()        adapter.clear()        loadDbItems(filter)      }   } )    ListItemAdapter.createAndAttach(this,new ArrayList<ListItem>())    loadDbItems(null)  } 
@Override public void onClick(View v){   final String itemName=addButtonName.getText().toString()    if (Strings.isEmpty(itemName)) {     Toast.makeText(SamplesDbActivity.this,getString(R.string.name_is_empty),Toast.LENGTH_SHORT).show()    }  else {     addItem(itemName)    } } 
@Override public void onClick(View v){   final String itemName=removeItemName.getText().toString()    if (Strings.isEmpty(itemName)) {     Toast.makeText(SamplesDbActivity.this,getString(R.string.name_is_empty),Toast.LENGTH_SHORT).show()    }  else {     removeItem(itemName)    } } 
@Override public void beforeTextChanged(CharSequence s,int start,int count,int after){ } 
@Override public void onTextChanged(CharSequence s,int start,int before,int count){ } 
@Override public void afterTextChanged(Editable s){   final String filter=s.toString()    final ListItemAdapter adapter=getListItemAdapter()    adapter.clear()    loadDbItems(filter)  } 
private void loadDbItems(@Nullable final String filter){ } 
@SuppressWarnings("unchecked") @Nonnull private ListItemAdapter<DbItemListItem> getListItemAdapter(){   return (ListItemAdapter<DbItemListItem>)getListView().getAdapter()  } 
private void removeItem(@Nonnull String itemName){ } 
private void addItem(@Nonnull String itemName){ } 
@Nonnull private DbItemService getDbItemService(){   return ((Locator)App.getLocator()).getDbItemService()  } 
public SqliteDbItemDao(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper){   super(context,sqliteOpenHelper)  } 
@Nonnull @Override public List<DbItem> loadAll(){   return AndroidDbUtils.doDbQuery(getSqliteOpenHelper(),new LoadAll(getContext(),getSqliteOpenHelper()))  } 
@Override public void insert(@Nonnull DbItem dbItem){   AndroidDbUtils.doDbExec(getSqliteOpenHelper(),new Insert(dbItem))  } 
@Override public void removeByName(@Nonnull String name){   AndroidDbUtils.doDbExec(getSqliteOpenHelper(),new RemoveByName(name))  } 
protected RemoveByName(@Nonnull String name){   super(name)  } 
@Override public long exec(@Nonnull SQLiteDatabase db){   final String name=getNotNullObject()    return db.delete("items","name = ?",new String[]{name})  } 
protected Insert(@Nonnull DbItem object){   super(object)  } 
@Override public long exec(@Nonnull SQLiteDatabase db){   final DbItem dbItem=getNotNullObject()    final ContentValues values=new ContentValues()    values.put("name",dbItem.getName())    return db.insert("items",null,values)  } 
protected LoadAll(@Nonnull Context context,@Nonnull SQLiteOpenHelper sqliteOpenHelper){   super(context,sqliteOpenHelper)  } 
@Nonnull @Override public Cursor createCursor(@Nonnull SQLiteDatabase db){   return db.query("items",null,null,null,null,null,null)  } 
@Nonnull @Override public List<DbItem> retrieveData(@Nonnull Cursor cursor){   return new ListMapper<DbItem>(DbItemMapper.getInstance()).convert(cursor)  } 
private DbItemMapper(){ } 
@Nonnull public static DbItemMapper getInstance(){   return instance  } 
@Nonnull @Override public DbItem convert(@Nonnull Cursor cursor){   final String name=cursor.getString(0)    return new DbItemImpl(name)  } 
public HttpListItem(@Nonnull String uri,@Nonnull ImageLoader imageLoader){   this.uri=uri    this.imageLoader=imageLoader  } 
@Override public OnClickAction getOnClickAction(){   return null  } 
@Override public OnClickAction getOnLongClickAction(){   return null  } 
@Nonnull @Override public View updateView(@Nonnull Context context,@Nonnull View view){   if (getTag().equals(view.getTag())) {     fillView(context,view)      return view    }  else {     return build(context)    } } 
private void fillView(@Nonnull Context context,@Nonnull View root){   final ImageView icon=(ImageView)root.findViewById(R.id.http_item_icon)    imageLoader.loadImage(uri,icon,R.drawable.icon)    final TextView text=(TextView)root.findViewById(R.id.http_item_text)    text.setText(uri)  } 
@Nonnull @Override public View build(@Nonnull Context context){   final View root=ViewFromLayoutBuilder.newInstance(R.layout.acl_http_list_item).build(context)    root.setTag(getTag())    fillView(context,root)    return root  } 
@Nonnull private String getTag(){   return "http_list_item"  } 
@Override protected void onCreate(Bundle savedInstanceState){ } 
private FetchHttpData(@Nonnull String uri){   super(uri,HttpMethod.GET)  } 
@Override public String getResponse(@Nonnull HttpResponse response){   try {     return EntityUtils.toString(response.getEntity())    }  catch (  IOException e) {     throw new HttpRuntimeIoException(e)    } } 
@Nonnull @Override public List<NameValuePair> getRequestParameters(){   return Collections.emptyList()  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_keyboard_layout)  } 
@Nonnull SQLiteOpenHelper getSqliteOpenHelper()  
@Nonnull DbItemDao getDbItemDao()  
@Nonnull DbItemService getDbItemService()  
@Nonnull TaskService getTaskService()  
public MenuListItem(int captionResId,int sortOrder){   this.captionResId=captionResId    this.sortOrder=sortOrder  } 
@Override public OnClickAction getOnClickAction(){   return new OnClickAction(){     @Override public void onClick(    @Nonnull Context context,    @Nonnull ListAdapter<? extends ListItem> adapter){       Toast.makeText(context,context.getString(R.string.long_press_to_open_menu),Toast.LENGTH_SHORT).show()      }   }   } 
@Override public void onClick(@Nonnull Context context,@Nonnull ListAdapter<? extends ListItem> adapter){   Toast.makeText(context,context.getString(R.string.long_press_to_open_menu),Toast.LENGTH_SHORT).show()  } 
@Override public OnClickAction getOnLongClickAction(){   return new SimpleMenuOnClick<MenuListItem>(Arrays.asList(MenuItemMenu.values()),this,String.valueOf(captionResId))  } 
@Nonnull @Override public View updateView(@Nonnull Context context,@Nonnull View view){   if (this.getTag().equals(view.getTag())) {     fillView(context,(TextView)view)      return view    }  else {     return build(context)    } } 
@Nonnull @Override public View build(@Nonnull Context context){   final TextView view=TextViewBuilder.newInstance(R.layout.acl_menu_list_item,getTag()).build(context)    fillView(context,view)    return view  } 
private void fillView(@Nonnull Context context,@Nonnull TextView view){   view.setText(context.getString(captionResId))  } 
@Nonnull private String getTag(){   return "menu_list_item"  } 
public int getSortOrder(){   return sortOrder  } 
@Override public void onClick(@Nonnull ListItemOnClickData<MenuListItem> data,@Nonnull Context context){   Toast.makeText(context,context.getString(R.string.show_menu_number_text,String.valueOf(data.getDataObject().getSortOrder())),Toast.LENGTH_SHORT).show()  } 
@Override public void onClick(@Nonnull ListItemOnClickData<MenuListItem> data,@Nonnull Context context){   Toast.makeText(context,context.getString(R.string.show_menu_name_text,context.getString(data.getDataObject().captionResId)),Toast.LENGTH_SHORT).show()  } 
private void MenuItemMenu(int captionResId){   this.captionResId=captionResId  } 
@Nonnull @Override public String getCaption(@Nonnull Context context){   return context.getString(captionResId)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_menu_layout)    Fragments.createFragment(this,SamplesListFragment.class,R.id.acl_main_linearlayout,"menu-list")  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setHasOptionsMenu(true)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    final List<MenuListItem> listItems=new ArrayList<MenuListItem>()    listItems.add(new MenuListItem(R.string.menu_01,1))    listItems.add(new MenuListItem(R.string.menu_02,2))    listItems.add(new MenuListItem(R.string.menu_03,3))    ListItemAdapter.createAndAttach(this,listItems)  } 
@Override public ListItemAdapter<MenuListItem> getListAdapter(){   return (ListItemAdapter<MenuListItem>)super.getListAdapter()  } 
@Override public void onCreateOptionsMenu(@Nonnull Menu menu,@Nonnull MenuInflater inflater){   if (this.menu == null) {     final List<LabeledMenuItem<MenuItem>> menuItems=new ArrayList<LabeledMenuItem<MenuItem>>()      Collections.addAll(menuItems,SamplesStaticMenu.values())      menuItems.add(new ReverseSortMenuItem())      menuItems.add(new AscSortMenuItem())      this.menu=ListActivityMenu.fromList(menuItems,AndroidMenuHelper.getInstance(),new MenuFilter())    }   this.menu.onCreateOptionsMenu(this.getActivity(),menu)  } 
@Override public boolean apply(@Nullable AMenuItem<MenuItem> menuItem){   if (menuItem instanceof AscSortMenuItem) {     return !ascSort    }  else {     return false    } } 
private ListItemComparator(boolean sortAsc){   this.sortAsc=sortAsc  } 
@Override public int compare(MenuListItem lhs,MenuListItem rhs){   int result=Objects.compare(lhs.getSortOrder(),rhs.getSortOrder())    if (sortAsc) {     return result    }  else {     return -result    } } 
public ReverseSortMenuItem(){   super(R.string.reverse_sort)  } 
@Override public void onClick(@Nonnull MenuItem data,@Nonnull Context context){   final SamplesListFragment a=SamplesListFragment.this    a.ascSort=!a.ascSort    getListAdapter().sort(new ListItemComparator(a.ascSort))  } 
public AscSortMenuItem(){   super(R.string.asc_menu_item)  } 
@Override public void onClick(@Nonnull MenuItem data,@Nonnull Context context){   Toast.makeText(context,getString(R.string.asc_sort_menu_item_text),Toast.LENGTH_LONG).show()  } 
@Override public boolean onOptionsItemSelected(@Nonnull MenuItem item){   return menu.onOptionsItemSelected(this.getActivity(),item)  } 
@Override public void onPrepareOptionsMenu(@Nonnull Menu menu){   this.menu.onPrepareOptionsMenu(this.getActivity(),menu)  } 
public CountryPickerDialogPreference(Context context,AttributeSet attrs){   super(context,attrs,null,false,Country.class)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    addPreferencesFromResource(R.xml.preferences)    final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this)    prefs.registerOnSharedPreferenceChangeListener(this)    updateAnswer(Preferences.toBeOrNotTobe.getKey(),getString(Preferences.toBeOrNotTobe.getPreference(prefs).getCaptionResId()))    updateAnswer(Preferences.integerNumber.getKey(),String.valueOf(Preferences.integerNumber.getPreference(prefs)))    updateAnswer(Preferences.doubleNumber.getKey(),String.valueOf(Preferences.doubleNumber.getPreference(prefs)))    updateAnswer(Preferences.country.getKey(),String.valueOf(Preferences.country.getPreference(prefs)))    updateAnswer(Preferences.floatInterval.getKey(),String.valueOf(Preferences.floatInterval.getPreference(prefs)))    updateAnswer(Preferences.integerInterval.getKey(),String.valueOf(Preferences.integerInterval.getPreference(prefs)))  } 
@Override public void onSharedPreferenceChanged(SharedPreferences prefs,String key){   if (Preferences.toBeOrNotTobe.getKey().equals(key)) {     final String answer=getString(Preferences.toBeOrNotTobe.getPreference(prefs).getCaptionResId())      updateAnswer(key,answer)    }   if (Preferences.integerNumber.getKey().equals(key)) {     final String answer=String.valueOf(Preferences.integerNumber.getPreference(prefs))      updateAnswer(key,answer)    }   if (Preferences.doubleNumber.getKey().equals(key)) {     final String answer=String.valueOf(Preferences.doubleNumber.getPreference(prefs))      updateAnswer(key,answer)    }   if (Preferences.country.getKey().equals(key)) {     final String answer=String.valueOf(Preferences.country.getPreference(prefs))      updateAnswer(key,answer)    }   if (Preferences.floatInterval.getKey().equals(key)) {     final String answer=String.valueOf(Preferences.floatInterval.getPreference(prefs))      updateAnswer(key,answer)    }   if (Preferences.integerInterval.getKey().equals(key)) {     final String answer=String.valueOf(Preferences.integerInterval.getPreference(prefs))      updateAnswer(key,answer)    } } 
private void updateAnswer(@Nonnull String key,@Nonnull String answer){   final android.preference.Preference preference=findPreference(key)    preference.setSummary(getString(R.string.answer) + ": " + answer)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_samples_list)    final List<SampleType> listItems=new ArrayList<SampleType>()    Collections.addAll(listItems,SampleType.values())    ListItemAdapter.createAndAttach(this,listItems)  } 
public SamplesApplication(){ } 
@Override public void onCreate(){   super.onCreate()    App.init(this)    sqliteOpenHelper=new CommonSQLiteOpenHelper(this,getSqliteOpenHelperConfiguration())    dbItemService=new DbItemServiceImpl()    taskService=Tasks.newTaskService()    AdsController.getInstance().init(this,ADMOB_USER_ID,ADS_FREE_PRODUCT,new SamplesBillingConfiguration())  } 
@Nonnull @Override public SQLiteOpenHelper getSqliteOpenHelper(){   return this.sqliteOpenHelper  } 
@Nonnull @Override public DbItemDao getDbItemDao(){   return new SqliteDbItemDao(this,getSqliteOpenHelper())  } 
@Nonnull @Override public DbItemService getDbItemService(){   return this.dbItemService  } 
@Nonnull @Override public TaskService getTaskService(){   return taskService  } 
@Nonnull private SQLiteOpenHelperConfiguration getSqliteOpenHelperConfiguration(){   return new DbConfiguration()  } 
@Nonnull @Override public String getName(){   return "samples"  } 
@Override public SQLiteDatabase.CursorFactory getCursorFactory(){   return null  } 
@Override public int getVersion(){   return 3  } 
@Override public byte[] getObfuscationSalt(){   return new byte[]{111,114,111,-29,-76,-128,87,-61,-117,26,-46,-57,109,-59,-42,-59,-21,-43,-100,-96}  } 
@Override public String getPublicKey(){   final StringBuilder result=new StringBuilder()    result.append("MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A")    result.append("MIIBCgKCAQEAquP2a7dEhTaJEQeXtSyreH5dCmTDOd")    result.append("dElCfg0ijOeB8JTxBiJTXLWnLA0kMaT/sRXswUaYI61YCQOoik82")    result.append("qrFH7W4+OFtiLb8WGX+YPEpQQ/IBZu9qm3xzS9Nolu79EBff0/CLa1FuT9RtjO")    result.append("iTW8Q0VP9meQdJEkfqJEyVCgHain+MGoQaRXI45EzkYmkz8TBx6X6aJF5NBAXnAWeyD0wPX1")    result.append("uedHH7+LgLcjnPVw82YjyJSzYnaaD2GX0Y7PGoFe6J5K4yJGGX5mih45pe2HWcG5lAkQhu1uX2hCcCBdF3")    result.append("W7paRq9mJvCsbn+BNTh9gq8QKui0ltmiWpa5U+/9L+FQIDAQAB")    return result.toString()  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_tasks_layout)    final View startTaskButton=findViewById(R.id.start_task_button)    startTaskButton.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       startTask()      }   } )    taskListeners.addTaskListener(SLEEP_TASK_NAME,Tasks.toUiThreadFutureCallback(this,new SleepTask()),this,R.string.acl_sleeping_title,R.string.acl_sleeping_message)  } 
@Override public void onClick(View v){   startTask()  } 
private void startTask(){   taskListeners.run(Tasks.toUiThreadTask(this,new SleepTask()),this,R.string.acl_sleeping_title,R.string.acl_sleeping_message)  } 
@Override protected void onDestroy(){   taskListeners.removeAllTaskListeners()    super.onDestroy()  } 
@Nonnull @Override public String getName(){   return SLEEP_TASK_NAME  } 
@Override public Integer call() throws Exception {   Thread.sleep(10000)    return 42  } 
@Override public void onSuccess(@Nonnull SamplesTaskActivity activity,Integer result){   Log.d(SLEEP_TASK_NAME,"OnSuccess, activity: " + activity)    final Button startTaskButton=(Button)activity.findViewById(R.id.start_task_button)    startTaskButton.setText(R.string.acl_start_task_again)  } 
@Override public void onFailure(@Nonnull SamplesTaskActivity activity,Throwable t){   Toast.makeText(activity,"Error: " + t,Toast.LENGTH_LONG).show()  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.acl_view_layout)    final Picker verticalPicker=(Picker)findViewById(R.id.vertical_picker)    verticalPicker.setRange(new IntegerRange(1,10,1,1,null))    verticalPicker.setOnChangeListener(this)    final Picker horizontalPicker=(Picker)findViewById(R.id.horizontal_picker)    horizontalPicker.setRange(new IntegerRange(1,10,1,1,null))    horizontalPicker.setOnChangeListener(this)    final DirectionDragButton dragButton=(DirectionDragButton)findViewById(R.id.drag_button)    dragButton.setOnDragListener(new SimpleOnDragListener(new SimpleOnDragListener.DragProcessor(){     @Override public boolean processDragEvent(    @Nonnull DragDirection dragDirection,    @Nonnull DragButton dragButton,    @Nonnull Point2d startPoint2d,    @Nonnull MotionEvent motionEvent){       Toast.makeText(SamplesViewActivity.this,"Button dragged: " + ((DirectionDragButton)dragButton).getText(dragDirection),Toast.LENGTH_SHORT).show()        return true      }   } ,SimpleOnDragListener.getDefaultPreferences(this)))    dragButton.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       Toast.makeText(SamplesViewActivity.this,"Button clicked: " + dragButton.getText(),Toast.LENGTH_SHORT).show()      }   } )  } 
@Override public boolean processDragEvent(@Nonnull DragDirection dragDirection,@Nonnull DragButton dragButton,@Nonnull Point2d startPoint2d,@Nonnull MotionEvent motionEvent){   Toast.makeText(SamplesViewActivity.this,"Button dragged: " + ((DirectionDragButton)dragButton).getText(dragDirection),Toast.LENGTH_SHORT).show()    return true  } 
@Override public void onClick(View v){   Toast.makeText(SamplesViewActivity.this,"Button clicked: " + dragButton.getText(),Toast.LENGTH_SHORT).show()  } 
@Override public void onChanged(@Nonnull Picker picker,@Nonnull Object value){ switch (picker.getId()) { case R.id.vertical_picker:     Toast.makeText(this,"Vertical picker new value: " + value,Toast.LENGTH_SHORT).show()    break  case R.id.horizontal_picker: Toast.makeText(this,"Horizontal picker new value: " + value,Toast.LENGTH_SHORT).show()  break  } } 
@Override public void setUp() throws Exception {   super.setUp()    random=new Random(new Date().getTime())  } 
public void testObfuscation() throws Exception {   final SecurityService<Transaction,Transaction,byte[]> ss=BillingSecurity.getObfuscationSecurityService(AESObfuscator.IV,AESObfuscator.SECURITY_PREFIX)    final String password=BillingSecurity.generatePassword(getContext())    final SecretKey sk=ss.getSecretKeyProvider().getSecretKey(password,salt)    for (int i=0  i < TEST_COUNT  i++) {     final Transaction transaction=generateRandomTransaction()      final Transaction obfuscated1=transaction.clone()      ObfuscateUtils.obfuscate(getContext(),obfuscated1,salt)      Assert.assertFalse(transaction.equals(obfuscated1))      final Transaction deobfuscated1=obfuscated1.clone()      ObfuscateUtils.unobfuscate(getContext(),deobfuscated1,salt)      Assert.assertEquals(transaction,deobfuscated1)      Transaction deobfuscated2=obfuscated1.clone()      deobfuscated2=ss.getCipherer().decrypt(sk,deobfuscated2)      Assert.assertEquals(transaction,deobfuscated2)      Transaction obfuscated2=transaction.clone()      obfuscated2=ss.getCipherer().encrypt(sk,obfuscated2)      Assert.assertFalse(transaction.equals(obfuscated2))      Assert.assertEquals(obfuscated1,obfuscated2)      Transaction deobfuscated3=obfuscated2.clone()      deobfuscated3=ss.getCipherer().decrypt(sk,deobfuscated3)      Assert.assertEquals(transaction,deobfuscated3)    } } 
@Nonnull private Transaction generateRandomTransaction(){   final Transaction transaction=new Transaction()    transaction.orderId=Strings.generateRandomString(random.nextInt(100))    transaction.developerPayload=Strings.generateRandomString(random.nextInt(100))    transaction.notificationId=Strings.generateRandomString(random.nextInt(100))    transaction.packageName=Strings.generateRandomString(random.nextInt(100))    transaction.productId=Strings.generateRandomString(random.nextInt(100))    transaction.purchaseTime=random.nextLong()    transaction.purchaseState=Transaction.PurchaseState.valueOf(random.nextInt(3))    return transaction  } 
public ListAdapterTest(){   super(ListAdapterActivity.class)  } 
@SmallTest public void testSaveState() throws Exception {   final ListAdapterActivity activity=getActivity()    ListItemAdapter<? extends ListItem> adapter=activity.getAdapter()    adapter.filter("test")    assertEquals("test",adapter.getFilterText())    Bundle outState=new Bundle()    adapter.saveState(outState)    ListItemAdapter<? extends ListItem> newAdapter=new ListItemAdapter<ListItem>(activity,new ArrayList<ListItem>())    newAdapter.restoreState(outState)    assertEquals("test",newAdapter.getFilterText())  } 
@UiThreadTest public void testList() throws Exception {   final Random random=new Random(new Date().getTime())    final ListAdapterActivity activity=getActivity()    final ListItemAdapter<? extends ListItem> adapter=activity.getAdapter()    for (int i=0  i < 100  i++) {     final int oldSize=adapter.getCount()      final int addedCount=random.nextInt(10)      activity.addItems(addedCount)      assertEquals(oldSize + addedCount,adapter.getCount())      adapter.filter(String.valueOf(random.nextInt(9)),new Filter.FilterListener(){       @Override public void onFilterComplete(      int count){         checkOrder(adapter)        }     } )      activity.removeItems(addedCount)      activity.addItemsViaRunnable(addedCount)      assertEquals(oldSize + addedCount,adapter.getCount())      adapter.filter(String.valueOf(random.nextInt(9)),new Filter.FilterListener(){       @Override public void onFilterComplete(      int count){         checkOrder(adapter)        }     } )      activity.removeItems(addedCount)    } } 
@Override public void onFilterComplete(int count){   checkOrder(adapter)  } 
@Override public void onFilterComplete(int count){   checkOrder(adapter)  } 
private void checkOrder(final ListItemAdapter<? extends ListItem> adapter){   adapter.doWork(new Runnable(){     @Override public void run(){       for (int i=0  i < adapter.getCount()  i++) {         if (i > 0) {           final ListItem prevItem=adapter.getItem(i - 1)            final ListItem item=adapter.getItem(i)            assertTrue(prevItem.toString().compareTo(item.toString()) <= 0)          }       }     }   } )  } 
@Override public void run(){   for (int i=0  i < adapter.getCount()  i++) {     if (i > 0) {       final ListItem prevItem=adapter.getItem(i - 1)        final ListItem item=adapter.getItem(i)        assertTrue(prevItem.toString().compareTo(item.toString()) <= 0)      }   } } 
public void testPreferences() throws Exception {   runPreferenceTest(createDefaultValue(),createValue())  } 
protected void runPreferenceTest(@Nullable T defaultValue,@Nullable T value){   final SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(getContext())    preferences.edit().clear().commit()    final Preference<T> preference=createPreference("test",defaultValue)    Assert.assertTrue(preference.isSameKey("test"))    Assert.assertEquals(preference.getKey(),"test")    Assert.assertEquals(false,preference.isSet(preferences))    Assert.assertEquals(defaultValue,preference.getPreference(preferences))    preference.tryPutDefault(preferences)    Assert.assertEquals(true,preference.isSet(preferences))    Assert.assertEquals(defaultValue,preference.getPreference(preferences))    preference.putPreference(preferences,value)    Assert.assertEquals(true,preference.isSet(preferences))    Assert.assertEquals(value,preference.getPreference(preferences))    Assert.assertEquals(defaultValue,preference.getDefaultValue())    preferences.edit().clear().commit()    Assert.assertEquals(false,preference.isSet(preferences))    Assert.assertEquals(defaultValue,preference.getPreference(preferences))  } 
@Nonnull protected abstract Preference<T> createPreference(@Nonnull String key,@Nullable T defaultValue)  
@Nonnull protected abstract T createDefaultValue()  
protected abstract T createValue()  
@Nonnull @Override protected Preference<Boolean> createPreference(@Nonnull String key,@Nonnull Boolean defaultValue){   return BooleanPreference.of(key,defaultValue)  } 
@Nonnull @Override protected Boolean createDefaultValue(){   return true  } 
@Override protected Boolean createValue(){   return false  } 
@Override public void testPreferences() throws Exception {   super.testPreferences()    runPreferenceTest(Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY)  } 
@Nonnull @Override protected Class<Double> getNumberClass(){   return Double.class  } 
@Nonnull @Override protected Double createDefaultValue(){   return 324d  } 
@Override protected Double createValue(){   return -0d  } 
@Nonnull @Override protected Preference<Float> createPreference(@Nonnull String key,@Nonnull Float defaultValue){   return FloatPreference.of(key,defaultValue)  } 
@Nonnull @Override protected Float createDefaultValue(){   return 23423f  } 
@Override protected Float createValue(){   return -0f  } 
@Nonnull @Override protected Class<Float> getNumberClass(){   return Float.class  } 
@Nonnull @Override protected Float createDefaultValue(){   return 123123f  } 
@Override protected Float createValue(){   return -123123f  } 
@Nonnull @Override protected Preference<Set<String>> createPreference(@Nonnull String key,@Nullable Set<String> defaultValue){   return HashSetPreference.ofStrings(key,defaultValue)  } 
@Nonnull @Override protected Set<String> createDefaultValue(){   return new HashSet<String>(Arrays.asList("1","2","3","4"))  } 
@Override protected Set<String> createValue(){   return new HashSet<String>(Arrays.asList("5","4","3","2","1"))  } 
@Nonnull @Override protected Preference<Integer> createPreference(@Nonnull String key,@Nonnull Integer defaultValue){   return IntegerPreference.of(key,defaultValue)  } 
@Nonnull @Override protected Integer createDefaultValue(){   return 122  } 
@Override protected Integer createValue(){   return -11  } 
@Nonnull @Override protected Preference<List<String>> createPreference(@Nonnull String key,@Nullable List<String> defaultValue){   return CollectionToStringPreference.forStringList(key,defaultValue)  } 
@Nonnull @Override protected List<String> createDefaultValue(){   return Arrays.asList("1","2","3","4")  } 
@Override protected List<String> createValue(){   return Arrays.asList("4","2","1","3")  } 
@Nonnull @Override protected Preference<Long> createPreference(@Nonnull String key,@Nonnull Long defaultValue){   return LongPreference.of(key,defaultValue)  } 
@Nonnull @Override protected Long createDefaultValue(){   return 1231231232132131L  } 
@Override protected Long createValue(){   return -1231231232132131L  } 
@Nonnull @Override protected Preference<N> createPreference(@Nonnull String key,@Nullable N defaultValue){   return NumberToStringPreference.of(key,defaultValue,getNumberClass())  } 
@Nonnull protected abstract Class<N> getNumberClass()  
public void testParcelable() throws Exception {   AProperty expected=Properties.newProperty("test_name","test_value")    Parcel parcel=Parcel.obtain()    expected.writeToParcel(parcel,0)    parcel.setDataPosition(0)    AProperty actual=APropertyImpl.CREATOR.createFromParcel(parcel)    Assert.assertEquals(expected,actual)    parcel=Parcel.obtain()    expected=Properties.newProperty("test_name",null)    expected.writeToParcel(parcel,0)    parcel.setDataPosition(0)    actual=APropertyImpl.CREATOR.createFromParcel(parcel)    Assert.assertEquals(expected,actual)  } 
public static Test suite(){   return new TestSuiteBuilder(AllTests.class).includeAllPackagesUnderHere().includePackages(ObfuscateUtilsTest.class.getPackage().getName()).includePackages(AndroidStringCiphererTest.class.getPackage().getName()).includePackages(AbstractPreferenceTest.class.getPackage().getName()).includePackages(APropertyTest.class.getPackage().getName()).includePackages(ListAdapterTest.class.getPackage().getName()).build()  } 
public SamplesActivityTest(){   super(SamplesActivity.class.getPackage().getName(),SamplesActivity.class)  } 
@SmallTest public void testPreconditions() throws Exception { } 
@UiThreadTest public void testList() throws Exception {   final SamplesActivity activity=getActivity()    final ListAdapter adapter=activity.getListAdapter()    if (adapter != null) {     assertTrue(adapter.getCount() >= 4)    }  else {     Log.w("Test","List adapter is null, must be fixed!")    } } 
public void testEncryptDecrypt() throws Exception {   final SecurityService<String,String,String> securityService=Security.newAndroidAesStringSecurityService()    final Cipherer<String,String> cipherer=securityService.getCipherer()    final SecretKeyProvider secretKeyProvider=securityService.getSecretKeyProvider()    final SaltGenerator saltGenerator=securityService.getSaltGenerator()    final HashProvider<String,String> hashProvider=securityService.getHashProvider()    final Random r=new Random(new Date().getTime())    for (int i=0  i < 100  i++) {     final String expected=Strings.generateRandomString(r.nextInt(1000))      final String secret=Strings.generateRandomString(10)      byte[] salt=saltGenerator.generateSalt()      final SecretKey sk=secretKeyProvider.getSecretKey(secret,salt)      final String encrypted=cipherer.encrypt(sk,expected)      final String decrypted=cipherer.decrypt(sk,encrypted)      Assert.assertEquals(expected,decrypted)      final byte[] hashSalt=saltGenerator.generateSalt()      final String decryptedHash=hashProvider.getHash(decrypted,hashSalt)      final String expectedHash=hashProvider.getHash(expected,hashSalt)      Assert.assertEquals(expectedHash,decryptedHash)    } } 
private ABase64StringDecoder(){ } 
@Nonnull public static Converter<String,byte[]> getInstance(){   return instance  } 
@Nonnull @Override public byte[] convert(@Nonnull String s){   return Base64.decode(s,Base64.DEFAULT)  } 
private ABase64StringEncoder(){ } 
@Nonnull public static Converter<byte[],String> getInstance(){   return instance  } 
@Nonnull @Override public String convert(@Nonnull byte[] bytes){   return Base64.encodeToString(bytes,Base64.DEFAULT)  } 
private Security(){   throw new AssertionError()  } 
@Nonnull public static Cipherer<byte[],byte[]> newAndroidAesByteCipherer(){   return org.solovyev.common.security.Security.newCipherer(CIPHER_ALGORITHM,PROVIDER,InitialVectorDef.newRandom(IV_RANDOM_ALGORITHM,IV_LENGTH))  } 
@Nonnull public static Cipherer<byte[],byte[]> newAndroidAesByteCipherer(final byte[] initialVector){   return org.solovyev.common.security.Security.newCipherer(CIPHER_ALGORITHM,PROVIDER,InitialVectorDef.newPredefined(initialVector))  } 
@Nonnull public static SecretKeyProvider newAndroidAesSecretKeyProvider(){   return org.solovyev.common.security.Security.newPbeSecretKeyProvider(PBE_ITERATION_COUNT,PBE_ALGORITHM,CIPHERER_ALGORITHM_AES,PROVIDER,PBE_KEY_LENGTH,SALT_LENGTH)  } 
@Nonnull public static HashProvider<byte[],byte[]> newAndroidSha512ByteHashProvider(){   return org.solovyev.common.security.Security.newHashProvider(HASH_ALGORITHM,PROVIDER)  } 
@Nonnull public static HashProvider<String,String> newAndroidSha512StringHashProvider(){   return TypedHashProvider.newInstance(newAndroidSha512ByteHashProvider(),StringDecoder.getInstance(),ABase64StringEncoder.getInstance())  } 
@Nonnull public static SaltGenerator newAndroidSaltGenerator(){   return org.solovyev.common.security.Security.newSaltGenerator(IV_RANDOM_ALGORITHM,SALT_LENGTH)  } 
@Nonnull public static Cipherer<String,String> newAndroidAesStringCipherer(){   return TypedCipherer.newInstance(newAndroidAesByteCipherer(),StringDecoder.getInstance(),StringEncoder.getInstance(),ABase64StringDecoder.getInstance(),ABase64StringEncoder.getInstance())  } 
@Nonnull public static Cipherer<String,String> newAndroidAesStringCipherer(final byte[] initialVector){   return TypedCipherer.newInstance(newAndroidAesByteCipherer(initialVector),StringDecoder.getInstance(),StringEncoder.getInstance(),ABase64StringDecoder.getInstance(),ABase64StringEncoder.getInstance())  } 
@Nonnull public static SecurityService<byte[],byte[],byte[]> newAndroidAesByteSecurityService(){   return newSecurityService(newAndroidAesByteCipherer(),newAndroidAesSecretKeyProvider(),newAndroidSaltGenerator(),newAndroidSha512ByteHashProvider())  } 
@Nonnull public static SecurityService<byte[],byte[],byte[]> newAndroidAesByteSecurityService(final byte[] initialVector){   return newSecurityService(newAndroidAesByteCipherer(initialVector),newAndroidAesSecretKeyProvider(),newAndroidSaltGenerator(),newAndroidSha512ByteHashProvider())  } 
@Nonnull public static SecurityService<String,String,String> newAndroidAesStringSecurityService(){   return newSecurityService(newAndroidAesStringCipherer(),newAndroidAesSecretKeyProvider(),newAndroidSaltGenerator(),newAndroidSha512StringHashProvider())  } 
@Nonnull public static SecurityService<String,String,String> newAndroidStringSecurityService(@Nonnull SecurityService<byte[],byte[],byte[]> securityService){   return SecurityServiceConverter.wrap(securityService,StringDecoder.getInstance(),StringEncoder.getInstance(),ABase64StringDecoder.getInstance(),ABase64StringEncoder.getInstance())  } 
public ActionBarNavigationFragmentListener(@Nonnull SherlockFragmentActivity activity,@Nonnull List<? extends FragmentItem> items,@Nonnull List<String> itemLabels){ } 
@Nonnull public synchronized ListAdapter getAdapter(){   return adapter  } 
@Override public boolean onNavigationItemSelected(int itemPosition,long itemId){   final FragmentManager fragmentManager=this.activity.getSupportFragmentManager()    final FragmentTransaction ft=fragmentManager.beginTransaction()    try {     if (selected != itemPosition) {       if (selected >= 0 && selected < items.size()) {         items.get(selected).onUnselected(ft)        }       if (itemPosition < items.size()) {         items.get(itemPosition).onSelected(ft)          selected=itemPosition        }     }   }   finally {     if (ft != null && !ft.isEmpty()) {       ft.commit()      }   }   return true  } 
private AndroidSherlockUtils(){   throw new AssertionError("Not intended for instantiation!")  } 
@Nonnull public static ActionBar getSupportActionBar(@Nonnull Activity activity){   if (activity instanceof SherlockActivity) {     return ((SherlockActivity)activity).getSupportActionBar()    }   if (activity instanceof SherlockFragmentActivity) {     return ((SherlockFragmentActivity)activity).getSupportActionBar()    }   if (activity instanceof SherlockListActivity) {     return ((SherlockListActivity)activity).getSupportActionBar()    }   if (activity instanceof SherlockPreferenceActivity) {     return ((SherlockPreferenceActivity)activity).getSupportActionBar()    }   throw new IllegalArgumentException(activity.getClass() + " is not supported!")  } 
public static ActionBar getSupportActionBar(@Nonnull Fragment fragment){   if (fragment instanceof SherlockFragment) {     return ((SherlockFragment)fragment).getSherlockActivity().getSupportActionBar()    }   if (fragment instanceof SherlockListFragment) {     return ((SherlockListFragment)fragment).getSherlockActivity().getSupportActionBar()    }   if (fragment instanceof SherlockDialogFragment) {     return ((SherlockDialogFragment)fragment).getSherlockActivity().getSupportActionBar()    }   throw new IllegalArgumentException(fragment.getClass() + " is not supported!")  } 
@Nonnull public static ListAdapter<String> newSherlockDefaultAdapter(@Nonnull SherlockFragmentActivity activity,@Nonnull List<String> items){   final ListAdapter<String> result=new ListAdapter<String>(activity,com.actionbarsherlock.R.layout.sherlock_spinner_item,items)    result.setDropDownViewResource(com.actionbarsherlock.R.layout.sherlock_spinner_dropdown_item)    return result  } 
@Nonnull public static MenuInflater getSupportMenuInflater(@Nonnull Activity activity){   if (activity instanceof SherlockActivity) {     return ((SherlockActivity)activity).getSupportMenuInflater()    }   if (activity instanceof SherlockFragmentActivity) {     return ((SherlockFragmentActivity)activity).getSupportMenuInflater()    }   if (activity instanceof SherlockListActivity) {     return ((SherlockListActivity)activity).getSupportMenuInflater()    }   if (activity instanceof SherlockPreferenceActivity) {     return ((SherlockPreferenceActivity)activity).getSupportMenuInflater()    }   throw new IllegalArgumentException(activity.getClass() + " is not supported!")  } 
public static void showDialog(@Nonnull DialogFragment dialogFragment,@Nonnull String fragmentTag,@Nonnull FragmentManager fm){   final FragmentTransaction ft=fm.beginTransaction()    Fragment prev=fm.findFragmentByTag(fragmentTag)    if (prev != null) {     ft.remove(prev)    }   dialogFragment.show(ft,fragmentTag)  } 
public void onSelected(@Nonnull FragmentTransaction ft)  
public void onUnselected(@Nonnull FragmentTransaction ft)  
/**   * Constructor used each time a new tab is created.  * @param activity      The host Activity, used to instantiate the fragment  * @param tag           The identifier tag for the fragment  * @param fragmentClass The fragment's Class, used to instantiate the fragment  * @param fragmentArgs  arguments to be passed to fragment  * @param parentViewId  parent view id  */ public FragmentItemImpl(@Nonnull SherlockFragmentActivity activity,@Nonnull String tag,@Nonnull Class<? extends Fragment> fragmentClass,@Nullable Bundle fragmentArgs,@Nullable Integer parentViewId){   this.activity=activity    this.tag=tag    this.fragmentClass=fragmentClass    this.fragmentArgs=fragmentArgs    this.parentViewId=parentViewId    final FragmentManager supportFragmentManager=activity.getSupportFragmentManager()    this.fragment=supportFragmentManager.findFragmentByTag(tag)  } 
@Override public void onSelected(@Nonnull FragmentTransaction ft){   if (fragment == null) {     fragment=activity.getSupportFragmentManager().findFragmentByTag(this.tag)    }   if (fragment == null) {     fragment=Fragment.instantiate(activity,fragmentClass.getName(),fragmentArgs)      if (parentViewId != null) {       ft.add(parentViewId,fragment,tag)      }  else {       ft.add(fragment,tag)      }   }  else {     if (fragment.isDetached()) {       ft.attach(fragment)      }   } } 
@Override public void onUnselected(@Nonnull FragmentTransaction ft){   if (fragment != null) {     ft.detach(fragment)    } } 
private Fragments(){ } 
public static void showDialog(@Nonnull DialogFragment dialogFragment,@Nonnull String fragmentTag,@Nonnull FragmentManager fm){   showDialog(dialogFragment,fragmentTag,fm,true)  } 
public static void showDialog(DialogFragment dialogFragment,String fragmentTag,FragmentManager fm,boolean useExisting){   Fragment prev=fm.findFragmentByTag(fragmentTag)    if (prev != null) {     if (!useExisting) {       final FragmentTransaction ft=fm.beginTransaction()        ft.remove(prev)        ft.addToBackStack(null)        dialogFragment.show(ft,fragmentTag)        fm.executePendingTransactions()      }   }  else {     final FragmentTransaction ft=fm.beginTransaction()      ft.addToBackStack(null)      dialogFragment.show(ft,fragmentTag)      fm.executePendingTransactions()    } } 
@Nonnull public static MenuHelper<Menu,MenuItem> getInstance(){   return instance  } 
private SherlockMenuHelper(){ } 
@Override public int size(@Nonnull Menu menu){   return menu.size()  } 
@Nonnull @Override public MenuItem add(@Nonnull Menu menu,int groupId,int itemId,int orderId,@Nonnull String caption){   return menu.add(groupId,itemId,orderId,caption)  } 
@Override public void setOnMenuItemClickListener(@Nonnull final MenuItem menuItem,@Nonnull final AMenuItem<MenuItem> onMenuItemClick,@Nonnull final Activity activity){   menuItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){     @Override public boolean onMenuItemClick(    MenuItem item){       onMenuItemClick.onClick(menuItem,activity)        return true      }   } )  } 
@Override public boolean onMenuItemClick(MenuItem item){   onMenuItemClick.onClick(menuItem,activity)    return true  } 
@Override public void removeItem(@Nonnull Menu menu,@Nonnull Integer menuItemId){   menu.removeItem(menuItemId)  } 
@Override public void inflateMenu(@Nonnull Activity activity,int layoutId,@Nonnull Menu menu){   AndroidSherlockUtils.getSupportMenuInflater(activity).inflate(layoutId,menu)  } 
@Nonnull @Override public Integer getItemId(@Nonnull MenuItem item){   return item.getItemId()  } 
/**   * Constructor used each time a new tab is created.  * @param activity      The host Activity, used to instantiate the fragment  * @param tag           The identifier tag for the fragment  * @param fragmentClass The fragment's Class, used to instantiate the fragment  * @param fragmentArgs  arguments to be passed to fragment  * @param parentViewId  parent view id  */ public ActionBarFragmentTabListener(@Nonnull SherlockFragmentActivity activity,@Nonnull String tag,@Nonnull Class<? extends Fragment> fragmentClass,@Nullable Bundle fragmentArgs,@Nullable Integer parentViewId){   this.fragmentItem=new FragmentItemImpl(activity,tag,fragmentClass,fragmentArgs,parentViewId)  } 
public void onTabSelected(ActionBar.Tab tab,FragmentTransaction ft){   this.fragmentItem.onSelected(ft)  } 
public void onTabUnselected(ActionBar.Tab tab,FragmentTransaction ft){   this.fragmentItem.onUnselected(ft)  } 
public void onTabReselected(ActionBar.Tab tab,FragmentTransaction ft){ } 
ContextAwareFutureCallback(@Nonnull C context){   this.contextRef=new WeakReference<C>(context)  } 
@Nullable protected C getContext(){   return contextRef.get()  } 
void onSuccess(@Nonnull C context,V result)  
void onFailure(@Nonnull C context,Throwable t)  
@Nonnull String getName()  
public TaskListeners(@Nonnull TaskService taskService){   this.taskService=taskService  } 
@Nullable private <T>FutureCallback<T> tryAddListener(@Nonnull String taskName,@Nullable FutureCallback<T> listener){   if (listener != null) {     List<FutureCallback<?>> listenersByTask=listeners.get(taskName)      if (listenersByTask == null) {       listenersByTask=new ArrayList<FutureCallback<?>>()        listeners.put(taskName,listenersByTask)      }     listenersByTask.add(listener)    }   return listener  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull NamedTask<T> task){   return tryAddListener(task.getName(),taskService.run(task))  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull NamedTask<T> task,@Nonnull Activity activity,int titleResId,int messageResId){   final FutureCallback<T> result=tryAddListener(task.getName(),taskService.run(task))    overlayDialogs.addTaskOverlayDialog(TaskOverlayDialog.attachToTask(taskService,activity,task.getName(),titleResId,messageResId))    return result  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull String taskName,@Nonnull Task<T> task){   return tryAddListener(taskName,taskService.run(taskName,task))  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull String taskName,@Nonnull Task<T> task,@Nonnull Activity activity,int titleResId,int messageResId){   final FutureCallback<T> result=tryAddListener(taskName,taskService.run(taskName,task))    overlayDialogs.addTaskOverlayDialog(TaskOverlayDialog.attachToTask(taskService,activity,taskName,titleResId,messageResId))    return result  } 
public <T>void run(@Nonnull String taskName,@Nonnull Callable<T> task){   taskService.run(taskName,task)  } 
public <T>void run(@Nonnull String taskName,@Nonnull Callable<T> task,@Nonnull Activity activity,int titleResId,int messageResId){   taskService.run(taskName,task)    overlayDialogs.addTaskOverlayDialog(TaskOverlayDialog.attachToTask(taskService,activity,taskName,titleResId,messageResId))  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull String taskName,@Nonnull Callable<T> task,@Nullable FutureCallback<T> taskListener){   return tryAddListener(taskName,taskService.run(taskName,task,taskListener))  } 
@Nullable public <T>FutureCallback<T> run(@Nonnull String taskName,@Nonnull Callable<T> task,@Nullable FutureCallback<T> taskListener,@Nonnull Activity activity,int titleResId,int messageResId){   final FutureCallback<T> result=tryAddListener(taskName,taskService.run(taskName,task,taskListener))    overlayDialogs.addTaskOverlayDialog(TaskOverlayDialog.attachToTask(taskService,activity,taskName,titleResId,messageResId))    return result  } 
@Nullable public <T>FutureCallback<T> addTaskListener(@Nonnull String taskName,@Nonnull FutureCallback<T> taskListener){   return tryAddListener(taskName,taskService.addTaskListener(taskName,taskListener))  } 
@Nullable public <T>FutureCallback<T> addTaskListener(@Nonnull String taskName,@Nonnull FutureCallback<T> taskListener,@Nonnull Activity activity,int titleResId,int messageResId){   final FutureCallback<T> result=tryAddListener(taskName,taskService.addTaskListener(taskName,taskListener))    overlayDialogs.addTaskOverlayDialog(TaskOverlayDialog.attachToTask(taskService,activity,taskName,titleResId,messageResId))    return result  } 
public void removeAllTaskListeners(){   for (  String taskName : listeners.keySet()) {     removeAllTaskListeners(taskName)    }   listeners.clear()    overlayDialogs.dismissAll()  } 
private void removeAllTaskListeners(@Nonnull String taskName){   final List<FutureCallback<?>> listenersByTask=listeners.get(taskName)    if (listenersByTask != null) {     for (    FutureCallback<?> listener : listenersByTask) {       taskService.removeTaskListener(taskName,listener)      }     listenersByTask.clear()    } } 
private TaskOverlayDialog(@Nonnull ProgressDialog progressDialog){   this.progressDialog=progressDialog  } 
@Nonnull private static <V>TaskOverlayDialog<V> newInstance(@Nonnull Activity activity,int titleResId,int messageResId){   final ProgressDialog progressDialog=new ProgressDialog(activity)    progressDialog.setIndeterminate(true)    progressDialog.setCancelable(false)    progressDialog.setTitle(titleResId)    progressDialog.setMessage(activity.getText(messageResId))    return new TaskOverlayDialog<V>(progressDialog)  } 
/**   * Method tries to attach overlay dialog to the task identified by <var>taskName</var>. If task has been finished or not started - nothing is done and null is returned.  * @param taskService  task service  * @param activity     activity which should be masked  * @param taskName     name of the task which result is waited  * @param titleResId   dialog title  * @param messageResId dialog message  * @return not null dialog if task is running, null otherwise  */ @Nullable public static TaskOverlayDialog<?> attachToTask(@Nonnull TaskService taskService,@Nonnull Activity activity,@Nonnull String taskName,int titleResId,int messageResId){   TaskOverlayDialog<Object> taskOverlayDialog=newInstance(activity,titleResId,messageResId)    try {     taskService.tryAddTaskListener(taskName,Tasks.toFutureCallback(activity,taskOverlayDialog))      taskOverlayDialog.show()    }  catch (  NoSuchTaskException e) {     taskOverlayDialog=null    } catch (  TaskFinishedException e) {     taskOverlayDialog=null    }   return taskOverlayDialog  } 
@Override public void onSuccess(@Nonnull Activity context,V result){   dismiss()  } 
public synchronized void dismiss(){   finished=true    if (progressDialog.isShowing()) {     progressDialog.dismiss()    } } 
public synchronized void show(){   if (!finished) {     progressDialog.show()    } } 
@Override public void onFailure(@Nonnull Activity context,Throwable t){   dismiss()  } 
public void addTaskOverlayDialog(@Nullable TaskOverlayDialog<?> t){   if (t != null) {     taskOverlayDialogs.add(t)    } } 
public void dismissAll(){   for (  TaskOverlayDialog<?> taskOverlayDialog : taskOverlayDialogs) {     taskOverlayDialog.dismiss()    }   taskOverlayDialogs.clear()  } 
private Tasks(){   super()  } 
/**   * The only difference from  {@link Tasks#toFutureCallback(A, ContextCallback <A,V>)} is that all {@link ContextCallback}method calls will be done on UI thread (main application thread)  * @see Tasks#toFutureCallback(A, ContextCallback <A,V>)  */ @Nonnull public static <A extends Activity,V>FutureCallback<V> toUiThreadFutureCallback(@Nonnull A activity,@Nonnull ContextCallback<A,V> callback){   return FutureCallbackAdapter.newUiThreadAdapter(activity,callback)  } 
/**   * Method convert specified context <var>callback</var> to  {@link com.google.common.util.concurrent.FutureCallback}.  * @param context  context to be used in {@link ContextCallback} methods  * @param callback context callback  * @param < C >      type of context  * @param < V >      type of result  * @return {@link com.google.common.util.concurrent.FutureCallback} wrapper for specified <var>callback</var>  */ @Nonnull public static <C extends Context,V>FutureCallback<V> toFutureCallback(@Nonnull C context,@Nonnull ContextCallback<C,V> callback){   return FutureCallbackAdapter.newAdapter(context,callback)  } 
/**   * Method converts specified context <var>task</var> to  {@link Task}  * @param context context to be used in {@link ContextCallback} methods  * @param task    context task  * @param < C >     type of context  * @param < V >     type of result  * @return {@link Task} wrapper for specified <var>task</var>  */ @Nonnull public static <C extends Context,V>Task<V> toTask(@Nonnull C context,@Nonnull ContextTask<C,V> task){   return TaskAdapter.newAdapter(context,task)  } 
@Nonnull public static <C extends Context,V>NamedTask<V> toTask(@Nonnull C context,@Nonnull NamedContextTask<C,V> task){   return NamedTaskAdapter.newAdapter(context,task)  } 
/**   * The only difference from  {@link Tasks#toTask(C, ContextTask<C,V>)} is that all {@link ContextCallback}method calls will be done on UI thread (main application thread)  * @see Tasks#toTask(C, ContextTask<C,V>)  */ @Nonnull public static <A extends Activity,V>Task<V> toUiThreadTask(@Nonnull A activity,@Nonnull ContextTask<A,V> task){   return TaskAdapter.newUiThreadTaskAdapter(activity,task)  } 
@Nonnull public static <A extends Activity,V>NamedTask<V> toUiThreadTask(@Nonnull A activity,@Nonnull NamedContextTask<A,V> task){   return NamedTaskAdapter.newUiThreadAdapter(activity,task)  } 
private FutureCallbackAdapter(@Nonnull C context,@Nonnull ContextCallback<C,V> callback,boolean onUiThread){   super(context)    this.callback=callback    this.onUiThread=onUiThread  } 
private static <A extends Activity,V>FutureCallbackAdapter<A,V> newUiThreadAdapter(@Nonnull A activity,@Nonnull ContextCallback<A,V> callback){   return new FutureCallbackAdapter<A,V>(activity,callback,true)  } 
private static <C extends Context,V>FutureCallbackAdapter<C,V> newAdapter(@Nonnull C context,@Nonnull ContextCallback<C,V> callback){   return new FutureCallbackAdapter<C,V>(context,callback,false)  } 
@Override public void onSuccess(final V result){   final C context=getContext()    if (context != null) {     if (onUiThread) {       final Activity activity=(Activity)context        Threads.tryRunOnUiThread(activity,new Runnable(){         @Override public void run(){           callback.onSuccess(context,result)          }       } )      }  else {       callback.onSuccess(context,result)      }   } } 
@Override public void run(){   callback.onSuccess(context,result)  } 
@Override public void onFailure(final Throwable e){   final C context=getContext()    if (context != null) {     if (onUiThread) {       Threads.tryRunOnUiThread((Activity)context,new Runnable(){         @Override public void run(){           callback.onFailure(context,e)          }       } )      }  else {       callback.onFailure(context,e)      }   } } 
@Override public void run(){   callback.onFailure(context,e)  } 
private TaskAdapter(@Nonnull ContextTask<C,V> task,@Nonnull FutureCallback<V> callback){   this.task=task    this.callback=callback  } 
@Nonnull private static <A extends Activity,V>Task<V> newUiThreadTaskAdapter(@Nonnull A activity,@Nonnull ContextTask<A,V> task){   return new TaskAdapter<A,V>(task,toUiThreadFutureCallback(activity,task))  } 
@Nonnull private static <C extends Context,V>Task<V> newAdapter(@Nonnull C context,@Nonnull ContextTask<C,V> task){   return new TaskAdapter<C,V>(task,toFutureCallback(context,task))  } 
@Override public V call() throws Exception {   return task.call()  } 
@Override public void onSuccess(V result){   callback.onSuccess(result)  } 
@Override public void onFailure(Throwable t){   callback.onFailure(t)  } 
private NamedTaskAdapter(@Nonnull NamedContextTask<C,V> namedTask,@Nonnull Task<V> task){   this.task=task    this.namedTask=namedTask  } 
@Nonnull private static <C extends Context,V>NamedTaskAdapter<C,V> newAdapter(@Nonnull C context,@Nonnull NamedContextTask<C,V> namedTask){   return new NamedTaskAdapter<C,V>(namedTask,TaskAdapter.newAdapter(context,namedTask))  } 
@Nonnull private static <A extends Activity,V>NamedTaskAdapter<A,V> newUiThreadAdapter(@Nonnull A activity,@Nonnull NamedContextTask<A,V> namedTask){   return new NamedTaskAdapter<A,V>(namedTask,TaskAdapter.newUiThreadTaskAdapter(activity,namedTask))  } 
@Nonnull @Override public String getName(){   return namedTask.getName()  } 
@Override public V call() throws Exception {   return namedTask.call()  } 
@Override public void onSuccess(V result){   task.onSuccess(result)  } 
@Override public void onFailure(Throwable t){   task.onFailure(t)  } 
public HistoryDragProcessor(@Nonnull HistoryControl<T> historyControl){   this.historyControl=historyControl  } 
@Override public boolean processDragEvent(@Nonnull DragDirection dragDirection,@Nonnull DragButton dragButton,@Nonnull Point2d startPoint2d,@Nonnull MotionEvent motionEvent){   boolean result=false    Log.d(String.valueOf(dragButton.getId()),"History on drag event start: " + dragDirection)    final HistoryAction historyAction    if (dragDirection == DragDirection.up) {     historyAction=HistoryAction.undo    }  else   if (dragDirection == DragDirection.down) {     historyAction=HistoryAction.redo    }  else {     historyAction=null    }   if (historyAction != null) {     result=true      historyControl.doHistoryAction(historyAction)    }   return result  } 
/**   * Constructor applies saved preference value on tabHost returned by  android.app.TabActivity#getTabHost() method and registers as onTabChangeListener  * @param tabActivity  tab activity  * @param defaultTabId default tab (if no preference value is not defined)  */ public LastTabSaver(@Nonnull TabActivity tabActivity,@Nonnull String defaultTabId){   this.tabActivity=tabActivity    this.preference=StringPreference.of(getPreferenceKey(),defaultTabId)    final TabHost tabHost=tabActivity.getTabHost()    tabHost.setCurrentTabByTag(this.getLastOpenedTabId())    tabHost.setOnTabChangedListener(this)  } 
/**   * Method must be invoked on android.app.Activity#onDestroy() method of tab activity  */ public void destroy(){   final TabHost tabHost=tabActivity.getTabHost()    tabHost.setOnTabChangedListener(null)  } 
@Override public void onTabChanged(String tabId){   preference.putPreference(PreferenceManager.getDefaultSharedPreferences(tabActivity),tabId)  } 
@Nonnull public String getLastOpenedTabId(){   return preference.getPreference(PreferenceManager.getDefaultSharedPreferences(tabActivity))  } 
@Nonnull private String getPreferenceKey(){   return LAST_OPENED_TAB_P_KEY + tabActivity.getClass().getName()  } 
protected AbstractEnumPickerDialogPreference(Context context,AttributeSet attrs,@Nullable String defaultStringValue,boolean needValueText,@Nonnull Class<T> enumClass){   super(context,attrs,defaultStringValue,needValueText,EnumMapper.of(enumClass))    this.enumClass=enumClass  } 
@Nonnull @Override protected Picker.Range<T> createRange(@Nonnull T selected){   return new ListRange<T>(Arrays.asList(enumClass.getEnumConstants()),selected,new LabeledFormatter<T>(getContext()))  } 
protected AbstractPickerDialogPreference(Context context,AttributeSet attrs,@Nullable String defaultStringValue,boolean needValueText,@Nonnull Mapper<T> mapper){   super(context,attrs,defaultStringValue,needValueText,mapper)  } 
@Override protected LinearLayout.LayoutParams getParams(){   final LinearLayout.LayoutParams result=new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,LinearLayout.LayoutParams.WRAP_CONTENT)    result.gravity=Gravity.CENTER    return result  } 
@Nonnull @Override protected View createPreferenceView(@Nonnull Context context){   final Picker<T> result=new Picker<T>(context)    result.setOnChangeListener(this)    return result  } 
@Override protected void initPreferenceView(@Nonnull View v,@Nullable T value){   if (value != null) {     ((Picker<T>)v).setRange(createRange(value))    } } 
@Nonnull protected abstract Picker.Range<T> createRange(@Nonnull T selected)  
@Override public void onChanged(@Nonnull Picker picker,@Nonnull T o){   persistValue(o)  } 
@Nonnull @Override protected Double getDefaultStep(){   return 1d  } 
@Nonnull @Override protected NumberRange<Double> createRange(@Nonnull Interval<Double> boundaries,@Nonnull Double step,@Nonnull Double selected){   return DoubleRange.newInstance(boundaries.getLeftLimit(),boundaries.getRightLimit(),step,selected,simpleFormatter)  } 
public DoublePickerDialogPreference(Context context,AttributeSet attrs){   super(context,attrs,NumberIntervalMapper.of(Double.class))  } 
private DoubleFormatter(int numberOfDecimalDigits){   final StringBuilder sb=new StringBuilder("#.#")    for (int i=1  i < numberOfDecimalDigits  i++) {     sb.append("#")    }   this.df=new DecimalFormat(sb.toString())  } 
@Override public String formatValue(@Nullable Double value) throws IllegalArgumentException {   if (value == null) {     return "null"    }  else { synchronized (df) {       return df.format(value)      }   } } 
public FloatRangeSeekBarPreference(@Nonnull Context context,AttributeSet attrs){   super(context,attrs,NumberIntervalMapper.of(Float.class))  } 
@Nonnull @Override protected Float getDefaultStep(){   return 1f  } 
@Nonnull @Override protected Float add(@Nonnull Float l,@Nonnull Float r){   return l + r  } 
public IntegerPickerDialogPreference(Context context,AttributeSet attrs){   super(context,attrs,NumberIntervalMapper.of(Integer.class))  } 
@Nonnull @Override protected Integer getDefaultStep(){   return 1  } 
@Nonnull @Override protected NumberRange<Integer> createRange(@Nonnull Interval<Integer> boundaries,@Nonnull Integer step,@Nonnull Integer selected){   return IntegerRange.newInstance(boundaries.getLeftLimit(),boundaries.getRightLimit(),step,selected)  } 
public IntegerRangeSeekBarPreference(@Nonnull Context context,AttributeSet attrs){   super(context,attrs,NumberIntervalMapper.of(Integer.class))  } 
@Nonnull @Override protected Integer getDefaultStep(){   return 1  } 
@Nonnull @Override protected Integer add(@Nonnull Integer l,@Nonnull Integer r){   return l + r  } 
public MultiSelectListPreference(Context context){   this(context,null)  } 
public MultiSelectListPreference(Context context,@Nullable AttributeSet attrs){   super(context,attrs)    final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.MultiSelectListPreference)    final String separator    if (a.hasValue(R.styleable.MultiSelectListPreference_separator)) {     separator=a.getString(R.styleable.MultiSelectListPreference_separator)    }  else {     separator=DEFAULT_SEPARATOR    }   a.recycle()    this.mapper=new Mapper(separator)    this.checkedIndices=new boolean[getEntries().length]  } 
@Override public void setEntries(@Nonnull CharSequence[] entries){   super.setEntries(entries)    checkedIndices=new boolean[entries.length]  } 
@Override protected void onPrepareDialogBuilder(@Nonnull Builder builder){   final CharSequence[] entries=getEntries()    final CharSequence[] entryValues=getEntryValues()    if (entries == null || entryValues == null || entries.length != entryValues.length) {     throw new IllegalStateException("ListPreference requires an entries array and an entryValues array which are both the same length")    }   restoreCheckedEntries()    builder.setMultiChoiceItems(entries,checkedIndices,new DialogInterface.OnMultiChoiceClickListener(){     public void onClick(    DialogInterface dialog,    int which,    boolean value){       checkedIndices[which]=value      }   } )  } 
public void onClick(DialogInterface dialog,int which,boolean value){   checkedIndices[which]=value  } 
private void restoreCheckedEntries(){   final CharSequence[] entryValues=getEntryValues()    final List<String> values=mapper.parseValue(getValue())    if (values != null) {     for (    String value : values) {       for (int i=0  i < entryValues.length  i++) {         final CharSequence entry=entryValues[i]          if (entry.equals(value)) {           checkedIndices[i]=true            break          }       }     }   } } 
@Override protected void onDialogClosed(boolean positiveResult){   final CharSequence[] entryValues=getEntryValues()    if (positiveResult && entryValues != null) {     final List<String> checkedValues=new ArrayList<String>()      for (int i=0  i < entryValues.length  i++) {       if (checkedIndices[i]) {         checkedValues.add(entryValues[i].toString())        }     }     final String value=mapper.formatValue(checkedValues)      if (callChangeListener(value)) {       setValue(value)      }   } } 
public Mapper(@Nonnull String separator){   this.separator=separator  } 
@Override public String formatValue(@Nullable List<String> value) throws IllegalArgumentException {   return StringCollections.formatValue(value,separator,StringMapper.getInstance())  } 
@Override public List<String> parseValue(@Nullable String value) throws IllegalArgumentException {   return StringCollections.split(value,separator,StringMapper.getInstance())  } 
@Nonnull public static <T>org.solovyev.common.text.Mapper<List<T>> newListMapper(@Nonnull org.solovyev.common.text.Mapper<T> nestedMapper){   return new ListMapper<T>(DEFAULT_SEPARATOR,nestedMapper)  } 
@Nonnull public static <T>org.solovyev.common.text.Mapper<List<T>> newListMapper(@Nonnull org.solovyev.common.text.Mapper<T> nestedMapper,@Nonnull String separator){   return new ListMapper<T>(separator,nestedMapper)  } 
public ListMapper(@Nonnull String separator,@Nonnull org.solovyev.common.text.Mapper<T> nestedMapper){   this.separator=separator    this.nestedMapper=nestedMapper  } 
@Override public String formatValue(@Nullable List<T> value) throws IllegalArgumentException {   return StringCollections.formatValue(value,separator,nestedMapper)  } 
@Override public List<T> parseValue(@Nullable String value) throws IllegalArgumentException {   return StringCollections.split(value,separator,nestedMapper)  } 
protected NumberPickerDialogPreference(Context context,AttributeSet attrs,@Nonnull NumberIntervalMapper<N> mapper){   super(context,attrs,null,false,mapper.getMapper())    boundaries=mapper.parseValue(attrs.getAttributeValue(AbstractDialogPreference.localNameSpace,"boundaries"))    final String stringStep=attrs.getAttributeValue(AbstractDialogPreference.localNameSpace,"step")    if (stringStep == null) {     step=getDefaultStep()    }  else {     step=mapper.getMapper().parseValue(stringStep)    } } 
@Nonnull protected abstract N getDefaultStep()  
@Nonnull @Override protected Picker.Range<N> createRange(@Nonnull N selected){   return createRange(boundaries,step,selected)  } 
@Nonnull protected abstract NumberRange<N> createRange(@Nonnull Interval<N> boundaries,@Nonnull N step,@Nonnull N selected)  
public RangeSeekBarPreference(@Nonnull Context context,AttributeSet attrs,@Nonnull NumberIntervalMapper<T> mapper){   super(context,attrs,null,true,mapper)    boundaries=mapper.parseValue(attrs.getAttributeValue(AbstractDialogPreference.localNameSpace,"boundaries"))    final String stepValue=attrs.getAttributeValue(AbstractDialogPreference.localNameSpace,"step")    if (stepValue == null) {     step=getDefaultStep()    }  else {     step=mapper.getMapper().parseValue(stepValue)    } } 
@Nonnull protected abstract T getDefaultStep()  
@Nonnull protected View createPreferenceView(@Nonnull Context context){   int count=0    for (T t=boundaries.getLeftLimit()  t.compareTo(boundaries.getRightLimit()) <= 0  t=add(t,step)) {     count+=1    }   final NumberRangeSeekBar<T> result=new NumberRangeSeekBar<T>(boundaries,count,context)    result.setNotifyWhileDragging(true)    result.setOnRangeSeekBarChangeListener(this)    return result  } 
@Nonnull protected abstract T add(@Nonnull T l,@Nonnull T r)  
@Override protected LinearLayout.LayoutParams getParams(){   return null  } 
@Override protected void initPreferenceView(@Nonnull View v,Interval<T> value){   if (value != null) {     ((NumberRangeSeekBar<T>)v).setSelectedMinValue(value.getLeftLimit())      ((NumberRangeSeekBar<T>)v).setSelectedMaxValue(value.getRightLimit())      setValueText(value)    } } 
@Override public void rangeSeekBarValuesChanged(T minValue,T maxValue,boolean changeComplete){   final Interval<T> interval=Intervals.newClosedInterval(minValue,maxValue)    if (changeComplete) {     persistValue(interval)    }   setValueText(interval)  } 
private void setValueText(@Nonnull Interval<T> interval){   final String t=String.valueOf(interval)    final String valueText=getValueText()    updateValueText(valueText == null ? t : t.concat(valueText))  } 
/**   * Creates a new RangeSeekBar.  * @param minValue The minimum value of the selectable range.  * @param maxValue The maximum value of the selectable range.  * @param steps    number of steps to be used in range seek bar  * @param context  parent context  * @throws IllegalArgumentException Will be thrown if min/max value types are not one of Long, Double, Integer, Float, Short, Byte or BigDecimal.  */ public AbstractRangeSeekBar(@Nonnull T minValue,@Nonnull T maxValue,@Nullable Integer steps,Context context) throws IllegalArgumentException {   super(context)    this.minValue=minValue    this.maxValue=maxValue    this.toDoubleConverter=getToDoubleConverter()    this.toTConverter=getToTConverter()    fromValueNormalizer=new LinearNormalizer(toDoubleConverter.convert(minValue),toDoubleConverter.convert(maxValue))    tc=new ThumbContainer()    fromScreenNormalizer=new Normalizer(){     @Override public double normalize(    double value){       int width=getWidth()        if (width <= 2 * tc.padding) {         return 0d        }  else {         double result=(value - tc.padding) / (width - 2 * tc.padding)          return Math.min(1d,Math.max(0d,result))        }     }     @Override public double denormalize(    double value){       return (float)(tc.padding + value * (getWidth() - 2 * tc.padding))      }   }   } 
@Override public double normalize(double value){   int width=getWidth()    if (width <= 2 * tc.padding) {     return 0d    }  else {     double result=(value - tc.padding) / (width - 2 * tc.padding)      return Math.min(1d,Math.max(0d,result))    } } 
@Override public double denormalize(double value){   return (float)(tc.padding + value * (getWidth() - 2 * tc.padding))  } 
@Nonnull protected abstract Converter<Double,T> getToTConverter()  
@Nonnull protected abstract Converter<T,Double> getToDoubleConverter()  
public boolean isNotifyWhileDragging(){   return notifyWhileDragging  } 
/**   * Should the widget notify the listener callback while the user is still dragging a thumb? Default is false.  * @param flag  */ public void setNotifyWhileDragging(boolean flag){   this.notifyWhileDragging=flag  } 
/**   * Returns the absolute minimum value of the range that has been set at construction time.  * @return The absolute minimum value of the range.  */ @Nonnull public T getMinValue(){   return minValue  } 
/**   * Returns the absolute maximum value of the range that has been set at construction time.  * @return The absolute maximum value of the range.  */ @Nonnull public T getMaxValue(){   return maxValue  } 
/**   * Returns the currently selected min value.  * @return The currently selected min value.  */ public T getSelectedMinValue(){   return denormalizeValue(normalizedMinValue)  } 
/**   * Sets the currently selected minimum value. The widget will be invalidated and redrawn.  * @param value The Number value to set the minimum value to. Will be clamped to given absolute minimum/maximum range.  */ public void setSelectedMinValue(@Nonnull T value){   setNormalizedMinValue(normalizeValue(value))  } 
/**   * Returns the currently selected max value.  * @return The currently selected max value.  */ public T getSelectedMaxValue(){   return denormalizeValue(normalizedMaxValue)  } 
/**   * Sets the currently selected maximum value. The widget will be invalidated and redrawn.  * @param value The Number value to set the maximum value to. Will be clamped to given absolute minimum/maximum range.  */ public void setSelectedMaxValue(@Nonnull T value){   setNormalizedMaxValue(normalizeValue(value))  } 
/**   * Registers given listener callback to notify about changed selected values.  * @param listener The listener to notify about changed selected values.  */ public void setOnRangeSeekBarChangeListener(OnRangeSeekBarChangeListener<T> listener){   this.listener=listener  } 
/**   * Handles thumb selection and movement. Notifies listener callback on certain events.  */ @Override public boolean onTouchEvent(MotionEvent event){ switch (event.getAction()) { case MotionEvent.ACTION_DOWN:     pressedThumb=evalPressedThumb(event.getX())    invalidate()  break  case MotionEvent.ACTION_MOVE: if (pressedThumb != null) { double value=convertToNormalizedValue(event.getX())  if (Thumb.MIN.equals(pressedThumb)) {   setNormalizedMinValue(value)  }  else if (Thumb.MAX.equals(pressedThumb)) {   setNormalizedMaxValue(value)  } if (notifyWhileDragging && listener != null) {   listener.rangeSeekBarValuesChanged(getSelectedMinValue(),getSelectedMaxValue(),false)  } } break  case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: pressedThumb=null  invalidate()  if (listener != null) { listener.rangeSeekBarValuesChanged(getSelectedMinValue(),getSelectedMaxValue(),true)  } break  } return true  } 
/**   * Ensures correct size of the widget.  */ @Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   int width=200    if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(widthMeasureSpec)) {     width=MeasureSpec.getSize(widthMeasureSpec)    }   int height=tc.thumbImage.getHeight()    if (MeasureSpec.UNSPECIFIED != MeasureSpec.getMode(heightMeasureSpec)) {     height=Math.min(height,MeasureSpec.getSize(heightMeasureSpec))    }   setMeasuredDimension(width,height)  } 
/**   * Draws the widget on the given canvas.  */ @Override protected void onDraw(Canvas canvas){   super.onDraw(canvas)    final RectF rect=tc.getRect()    paint.setStyle(Style.FILL)    paint.setColor(Color.GRAY)    canvas.drawRect(rect,paint)    rect.left=convertToScreenValue(normalizedMinValue)    rect.right=convertToScreenValue(normalizedMaxValue)    paint.setColor(Color.rgb(255,165,0))    canvas.drawRect(rect,paint)    drawThumb(convertToScreenValue(normalizedMinValue),Thumb.MIN == pressedThumb,canvas)    drawThumb(convertToScreenValue(normalizedMaxValue),Thumb.MAX == pressedThumb,canvas)  } 
/**   * Draws the "normal" resp. "pressed" thumb image on specified x-coordinate.  * @param normalizedToScreenValue The x-coordinate in screen space where to draw the image.  * @param pressed                 Is the thumb currently in "pressed" state?  * @param canvas                  The canvas to draw upon.  */ private void drawThumb(float normalizedToScreenValue,boolean pressed,Canvas canvas){   canvas.drawBitmap(tc.getImage(pressed),normalizedToScreenValue - tc.thumbHalfWidth,(float)((0.5f * getHeight()) - tc.thumbHalfHeight),paint)  } 
/**   * Decides which (if any) thumb is touched by the given x-coordinate.  * @param touchX The x-coordinate of a touch event in screen space.  * @return The pressed thumb or null if none has been touched.  */ private Thumb evalPressedThumb(float touchX){   Thumb result=null    boolean minThumbPressed=isInThumbRange(touchX,normalizedMinValue)    boolean maxThumbPressed=isInThumbRange(touchX,normalizedMaxValue)    if (minThumbPressed && maxThumbPressed) {     result=(touchX / getWidth() > 0.5f) ? Thumb.MIN : Thumb.MAX    }  else   if (minThumbPressed) {     result=Thumb.MIN    }  else   if (maxThumbPressed) {     result=Thumb.MAX    }   return result  } 
/**   * Decides if given x-coordinate in screen space needs to be interpreted as "within" the normalized thumb x-coordinate.  * @param touchX               The x-coordinate in screen space to check.  * @param normalizedThumbValue The normalized x-coordinate of the thumb to check.  * @return true if x-coordinate is in thumb range, false otherwise.  */ private boolean isInThumbRange(float touchX,double normalizedThumbValue){   return Math.abs(touchX - convertToScreenValue(normalizedThumbValue)) <= tc.thumbHalfWidth  } 
/**   * Sets normalized min value to value so that 0 <= value <= normalized max value <= 1. The View will get invalidated when calling this method.  * @param value The new normalized min value to set.  */ private void setNormalizedMinValue(double value){   normalizedMinValue=Math.max(0d,Math.min(1d,Math.min(value,normalizedMaxValue)))    invalidate()  } 
/**   * Sets normalized max value to value so that 0 <= normalized min value <= value <= 1. The View will get invalidated when calling this method.  * @param value The new normalized max value to set.  */ private void setNormalizedMaxValue(double value){   normalizedMaxValue=Math.max(0d,Math.min(1d,Math.max(value,normalizedMinValue)))    invalidate()  } 
/**   * Converts a normalized value to a Number object in the value space between absolute minimum and maximum.  * @param normalized  * @return  */ @SuppressWarnings("unchecked") private T denormalizeValue(double normalized){   return toTConverter.convert(fromValueNormalizer.denormalize(normalized))  } 
/**   * Converts the given Number value to a normalized double.  * @param value The Number value to normalize.  * @return The normalized double.  */ private double normalizeValue(T value){   return fromValueNormalizer.normalize(toDoubleConverter.convert(value))  } 
/**   * Converts a normalized value into screen space.  * @param normalizedValue The normalized value to convert.  * @return The converted value in screen space.  */ private float convertToScreenValue(double normalizedValue){   return (float)this.fromScreenNormalizer.denormalize(normalizedValue)  } 
/**   * Converts screen space x-coordinates into normalized values.  * @param screenValue The x-coordinate in screen space to convert.  * @return The normalized value.  */ private double convertToNormalizedValue(float screenValue){   return this.fromScreenNormalizer.normalize(screenValue)  } 
void rangeSeekBarValuesChanged(T minValue,T maxValue,boolean changeComplete)  
public RectF getRect(){   return new RectF(padding,0.5f * (getHeight() - lineHeight),getWidth() - padding,0.5f * (getHeight() + lineHeight))  } 
public Bitmap getImage(boolean pressed){   return pressed ? thumbPressedImage : thumbImage  } 
void buildView(@Nonnull Activity activity)  
private AndroidViewUtils(){   throw new AssertionError()  } 
public static boolean drawDrawables(Canvas canvas,@Nonnull TextView textView){   final int compoundPaddingLeft=textView.getCompoundPaddingLeft()    final int compoundPaddingTop=textView.getCompoundPaddingTop()    final int compoundPaddingRight=textView.getCompoundPaddingRight()    final int compoundPaddingBottom=textView.getCompoundPaddingBottom()    final int scrollX=textView.getScrollX()    final int scrollY=textView.getScrollY()    final int right=textView.getRight()    final int left=textView.getLeft()    final int bottom=textView.getBottom()    final int top=textView.getTop()    final Drawable[] drawables=textView.getCompoundDrawables()    if (drawables != null) {     int vspace=bottom - top - compoundPaddingBottom- compoundPaddingTop      int hspace=right - left - compoundPaddingRight- compoundPaddingLeft      Drawable topDr=drawables[1]      if (topDr != null) {       canvas.save()        canvas.translate(scrollX + compoundPaddingLeft + (hspace - topDr.getBounds().width()) / 2,scrollY + textView.getPaddingTop() + vspace / 2)        topDr.draw(canvas)        canvas.restore()        return true      }   }   return false  } 
public static void applyButtonDef(@Nonnull Button button,@Nonnull ButtonDef buttonDef){   button.setText(buttonDef.getText())    final Integer drawableResId=buttonDef.getDrawableResId()    if (drawableResId != null) {     button.setPadding(0,0,0,0)      final Drawable drawable=button.getContext().getResources().getDrawable(drawableResId)      button.setCompoundDrawablesWithIntrinsicBounds(null,drawable,null,null)      button.setCompoundDrawablePadding(0)    }   applyViewDef(button,buttonDef)  } 
public static void applyButtonDef(@Nonnull ImageButton imageButton,@Nonnull ButtonDef buttonDef){   final Integer drawableResId=buttonDef.getDrawableResId()    if (drawableResId != null) {     imageButton.setImageDrawable(imageButton.getContext().getResources().getDrawable(drawableResId))    }   applyViewDef(imageButton,buttonDef)  } 
public static void applyViewDef(@Nonnull View view,@Nonnull ViewDef viewDef){   final Integer backgroundResId=viewDef.getBackgroundResId()    if (backgroundResId != null) {     view.setBackgroundResource(backgroundResId)    }   final String tag=viewDef.getTag()    if (tag != null) {     view.setTag(tag)    } } 
public void onTextResize(TextView textView,float oldSize,float newSize)  
public AutoResizeTextView(Context context){   super(context)  } 
public AutoResizeTextView(Context context,AttributeSet attrs){   super(context,attrs)  } 
public AutoResizeTextView(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)  } 
/**   * When text changes, set the force resize flag to true and resetInterpreter the text size.  */ @Override protected void onTextChanged(final CharSequence text,final int start,final int before,final int after){   needsResize=true  } 
/**   * If the text view size changed, set the force resize flag to true  */ @Override protected void onSizeChanged(int w,int h,int oldw,int oldh){   if (w != oldw || h != oldh) {     needsResize=true    } } 
/**   * Register listener to receive resize notifications  * @param listener  */ public void setOnResizeListener(OnTextResizeListener listener){   textResizeListener=listener  } 
/**   * Override the set text size to update our internal reference values  */ @Override public void setTextSize(int unit,float size){   super.setTextSize(unit,size)  } 
/**   * Override the set line spacing to update our internal reference values  */ @Override public void setLineSpacing(float add,float mult){   super.setLineSpacing(add,mult)    spacingMult=mult    spacingAdd=add  } 
/**   * Set the lower text size limit and invalidate the view  * @param minTextSize  */ public void setMinTextSize(float minTextSize){   this.minTextSize=minTextSize    requestLayout()    invalidate()  } 
/**   * Return lower text size limit  * @return  */ public float getMinTextSize(){   return minTextSize  } 
/**   * Set flag to add ellipsis to text that overflows at the smallest text size  * @param addEllipsis  */ public void setAddEllipsis(boolean addEllipsis){   this.addEllipsis=addEllipsis  } 
/**   * Return flag to add ellipsis to text that overflows at the smallest text size  * @return  */ public boolean getAddEllipsis(){   return addEllipsis  } 
/**   * Resize text after measuring  */ @Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){   if (changed || needsResize) {     int widthLimit=(right - left) - getCompoundPaddingLeft() - getCompoundPaddingRight()      int heightLimit=(bottom - top) - getCompoundPaddingBottom() - getCompoundPaddingTop()      resizeText(widthLimit,heightLimit,getText())    }   super.onLayout(changed,left,top,right,bottom)  } 
/**   * Resize the text size with default width and height  */ public void resizeText(){   resizeText(getText())  } 
private void resizeText(final CharSequence text){   int heightLimit=getHeight() - getPaddingBottom() - getPaddingTop()    int widthLimit=getWidth() - getPaddingLeft() - getPaddingRight()    resizeText(widthLimit,heightLimit,text)  } 
/**   * Resize the text size with specified width and height  * @param width  * @param height  * @param text  */ private void resizeText(int width,int height,CharSequence text){   Log.d(this.getClass().getName(),"Resizing: w=" + width + ", h="+ height+ ", text='"+ text+ "'")    if (text == null || text.length() == 0 || height <= 0 || width <= 0) {     return    }   TextPaint textPaint=getPaint()    float oldTextSize=textPaint.getTextSize()    Log.d(this.getClass().getName(),"Old text size: " + oldTextSize)    float newTextSize=initialTextSize + 2    int newTextHeight    if (text instanceof Editable) {     ((Editable)text).append("|")    }   try {     newTextHeight=getTextRect(text,textPaint,width,newTextSize)      logDimensions(newTextSize,newTextHeight)      if (newTextHeight > height) {       while (newTextHeight > height) {         if (newTextSize <= minTextSize) {           break          }         newTextSize=Math.max(newTextSize - 1,minTextSize)          newTextHeight=getTextRect(text,textPaint,width,newTextSize)          logDimensions(newTextSize,newTextHeight)        }     }  else {       while (newTextHeight < height) {         if (newTextSize <= minTextSize) {           break          }         newTextSize=Math.max(newTextSize + 1,minTextSize)          newTextHeight=getTextRect(text,textPaint,width,newTextSize)          logDimensions(newTextSize,newTextHeight)        }     }   }   finally {     if (text instanceof Editable) {       ((Editable)text).delete(text.length() - 1,text.length())      }   }   initialTextSize=newTextSize    if (addEllipsis && newTextSize == minTextSize && newTextHeight > height) {     StaticLayout layout=new StaticLayout(text,textPaint,width,Alignment.ALIGN_NORMAL,spacingMult,spacingAdd,false)      layout.draw(textResizeCanvas)      int lastLine=layout.getLineForVertical(height) - 1      int start=layout.getLineStart(lastLine)      int end=layout.getLineEnd(lastLine)      float lineWidth=layout.getLineWidth(lastLine)      float ellipseWidth=textPaint.measureText(ellipsis)      while (width < lineWidth + ellipseWidth) {       lineWidth=textPaint.measureText(text.subSequence(start,--end + 1).toString())      }     setText(text.subSequence(0,end) + ellipsis)    }   textPaint.setTextSize(newTextSize)    setLineSpacing(spacingAdd,spacingMult)    if (textResizeListener != null) {     textResizeListener.onTextResize(this,oldTextSize,newTextSize)    }   needsResize=false  } 
private void logDimensions(float newTextSize,int newTextHeight){   Log.d(this.getClass().getName(),"Nex text size: " + newTextSize + ", new text height: "+ newTextHeight)  } 
private int getTextRect(CharSequence source,TextPaint paint,int width,float textSize){   paint.setTextSize(textSize)    StaticLayout layout=new StaticLayout(source,paint,width,Alignment.ALIGN_NORMAL,spacingMult,spacingAdd,false)    layout.draw(textResizeCanvas)    return layout.getHeight()  } 
@Nullable Integer getDrawableResId()  
@Nullable CharSequence getText()  
public ColorButton(Context context,AttributeSet attrs){   this(context,attrs,true)  } 
public ColorButton(Context context,AttributeSet attrs,boolean init){   super(context,attrs)    TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DragButton)    if (a.hasValue(R.styleable.DragButton_hTextPosition)) {     this.hTextPosition=Float.valueOf(a.getString(R.styleable.DragButton_hTextPosition))    }  else {     this.hTextPosition=H_TEXT_POSITION_DEFAULT_VALUE    }   a.recycle()    if (init) {     init(context)    }   this.onClickListener=new OnClickListenerVibrator((Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE),PreferenceManager.getDefaultSharedPreferences(context))  } 
protected void init(Context context){   final Resources resources=getResources()    magicFlameColour=resources.getColor(R.color.magic_flame)    feedbackPaint=new Paint()    feedbackPaint.setStyle(Style.STROKE)    feedbackPaint.setStrokeWidth(2)    getPaint().setColor(getCurrentTextColor())    animationStart=-1  } 
@Override public void onSizeChanged(int w,int h,int oldW,int oldH){   measureText()  } 
protected void measureText(){   Paint paint=getPaint()    if (getText() != null) {     textPosition=getTextPosition(paint,getText())    } } 
private Point2d getTextPosition(@Nonnull Paint paint,@Nonnull CharSequence text){   final Point2d result=new Point2d()    result.setX(hTextPosition * getWidth() - 0.5f * paint.measureText(text.toString()))    float height=getHeight() - paint.ascent() - paint.descent()    result.setY(height / 2)    return result  } 
@Override protected void onTextChanged(CharSequence text,int start,int before,int after){   measureText()  } 
public void drawMagicFlame(int duration,Canvas canvas){   int alpha=255 - 255 * duration / CLICK_FEEDBACK_DURATION    int color=magicFlameColour | (alpha << 24)    feedbackPaint.setColor(color)    canvas.drawRect(1,1,getWidth() - 1,getHeight() - 1,feedbackPaint)  } 
@Override public void onDraw(Canvas canvas){   if (drawMagicFlame) {     if (animationStart != -1) {       int animDuration=(int)(System.currentTimeMillis() - animationStart)        if (animDuration >= CLICK_FEEDBACK_DURATION) {         animationStart=-1        }  else {         drawMagicFlame(animDuration,canvas)          postInvalidateDelayed(CLICK_FEEDBACK_INTERVAL)        }     }   }   CharSequence text=getText()    if (!Strings.isEmpty(text) && textPosition != null) {     if (showText) {       canvas.drawText(text,0,text.length(),textPosition.getX(),textPosition.getY(),getPaint())      }   }  else {     AndroidViewUtils.drawDrawables(canvas,this)    } } 
public void animateClickFeedback(){   animationStart=System.currentTimeMillis()    invalidate()  } 
@Override public boolean performClick(){   vibrate()    return super.performClick()  } 
@Override public boolean performLongClick(){   vibrate()    return super.performLongClick()  } 
private void vibrate(){   this.onClickListener.onClick(this)  } 
@Override public boolean onTouchEvent(MotionEvent event){   boolean result=super.onTouchEvent(event)    if (this.drawMagicFlame) { switch (event.getAction()) { case MotionEvent.ACTION_UP:       animateClickFeedback()      break  case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_CANCEL:   invalidate()  break  } } return result  } 
public void setDrawMagicFlame(boolean drawMagicFlame){   this.drawMagicFlame=drawMagicFlame  } 
public boolean isShowText(){   return showText  } 
public void setShowText(boolean showText){   this.showText=showText  } 
void colorChanged(int color)  
ColorPickerView(Context c,OnColorChangedListener l,int color){   super(c)    mListener=l    mColors=new int[]{0xFFFF0000,0xFFFF00FF,0xFF0000FF,0xFF00FFFF,0xFF00FF00,0xFFFFFF00,0xFFFF0000}    Shader s=new SweepGradient(0,0,mColors,null)    mPaint=new Paint(Paint.ANTI_ALIAS_FLAG)    mPaint.setShader(s)    mPaint.setStyle(Paint.Style.STROKE)    mPaint.setStrokeWidth(32)    mCenterPaint=new Paint(Paint.ANTI_ALIAS_FLAG)    mCenterPaint.setColor(color)    mCenterPaint.setStrokeWidth(5)  } 
@Override protected void onDraw(Canvas canvas){   float r=CENTER_X - mPaint.getStrokeWidth() * 0.5f    canvas.translate(CENTER_X,CENTER_X)    canvas.drawOval(new RectF(-r,-r,r,r),mPaint)    canvas.drawCircle(0,0,CENTER_RADIUS,mCenterPaint)    if (mTrackingCenter) {     int c=mCenterPaint.getColor()      mCenterPaint.setStyle(Paint.Style.STROKE)      if (mHighlightCenter) {       mCenterPaint.setAlpha(0xFF)      }  else {       mCenterPaint.setAlpha(0x80)      }     canvas.drawCircle(0,0,CENTER_RADIUS + mCenterPaint.getStrokeWidth(),mCenterPaint)      mCenterPaint.setStyle(Paint.Style.FILL)      mCenterPaint.setColor(c)    } } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   setMeasuredDimension(CENTER_X * 2,CENTER_Y * 2)  } 
private int floatToByte(float x){   int n=java.lang.Math.round(x)    return n  } 
private int pinToByte(int n){   if (n < 0) {     n=0    }  else   if (n > 255) {     n=255    }   return n  } 
private int ave(int s,int d,float p){   return s + java.lang.Math.round(p * (d - s))  } 
private int interpColor(int colors[],float unit){   if (unit <= 0) {     return colors[0]    }   if (unit >= 1) {     return colors[colors.length - 1]    }   float p=unit * (colors.length - 1)    int i=(int)p    p-=i    int c0=colors[i]    int c1=colors[i + 1]    int a=ave(Color.alpha(c0),Color.alpha(c1),p)    int r=ave(Color.red(c0),Color.red(c1),p)    int g=ave(Color.green(c0),Color.green(c1),p)    int b=ave(Color.blue(c0),Color.blue(c1),p)    return Color.argb(a,r,g,b)  } 
private int rotateColor(int color,float rad){   float deg=rad * 180 / 3.1415927f    int r=Color.red(color)    int g=Color.green(color)    int b=Color.blue(color)    ColorMatrix cm=new ColorMatrix()    ColorMatrix tmp=new ColorMatrix()    cm.setRGB2YUV()    tmp.setRotate(0,deg)    cm.postConcat(tmp)    tmp.setYUV2RGB()    cm.postConcat(tmp)    final float[] a=cm.getArray()    int ir=floatToByte(a[0] * r + a[1] * g + a[2] * b)    int ig=floatToByte(a[5] * r + a[6] * g + a[7] * b)    int ib=floatToByte(a[10] * r + a[11] * g + a[12] * b)    return Color.argb(Color.alpha(color),pinToByte(ir),pinToByte(ig),pinToByte(ib))  } 
@Override public boolean onTouchEvent(MotionEvent event){   float x=event.getX() - CENTER_X    float y=event.getY() - CENTER_Y    boolean inCenter=java.lang.Math.sqrt(x * x + y * y) <= CENTER_RADIUS  switch (event.getAction()) { case MotionEvent.ACTION_DOWN:     mTrackingCenter=inCenter    if (inCenter) {     mHighlightCenter=true      invalidate()      break    } case MotionEvent.ACTION_MOVE: if (mTrackingCenter) {   if (mHighlightCenter != inCenter) {     mHighlightCenter=inCenter      invalidate()    } }  else {   float angle=(float)java.lang.Math.atan2(y,x)    float unit=angle / (2 * PI)    if (unit < 0) {     unit+=1    }   mCenterPaint.setColor(interpColor(mColors,unit))    invalidate()  } break  case MotionEvent.ACTION_UP: if (mTrackingCenter) { if (inCenter) { mListener.colorChanged(mCenterPaint.getColor())  } mTrackingCenter=false  invalidate()  } break  } return true  } 
public ColorPickerDialog(Context context,OnColorChangedListener listener,int initialColor){   super(context)    mListener=listener    mInitialColor=initialColor  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    OnColorChangedListener l=new OnColorChangedListener(){     public void colorChanged(    int color){       mListener.colorChanged(color)        dismiss()      }   }     setContentView(new ColorPickerView(getContext(),l,mInitialColor))    setTitle("Pick a Color")  } 
public void colorChanged(int color){   mListener.colorChanged(color)    dismiss()  } 
private ConfirmationDialogBuilder(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,int messageResId){   this.fragmentActivity=fragmentActivity    this.fragmentTag=fragmentTag    this.messageResId=messageResId  } 
@Nonnull public static ConfirmationDialogBuilder newInstance(@Nonnull FragmentActivity fragmentActivity,@Nonnull String fragmentTag,int messageResId){   return new ConfirmationDialogBuilder(fragmentActivity,fragmentTag,messageResId)  } 
@Nonnull public ConfirmationDialogBuilder setTitleResId(int titleResId){   this.titleResId=titleResId    return this  } 
@Nonnull public ConfirmationDialogBuilder setPositiveButtonTextResId(int positiveButtonTextResId){   this.positiveButtonTextResId=positiveButtonTextResId    return this  } 
@Nonnull public ConfirmationDialogBuilder setNegativeButtonTextResId(int negativeButtonTextResId){   this.negativeButtonTextResId=negativeButtonTextResId    return this  } 
@Nonnull public ConfirmationDialogBuilder setPositiveHandler(@Nullable DialogInterface.OnClickListener positiveHandler){   this.positiveHandler=positiveHandler    return this  } 
@Nonnull public ConfirmationDialogBuilder setNegativeHandler(@Nullable DialogInterface.OnClickListener negativeHandler){   this.negativeHandler=negativeHandler    return this  } 
@Nonnull @Override public DialogFragmentShower build(){   AlertDialog.Builder builder=new AlertDialog.Builder(fragmentActivity)    builder.setTitle(titleResId)    builder.setMessage(messageResId)    builder.setPositiveButton(positiveButtonTextResId,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       if (positiveHandler != null) {         positiveHandler.onClick(dialog,which)        }     }   } )    builder.setNegativeButton(negativeButtonTextResId,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       if (negativeHandler != null) {         negativeHandler.onClick(dialog,which)        }     }   } )    return new DialogFragmentShower(fragmentActivity,fragmentTag,builder)  } 
@Override public void onClick(DialogInterface dialog,int which){   if (positiveHandler != null) {     positiveHandler.onClick(dialog,which)    } } 
@Override public void onClick(DialogInterface dialog,int which){   if (negativeHandler != null) {     negativeHandler.onClick(dialog,which)    } } 
void setData(@Nonnull D data)  
public DoubleRange(@Nonnull Double min,@Nonnull Double max,@Nonnull Double step,int startPosition,@Nullable Formatter<Double> formatter){   super(min,max,step,startPosition,formatter)  } 
@Nonnull public static NumberRange<Double> newInstance(@Nonnull Double min,@Nonnull Double max,@Nonnull Double step,@Nonnull Double selected,@Nullable Formatter<Double> formatter){   if (selected < min || selected > max) {     throw new IllegalArgumentException("Selected value: " + selected + " should be >= "+ min+ " and <= "+ max+ "!")    }   int startPosition=0    for (double i=min  i < selected  i+=step) {     startPosition+=1    }   return new DoubleRange(min,max,step,startPosition,formatter)  } 
@Override protected int getCount(@Nonnull Double min,@Nonnull Double max,@Nonnull Double step){   int result=(int)((max - min) / step)    return result + 1  } 
@Nonnull @Override protected Double getValueAt(int position,@Nonnull Double min,@Nonnull Double max,@Nonnull Double step){   return min + position * step  } 
private DirectionTextData(@Nonnull GuiDragDirection direction,@Nonnull String text){   this.direction=direction    this.text=text  } 
protected void init(@Nonnull Paint basePaint,int color,int alpha){   paint.set(basePaint)    paint.setColor(color)    paint.setAlpha(alpha)    paint.setTextSize(basePaint.getTextSize() * scale)  } 
@Nonnull public GuiDragDirection getDirection(){   return direction  } 
@Nonnull public String getText(){   return text  } 
@Nonnull public Point2d getPosition(){   return position  } 
@Nonnull public TextPaint getPaint(){   return paint  } 
@Nonnull public Float getScale(){   return scale  } 
public boolean isShow(){   return show  } 
@Override public int getAttributeId(){   return R.styleable.DirectionDragButton_textUp  } 
@Nonnull @Override public Point2d getTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,int w,int h){   return getUpDownTextPosition(paint,basePaint,text,baseText,1,w,h)  } 
@Override public int getAttributeId(){   return R.styleable.DirectionDragButton_textDown  } 
@Nonnull @Override public Point2d getTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,int w,int h){   return getUpDownTextPosition(paint,basePaint,text,baseText,-1,w,h)  } 
@Override public int getAttributeId(){   return R.styleable.DirectionDragButton_textLeft  } 
@Nonnull @Override public Point2d getTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,int w,int h){   return getLeftRightTextPosition(paint,basePaint,text,baseText,w,h,true)  } 
@Override public int getAttributeId(){   return R.styleable.DirectionDragButton_textRight  } 
@Nonnull @Override public Point2d getTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,int w,int h){   return getLeftRightTextPosition(paint,basePaint,text,baseText,w,h,false)  } 
void GuiDragDirection(@Nonnull DragDirection dragDirection,int attributePosition){   this.dragDirection=dragDirection    this.attributePosition=attributePosition  } 
public abstract int getAttributeId()  
public int getAttributePosition(){   return attributePosition  } 
@Nonnull public abstract Point2d getTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,int w,int h)  
@Nonnull private static Point2d getLeftRightTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,CharSequence text,@Nonnull CharSequence baseText,int w,int h,boolean left){   final Point2d result=new Point2d()    if (left) {     float width=paint.measureText(" ")      result.setX(width)    }  else {     float width=paint.measureText(text.toString() + " ")      result.setX(w - width)    }   float selfHeight=paint.ascent() + paint.descent()    basePaint.measureText(Strings.getNotEmpty(baseText,"|"))    result.setY(h / 2 - selfHeight / 2)    return result  } 
@Nonnull private static Point2d getUpDownTextPosition(@Nonnull Paint paint,@Nonnull Paint basePaint,@Nonnull CharSequence text,CharSequence baseText,float direction,int w,int h){   final Point2d result=new Point2d()    float width=paint.measureText(text.toString() + " ")    result.setX(w - width)    float selfHeight=paint.ascent() + paint.descent()    basePaint.measureText(Strings.getNotEmpty(baseText,"|"))    if (direction < 0) {     result.setY(h / 2 + h / 3 - selfHeight / 2)    }  else {     result.setY(h / 2 - h / 3 - selfHeight / 2)    }   return result  } 
@Nullable public static GuiDragDirection valueOf(@Nonnull DragDirection dragDirection){   for (  GuiDragDirection guiDragDirection : values()) {     if (guiDragDirection.dragDirection == dragDirection) {       return guiDragDirection      }   }   return null  } 
public DirectionDragButton(Context context,@Nonnull AttributeSet attrs){   super(context,attrs)    init(context,attrs)  } 
public DirectionDragButton(Context context,@Nonnull DirectionDragButtonDef directionDragButtonDef){   super(context,directionDragButtonDef)    init(context,directionDragButtonDef)  } 
private void init(@Nonnull Context context,@Nonnull DirectionDragButtonDef directionDragButtonDef){   for (  GuiDragDirection direction : GuiDragDirection.values()) {     final CharSequence directionText=directionDragButtonDef.getText(direction.dragDirection)      this.textDataMap.put(direction,new DirectionTextData(direction,Strings.getNotEmpty(directionText,"")))    }   this.initialized=true  } 
public void applyDef(@Nonnull DirectionDragButtonDef directionDragButtonDef){   super.applyDef(directionDragButtonDef)    for (  GuiDragDirection guiDragDirection : GuiDragDirection.values()) {     final CharSequence directionText=directionDragButtonDef.getText(guiDragDirection.dragDirection)      this.textDataMap.put(guiDragDirection,new DirectionTextData(guiDragDirection,Strings.getNotEmpty(directionText,"")))    } } 
private void init(@Nonnull Context context,@Nonnull AttributeSet attrs){   TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DirectionDragButton)    for (int i=0  i < a.getIndexCount()  i++) {     int attr=a.getIndex(i)      if (a.hasValue(attr)) {       if (attr == R.styleable.DirectionDragButton_directionTextColor) {         this.directionTextColor=a.getColor(attr,DEFAULT_DIRECTION_TEXT_COLOR)        }  else       if (attr == R.styleable.DirectionDragButton_directionTextScale) {         this.directionTextScale=a.getString(attr)        }  else       if (attr == R.styleable.DirectionDragButton_directionTextAlpha) {         this.directionTextAlpha=a.getInt(attr,DEFAULT_DIRECTION_TEXT_ALPHA)        }  else {         for (        GuiDragDirection guiDragDirection : GuiDragDirection.values()) {           if (guiDragDirection.getAttributeId() == attr) {             this.textDataMap.put(guiDragDirection,new DirectionTextData(guiDragDirection,a.getString(attr)))              break            }         }       }     }   }   a.recycle()    for (  Map.Entry<GuiDragDirection,Float> entry : getDirectionTextScales().entrySet()) {     final DirectionTextData td=textDataMap.get(entry.getKey())      if (td != null) {       td.scale=entry.getValue()      }   }   initialized=true  } 
@Override public void onSizeChanged(int w,int h,int oldW,int oldH){   measureText()  } 
@Override protected void onTextChanged(CharSequence text,int start,int before,int after){   measureText()  } 
protected void measureText(){   if (initialized) {     final Paint basePaint=getPaint()      for (    DirectionTextData textData : textDataMap.values()) {       initDirectionTextPaint(basePaint,textData)        textData.position=textData.direction.getTextPosition(textData.paint,basePaint,textData.text,getText(),getWidth(),getHeight())      }   } } 
protected void initDirectionTextPaint(@Nonnull Paint basePaint,@Nonnull DirectionTextData textData){   textData.init(basePaint,directionTextColor,directionTextAlpha)  } 
@Override public void onDraw(Canvas canvas){   super.onDraw(canvas)    final TextPaint paint=getPaint()    for (  DirectionTextData td : textDataMap.values()) {     if (td.show) {       initDirectionTextPaint(paint,td)        final String text=td.text        final Point2d position=td.position        canvas.drawText(text,0,text.length(),position.getX(),position.getY(),td.paint)      }   } } 
@SuppressWarnings("UnusedDeclaration") @Nullable public String getTextUp(){   return getText(GuiDragDirection.up)  } 
@SuppressWarnings("UnusedDeclaration") @Nullable public String getTextDown(){   return getText(GuiDragDirection.down)  } 
@Nullable public String getText(@Nonnull DragDirection direction){   final GuiDragDirection guiDragDirection=GuiDragDirection.valueOf(direction)    return guiDragDirection == null ? null : getText(guiDragDirection)  } 
@SuppressWarnings("UnusedDeclaration") public void showDirectionText(boolean show,@Nonnull DragDirection direction){   final GuiDragDirection guiDragDirection=GuiDragDirection.valueOf(direction)    final DirectionTextData td=this.textDataMap.get(guiDragDirection)    if (td != null) {     td.show=show    } } 
@Nullable private String getText(@Nonnull GuiDragDirection direction){   DirectionTextData td=this.textDataMap.get(direction)    if (td == null) {     return null    }  else {     if (td.show) {       return td.text      }  else {       return null      }   } } 
@Nonnull public String getDirectionTextScale(){   return directionTextScale  } 
@Nonnull private Map<GuiDragDirection,Float> getDirectionTextScales(){   final List<Float> scales=StringCollections.split(getDirectionTextScale()," ",NumberParser.of(Float.class))    final Map<GuiDragDirection,Float> result=new HashMap<GuiDragDirection,Float>()    for (  GuiDragDirection direction : GuiDragDirection.values()) {     result.put(direction,DEFAULT_DIRECTION_TEXT_SCALE_FLOAT)    }   if (scales.size() == 1) {     final Float scale=scales.get(0)      for (    Map.Entry<GuiDragDirection,Float> entry : result.entrySet()) {       entry.setValue(scale)      }   }  else {     for (int i=0  i < scales.size()  i++) {       for (      GuiDragDirection direction : GuiDragDirection.values()) {         if (direction.getAttributePosition() == i) {           result.put(direction,scales.get(i))          }       }     }   }   return result  } 
@Nullable CharSequence getText(@Nonnull DragDirection dragDirection)  
private DirectionDragButtonDefImpl(){ } 
@Nonnull public static DirectionDragButtonDefImpl newInstance(@Nullable CharSequence text){   return newInstance(text,null,null,null,null)  } 
@Nonnull public static DirectionDragButtonDefImpl newInstance(@Nullable CharSequence text,@Nullable CharSequence up,@Nullable CharSequence right,@Nullable CharSequence down,@Nullable CharSequence left){   return newInstance(text,up,right,down,left,null)  } 
@Nonnull public static DirectionDragButtonDefImpl newInstance(@Nullable CharSequence text,@Nullable CharSequence up,@Nullable CharSequence right,@Nullable CharSequence down,@Nullable CharSequence left,@Nullable Integer backgroundColor){   final DirectionDragButtonDefImpl result=new DirectionDragButtonDefImpl()    result.text=text    result.directionsTexts.put(DragDirection.up,up)    result.directionsTexts.put(DragDirection.right,right)    result.directionsTexts.put(DragDirection.down,down)    result.directionsTexts.put(DragDirection.left,left)    result.backgroundResId=backgroundColor    return result  } 
@Nonnull public static DirectionDragButtonDefImpl newDrawableInstance(@Nonnull Integer drawableResId){   return newDrawableInstance(drawableResId,null)  } 
@Nonnull public static DirectionDragButtonDefImpl newDrawableInstance(@Nonnull Integer drawableResId,@Nullable Integer backgroundColor){   final DirectionDragButtonDefImpl result=new DirectionDragButtonDefImpl()    result.drawableResId=drawableResId    result.backgroundResId=backgroundColor    return result  } 
@Nullable @Override public CharSequence getText(@Nonnull DragDirection dragDirection){   return directionsTexts.get(dragDirection)  } 
@Nullable @Override public Float getLayoutWeight(){   return this.weight  } 
@Nullable @Override public Integer getLayoutMarginLeft(){   return this.layoutMarginLeft  } 
@Nullable @Override public Integer getLayoutMarginRight(){   return this.layoutMarginRight  } 
@Nullable @Override public Integer getDrawableResId(){   return this.drawableResId  } 
@Nullable @Override public String getTag(){   return tag  } 
@Nullable @Override public Integer getBackgroundResId(){   return this.backgroundResId  } 
@Nullable @Override public CharSequence getText(){   return text  } 
public void setWeight(@Nullable Float weight){   this.weight=weight  } 
public void setLayoutMarginRight(@Nullable Integer layoutMarginRight){   this.layoutMarginRight=layoutMarginRight  } 
public void setLayoutMarginLeft(@Nullable Integer layoutMarginLeft){   this.layoutMarginLeft=layoutMarginLeft  } 
public void setBackgroundResId(int backgroundResId){   this.backgroundResId=backgroundResId  } 
public void setTag(@Nullable String tag){   this.tag=tag  } 
public void setText(@Nullable CharSequence text){   this.text=text  } 
public void setBackgroundResId(@Nullable Integer backgroundResId){   this.backgroundResId=backgroundResId  } 
public void setDrawableResId(@Nullable Integer drawableResId){   this.drawableResId=drawableResId  } 
public void setDirectionText(@Nonnull DragDirection key,@Nullable CharSequence text){   directionsTexts.put(key,text)  } 
public DragButton(@Nonnull Context context,@Nonnull AttributeSet attrs){   super(context,attrs)    setOnTouchListener(new OnTouchListenerImpl())  } 
public DragButton(@Nonnull Context context,@Nonnull DragButtonDef dragButtonDef){   super(context)    setOnTouchListener(new OnTouchListenerImpl())    setText(dragButtonDef.getText())  } 
public void setOnDragListener(@Nullable org.solovyev.android.view.drag.OnDragListener onDragListener){   this.onDragListener=onDragListener  } 
@Nullable public org.solovyev.android.view.drag.OnDragListener getOnDragListener(){   return onDragListener  } 
public void applyDef(@Nonnull DragButtonDef buttonDef){   AndroidViewUtils.applyButtonDef(this,buttonDef)  } 
@Override public void setOnTouchListener(OnTouchListener l){   if (l instanceof OnTouchListenerImpl) {     this.onTouchListener=(OnTouchListenerImpl)l      super.setOnTouchListener(l)    }  else {     this.onTouchListener.nestedOnTouchListener=l    } } 
@Override public boolean onTouch(@Nonnull View v,@Nonnull MotionEvent event){   boolean consumed=false    final Point2d localStartPoint=startPoint    final org.solovyev.android.view.drag.OnDragListener localOnDragListener=onDragListener    if (localOnDragListener != null) {     Log.d(String.valueOf(getId()),"onTouch() for: " + getId() + " . Motion event: "+ event)  switch (event.getAction()) { case MotionEvent.ACTION_DOWN:       startPoint=new Point2d(event.getX(),event.getY())      break  case MotionEvent.ACTION_UP:   if (localStartPoint != null) {     consumed=localOnDragListener.onDrag(DragButton.this,new DragEvent(localStartPoint,event))      if (consumed) {       if (localOnDragListener.isSuppressOnClickEvent()) {         v.setPressed(false)        }     }   } startPoint=null  break  } } if (nestedOnTouchListener != null && !consumed) { return nestedOnTouchListener.onTouch(v,event)  }  else { return consumed  } } 
@Override protected void onDraw(Canvas canvas){   CharSequence text=getText()    if (!Strings.isEmpty(text)) {     super.onDraw(canvas)    }  else {     if (!AndroidViewUtils.drawDrawables(canvas,this)) {       super.onDraw(canvas)      }   } } 
public boolean isShowText(){   return showText  } 
public void setShowText(boolean showText){   if (this.showText != showText) {     if (showText) {       setText(textBackup)        textBackup=null      }  else {       textBackup=this.getText()        setText(null)      }     this.showText=showText    } } 
public DragEvent(@Nonnull Point2d startPoint,@Nonnull MotionEvent motionEvent){   this.startPoint=startPoint    this.motionEvent=motionEvent  } 
/**   * @return motion event started at start point  */ @Nonnull public MotionEvent getMotionEvent(){   return motionEvent  } 
/**   * @return start point of dragging  */ @Nonnull public Point2d getStartPoint(){   return startPoint  } 
void onDragPreferencesChange(@Nonnull SimpleOnDragListener.Preferences preferences)  
/**   * @return 'true': if drag event has taken place (i.e. onDrag() method returned true) then click action will be suppresed  */ boolean isSuppressOnClickEvent()  
/**   * @param dragButton drag button object for which onDrag listener was set  * @param event      drag event  * @return 'true' if drag event occurred, 'false' otherwise  */ boolean onDrag(@Nonnull DragButton dragButton,@Nonnull DragEvent event)  
public OnDragListenerWrapper(@Nonnull OnDragListener onDragListener){   this.onDragListener=onDragListener  } 
@Override public boolean isSuppressOnClickEvent(){   return this.onDragListener.isSuppressOnClickEvent()  } 
@Override public boolean onDrag(@Nonnull DragButton dragButton,@Nonnull DragEvent event){   return this.onDragListener.onDrag(dragButton,event)  } 
public SimpleOnDragListener(@Nonnull Preferences preferences){   this.preferences=preferences  } 
public SimpleOnDragListener(@Nonnull DragProcessor dragProcessor,@Nonnull Preferences preferences){   this.dragProcessor=dragProcessor    this.preferences=preferences  } 
@Override public boolean onDrag(@Nonnull DragButton dragButton,@Nonnull DragEvent event){   boolean result=false    logDragEvent(dragButton,event)    final Point2d startPoint=event.getStartPoint()    final MotionEvent motionEvent=event.getMotionEvent()    final Point2d endPoint=new Point2d(motionEvent.getX(),motionEvent.getY())    final float distance=Maths.getDistance(startPoint,endPoint)    final MutableObject<Boolean> right=new MutableObject<Boolean>()    final double angle=Math.toDegrees(Maths.getAngle(startPoint,Maths.sum(startPoint,axis),endPoint,right))    Log.d(String.valueOf(dragButton.getId()),"Angle: " + angle)    Log.d(String.valueOf(dragButton.getId()),"Is right?: " + right.getObject())    final double duration=motionEvent.getEventTime() - motionEvent.getDownTime()    final Preference distancePreferences=preferences.getPreferencesMap().get(PreferenceType.distance)    final Preference anglePreferences=preferences.getPreferencesMap().get(PreferenceType.angle)    DragDirection direction=null    for (  Map.Entry<DragDirection,DragPreference> directionEntry : distancePreferences.getDirectionPreferences().entrySet()) {     Log.d(String.valueOf(dragButton.getId()),"Drag direction: " + directionEntry.getKey())      Log.d(String.valueOf(dragButton.getId()),"Trying direction interval: " + directionEntry.getValue().getInterval())      if (directionEntry.getValue().getInterval().contains(distance)) {       final DragPreference anglePreference=anglePreferences.getDirectionPreferences().get(directionEntry.getKey())        Log.d(String.valueOf(dragButton.getId()),"Trying angle interval: " + anglePreference.getInterval())        if (directionEntry.getKey() == DragDirection.left && right.getObject()) {       }  else       if (directionEntry.getKey() == DragDirection.right && !right.getObject()) {       }  else {         if (anglePreference.getInterval().contains((float)angle)) {           direction=directionEntry.getKey()            Log.d(String.valueOf(dragButton.getId()),"MATCH! Direction: " + direction)            break          }       }     }   }   if (direction != null) {     final Preference durationPreferences=preferences.getPreferencesMap().get(PreferenceType.duration)      final DragPreference durationDragPreferences=durationPreferences.getDirectionPreferences().get(direction)      Log.d(String.valueOf(dragButton.getId()),"Trying time interval: " + durationDragPreferences.getInterval())      if (durationDragPreferences.getInterval().contains((float)duration)) {       Log.d(String.valueOf(dragButton.getId()),"MATCH!")        result=dragProcessor.processDragEvent(direction,dragButton,startPoint,motionEvent)      }   }   return result  } 
@Override public boolean isSuppressOnClickEvent(){   return true  } 
private void logDragEvent(@Nonnull DragButton dragButton,@Nonnull DragEvent event){   final Point2d startPoint=event.getStartPoint()    final MotionEvent motionEvent=event.getMotionEvent()    final Point2d endPoint=new Point2d(motionEvent.getX(),motionEvent.getY())    Log.d(String.valueOf(dragButton.getId()),"Start point: " + startPoint + ", End point: "+ endPoint)    Log.d(String.valueOf(dragButton.getId()),"Distance: " + Maths.getDistance(startPoint,endPoint))    final MutableObject<Boolean> right=new MutableObject<Boolean>()    Log.d(String.valueOf(dragButton.getId()),"Angle: " + Math.toDegrees(Maths.getAngle(startPoint,Maths.sum(startPoint,axis),endPoint,right)))    Log.d(String.valueOf(dragButton.getId()),"Is right angle? " + right)    Log.d(String.valueOf(dragButton.getId()),"Axis: " + axis + " Vector: "+ Maths.subtract(endPoint,startPoint))    Log.d(String.valueOf(dragButton.getId()),"Total time: " + (motionEvent.getEventTime() - motionEvent.getDownTime()) + " ms")  } 
@Nonnull public DragProcessor getDragProcessor(){   return dragProcessor  } 
public void setDragProcessor(@Nonnull DragProcessor dragProcessor){   this.dragProcessor=dragProcessor  } 
@Override public void onDragPreferencesChange(@Nonnull Preferences preferences){   this.preferences=preferences  } 
boolean processDragEvent(@Nonnull DragDirection dragDirection,@Nonnull DragButton dragButton,@Nonnull Point2d startPoint2d,@Nonnull MotionEvent motionEvent)  
public static String getPreferenceId(@Nonnull PreferenceType preferenceType,@Nonnull DragDirection direction){   return "org.solovyev.android.calculator.DragButtonCalibrationActivity" + "_" + preferenceType.name()  } 
@Nonnull public static Preferences getDefaultPreferences(@Nonnull Context context){   return getPreferences0(null,context)  } 
@Nonnull public static Preferences getPreferences(@Nonnull final SharedPreferences preferences,@Nonnull Context context){   return getPreferences0(preferences,context)  } 
@Nonnull private static Preferences getPreferences0(@Nullable final SharedPreferences preferences,@Nonnull Context context){   final Mapper<Interval<Float>> mapper=NumberIntervalMapper.of(Float.class)    final Preferences result=new Preferences()    for (  PreferenceType preferenceType : PreferenceType.values()) {     for (    DragDirection dragDirection : DragDirection.values()) {       final String preferenceId=getPreferenceId(preferenceType,dragDirection)        final String defaultValue  switch (preferenceType) { case angle:         defaultValue=context.getResources().getString(R.string.p_drag_angle)        break  case distance:     defaultValue=context.getResources().getString(R.string.p_drag_distance)    break  case duration: defaultValue=context.getResources().getString(R.string.p_drag_duration)  break  default : defaultValue=null  Log.e(SimpleOnDragListener.class.getName(),"New preference type added: default preferences should be defined. Preference id: " + preferenceId)  } final String value=preferences == null ? defaultValue : preferences.getString(preferenceId,defaultValue)  if (value != null) { final Interval<Float> intervalPref=transformInterval(preferenceType,dragDirection,mapper.parseValue(value))  Log.d(SimpleOnDragListener.class.getName(),"Preference loaded for " + dragDirection + ". Id: "+ preferenceId+ ", value: "+ intervalPref.toString())  final DragPreference directionPreference=new DragPreference(dragDirection,intervalPref)  Preference preference=result.getPreferencesMap().get(preferenceType)  if (preference == null) { preference=new Preference(preferenceType)  result.getPreferencesMap().put(preferenceType,preference)  } preference.getDirectionPreferences().put(dragDirection,directionPreference)  } } } return result  } 
@Nonnull public static Interval<Float> transformInterval(@Nonnull PreferenceType preferenceType,@Nonnull DragDirection dragDirection,@Nonnull Interval<Float> interval){   if (preferenceType == PreferenceType.angle) {     final Float leftLimit=interval.getLeftLimit()      final Float rightLimit=interval.getRightLimit()      if (leftLimit != null && rightLimit != null) {       final Float newLeftLimit        final Float newRightLimit        if (dragDirection == DragDirection.up) {         newLeftLimit=180f - rightLimit          newRightLimit=180f - leftLimit        }  else       if (dragDirection == DragDirection.left) {         newLeftLimit=90f - rightLimit          newRightLimit=90f + rightLimit        }  else       if (dragDirection == DragDirection.right) {         newLeftLimit=90f - rightLimit          newRightLimit=90f + rightLimit        }  else {         newLeftLimit=leftLimit          newRightLimit=rightLimit        }       return Intervals.newClosedInterval(newLeftLimit,newRightLimit)      }   }   return interval  } 
public DragPreference(@Nonnull DragDirection direction,@Nonnull Interval<Float> interval){   this.direction=direction    this.interval=interval  } 
@Nonnull public DragDirection getDirection(){   return direction  } 
public void setDirection(@Nonnull DragDirection direction){   this.direction=direction  } 
@Nonnull public Interval<Float> getInterval(){   return interval  } 
public void setInterval(@Nonnull Interval<Float> interval){   this.interval=interval  } 
public Preference(@Nonnull PreferenceType preferenceType){   this.preferenceType=preferenceType  } 
@Nonnull public PreferenceType getPreferenceType(){   return preferenceType  } 
public void setPreferenceType(@Nonnull PreferenceType preferenceType){   this.preferenceType=preferenceType  } 
@Nonnull public Map<DragDirection,DragPreference> getDirectionPreferences(){   return directionPreferences  } 
public void setDirectionPreferences(@Nonnull Map<DragDirection,DragPreference> directionPreferences){   this.directionPreferences=directionPreferences  } 
public Map<PreferenceType,Preference> getPreferencesMap(){   return preferencesMap  } 
public FlowLayout(Context context){   super(context)    this.readStyleParameters(context,null)  } 
public FlowLayout(Context context,AttributeSet attributeSet){   super(context,attributeSet)    this.readStyleParameters(context,attributeSet)  } 
public FlowLayout(Context context,AttributeSet attributeSet,int defStyle){   super(context,attributeSet,defStyle)    this.readStyleParameters(context,attributeSet)  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   int sizeWidth=MeasureSpec.getSize(widthMeasureSpec) - this.getPaddingRight() - this.getPaddingLeft()    int sizeHeight=MeasureSpec.getSize(heightMeasureSpec) - this.getPaddingRight() - this.getPaddingLeft()    int modeWidth=MeasureSpec.getMode(widthMeasureSpec)    int modeHeight=MeasureSpec.getMode(heightMeasureSpec)    int size    int mode    if (orientation == HORIZONTAL) {     size=sizeWidth      mode=modeWidth    }  else {     size=sizeHeight      mode=modeHeight    }   int lineThicknessWithSpacing=0    int lineThickness=0    int lineLengthWithSpacing=0    int lineLength    int prevLinePosition=0    int controlMaxLength=0    int controlMaxThickness=0    final int count=getChildCount()    for (int i=0  i < count  i++) {     final View child=getChildAt(i)      if (child.getVisibility() == GONE) {       continue      }     child.measure(MeasureSpec.makeMeasureSpec(sizeWidth,modeWidth == MeasureSpec.EXACTLY ? MeasureSpec.AT_MOST : modeWidth),MeasureSpec.makeMeasureSpec(sizeHeight,modeHeight == MeasureSpec.EXACTLY ? MeasureSpec.AT_MOST : modeHeight))      LayoutParams lp=(LayoutParams)child.getLayoutParams()      int hSpacing=this.getHorizontalSpacing(lp)      int vSpacing=this.getVerticalSpacing(lp)      int childWidth=child.getMeasuredWidth()      int childHeight=child.getMeasuredHeight()      int childLength      int childThickness      int spacingLength      int spacingThickness      if (orientation == HORIZONTAL) {       childLength=childWidth        childThickness=childHeight        spacingLength=hSpacing        spacingThickness=vSpacing      }  else {       childLength=childHeight        childThickness=childWidth        spacingLength=vSpacing        spacingThickness=hSpacing      }     lineLength=lineLengthWithSpacing + childLength      lineLengthWithSpacing=lineLength + spacingLength      boolean newLine=lp.newLine || (mode != MeasureSpec.UNSPECIFIED && lineLength > size)      if (newLine) {       prevLinePosition=prevLinePosition + lineThicknessWithSpacing        lineThickness=childThickness        lineLength=childLength        lineThicknessWithSpacing=childThickness + spacingThickness        lineLengthWithSpacing=lineLength + spacingLength      }     lineThicknessWithSpacing=Math.max(lineThicknessWithSpacing,childThickness + spacingThickness)      lineThickness=Math.max(lineThickness,childThickness)      int posX      int posY      if (orientation == HORIZONTAL) {       posX=getPaddingLeft() + lineLength - childLength        posY=getPaddingTop() + prevLinePosition      }  else {       posX=getPaddingLeft() + prevLinePosition        posY=getPaddingTop() + lineLength - childHeight      }     lp.setPosition(posX,posY)      controlMaxLength=Math.max(controlMaxLength,lineLength)      controlMaxThickness=prevLinePosition + lineThickness    }   if (orientation == HORIZONTAL) {     this.setMeasuredDimension(resolveSize(controlMaxLength,widthMeasureSpec),resolveSize(controlMaxThickness,heightMeasureSpec))    }  else {     this.setMeasuredDimension(resolveSize(controlMaxThickness,widthMeasureSpec),resolveSize(controlMaxLength,heightMeasureSpec))    } } 
private int getVerticalSpacing(LayoutParams lp){   int vSpacing    if (lp.verticalSpacingSpecified()) {     vSpacing=lp.verticalSpacing    }  else {     vSpacing=this.verticalSpacing    }   return vSpacing  } 
private int getHorizontalSpacing(LayoutParams lp){   int hSpacing    if (lp.horizontalSpacingSpecified()) {     hSpacing=lp.horizontalSpacing    }  else {     hSpacing=this.horizontalSpacing    }   return hSpacing  } 
@Override protected void onLayout(boolean changed,int l,int t,int r,int b){   final int count=getChildCount()    for (int i=0  i < count  i++) {     View child=getChildAt(i)      LayoutParams lp=(LayoutParams)child.getLayoutParams()      child.layout(lp.x,lp.y,lp.x + child.getMeasuredWidth(),lp.y + child.getMeasuredHeight())    } } 
@Override protected boolean drawChild(Canvas canvas,View child,long drawingTime){   boolean more=super.drawChild(canvas,child,drawingTime)    this.drawDebugInfo(canvas,child)    return more  } 
@Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p){   return p instanceof LayoutParams  } 
@Override protected LayoutParams generateDefaultLayoutParams(){   return new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT)  } 
@Override public LayoutParams generateLayoutParams(AttributeSet attributeSet){   return new LayoutParams(getContext(),attributeSet)  } 
@Override protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams p){   return new LayoutParams(p)  } 
private void readStyleParameters(Context context,AttributeSet attributeSet){   TypedArray a=context.obtainStyledAttributes(attributeSet,R.styleable.FlowLayout)    try {     horizontalSpacing=a.getDimensionPixelSize(R.styleable.FlowLayout_horizontalSpacing,0)      verticalSpacing=a.getDimensionPixelSize(R.styleable.FlowLayout_verticalSpacing,0)      orientation=a.getInteger(R.styleable.FlowLayout_orientation,HORIZONTAL)      debugDraw=a.getBoolean(R.styleable.FlowLayout_debugDraw,false)    }   finally {     a.recycle()    } } 
private void drawDebugInfo(Canvas canvas,View child){   if (!debugDraw) {     return    }   Paint childPaint=this.createPaint(0xffffff00)    Paint layoutPaint=this.createPaint(0xff00ff00)    Paint newLinePaint=this.createPaint(0xffff0000)    LayoutParams lp=(LayoutParams)child.getLayoutParams()    if (lp.horizontalSpacing > 0) {     float x=child.getRight()      float y=child.getTop() + child.getHeight() / 2.0f      canvas.drawLine(x,y,x + lp.horizontalSpacing,y,childPaint)      canvas.drawLine(x + lp.horizontalSpacing - 4.0f,y - 4.0f,x + lp.horizontalSpacing,y,childPaint)      canvas.drawLine(x + lp.horizontalSpacing - 4.0f,y + 4.0f,x + lp.horizontalSpacing,y,childPaint)    }  else   if (this.horizontalSpacing > 0) {     float x=child.getRight()      float y=child.getTop() + child.getHeight() / 2.0f      canvas.drawLine(x,y,x + this.horizontalSpacing,y,layoutPaint)      canvas.drawLine(x + this.horizontalSpacing - 4.0f,y - 4.0f,x + this.horizontalSpacing,y,layoutPaint)      canvas.drawLine(x + this.horizontalSpacing - 4.0f,y + 4.0f,x + this.horizontalSpacing,y,layoutPaint)    }   if (lp.verticalSpacing > 0) {     float x=child.getLeft() + child.getWidth() / 2.0f      float y=child.getBottom()      canvas.drawLine(x,y,x,y + lp.verticalSpacing,childPaint)      canvas.drawLine(x - 4.0f,y + lp.verticalSpacing - 4.0f,x,y + lp.verticalSpacing,childPaint)      canvas.drawLine(x + 4.0f,y + lp.verticalSpacing - 4.0f,x,y + lp.verticalSpacing,childPaint)    }  else   if (this.verticalSpacing > 0) {     float x=child.getLeft() + child.getWidth() / 2.0f      float y=child.getBottom()      canvas.drawLine(x,y,x,y + this.verticalSpacing,layoutPaint)      canvas.drawLine(x - 4.0f,y + this.verticalSpacing - 4.0f,x,y + this.verticalSpacing,layoutPaint)      canvas.drawLine(x + 4.0f,y + this.verticalSpacing - 4.0f,x,y + this.verticalSpacing,layoutPaint)    }   if (lp.newLine) {     if (orientation == HORIZONTAL) {       float x=child.getLeft()        float y=child.getTop() + child.getHeight() / 2.0f        canvas.drawLine(x,y - 6.0f,x,y + 6.0f,newLinePaint)      }  else {       float x=child.getLeft() + child.getWidth() / 2.0f        float y=child.getTop()        canvas.drawLine(x - 6.0f,y,x + 6.0f,y,newLinePaint)      }   } } 
private Paint createPaint(int color){   Paint paint=new Paint()    paint.setAntiAlias(true)    paint.setColor(color)    paint.setStrokeWidth(2.0f)    return paint  } 
public LayoutParams(Context context,AttributeSet attributeSet){   super(context,attributeSet)    this.readStyleParameters(context,attributeSet)  } 
public LayoutParams(int width,int height){   super(width,height)  } 
public LayoutParams(ViewGroup.LayoutParams layoutParams){   super(layoutParams)  } 
public boolean horizontalSpacingSpecified(){   return horizontalSpacing != NO_SPACING  } 
public boolean verticalSpacingSpecified(){   return verticalSpacing != NO_SPACING  } 
public void setPosition(int x,int y){   this.x=x    this.y=y  } 
private void readStyleParameters(Context context,AttributeSet attributeSet){   TypedArray a=context.obtainStyledAttributes(attributeSet,R.styleable.FlowLayout_LayoutParams)    try {     horizontalSpacing=a.getDimensionPixelSize(R.styleable.FlowLayout_LayoutParams_layout_horizontalSpacing,NO_SPACING)      verticalSpacing=a.getDimensionPixelSize(R.styleable.FlowLayout_LayoutParams_layout_verticalSpacing,NO_SPACING)      newLine=a.getBoolean(R.styleable.FlowLayout_LayoutParams_layout_newLine,false)    }   finally {     a.recycle()    } } 
void grayOut()  
void grayIn()  
@Override public void grayOut(){   paint=new Paint()    paint.setARGB(180,75,75,75)  } 
@Override public void grayIn(){   paint=null  } 
@Override public void dispatchDraw(@Nonnull View view,@Nonnull Canvas canvas){   final Paint localPaint=paint    if (localPaint != null) {     final RectF drawRect=new RectF()      drawRect.set(0,0,view.getMeasuredWidth(),view.getMeasuredHeight())      canvas.drawRoundRect(drawRect,5,5,localPaint)    } } 
public GrayableRelativeLayout(Context context,AttributeSet attrs){   super(context,attrs)  } 
public GrayableRelativeLayout(Context context){   super(context)  } 
@Override public void grayOut(){   grayable.grayOut()  } 
@Override public void grayIn(){   grayable.grayIn()  } 
@Override protected void dispatchDraw(Canvas canvas){   super.dispatchDraw(canvas)    this.grayable.dispatchDraw(this,canvas)  } 
public IntegerRange(@Nonnull Integer min,@Nonnull Integer max,@Nonnull Integer step,int startPosition,@Nullable Formatter<Integer> formatter){   super(min,max,step,startPosition,formatter)  } 
@Nonnull public static NumberRange<Integer> newInstance(@Nonnull Integer min,@Nonnull Integer max,@Nonnull Integer step,@Nonnull Integer selected){   if (selected < min || selected > max) {     throw new IllegalArgumentException("Selected value: " + selected + " should be >= "+ min+ " and <= "+ max+ "!")    }   int startPosition=0    for (int i=min  i < selected  i+=step) {     startPosition+=1    }   return new IntegerRange(min,max,step,startPosition,null)  } 
@Override protected int getCount(@Nonnull Integer min,@Nonnull Integer max,@Nonnull Integer step){   return (max - min) / step + 1  } 
@Nonnull @Override protected Integer getValueAt(int position,@Nonnull Integer min,@Nonnull Integer max,@Nonnull Integer step){   return min + position * step  } 
public ListRange(@Nonnull List<T> elements,@Nullable T selected){   this.elements=elements    this.startPosition=elements.indexOf(selected)    if (this.startPosition < 0) {     this.startPosition=0    }   this.formatter=null  } 
public ListRange(@Nonnull List<T> elements,@Nullable T selected,@Nullable Formatter<T> formatter){   this(elements,selected)    this.formatter=formatter  } 
@Override public int getStartPosition(){   return this.startPosition  } 
@Override public int getCount(){   return this.elements.size()  } 
@Nonnull @Override public String getStringValueAt(int position){   final T value=getValueAt(position)    return formatter == null ? value.toString() : formatter.formatValue(value)  } 
@Nonnull @Override public T getValueAt(int position){   return this.elements.get(position)  } 
private ListViewBuilder(){ } 
@Nonnull public static ViewBuilder<ListView> newInstance(@Nonnull ListAdapter listAdapter){   final ListViewBuilder result=new ListViewBuilder()    result.layoutId=null    result.listAdapter=listAdapter    return result  } 
@Nonnull public static ViewBuilder<ListView> newInstance(int layoutId,@Nonnull ListAdapter listAdapter){   final ListViewBuilder result=new ListViewBuilder()    result.layoutId=layoutId    result.listAdapter=listAdapter    return result  } 
@Nonnull @Override public ListView build(@Nonnull Context context){   final ListView result    if (layoutId != null) {     result=ViewFromLayoutBuilder.<ListView>newInstance(layoutId).build(context)    }  else {     result=new ListView(context)    }   result.setAdapter(listAdapter)    return result  } 
public NumberRange(@Nonnull N min,@Nonnull N max,@Nonnull N step,int startPosition,@Nullable Formatter<N> formatter){ } 
@Override public int getStartPosition(){   if (this.startPosition < getCount()) {     return this.startPosition    }  else {     return getCount() - 1    } } 
@Override public int getCount(){   if (count == -1) {     count=getCount(min,max,step)    }   return count  } 
protected abstract int getCount(@Nonnull N min,@Nonnull N max,@Nonnull N step)  
@Nonnull @Override public String getStringValueAt(int position){   int count=getCount()    if (position < 0 || position >= count) {     throw new IllegalArgumentException("Position " + position + " must be >= 0 and < "+ count+ "!")    }   final N number=getValueAt(position,min,max,step)    return formatter == null ? number.toString() : formatter.formatValue(number)  } 
@Nonnull @Override public N getValueAt(int position){   return getValueAt(position,min,max,step)  } 
@Nonnull protected abstract N getValueAt(int position,@Nonnull N min,@Nonnull N max,@Nonnull N step)  
public NumberRangeSeekBar(@Nonnull Interval<T> boundaries,@Nullable Integer steps,Context context) throws IllegalArgumentException {   this(boundaries.getLeftLimit(),boundaries.getRightLimit(),steps,context)  } 
/**   * Creates a new RangeSeekBar.  * @param minValue The minimum value of the selectable range.  * @param maxValue The maximum value of the selectable range.  * @param steps    number of steps of range  * @param context  parent context  * @throws IllegalArgumentException Will be thrown if min/max value types are not one of Long, Double, Integer, Float, Short, Byte or BigDecimal.  */ public NumberRangeSeekBar(@Nonnull T minValue,@Nonnull T maxValue,@Nullable Integer steps,Context context) throws IllegalArgumentException {   super(minValue,maxValue,steps,context)    numberType=NumberType.fromNumber(minValue)  } 
@Nonnull @Override protected Converter<Double,T> getToTConverter(){   return new Converter<Double,T>(){     @Nonnull @Override public T convert(    @Nonnull Double value){       return (T)numberType.toNumber(value)      }   }   } 
@Nonnull @Override public T convert(@Nonnull Double value){   return (T)numberType.toNumber(value)  } 
@Nonnull @Override protected Converter<T,Double> getToDoubleConverter(){   return new NumberValuer<T>()  } 
public OnClickListenerVibrator(@Nullable Vibrator vibrator,@Nonnull SharedPreferences preferences){   this.vibrator=new VibratorContainer(vibrator,preferences,VIBRATION_TIME_SCALE)  } 
@Override public void onClick(View v){   vibrator.vibrate()  } 
void onChanged(@Nonnull Picker picker,@Nonnull T value)  
int getStartPosition()  
int getCount()  
@Nonnull String getStringValueAt(int position)  
@Nonnull T getValueAt(int position)  
public void run(){   if (increment) {     changeCurrent(current + 1)      uiHandler.postDelayed(this,speed)    }  else   if (decrement) {     changeCurrent(current - 1)      uiHandler.postDelayed(this,speed)    } } 
/**   * Create a new number picker  * @param context the application environment  */ public Picker(Context context){   this(context,null)  } 
/**   * Create a new number picker  * @param context the application environment  * @param attrs   a collection of attributes  */ public Picker(Context context,@Nullable AttributeSet attrs){   super(context,attrs)    TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.Picker)    final int orientation=a.getInt(R.styleable.Picker_orientation,VERTICAL)    setOrientation(orientation)    final LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE)    if (orientation == HORIZONTAL) {     inflater.inflate(R.layout.number_picker_horizontal,this,true)    }  else {     inflater.inflate(R.layout.number_picker,this,true)    }   final OnClickListener clickListener=new OnClickListener(){     public void onClick(    View v){       if (R.id.increment == v.getId()) {         changeCurrent(current + 1)        }  else       if (R.id.decrement == v.getId()) {         changeCurrent(current - 1)        }     }   }     final OnLongClickListener longClickListener=new OnLongClickListener(){     /**   * We start the long click here but rely on the  {@link PickerButton}to inform us when the long click has ended.  */     public boolean onLongClick(    View v){       if (R.id.increment == v.getId()) {         increment=true          uiHandler.post(runnable)        }  else       if (R.id.decrement == v.getId()) {         decrement=true          uiHandler.post(runnable)        }       return true      }   }     incrementButton=(PickerButton)this.findViewById(R.id.increment)    incrementButton.setNumberPicker(this)    incrementButton.setOnClickListener(clickListener)    incrementButton.setOnLongClickListener(longClickListener)    decrementButton=(PickerButton)this.findViewById(R.id.decrement)    decrementButton.setNumberPicker(this)    decrementButton.setOnClickListener(clickListener)    decrementButton.setOnLongClickListener(longClickListener)    text=(TextView)this.findViewById(R.id.timepicker_input)    if (!isEnabled()) {     setEnabled(false)    } } 
public void onClick(View v){   if (R.id.increment == v.getId()) {     changeCurrent(current + 1)    }  else   if (R.id.decrement == v.getId()) {     changeCurrent(current - 1)    } } 
/**   * We start the long click here but rely on the  {@link PickerButton}to inform us when the long click has ended.  */ public boolean onLongClick(View v){   if (R.id.increment == v.getId()) {     increment=true      uiHandler.post(runnable)    }  else   if (R.id.decrement == v.getId()) {     decrement=true      uiHandler.post(runnable)    }   return true  } 
/**   * Set the enabled state of this view. The interpretation of the enabled state varies by subclass.  * @param enabled True if this view is enabled, false otherwise.  */ @Override public void setEnabled(boolean enabled){   super.setEnabled(enabled)    incrementButton.setEnabled(enabled)    decrementButton.setEnabled(enabled)    text.setEnabled(enabled)  } 
/**   * Set the callback that indicates the number has been adjusted by the user.  * @param listener the callback, should not be null.  */ public void setOnChangeListener(OnChangedListener<T> listener){   this.onChangedListener=listener  } 
public void setRange(@Nonnull Range<T> range){   this.range=range    this.current=range.getStartPosition()    updateView()  } 
public void setCurrent(int current){   if (current < 0 || current >= range.getCount()) {     throw new IllegalArgumentException("Current: " + current + " should be >= 0 and < "+ range.getCount())    }   this.current=current    updateView()  } 
/**   * Sets the speed at which the numbers will scroll when the +/- buttons are longpressed  * @param speed The speed (in milliseconds) at which the numbers will scrolldefault 300ms  */ public void setSpeed(long speed){   this.speed=speed  } 
protected void changeCurrent(int current){   if (current < 0) {     current=this.range.getCount() - 1    }  else   if (current >= this.range.getCount()) {     current=0    }   this.current=current    notifyChange()    updateView()  } 
private void notifyChange(){   if (onChangedListener != null) {     onChangedListener.onChanged(this,range.getValueAt(current))    } } 
private void updateView(){   text.setText(range.getStringValueAt(current))  } 
/**   * @hide  */ public void cancelIncrement(){   increment=false  } 
/**   * @hide  */ public void cancelDecrement(){   decrement=false  } 
/**   * @return current position in Picker  */ public int getCurrent(){   return current  } 
public PickerButton(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)  } 
public PickerButton(Context context,AttributeSet attrs){   super(context,attrs)  } 
public PickerButton(Context context){   super(context)  } 
public void setNumberPicker(Picker picker){   numberPicker=picker  } 
@Override public boolean onTouchEvent(MotionEvent event){   cancelLongPressIfRequired(event)    return super.onTouchEvent(event)  } 
@Override public boolean onTrackballEvent(MotionEvent event){   cancelLongPressIfRequired(event)    return super.onTrackballEvent(event)  } 
@Override public boolean onKeyUp(int keyCode,KeyEvent event){   if ((keyCode == KeyEvent.KEYCODE_DPAD_CENTER) || (keyCode == KeyEvent.KEYCODE_ENTER)) {     cancelLongpress()    }   return super.onKeyUp(keyCode,event)  } 
private void cancelLongPressIfRequired(MotionEvent event){   if ((event.getAction() == MotionEvent.ACTION_CANCEL) || (event.getAction() == MotionEvent.ACTION_UP)) {     cancelLongpress()    } } 
private void cancelLongpress(){   if (R.id.increment == getId()) {     numberPicker.cancelIncrement()    }  else   if (R.id.decrement == getId()) {     numberPicker.cancelDecrement()    } } 
public void onWindowFocusChanged(boolean hasWindowFocus){   super.onWindowFocusChanged(hasWindowFocus)    if (!hasWindowFocus) {     cancelLongpress()    } } 
public ScrollViewState(){ } 
public ScrollViewState(@Nonnull ScrollView scrollView){   this.scrollX=scrollView.getScrollX()    this.scrollY=scrollView.getScrollY()  } 
public void restoreState(@Nonnull final ScrollView scrollView){   scrollView.post(new Runnable(){     @Override public void run(){       scrollView.scrollTo(scrollX,scrollY)      }   } )  } 
@Override public void run(){   scrollView.scrollTo(scrollX,scrollY)  } 
public static void saveState(@Nonnull Bundle out,@Nonnull final ScrollView scrollView){   out.putSerializable(SCROLL_VIEW_STATE,new ScrollViewState(scrollView))  } 
public static void restoreState(@Nonnull Bundle in,@Nonnull final ScrollView scrollView){   final Object o=in.getSerializable(SCROLL_VIEW_STATE)    if (o instanceof ScrollViewState) {     ((ScrollViewState)o).restoreState(scrollView)    } } 
/**   * Called when slide action has been finished.  * @param opened true if sliding view has been opened, false - if closed  */ public void onSlideCompleted(boolean opened)  
private SideBarAttributes(){ } 
@Nonnull public static SideBarAttributes newAttributes(@Nonnull Context context,@Nonnull AttributeSet attrs){   final SideBarAttributes result=new SideBarAttributes()    final TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.SideBarLayout)    result.mainViewId=attributes.getResourceId(R.styleable.SideBarLayout_mainViewId,View.NO_ID)    result.slidingViewId=attributes.getResourceId(R.styleable.SideBarLayout_slidingViewId,View.NO_ID)    result.slidingViewLedge=attributes.getDimensionPixelSize(R.styleable.SideBarLayout_slidingViewLedge,0)    result.slidingViewPosition=SideBarSlidingViewPosition.getById(attributes.getInt(R.styleable.SideBarLayout_slidingViewPosition,0))    result.slidingViewStyle=SideBarSlidingViewStyle.getById(attributes.getInt(R.styleable.SideBarLayout_slidingViewStyle,0))    attributes.recycle()    checkAttributes(result)    return result  } 
private static void checkAttributes(SideBarAttributes result){   if (result.mainViewId == View.NO_ID) {     throw new IllegalArgumentException("Main view id must be set!")    }   if (result.slidingViewId == View.NO_ID) {     throw new IllegalArgumentException("Sliding view id must be set!")    } } 
@Nonnull public static SideBarAttributes newAttributes(int mainViewId,int slidingViewId,int slidingViewLedge,SideBarSlidingViewPosition slidingViewPosition){   final SideBarAttributes result=new SideBarAttributes()    result.mainViewId=mainViewId    result.slidingViewId=slidingViewId    result.slidingViewLedge=slidingViewLedge    result.slidingViewPosition=slidingViewPosition    checkAttributes(result)    return result  } 
public int getSlidingViewLedge(){   return slidingViewLedge  } 
public int getMainViewId(){   return mainViewId  } 
public int getSlidingViewId(){   return slidingViewId  } 
public boolean isSlideMainView(){   return slideMainView  } 
public SideBarSlidingViewPosition getSlidingViewPosition(){   return slidingViewPosition  } 
public boolean isSlidingViewLedgeExists(){   return slidingViewLedge > 0  } 
public SideBarSlidingViewStyle getSlidingViewStyle(){   return slidingViewStyle  } 
public SideBarLayout(Context context,int mainViewId,int slidingViewId){   super(context)    attributes=SideBarAttributes.newAttributes(mainViewId,slidingViewId,0,SideBarSlidingViewPosition.left)    init(context,null)  } 
public SideBarLayout(Context context,AttributeSet attrs){   super(context,attrs)    init(context,attrs)  } 
public SideBarLayout(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)    init(context,attrs)  } 
private void init(@Nonnull Context context,@Nullable AttributeSet attrs){   if (attrs != null) {     attributes=SideBarAttributes.newAttributes(context,attrs)    }   slider=new SideBarSlider(this,attributes,this)    cachedPaint=new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG)  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   final View slidingView=getSlidingView()    if (attributes.isSlideMainView()) {     final int slidingViewLedge=attributes.getSlidingViewLedge()      if (alwaysOpened || slidingViewLedge > 0) {       final View mainView=getMainView()        final LayoutParams lp=(LayoutParams)mainView.getLayoutParams()        if (alwaysOpened) {         measureChild(slidingView,widthMeasureSpec,heightMeasureSpec)  switch (attributes.getSlidingViewPosition()) { case left:           lp.leftMargin=slidingView.getMeasuredWidth()          break  case top:       lp.topMargin=slidingView.getMeasuredWidth()      break  case right:   lp.rightMargin=slidingView.getMeasuredWidth()  break  case bottom: lp.bottomMargin=slidingView.getMeasuredWidth()  break  } }  else { switch (attributes.getSlidingViewPosition()) { case left: measureChild(slidingView,slidingViewLedge,heightMeasureSpec)  lp.leftMargin=slidingViewLedge  break  case top: measureChild(slidingView,widthMeasureSpec,slidingViewLedge)  lp.topMargin=slidingViewLedge  break  case right: measureChild(slidingView,slidingViewLedge,heightMeasureSpec)  lp.rightMargin=slidingViewLedge  break  case bottom: measureChild(slidingView,widthMeasureSpec,slidingViewLedge)  lp.bottomMargin=slidingViewLedge  break  } } } } super.onMeasure(widthMeasureSpec,heightMeasureSpec)  } 
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){   final int height=bottom - top    final int width=right - left    final View slidingView=getSlidingView()    final View mainView=getMainView()    final int slidingViewWidth=slidingView.getMeasuredWidth()    final int slidingViewHeight=slidingView.getMeasuredHeight()    final int offset    if (alwaysOpened || slidingViewState == SlidingViewState.Opened) { switch (attributes.getSlidingViewPosition()) { case left: case right:       offset=slidingViewWidth      break  case top: case bottom:   offset=slidingViewHeight  break  default : throw new UnsupportedOperationException()  } }  else if (slidingViewState == SlidingViewState.Closed) { offset=attributes.getSlidingViewLedge()  }  else { offset=slider.getOffset()  } switch (attributes.getSlidingViewStyle()) { case hover: mainView.layout(0,0,width,height)  break  case push: switch (attributes.getSlidingViewPosition()) { case left: mainView.layout(offset,0,width + offset,height)  break  case top: mainView.layout(0,offset,width,height + offset)  break  case right: mainView.layout(-offset,0,width - offset,height)  break  case bottom: mainView.layout(0,-offset,width,height - offset)  break  } break  } switch (attributes.getSlidingViewPosition()) { case left: slidingView.layout(-slidingViewWidth + offset,0,offset,height)  break  case top: slidingView.layout(0,offset - slidingViewHeight,width,offset)  break  case right: slidingView.layout(width - offset,0,width - offset + slidingViewWidth,height)  break  case bottom: slidingView.layout(0,height - offset,width,height - offset + slidingViewHeight)  break  } invalidate()  } 
@Override protected void dispatchDraw(Canvas canvas){   try {     if (slidingViewState.isTransition()) {       if (drawCounter.getAndIncrement() > DRAW_FRAMES_SKIP_COUNT) {         updateCachedCanvas()          drawCounter.set(0)        }       canvas.save()  switch (attributes.getSlidingViewStyle()) { case push: switch (attributes.getSlidingViewPosition()) { case left:           canvas.translate(slider.getOffset(),0)          break  case top:       canvas.translate(0,slider.getOffset())      break  case right:   canvas.translate(-slider.getOffset(),0)  break  case bottom: canvas.translate(0,-slider.getOffset())  break  } break  } canvas.drawBitmap(cachedBitmap,0,0,cachedPaint)  canvas.restore()  final View slidingView=getSlidingView()  final int scrollX=slidingView.getScrollX()  final int scrollY=slidingView.getScrollY()  canvas.save()  final int width=canvas.getWidth()  final int height=canvas.getHeight()  switch (attributes.getSlidingViewPosition()) { case left: canvas.clipRect(0,0,slider.getOffsetOnScreen(),height,Region.Op.REPLACE)  canvas.translate(-scrollX - (slidingView.getMeasuredWidth() - slider.getOffset()),-scrollY)  break  case top: canvas.clipRect(0,0,width,slider.getOffsetOnScreen(),Region.Op.REPLACE)  canvas.translate(-scrollX,-scrollY - slidingView.getMeasuredHeight() + slider.getOffsetOnScreen())  break  case right: canvas.clipRect(slider.getOffsetOnScreen(),0,width,height,Region.Op.REPLACE)  canvas.translate(-scrollX + slider.getOffsetOnScreen(),-scrollY)  break  case bottom: canvas.clipRect(0,slider.getOffsetOnScreen(),width,height,Region.Op.REPLACE)  canvas.translate(-scrollX,-scrollY + slider.getOffsetOnScreen())  break  default : throw new UnsupportedOperationException()  } slidingView.draw(canvas)  canvas.restore()  }  else { if (!alwaysOpened) { if (!attributes.isSlidingViewLedgeExists()) { if (slidingViewState == SlidingViewState.Closed) { getSlidingView().setVisibility(View.GONE)  } } } super.dispatchDraw(canvas)  } }  catch (IndexOutOfBoundsException e) { } } 
private void updateCachedCanvas(){   final View mainView=getMainView()    cachedCanvas.drawColor(Color.TRANSPARENT,PorterDuff.Mode.CLEAR)    cachedCanvas.translate(-mainView.getScrollX(),-mainView.getScrollY())    mainView.draw(cachedCanvas)  } 
@Override protected Parcelable onSaveInstanceState(){   boolean opened    if (slidingViewState == SlidingViewState.Opened) {     opened=true    }  else   if (slidingViewState.isTransition()) {     opened=slider.isOpening()    }  else {     opened=false    }   return new ViewState(super.onSaveInstanceState(),opened)  } 
@Override protected void onRestoreInstanceState(Parcelable state){   if (state instanceof ViewState) {     final ViewState viewState=(ViewState)state      super.onRestoreInstanceState(viewState.getSuperState())      if (viewState.mOpened) {       openImmediately()      }  else {       closeImmediately()      }   }  else {     super.onRestoreInstanceState(state)    } } 
/**   * @return child view which is slided, in contrast to main view this view may be not shown initially and may appear only after user actions  */ @Nonnull private View getSlidingView(){   if (slidingView == null) {     slidingView=findViewById(attributes.getSlidingViewId())    }   return slidingView  } 
@Nonnull private View getMainView(){   if (mainView == null) {     mainView=findViewById(attributes.getMainViewId())    }   return mainView  } 
public void setAlwaysOpened(boolean opened){   alwaysOpened=opened    requestLayout()  } 
public void setOnSlideListener(OnSlideListener lis){   listener=lis  } 
public boolean isOpened(){   return slidingViewState == SlidingViewState.Opened  } 
public void toggle(boolean immediately){   if (immediately) {     toggleImmediately()    }  else {     toggle()    } } 
public void toggle(){   if (isOpened()) {     close()    }  else {     open()    } } 
public void toggleImmediately(){   if (isOpened()) {     closeImmediately()    }  else {     openImmediately()    } } 
public boolean open(){   if (isOpened() || alwaysOpened || slidingViewState.isTransition()) {     return false    }   initSlideMode()    startAnimation(slider.newOpenAnimation())    invalidate()    return true  } 
public boolean openImmediately(){   if (isOpened() || alwaysOpened || slidingViewState.isTransition()) {     return false    }   getSlidingView().setVisibility(View.VISIBLE)    slidingViewState=SlidingViewState.Opened    requestLayout()    if (listener != null) {     listener.onSlideCompleted(true)    }   return true  } 
public boolean close(){   if (!isOpened() || alwaysOpened || slidingViewState.isTransition()) {     return false    }   initSlideMode()    startAnimation(slider.newCloseAnimation())    invalidate()    return true  } 
public boolean closeImmediately(){   if (!isOpened() || alwaysOpened || slidingViewState.isTransition()) {     return false    }   if (!attributes.isSlidingViewLedgeExists()) {     getSlidingView().setVisibility(View.GONE)    }   slidingViewState=SlidingViewState.Closed    requestLayout()    if (listener != null) {     listener.onSlideCompleted(false)    }   return true  } 
@Override public boolean dispatchTouchEvent(MotionEvent e){   if (alwaysOpened) {     return super.dispatchTouchEvent(e)    }  else   if (!isEnabled() && slidingViewState == SlidingViewState.Closed) {     return super.dispatchTouchEvent(e)    }   if (slidingViewState != SlidingViewState.Opened) {     onTouchEvent(e)      if (slidingViewState.isEndState()) {       super.dispatchTouchEvent(e)      }  else {       final MotionEvent cancelEvent=MotionEvent.obtain(e)        cancelEvent.setAction(MotionEvent.ACTION_CANCEL)        super.dispatchTouchEvent(cancelEvent)      }     return true    }  else {     final View slidingView=getSlidingView()      final View mainView=getMainView()      final Rect slidingRect=new Rect()      slidingView.getHitRect(slidingRect)      if (!slidingRect.contains((int)e.getX(),(int)e.getY())) {       e.offsetLocation(-mainView.getLeft(),-mainView.getTop())        mainView.dispatchTouchEvent(e)        e.offsetLocation(mainView.getLeft(),mainView.getTop())        onTouchEvent(e)        return true      }  else {       onTouchEvent(e)        e.offsetLocation(-slidingView.getLeft(),-slidingView.getTop())        slidingView.dispatchTouchEvent(e)        return true      }   } } 
private boolean handleTouchEvent(@Nonnull MotionEvent e){   if (!isEnabled()) {     return false    }   final float z  switch (attributes.getSlidingViewPosition()) { case left: case right:     z=e.getX()    break  case top: case bottom: z=e.getY()  break  default : throw new UnsupportedOperationException()  } switch (e.getAction()) { case MotionEvent.ACTION_DOWN: mHistoricalZ=(int)z  return true  case MotionEvent.ACTION_MOVE: return handleTouchMove(z)  case MotionEvent.ACTION_UP: if (slidingViewState == SlidingViewState.InTransition) { slider.finishSlide()  } return false  } return slidingViewState.isTransition()  } 
private boolean handleTouchMove(float z){   final float diff=z - mHistoricalZ    final float prevHistoricalZ=mHistoricalZ    mHistoricalZ=(int)z    if (slidingViewState.isTransition()) {     if (slidingViewState == SlidingViewState.InTransition) {       slider.addOffsetDelta((int)diff)      }     return true    }  else {     final boolean openingAllowed      final boolean closingAllowed  switch (attributes.getSlidingViewPosition()) { case left: case top:       openingAllowed=diff > MIN_Z_DIFF && slidingViewState == SlidingViewState.Closed      closingAllowed=diff < -MIN_Z_DIFF && slidingViewState == SlidingViewState.Opened    break  case right: case bottom: openingAllowed=diff < -MIN_Z_DIFF && slidingViewState == SlidingViewState.Closed  closingAllowed=diff > MIN_Z_DIFF && slidingViewState == SlidingViewState.Opened  break  default : throw new UnsupportedOperationException()  } if (openingAllowed || closingAllowed) { if (slider.canStartSlide(prevHistoricalZ)) { initSlideMode()  slider.addOffsetDelta((int)diff)  } } return false  } } 
@Override public void startAnimation(Animation animation){   slidingViewState=SlidingViewState.InAnimation    super.startAnimation(animation)  } 
@Override public boolean onTouchEvent(MotionEvent ev){   boolean handled=handleTouchEvent(ev)    invalidate()    return handled  } 
private void initSlideMode(){   final View mainView=getMainView()    final int openedOffset    final int width=getWidth()    final int height=getHeight()  switch (attributes.getSlidingViewPosition()) { case left: case right:     openedOffset=getSlidingView().getMeasuredWidth()    break  case bottom: case top: openedOffset=getSlidingView().getMeasuredHeight()  break  default : throw new UnsupportedOperationException("")  } slider.init(attributes.getSlidingViewLedge(),openedOffset,slidingViewState == SlidingViewState.Closed)  if (cachedBitmap == null || cachedBitmap.isRecycled() || cachedBitmap.getWidth() != width) { cachedBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888)  cachedCanvas=new Canvas(cachedBitmap)  } mainView.setVisibility(View.VISIBLE)  updateCachedCanvas()  slidingViewState=SlidingViewState.InTransition  getSlidingView().setVisibility(View.VISIBLE)  } 
@Override public void onSlideCompleted(final boolean opened){   requestLayout()    post(new Runnable(){     @Override public void run(){       if (opened) {         slidingViewState=SlidingViewState.Opened          if (!attributes.isSlidingViewLedgeExists()) {           getSlidingView().setVisibility(View.VISIBLE)          }       }  else {         slidingViewState=SlidingViewState.Closed          if (!attributes.isSlidingViewLedgeExists()) {           getSlidingView().setVisibility(View.GONE)          }       }     }   } )    if (listener != null) {     listener.onSlideCompleted(opened)    } } 
@Override public void run(){   if (opened) {     slidingViewState=SlidingViewState.Opened      if (!attributes.isSlidingViewLedgeExists()) {       getSlidingView().setVisibility(View.VISIBLE)      }   }  else {     slidingViewState=SlidingViewState.Closed      if (!attributes.isSlidingViewLedgeExists()) {       getSlidingView().setVisibility(View.GONE)      }   } } 
void SlidingViewState(boolean endState){   mEndState=endState  } 
public boolean isEndState(){   return mEndState  } 
public boolean isTransition(){   return !isEndState()  } 
public ViewState(Parcel in){   super(in)    mOpened=in.readInt() == 1  } 
public ViewState(Parcelable state,boolean opened){   super(state)    mOpened=opened  } 
@Override public void writeToParcel(Parcel out,int flags){   super.writeToParcel(out,flags)    out.writeInt(this.mOpened ? 1 : 0)  } 
SideBarSlider(@Nonnull View sideBarLayout,SideBarAttributes attributes,@Nullable OnSlideListener onSlideListener){   this.sideBarLayout=sideBarLayout    this.offset=attributes.getSlidingViewLedge()    this.closedOffset=attributes.getSlidingViewLedge()    this.openedOffset=attributes.getSlidingViewLedge()    this.opening=true    this.attributes=attributes    this.onSlideListener=onSlideListener  } 
public void init(int closedOffset,int openedOffset,boolean opening){   if (opening) {     this.offset=closedOffset    }  else {     this.offset=openedOffset    }   this.closedOffset=closedOffset    this.openedOffset=openedOffset    this.opening=opening  } 
public int getOffsetOnScreen(){   final int result  switch (attributes.getSlidingViewPosition()) { case left: case top:     result=offset    break  case right: result=sideBarLayout.getMeasuredWidth() - offset  break  case bottom: result=sideBarLayout.getMeasuredHeight() - offset  break  default : throw new UnsupportedOperationException()  } return result  } 
public void completeOpening(){   offset=openedOffset  } 
public void completeClosing(){   offset=closedOffset  } 
public int getOffset(){   return offset  } 
public boolean isOpening(){   return opening  } 
@Nonnull public Animation newCloseAnimation(){   offset=Math.max(offset,closedOffset)    final Animation animation=new SlideAnimation(offset,closedOffset)    animation.setAnimationListener(closeListener)    return animation  } 
@Nonnull public Animation newOpenAnimation(){   offset=Math.min(offset,openedOffset)    final Animation animation=new SlideAnimation(offset,openedOffset)    animation.setAnimationListener(openListener)    return animation  } 
public void addOffsetDelta(int delta){ switch (attributes.getSlidingViewPosition()) { case left: case top:     offset+=delta    break  case right: case bottom: offset-=delta  break  } final boolean canFinishSlide=offset <= closedOffset || offset >= openedOffset  offset=Math.min(offset,openedOffset)  offset=Math.max(offset,closedOffset)  if (canFinishSlide) { finishSlide()  } } 
public void finishSlide(){   final boolean proceedOpening    if (isOpening()) {     final int third=Math.abs(openedOffset + 2 * closedOffset) / 3      proceedOpening=offset > third    }  else {     final int twoThirds=Math.abs(2 * openedOffset + closedOffset) / 3      proceedOpening=offset > twoThirds    }   sideBarLayout.startAnimation(proceedOpening ? newOpenAnimation() : newCloseAnimation())  } 
@Override public String toString(){   return "SideBarViewOffsets{" + "offset=" + offset + ", closedOffset="+ closedOffset+ ", openedOffset="+ openedOffset+ ", opening="+ opening+ '}'  } 
public boolean canStartSlide(float z){   final boolean result  switch (attributes.getSlidingViewPosition()) { case left: case top:     result=z < getOffsetOnScreen() + MAX_OFFSET_DIFF    break  case right: case bottom: result=z > getOffsetOnScreen() - MAX_OFFSET_DIFF  break  default : throw new UnsupportedOperationException()  } return result  } 
public SlideAnimation(float fromX,float toX){   mStart=fromX    mEnd=toX    setInterpolator(new DecelerateInterpolator())    float duration=Math.abs(mEnd - mStart) / SPEED    setDuration((long)duration)  } 
@Override protected void applyTransformation(float interpolatedTime,Transformation t){   super.applyTransformation(interpolatedTime,t)    final float offset=(mEnd - mStart) * interpolatedTime + mStart    SideBarSlider.this.offset=(int)offset    sideBarLayout.postInvalidate()  } 
@Override public void onAnimationStart(Animation animation){ } 
@Override public void onAnimationRepeat(Animation animation){ } 
@Override public void onAnimationEnd(Animation animation){   completeOpening()    onSlideListener.onSlideCompleted(true)  } 
@Override public void onAnimationStart(Animation animation){ } 
@Override public void onAnimationRepeat(Animation animation){ } 
@Override public void onAnimationEnd(Animation animation){   completeClosing()    onSlideListener.onSlideCompleted(false)  } 
private TextViewBuilder(){ } 
@Nonnull public static UpdatableViewBuilder<TextView> newInstance(int textViewLayoutId,@Nullable String tag){   final TextViewBuilder result=new TextViewBuilder()    result.textViewLayoutId=textViewLayoutId    result.tag=tag    return result  } 
@Nonnull @Override public TextView build(@Nonnull Context context){   final TextView result=ViewFromLayoutBuilder.<TextView>newInstance(textViewLayoutId).build(context)    result.setTag(createViewTag())    return updateView(context,result)  } 
@Nonnull private String createViewTag(){   return tag == null ? this.getClass().getName() : tag  } 
@Nonnull @Override public TextView updateView(@Nonnull Context context,@Nonnull View view){   if (createViewTag().equals(view.getTag())) {     return (TextView)view    }  else {     return build(context)    } } 
public VibratorContainer(@Nullable Vibrator vibrator,@Nonnull SharedPreferences preferences,float vibrationTimeScale){   this.vibrator=vibrator    this.vibrationTimeScale=vibrationTimeScale    preferences.registerOnSharedPreferenceChangeListener(this)    onSharedPreferenceChanged(preferences,null)  } 
public void vibrate(){   if (time > 0 && vibrator != null) {     vibrator.vibrate(time)    } } 
@Override public void onSharedPreferenceChanged(SharedPreferences preferences,@Nullable String key){   if (Preferences.hapticFeedbackEnabled.getPreference(preferences)) {     this.time=getScaledValue(Preferences.hapticFeedbackDuration.getPreference(preferences))    }  else {     this.time=0    } } 
private long getScaledValue(long vibrationTime){   return (long)(vibrationTime * vibrationTimeScale)  } 
@Nullable Float getLayoutWeight()  
@Nullable Integer getLayoutMarginLeft()  
@Nullable Integer getLayoutMarginRight()  
@Nullable String getTag()  
@Nullable Integer getBackgroundResId()  
private ViewFromLayoutBuilder(int layoutId,int viewId,boolean wholeLayout){   this.layoutId=layoutId    this.viewId=viewId    this.wholeLayout=wholeLayout  } 
@Nonnull public static <V extends View>ViewFromLayoutBuilder<V> newInstance(int layoutId,int viewId){   return new ViewFromLayoutBuilder<V>(layoutId,viewId,false)  } 
@Nonnull public static <V extends View>ViewFromLayoutBuilder<V> newInstance(int layoutId){   return new ViewFromLayoutBuilder<V>(layoutId,0,true)  } 
public void setLayoutInflater(@Nullable LayoutInflater layoutInflater){   this.layoutInflater=layoutInflater  } 
@Nonnull @Override public V build(@Nonnull Context context){   LayoutInflater li=layoutInflater    if (li == null) {     li=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)    }   if (wholeLayout) {     return (V)li.inflate(layoutId,null)    }  else {     final ViewGroup itemView=(ViewGroup)li.inflate(layoutId,null)      return (V)itemView.findViewById(viewId)    } } 
void dispatchDraw(@Nonnull View view,@Nonnull Canvas canvas)  
public BaseWizard(@Nonnull String name,@Nonnull Context context,@Nonnull WizardFlow flow){   this.name=name    this.context=context    this.flow=flow  } 
@Override public void saveLastStep(@Nonnull WizardStep step){   final SharedPreferences preferences=getPreferences()    final SharedPreferences.Editor editor=preferences.edit()    editor.putString(makeLastStepPreferenceKey(name),step.getName())    editor.commit()  } 
@Override public void saveFinished(@Nonnull WizardStep step,boolean forceFinish){   final SharedPreferences preferences=getPreferences()    final SharedPreferences.Editor editor=preferences.edit()    editor.putBoolean(makeFinishedPreferenceKey(name),forceFinish || flow.getNextStep(step) == null)    editor.commit()  } 
@Nonnull private SharedPreferences getPreferences(){   return getDefaultSharedPreferences(context)  } 
@Override @Nullable public String getLastSavedStepName(){   return getPreferences().getString(makeLastStepPreferenceKey(name),null)  } 
@Override public boolean isFinished(){   return getPreferences().getBoolean(makeFinishedPreferenceKey(name),false)  } 
@Override public boolean isStarted(){   return getLastSavedStepName() != null  } 
@Nonnull static String makeFinishedPreferenceKey(@Nonnull String flowName){   return FLOW_FINISHED + ":" + flowName  } 
@Nonnull static String makeLastStepPreferenceKey(@Nonnull String flowName){   return FLOW + ":" + flowName  } 
@Override @Nonnull public WizardFlow getFlow(){   return flow  } 
@Nonnull @Override public String getName(){   return name  } 
protected BaseWizardActivity(int layoutResId){   ui=new WizardUi<BaseWizardActivity>(this,this,layoutResId)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    ui.onCreate(savedInstanceState)  } 
@Override protected void onSaveInstanceState(Bundle out){   super.onSaveInstanceState(out)    ui.onSaveInstanceState(out)  } 
@Override public void onPause(){   super.onPause()    ui.onPause()  } 
@Override public void onBackPressed(){   ui.onBackPressed()  } 
@Override public void finishWizardAbruptly(){   ui.finishWizardAbruptly()  } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   final AlertDialog.Builder b=new AlertDialog.Builder(getActivity())    b.setMessage(R.string.acl_wizard_finish_confirmation)    b.setPositiveButton(R.string.acl_yes,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       ((Listener)getActivity()).finishWizardAbruptly()      }   } )    b.setNegativeButton(R.string.acl_no,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       dismiss()      }   } )    return b.create()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   ((Listener)getActivity()).finishWizardAbruptly()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   dismiss()  } 
public static <A extends FragmentActivity & Listener>void show(@Nonnull A activity){   if (!(activity instanceof Listener)) {     throw new IllegalArgumentException("Activity should implement " + Listener.class)    }   AndroidSherlockUtils.showDialog(new FinishWizardConfirmationDialog(),FinishWizardConfirmationDialog.class.getSimpleName(),activity.getSupportFragmentManager())  } 
void finishWizardAbruptly()  
public ListWizardFlow(@Nonnull List<WizardStep> steps){   this.steps=steps  } 
@Nullable @Override public WizardStep getStepByName(@Nonnull final String name){ } 
@Nullable @Override public WizardStep getNextStep(@Nonnull WizardStep step){   final int i=steps.indexOf(step)    if (i >= 0 && i + 1 < steps.size()) {     return steps.get(i + 1)    }  else {     return null    } } 
@Nullable @Override public WizardStep getPrevStep(@Nonnull WizardStep step){   final int i=steps.indexOf(step)    if (i >= 1) {     return steps.get(i - 1)    }  else {     return null    } } 
@Nonnull @Override public WizardStep getFirstStep(){   return steps.get(0)  } 
@Nullable String getLastSavedStepName()  
boolean isFinished()  
boolean isStarted()  
void saveLastStep(@Nonnull WizardStep step)  
void saveFinished(@Nonnull WizardStep step,boolean forceFinish)  
@Nonnull WizardFlow getFlow()  
@Nonnull String getName()  
@Nullable WizardStep getStepByName(@Nonnull String name)  
@Nullable WizardStep getNextStep(@Nonnull WizardStep step)  
@Nullable WizardStep getPrevStep(@Nonnull WizardStep step)  
@Nonnull WizardStep getFirstStep()  
@Nonnull Class<? extends Activity> getActivityClassName()  
@Nonnull public Wizard getWizard(@Nullable String name) throws IllegalArgumentException   
@Nonnull Wizards getWizards()  
@Nonnull String getFragmentTag()  
@Nonnull Class<? extends Fragment> getFragmentClass()  
@Nullable Bundle getFragmentArgs()  
int getTitleResId()  
int getNextButtonTitleResId()  
boolean onNext(@Nonnull Fragment fragment)  
boolean onPrev(@Nonnull Fragment fragment)  
boolean isVisible()  
@Nonnull String getName()  
public WizardUi(@Nonnull A activity,@Nonnull WizardsAware wizardsAware,int layoutResId){   this.activity=activity    this.wizardsAware=wizardsAware    this.layoutResId=layoutResId  } 
public void onCreate(@Nullable Bundle savedInstanceState){   activity.setContentView(layoutResId)    prevButton=activity.findViewById(R.id.acl_wizard_prev_button)    nextButton=(Button)activity.findViewById(R.id.acl_wizard_next_button)    String wizardName=activity.getIntent().getStringExtra(FLOW)    String stepName=activity.getIntent().getStringExtra(STEP)    if (savedInstanceState != null) {     wizardName=savedInstanceState.getString(FLOW)      stepName=savedInstanceState.getString(STEP)    }   wizard=wizardsAware.getWizards().getWizard(wizardName)    WizardStep step=null    if (stepName != null) {     step=wizard.getFlow().getStepByName(stepName)    }   if (step == null) {     step=wizard.getFlow().getFirstStep()    }   setStep(step)  } 
public void setStep(@Nonnull WizardStep step){   if (this.step == null || !this.step.equals(step)) {     hideFragment()      this.step=step      showFragment()      initTitle()      initNextButton()      initPrevButton()    } } 
private void initTitle(){   activity.setTitle(step.getTitleResId())  } 
private void initPrevButton(){   if (prevButton != null) {     final WizardStep prevStep=wizard.getFlow().getPrevStep(step)      if (prevStep == null) {       prevButton.setVisibility(GONE)        prevButton.setOnClickListener(null)      }  else {       prevButton.setVisibility(VISIBLE)        prevButton.setOnClickListener(new View.OnClickListener(){         @Override public void onClick(        View v){           if (tryGoPrev()) {             setStep(prevStep)            }         }       } )      }   } } 
@Override public void onClick(View v){   if (tryGoPrev()) {     setStep(prevStep)    } } 
private void initNextButton(){   final WizardStep nextStep=wizard.getFlow().getNextStep(step)    if (nextStep == null) {     nextButton.setText(R.string.acl_wizard_finish)      nextButton.setOnClickListener(new View.OnClickListener(){       @Override public void onClick(      View v){         if (tryGoNext()) {           finishWizard()          }       }     } )    }  else {     nextButton.setText(step.getNextButtonTitleResId())      nextButton.setOnClickListener(new View.OnClickListener(){       @Override public void onClick(      View v){         if (tryGoNext()) {           setStep(nextStep)          }       }     } )    } } 
@Override public void onClick(View v){   if (tryGoNext()) {     finishWizard()    } } 
@Override public void onClick(View v){   if (tryGoNext()) {     setStep(nextStep)    } } 
public void finishWizardAbruptly(){   finishWizard(true)  } 
public void finishWizard(){   finishWizard(false)  } 
void finishWizard(boolean forceFinish){   if (wizard != null && step != null) {     wizard.saveFinished(step,forceFinish)    }   activity.finish()  } 
private boolean tryGoPrev(){   if (step == null) {     return true    }  else {     final Fragment fragment=getFragmentManager().findFragmentByTag(step.getFragmentTag())      return fragment == null || step.onPrev(fragment)    } } 
@Nonnull private FragmentManager getFragmentManager(){   return activity.getSupportFragmentManager()  } 
private boolean tryGoNext(){   if (step == null) {     return true    }  else {     final Fragment fragment=getFragmentManager().findFragmentByTag(step.getFragmentTag())      return fragment == null || step.onNext(fragment)    } } 
@Nonnull private Fragment showFragment(){   final FragmentManager fm=getFragmentManager()    final FragmentTransaction ft=fm.beginTransaction()    Fragment newFragment=fm.findFragmentByTag(step.getFragmentTag())    if (newFragment == null) {     newFragment=Fragment.instantiate(activity,step.getFragmentClass().getName(),step.getFragmentArgs())      ft.add(R.id.acl_wizard_content,newFragment,step.getFragmentTag())    }   ft.commit()    fm.executePendingTransactions()    return newFragment  } 
private void hideFragment(){   final FragmentManager fm=getFragmentManager()    final FragmentTransaction ft=fm.beginTransaction()    if (step != null) {     hideFragmentByTag(fm,ft,step.getFragmentTag())    }   ft.commit()    fm.executePendingTransactions()  } 
private void hideFragmentByTag(@Nonnull FragmentManager fm,@Nonnull FragmentTransaction ft,@Nonnull String fragmentTag){   final Fragment oldFragment=fm.findFragmentByTag(fragmentTag)    if (oldFragment != null) {     ft.remove(oldFragment)    } } 
public void onSaveInstanceState(@Nonnull Bundle out){   out.putString(FLOW,wizard.getName())    out.putString(STEP,step.getName())  } 
public void onPause(){   if (wizard != null && step != null) {     wizard.saveLastStep(step)    } } 
public void onBackPressed(){   FinishWizardConfirmationDialog.show(activity)  } 
public WizardStep getStep(){   return step  } 
public WizardFlow getFlow(){   return wizard.getFlow()  } 
public Wizard getWizard(){   return wizard  } 
@Nullable public View getPrevButton(){   return prevButton  } 
public View getNextButton(){   return nextButton  } 
public static void startWizard(@Nonnull Wizards wizards,@Nonnull Context context){   context.startActivity(createLaunchIntent(wizards,null,context))  } 
public static void startWizard(@Nonnull Wizards wizards,@Nullable String name,@Nonnull Context context){   context.startActivity(createLaunchIntent(wizards,name,context))  } 
public static void continueWizard(@Nonnull Wizards wizards,@Nonnull String name,@Nonnull Context context){   final Intent intent=createLaunchIntent(wizards,name,context)    final Wizard wizard=wizards.getWizard(name)    final String step=wizard.getLastSavedStepName()    tryPutStep(intent,step)    context.startActivity(intent)  } 
public static void tryPutStep(@Nonnull Intent intent,@Nullable WizardStep step){   tryPutStep(intent,step != null ? step.getName() : null)  } 
private static void tryPutStep(@Nonnull Intent intent,@Nullable String step){   if (step != null) {     intent.putExtra(STEP,step)    } } 
@Nonnull private static Intent createLaunchIntent(@Nonnull Wizards wizards,@Nullable String name,@Nonnull Context context){   final Intent intent=new Intent(context,wizards.getActivityClassName())    intent.putExtra(FLOW,name)    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)    return intent  } 
public static Uri buildUriForItem(long itemId){   return ContentUris.withAppendedId(CONTENT_URI,itemId)  } 
public Database(Context context){   super(context,DB_NAME,null,DB_VERSION)  } 
@Override public void onCreate(SQLiteDatabase db){   db.execSQL("create table " + Tables.PEOPLE + " ("+ Contract.PeopleColumns._ID+ " INTEGER PRIMARY KEY AUTOINCREMENT, "+ Contract.PeopleColumns.FIRST_NAME+ " TEXT NOT NULL, "+ Contract.PeopleColumns.SECOND_NAME+ " TEXT NOT NULL)")  } 
@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){ } 
public static void schedule(Context context){   context.startService(new Intent(context,PeopleInsertingService.class))  } 
public PeopleInsertingService(){   super(NAME)  } 
@Override protected void onHandleIntent(Intent intent){   final SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this)    if (!prefs.getBoolean(KEY_ALREADY_INSERTED,false)) {     insertStuff()      prefs.edit().putBoolean(KEY_ALREADY_INSERTED,true).commit()    } } 
private void insertStuff(){   ArrayList<ContentProviderOperation> operations=Lists.newArrayList()    for (  String name : NAMES) {     String[] firstAndSecond=name.split(" ")      final ContentValues values=new ContentValues()      values.put(Contract.People.FIRST_NAME,firstAndSecond[0])      values.put(Contract.People.SECOND_NAME,firstAndSecond[1])      final ContentProviderOperation operation=ContentProviderOperation.newInsert(Contract.People.CONTENT_URI).withValues(values).build()      operations.add(operation)    }   try {     getContentResolver().applyBatch(Contract.AUTHORITY,operations)    }  catch (  RemoteException e) {     Log.e(NAME,"RemoteException: ",e)    } catch (  OperationApplicationException e) {     Log.e(NAME,"OperationApplicationException: ",e)    } } 
@Override public boolean onCreate(){   mDatabase=new Database(getContext())    return true  } 
@Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String orderBy){ switch (sUriMatcher.match(uri)) { case PEOPLE_DIR:     final Cursor result=Query.select().columns(projection).from(Database.Tables.PEOPLE).where(selection,(Object[])selectionArgs).orderBy(orderBy).build().perform(mDatabase.getReadableDatabase())    result.setNotificationUri(getContentResolver(),Contract.People.CONTENT_URI)  return result  default : throw new IllegalArgumentException("Couldn't match uri: " + uri)  } } 
@Override public String getType(Uri uri){ switch (sUriMatcher.match(uri)) { case PEOPLE_DIR:     return "vnd.android.cursor.dir/people"  } throw new IllegalArgumentException("Couldn't match uri: uri")  } 
@Override public Uri insert(Uri uri,ContentValues contentValues){ switch (sUriMatcher.match(uri)) { case PEOPLE_DIR:     final long id=Insert.insert().into(Database.Tables.PEOPLE).values(contentValues).perform(mDatabase.getWritableDatabase())    getContentResolver().notifyChange(Contract.People.CONTENT_URI,null)  return Contract.People.buildUriForItem(id)  } throw new IllegalArgumentException("Couldn't match uri: uri")  } 
@Override public int delete(Uri uri,String s,String[] strings){   throw new UnsupportedOperationException("This operation is not yet supported")  } 
@Override public int update(Uri uri,ContentValues contentValues,String s,String[] strings){   throw new UnsupportedOperationException("This operation is not yet supported")  } 
private ContentResolver getContentResolver(){   return getContext().getContentResolver()  } 
public Person(String firstName,String lastName){   this.firstName=firstName    this.lastName=lastName  } 
public String getFirstName(){   return firstName  } 
public String getLastName(){   return lastName  } 
@Override public Character getSection(){   return firstName.charAt(0)  } 
public String getFullname(){   return String.format("%s %s",firstName,lastName)  } 
T getSection()  
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    PeopleInsertingService.schedule(this)    setContentView(R.layout.activity_main)    Button button=(Button)findViewById(R.id.toggle)    button.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View view){       toggleFragment()      }   } )    if (savedInstanceState == null) {     toggleFragment()    } } 
@Override public void onClick(View view){   toggleFragment()  } 
private void toggleFragment(){   final Fragment fragment=fragmentsQueue.poll()    fragmentsQueue.add(fragment)    getSupportFragmentManager().beginTransaction().replace(R.id.content,fragment).commit()  } 
public SectionedPeopleAdapter(Context context){   this.context=context    inflater=LayoutInflater.from(context)  } 
public void setNewModel(SectionedPeopleList list){   this.currentList=list    notifyDataSetChanged()  } 
@Override public int getCount(){   if (currentList == null) {     return 0    }   return currentList.getCount()  } 
@Override public Object getItem(int position){   if (currentList.isSection(position)) {     return currentList.getSection(position)    }   return currentList.getItem(position)  } 
@Override public long getItemId(int position){   return 0  } 
@Override public View getView(int position,View view,ViewGroup viewGroup){   if (view == null) {     view=inflater.inflate(android.R.layout.simple_list_item_1,viewGroup,false)      ViewHolder holder=new ViewHolder()      holder.text=(TextView)view.findViewById(android.R.id.text1)      view.setTag(holder)    }   ViewHolder holder=(ViewHolder)view.getTag()    holder.text.setTextColor(getColorForPosition(position))    holder.text.setText(getTextForPosition(position))    return view  } 
private int getColorForPosition(int position){   if (currentList.isSection(position)) {     return context.getResources().getColor(R.color.section_header)    }   return context.getResources().getColor(android.R.color.white)  } 
private CharSequence getTextForPosition(int position){   if (currentList.isSection(position)) {     return String.valueOf(currentList.getSection(position))    }   final Person person=currentList.getItem(position)    return person.getFullname()  } 
public SectionedPeopleList(List<Person> people){   this.people=ImmutableList.copyOf(people)    naiveAlgorithmInitialize()  } 
private void naiveAlgorithmInitialize(){   Character currSection=null    sections=Maps.newTreeMap()    int index=0    for (  Person person : people) {     final Character section=person.getSection()      if (!section.equals(currSection)) {       sections.put(sections.size() + index,section)        currSection=section      }     index++    } } 
public boolean isSection(int position){   return sections.get(position) != null  } 
public char getSection(int position){   return sections.get(position)  } 
public Person getItem(int position){   int positionInList=position - sections.headMap(position).size()    return people.get(positionInList)  } 
public int getCount(){   return people.size() + sections.size()  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    mAdapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_list_item_1,android.R.id.text1)    setListAdapter(mAdapter)  } 
@Override public void onActivityCreated(Bundle savedInstanceState){   super.onActivityCreated(savedInstanceState)    loaderHelper.initLoader(this,null,this)  } 
@Override protected Loader<List<String>> onCreateLoader(Context context,Bundle args){   return CursorLoaderBuilder.forUri(Contract.People.CONTENT_URI).projection(Contract.People.FIRST_NAME,Contract.People.SECOND_NAME).transformRow(new Function<Cursor,String>(){     @Override public String apply(    Cursor cursor){       return String.format("%s %s",cursor.getString(0),cursor.getString(1))      }   } ).lazy().build(context)  } 
@Override public String apply(Cursor cursor){   return String.format("%s %s",cursor.getString(0),cursor.getString(1))  } 
@Override public void onLoadFinished(Loader<List<String>> loader,List<String> data){   for (  String s : data) {     mAdapter.add(s)    } } 
@Override public void onLoaderReset(Loader<List<String>> loader){   mAdapter.clear()  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    adapter=new SectionedPeopleAdapter(getActivity())    setListAdapter(adapter)  } 
@Override public void onActivityCreated(Bundle savedInstanceState){   super.onActivityCreated(savedInstanceState)    loaderHelper.initLoader(this,null,this)  } 
@Override protected Loader<SectionedPeopleList> onCreateLoader(Context context,Bundle args){   return CursorLoaderBuilder.forUri(Contract.People.CONTENT_URI).projection(Contract.People.FIRST_NAME,Contract.People.SECOND_NAME).orderBy(Contract.People.FIRST_NAME).transformRow(new Function<Cursor,Person>(){     @Override public Person apply(    Cursor cursor){       final String firstName=cursor.getString(cursor.getColumnIndexOrThrow(Contract.PeopleColumns.FIRST_NAME))        final String secondName=cursor.getString(cursor.getColumnIndexOrThrow(Contract.PeopleColumns.SECOND_NAME))        return new Person(firstName,secondName)      }   } ).lazy().transform(new Function<List<Person>,SectionedPeopleList>(){     @Override public SectionedPeopleList apply(    List<Person> people){       return new SectionedPeopleList(people)      }   } ).build(context)  } 
@Override public Person apply(Cursor cursor){   final String firstName=cursor.getString(cursor.getColumnIndexOrThrow(Contract.PeopleColumns.FIRST_NAME))    final String secondName=cursor.getString(cursor.getColumnIndexOrThrow(Contract.PeopleColumns.SECOND_NAME))    return new Person(firstName,secondName)  } 
@Override public SectionedPeopleList apply(List<Person> people){   return new SectionedPeopleList(people)  } 
@Override public void onLoadFinished(Loader<SectionedPeopleList> loader,SectionedPeopleList data){   adapter.setNewModel(data)  } 
@Override public void onLoaderReset(Loader<SectionedPeopleList> loader){   adapter.setNewModel(null)  } 
public QueryData(Uri uri,String[] projection,String selection,String[] selectionArgs,String orderBy){   this.uri=uri    this.projection=projection    this.selection=selection    this.selectionArgs=selectionArgs    this.orderBy=orderBy  } 
public Uri getUri(){   return uri  } 
public String[] getProjection(){   return projection  } 
public String getSelection(){   return selection  } 
public String[] getSelectionArgs(){   return selectionArgs  } 
public String getOrderBy(){   return orderBy  } 
private Cursors(){ } 
/**   * Transforms  {@code cursor} to {@link com.google.common.collect.FluentIterable}of type  {@code T} by applying the {@code singleRowTransform} to every row.  */ public static <T>FluentIterable<T> toFluentIterable(Cursor cursor,Function<? super Cursor,T> singleRowTransform){   List<T> transformed=Lists.newArrayList()    if (cursor != null) {     for (int i=0  cursor.moveToPosition(i)  i++) {       transformed.add(singleRowTransform.apply(cursor))      }   }   return FluentIterable.from(transformed)  } 
/**   * Closes non-null and opened  {@code cursor} or does nothing in case {@code cursor}is null or it's already closed.  */ public static void closeQuietly(Cursor cursor){   if (cursor != null && !cursor.isClosed()) {     cursor.close()    } } 
/**   * Returns  {@code cursor} if it's not null, otherwise returns new instanceof  {@link android.database.Cursor} with no data and no columns.  */ public static Cursor returnSameOrEmptyIfNull(Cursor cursor){   if (cursor == null) {     return new EmptyCursor()    }   return cursor  } 
public EmptyCursor(){   super(new String[]{})  } 
@Override public int getColumnIndexOrThrow(String columnName){   return -1  } 
@Override public int getColumnIndex(String columnName){   return -1  } 
public FluentCursor(Cursor cursor){   super(Cursors.returnSameOrEmptyIfNull(cursor))  } 
/**   * Transforms Cursor to FluentIterable of T applying given function WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @param singleRowTransform Function to apply on every single row of this cursor  * @param < T > Type of Iterable's single element  * @return Transformed iterable  */ public <T>FluentIterable<T> toFluentIterable(Function<? super Cursor,T> singleRowTransform){   try {     return Cursors.toFluentIterable(this,singleRowTransform)    }   finally {     close()    } } 
/**   * Transforms Cursor to LazyCursorList of T applying given function WARNING: This method doesn't close cursor. You are responsible for calling close() on returned list or on backing Cursor.  * @param singleRowTransform Function to apply on every single row of this cursor  * @param < T > Type of List's single element  * @return Transformed list  */ public <T>LazyCursorList<T> toLazyCursorList(Function<? super Cursor,T> singleRowTransform){   return new LazyCursorList<>(this,singleRowTransform)  } 
/**   * Transforms Cursor to LinkedHashMultimap<TKey, TValue> by applying given functions. The iteration order for the returned map is the same as the iteration order over rows of Cursor. WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @param keyTransform Function to apply on every single row of this cursorto get the key of the entry representing this row.  * @param valueTransform Function to apply on every single row of this cursorto get the value of the entry representing this row.  * @param < TKey > Type of keys in the returned multimap  * @param < TValue > Type of values in the returned multimap  * @return Transformed map  */ public <TKey,TValue>LinkedHashMultimap<TKey,TValue> toMultimap(Function<? super Cursor,TKey> keyTransform,Function<? super Cursor,TValue> valueTransform){   try {     LinkedHashMultimap<TKey,TValue> result=LinkedHashMultimap.create(getCount(),1)      for (moveToFirst()  !isAfterLast()  moveToNext()) {       result.put(keyTransform.apply(this),valueTransform.apply(this))      }     return result    }   finally {     close()    } } 
/**   * Transforms Cursor to LinkedHashMap<TKey, TValue> by applying given functions. The iteration order for the returned map is the same as the iteration order over rows of Cursor. WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @param keyTransform Function to apply on every single row of this cursorto get the key of the entry representing this row.  * @param valueTransform Function to apply on every single row of this cursorto get the value of the entry representing this row.  * @param < TKey > Type of keys in the returned map  * @param < TValue > Type of values in the returned map  * @return Transformed map  * @throws IllegalArgumentException if Cursor contains duplicate keys  */ public <TKey,TValue>LinkedHashMap<TKey,TValue> toMap(Function<? super Cursor,TKey> keyTransform,Function<? super Cursor,TValue> valueTransform){   try {     LinkedHashMap<TKey,TValue> result=new LinkedHashMap<>(getCount(),1)      for (moveToFirst()  !isAfterLast()  moveToNext()) {       final TKey key=keyTransform.apply(this)        final TValue value=valueTransform.apply(this)        final TValue previousValue=result.put(key,value)        Preconditions.checkArgument(previousValue == null,"Duplicate key %s found on position %s",key,getPosition())      }     return result    }   finally {     close()    } } 
/**   * Returns the only row of this cursor transformed using the given function. WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @param singleRowTransform Function to apply on the only row of this cursor  * @param < T > Type of returned element  * @return Transformed first row of the cursor. If the cursor is empty,NoSuchElementException is thrown. If the cursor contains more than one row, IllegalArgumentException is thrown.  */ public <T>T toOnlyElement(Function<? super Cursor,T> singleRowTransform){   try { switch (getCount()) { case 0:       throw new NoSuchElementException()  case 1:     moveToFirst()    return singleRowTransform.apply(this)  default : throw new IllegalArgumentException("expected one element but was: " + getCount())  } }   finally { close()  } } 
/**   * Returns the only row of this cursor transformed using the given function, or the supplied default value if cursor is empty. WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @param singleRowTransform Function to apply on the only row of this cursor  * @param < T > Type of returned element  * @return Transformed first row of the cursor or the supplied defaultvalue if the cursor is empty. If the cursor contains more than one row, IllegalArgumentException is thrown.  */ public <T>T toOnlyElement(Function<? super Cursor,T> singleRowTransform,T defaultValue){   if (moveToFirst()) {     return toOnlyElement(singleRowTransform)    }  else {     close()      return defaultValue    } } 
/**   * Returns number of rows in this cursor and closes it. WARNING: This method closes cursor. Do not use this from onLoadFinished()  * @return Row count from this cursor  */ public int toRowCount(){   try {     return getCount()    }   finally {     close()    } } 
/**   * Sets the notification  {@code Uri} on wrapped {@code Cursor}.  * @return this {@code FluentCursor}  */ public FluentCursor withNotificationUri(ContentResolver resolver,Uri uri){   setNotificationUri(resolver,uri)    return this  } 
private SingleRowTransforms(){ } 
/**   * Constructs new  {@link Builder} for specified {@code columnName}.  */ public static Builder getColumn(String columnName){   return new Builder(columnName)  } 
Builder(String columnName){   mColumnName=columnName  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.String}  */ public Function<Cursor,String> asString(){   return new CursorRowFunction<String>(mColumnName){     @Override protected String getValue(    Cursor c,    int columnIndex){       return c.getString(columnIndex)      }   }   } 
@Override protected String getValue(Cursor c,int columnIndex){   return c.getString(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Short}  */ public Function<Cursor,Short> asShort(){   return new CursorRowFunction<Short>(mColumnName){     @Override protected Short getValue(    Cursor c,    int columnIndex){       return c.getShort(columnIndex)      }   }   } 
@Override protected Short getValue(Cursor c,int columnIndex){   return c.getShort(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Integer}  */ public Function<Cursor,Integer> asInteger(){   return new CursorRowFunction<Integer>(mColumnName){     @Override protected Integer getValue(    Cursor c,    int columnIndex){       return c.getInt(columnIndex)      }   }   } 
@Override protected Integer getValue(Cursor c,int columnIndex){   return c.getInt(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Long}  */ public Function<Cursor,Long> asLong(){   return new CursorRowFunction<Long>(mColumnName){     @Override protected Long getValue(    Cursor c,    int columnIndex){       return c.getLong(columnIndex)      }   }   } 
@Override protected Long getValue(Cursor c,int columnIndex){   return c.getLong(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Float}  */ public Function<Cursor,Float> asFloat(){   return new CursorRowFunction<Float>(mColumnName){     @Override protected Float getValue(    Cursor c,    int columnIndex){       return c.getFloat(columnIndex)      }   }   } 
@Override protected Float getValue(Cursor c,int columnIndex){   return c.getFloat(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Double}  */ public Function<Cursor,Double> asDouble(){   return new CursorRowFunction<Double>(mColumnName){     @Override protected Double getValue(    Cursor c,    int columnIndex){       return c.getDouble(columnIndex)      }   }   } 
@Override protected Double getValue(Cursor c,int columnIndex){   return c.getDouble(columnIndex)  } 
/**   * Constructs  {@link com.google.common.base.Function} converting thespecified column in  {@link android.database.Cursor} row to{@link java.lang.Boolean}, by fetching column as integer. The Function returns true when the integer value of the column is 1, otherwise it returns false.  */ public Function<Cursor,Boolean> asBoolean(){   return new CursorRowFunction<Boolean>(mColumnName){     @Override protected Boolean getValue(    Cursor c,    int columnIndex){       return c.getInt(columnIndex) == 1      }   }   } 
@Override protected Boolean getValue(Cursor c,int columnIndex){   return c.getInt(columnIndex) == 1  } 
protected CursorRowFunction(String columnName){   mColumnName=columnName  } 
private int getColumnIndex(Cursor c){   if (!Objects.equal(mInitializedForCursor,c)) {     mColumnIndex=c.getColumnIndexOrThrow(mColumnName)      mInitializedForCursor=c    }   return mColumnIndex  } 
@Override public final T apply(Cursor c){   int index=getColumnIndex(c)    return c.isNull(index) ? null : getValue(c,index)  } 
protected abstract T getValue(Cursor c,int columnIndex)  
private Delete(){ } 
public static DeleteTableSelector delete(){   return new Delete()  } 
public int perform(SQLiteDatabase db){   return db.delete(mTable,Joiner.on(" AND ").join(mSelections),FluentIterable.from(mSelectionArgs).transform(Functions.toStringFunction()).toArray(String.class))  } 
@Override public Delete from(String table){   mTable=checkNotNull(table)    return this  } 
@SafeVarargs public final <T>Delete where(String selection,T... selectionArgs){   if (selection != null) {     mSelections.add("(" + selection + ")")      if (selectionArgs != null) {       mSelectionArgs.addAll(Arrays.asList(selectionArgs))      }   }  else {     Preconditions.checkArgument(selectionArgs == null || selectionArgs.length == 0,"Cannot use not null arguments with null selection")    }   return this  } 
@SafeVarargs public final <T>Delete where(Expression expression,T... selectionArgs){   return where(expression.getSql(),expression.getMergedArgs(selectionArgs))  } 
Delete from(String table)  
private Expressions(){ } 
static void addExpressionArgs(List<Object> args,Expression expression,Object... boundArgs){   if (boundArgs == null) {     Preconditions.checkArgument(expression.getArgsCount() == expression.getBoundArgs().size(),"Expression contains args placeholders, but bound args list is null")      args.addAll(expression.getBoundArgs().values())    }  else {     Preconditions.checkArgument(expression.getArgsCount() == boundArgs.length + expression.getBoundArgs().size(),"Invalid number of arguments: expression has %s arg placeholders and %s bound args, so I need %s additional args specified, but there was %s args",expression.getArgsCount(),expression.getBoundArgs().size(),(expression.getArgsCount() - expression.getBoundArgs().size()),boundArgs.length)      int boundArgsIndex=0      for (int i=0  i < expression.getArgsCount()  i++) {       final Object arg        if (expression.getBoundArgs().containsKey(i)) {         arg=expression.getBoundArgs().get(i)        }  else {         arg=boundArgs[boundArgsIndex++]        }       args.add(arg)      }   } } 
ExpressionCore not()  
ExpressionCombiner collate(CollatingSequence collatingSequence)  
Expression(){ } 
public String toRawSql(){   Preconditions.checkState(getBoundArgs().isEmpty(),"Cannot get raw sql for Expression with bound args.")    return getSql()  } 
abstract String getSql()  
abstract int getArgsCount()  
abstract Map<Integer,Object> getBoundArgs()  
abstract Set<String> getTables()  
@SuppressWarnings("unchecked") abstract <T>Object[] getMergedArgs(T... boundArgs)  
ExpressionCombiner column(String col)  
ExpressionCombiner column(String table,String col)  
ExpressionCombiner arg()  
ExpressionCombiner nul()  
ExpressionCombiner literal(Number number)  
ExpressionCombiner literal(Object object)  
ExpressionCombiner sum(Expression e)  
ExpressionCombiner count(Expression e)  
ExpressionCombiner count()  
ExpressionCombiner max(Expression e)  
ExpressionCombiner min(Expression e)  
ExpressionCombiner ifNull(Expression left,Expression right)  
ExpressionCombiner nullIf(Expression left,Expression right)  
ExpressionCombiner coalesce(Expression... expressions)  
ExpressionCombiner length(Expression e)  
ExpressionCombiner concat(Expression... e)  
ExpressionCombiner join(String on,Expression... e)  
ExpressionCombiner expr(String expression)  
ExpressionCombiner expr(Expression expression)  
CaseCondition cases()  
CaseCondition cases(Expression e)  
CaseValue when(Expression e)  
CaseExpressionBuilder then(Expression e)  
ExpressionCombiner otherwise(Expression e)  
ExpressionCombiner end()  
ExpressionBuilder eq()  
ExpressionCombiner eq(Expression e)  
ExpressionBuilder ne()  
ExpressionCombiner ne(Expression e)  
ExpressionBuilder gt()  
ExpressionCombiner gt(Expression e)  
ExpressionBuilder ge()  
ExpressionCombiner ge(Expression e)  
ExpressionBuilder lt()  
ExpressionCombiner lt(Expression e)  
ExpressionBuilder le()  
ExpressionCombiner le(Expression e)  
ExpressionBuilder is()  
ExpressionCombiner is(Expression e)  
ExpressionCombiner in(Query subquery)  
ExpressionCombiner in(QueryBuilder subqueryBuilder)  
ExpressionCombiner in(Expression... e)  
ExpressionCombiner notIn(Query subquery)  
ExpressionCombiner notIn(QueryBuilder subqueryBuilder)  
ExpressionCombiner notIn(Expression... e)  
ExpressionBuilder or()  
ExpressionCombiner or(Expression e)  
ExpressionBuilder and()  
ExpressionCombiner and(Expression e)  
public static ExpressionCore not(){   return new Builder().not()  } 
public static ExpressionCombiner column(String col){   return new Builder().column(col)  } 
public static ExpressionCombiner column(String table,String col){   return new Builder().column(table,col)  } 
public static ExpressionCombiner arg(){   return new Builder().arg()  } 
public static ExpressionCombiner nul(){   return new Builder().nul()  } 
public static ExpressionCombiner literal(Number number){   return new Builder().literal(number)  } 
public static ExpressionCombiner literal(Object object){   return new Builder().literal(object)  } 
@SafeVarargs public static <T>Expression[] literals(T... objects){   Preconditions.checkNotNull(objects)    Expression[] result=new Expression[objects.length]    for (int i=0  i < objects.length  i++) {     result[i]=literal(objects[i])    }   return result  } 
public static Expression[] literals(Number... numbers){   Preconditions.checkNotNull(numbers)    Expression[] result=new Expression[numbers.length]    for (int i=0  i < numbers.length  i++) {     result[i]=literal(numbers[i])    }   return result  } 
public static ExpressionCombiner sum(Expression e){   return new Builder().sum(e)  } 
public static ExpressionCombiner count(Expression e){   return new Builder().count(e)  } 
public static ExpressionCombiner count(){   return new Builder().count()  } 
public static ExpressionCombiner max(Expression e){   return new Builder().max(e)  } 
public static ExpressionCombiner min(Expression e){   return new Builder().min(e)  } 
public static ExpressionCombiner ifNull(Expression left,Expression right){   return new Builder().ifNull(left,right)  } 
public static ExpressionCombiner nullIf(Expression left,Expression right){   return new Builder().nullIf(left,right)  } 
public static ExpressionCombiner coalesce(Expression... expressions){   return new Builder().coalesce(expressions)  } 
public static ExpressionCombiner length(Expression e){   return new Builder().length(e)  } 
public static ExpressionCombiner concat(Expression... e){   return new Builder().concat(e)  } 
public static ExpressionCombiner expr(String expression){   return new Builder().expr(expression)  } 
public static ExpressionCombiner expr(Expression expression){   return new Builder().expr(expression)  } 
public static ExpressionCombiner join(String on,Expression... e){   return new Builder().join(on,e)  } 
public static CaseCondition cases(){   return new Builder().cases()  } 
public static CaseCondition cases(Expression e){   return new Builder().cases(e)  } 
private void expressions(Expression e){   addArgs(e)    mBuilder.append("(").append(e.getSql()).append(")")  } 
private void expressions(Expression... e){   for (  Expression expression : e) {     addArgs(expression)    }   mBuilder.append("(").append(ARGS_JOINER.join(getSQLs(e))).append(")")  } 
private void addArgs(Expression expression){   for (  Entry<Integer,Object> boundArg : expression.getBoundArgs().entrySet()) {     mArgs.put(mArgsCount + boundArg.getKey(),boundArg.getValue())    }   mArgsCount+=expression.getArgsCount()  } 
private ExpressionBuilder binaryOperator(String operator){   mBuilder.append(" ")    mBuilder.append(operator)    mBuilder.append(" ")    return this  } 
@Override public ExpressionBuilder eq(){   return binaryOperator("==")  } 
@Override public ExpressionCombiner eq(Expression e){   eq()    expressions(e)    return this  } 
@Override public ExpressionBuilder ne(){   return binaryOperator("!=")  } 
@Override public ExpressionCombiner ne(Expression e){   ne()    expressions(e)    return this  } 
@Override public ExpressionBuilder gt(){   return binaryOperator(">")  } 
@Override public ExpressionCombiner gt(Expression e){   gt()    expressions(e)    return this  } 
@Override public ExpressionBuilder ge(){   return binaryOperator(">=")  } 
@Override public ExpressionCombiner ge(Expression e){   ge()    expressions(e)    return this  } 
@Override public ExpressionBuilder lt(){   return binaryOperator("<")  } 
@Override public ExpressionCombiner lt(Expression e){   lt()    expressions(e)    return this  } 
@Override public ExpressionBuilder le(){   return binaryOperator("<=")  } 
@Override public ExpressionCombiner le(Expression e){   le()    expressions(e)    return this  } 
@Override public ExpressionBuilder is(){   return binaryOperator("IS")  } 
@Override public ExpressionCombiner is(Expression e){   is()    expressions(e)    return this  } 
@Override public ExpressionCombiner in(Query subquery){   RawQuery rawQuery=subquery.toRawQuery()    for (  String rawQueryArg : rawQuery.mRawQueryArgs) {     mArgs.put(mArgsCount++,rawQueryArg)    }   mSubqueries.add(subquery)    binaryOperator("IN")    mBuilder.append("(").append(rawQuery.mRawQuery).append(")")    return this  } 
@Override public ExpressionCombiner in(QueryBuilder subqueryBuilder){   return in(subqueryBuilder.build())  } 
@Override public ExpressionCombiner in(Expression... e){   binaryOperator("IN")    expressions(e)    return this  } 
@Override public ExpressionCombiner notIn(Query subquery){   mBuilder.append(" NOT")    return in(subquery)  } 
@Override public ExpressionCombiner notIn(QueryBuilder subqueryBuilder){   return notIn(subqueryBuilder.build())  } 
@Override public ExpressionCombiner notIn(Expression... e){   mBuilder.append(" NOT")    return in(e)  } 
@Override public ExpressionBuilder or(){   return binaryOperator("OR")  } 
@Override public ExpressionCombiner or(Expression e){   or()    expressions(e)    return this  } 
@Override public ExpressionBuilder and(){   return binaryOperator("AND")  } 
@Override public ExpressionCombiner and(Expression e){   and()    expressions(e)    return this  } 
@Override public String getSql(){   return mBuilder.toString().trim()  } 
@Override public int getArgsCount(){   return mArgsCount  } 
@Override public Map<Integer,Object> getBoundArgs(){   return mArgs  } 
@Override public Set<String> getTables(){   return FluentIterable.from(mSubqueries).transformAndConcat(GET_TABLES).toSet()  } 
@SafeVarargs @Override public final <T>Object[] getMergedArgs(T... boundArgs){   ArrayList<Object> args=Lists.newArrayList()    addExpressionArgs(args,this,boundArgs)    return args.toArray()  } 
@Override public ExpressionCombiner column(String col){   mBuilder.append(col)    return this  } 
@Override public ExpressionCombiner column(String table,String col){   mBuilder.append(table)    mBuilder.append(".")    mBuilder.append(col)    return this  } 
@Override public ExpressionCombiner arg(){   mBuilder.append("?")    ++mArgsCount    return this  } 
@Override public ExpressionCombiner nul(){   mBuilder.append("NULL")    return this  } 
@Override public ExpressionCombiner literal(Number number){   mBuilder.append(number.toString())    return this  } 
@Override public ExpressionCombiner literal(Object object){   mBuilder.append('\'').append(object.toString().replaceAll("'","''")).append('\'')    return this  } 
@Override public ExpressionCombiner sum(Expression e){   return function("SUM",e)  } 
@Override public ExpressionCombiner count(Expression e){   return function("COUNT",e)  } 
@Override public ExpressionCombiner count(){   mBuilder.append("COUNT(*)")    return this  } 
@Override public ExpressionCombiner max(Expression e){   return function("MAX",e)  } 
@Override public ExpressionCombiner min(Expression e){   return function("MIN",e)  } 
@Override public ExpressionCombiner ifNull(Expression left,Expression right){   return function("ifnull",left,right)  } 
@Override public ExpressionCombiner nullIf(Expression left,Expression right){   return function("nullif",left,right)  } 
@Override public ExpressionCombiner coalesce(Expression... expressions){   Preconditions.checkArgument(expressions.length >= 2)    return function("coalesce",expressions)  } 
@Override public ExpressionCombiner length(Expression e){   return function("length",e)  } 
@Override public ExpressionCombiner concat(Expression... e){   mBuilder.append(CONCAT_JOINER.join(getSQLs(e)))    return this  } 
private Iterable<String> getSQLs(Expression[] e){   return Iterables.transform(Arrays.asList(e),GET_EXPR_SQL)  } 
private static <T>Iterable<T> intersperse(final T element,final Iterable<T> iterable){   return new Iterable<T>(){     @Override public Iterator<T> iterator(){       final Iterator<T> iterator=iterable.iterator()        return new AbstractIterator<T>(){         boolean intersperse=false          @Override protected T computeNext(){           if (iterator.hasNext()) {             final T result              if (intersperse) {               result=element              }  else {               result=iterator.next()              }             intersperse=!intersperse              return result            }           return endOfData()          }       }       }   }   } 
@Override public Iterator<T> iterator(){   final Iterator<T> iterator=iterable.iterator()    return new AbstractIterator<T>(){     boolean intersperse=false      @Override protected T computeNext(){       if (iterator.hasNext()) {         final T result          if (intersperse) {           result=element          }  else {           result=iterator.next()          }         intersperse=!intersperse          return result        }       return endOfData()      }   }   } 
@Override protected T computeNext(){   if (iterator.hasNext()) {     final T result      if (intersperse) {       result=element      }  else {       result=iterator.next()      }     intersperse=!intersperse      return result    }   return endOfData()  } 
@Override public ExpressionCombiner join(String on,Expression... e){   return concat(FluentIterable.from(intersperse(Expressions.literal(on),Arrays.asList(e))).toArray(Expression.class))  } 
private ExpressionCombiner function(String func,Expression... e){   mBuilder.append(func)    expressions(e)    return this  } 
@Override public ExpressionCombiner expr(String expr){   mBuilder.append(expr)    return this  } 
@Override public ExpressionCombiner expr(Expression expression){   expressions(expression)    return this  } 
@Override public ExpressionCore not(){   mBuilder.append("NOT ")    return this  } 
@Override public ExpressionCombiner otherwise(Expression e){   mBuilder.append(" ELSE ")    expressions(e)    return end()  } 
@Override public CaseValue when(Expression e){   mBuilder.append(" WHEN ")    expressions(e)    return this  } 
@Override public ExpressionCombiner end(){   mBuilder.append(" END")    return this  } 
@Override public CaseCondition cases(){   mBuilder.append("CASE")    return this  } 
@Override public CaseCondition cases(Expression e){   mBuilder.append("CASE ")    expressions(e)    return this  } 
@Override public CaseExpressionBuilder then(Expression e){   mBuilder.append(" THEN ")    expressions(e)    return this  } 
@Override public ExpressionCombiner collate(CollatingSequence collatingSequence){   mBuilder.append(" COLLATE ").append(collatingSequence.name())    return this  } 
private Insert(String table,ContentValues values){   mTable=table    mValues=values  } 
public static InsertTableSelector insert(){   return new InsertBuilder()  } 
@Override public InsertFormSelector into(String table){   mTable=checkNotNull(table)    return this  } 
@Override public DefaultValuesInsert defaultValues(String nullColumnHack){   return new DefaultValuesInsert(mTable,checkNotNull(nullColumnHack))  } 
@Override public InsertSubqueryForm columns(String... columns){   Preconditions.checkArgument(columns != null,"Column list cannot be null")    Collections.addAll(mQueryFormColumns,columns)    return this  } 
@Override public InsertWithSelect resultOf(Query query){   checkNotNull(query)    return new InsertWithSelect(mTable,query.toRawQuery(),mQueryFormColumns)  } 
@Override public InsertWithSelect resultOf(QueryBuilder queryBuilder){   checkNotNull(queryBuilder)    return resultOf(queryBuilder.build())  } 
@Override public Insert values(ContentValues values){   return new Insert(mTable,new ContentValues(values))  } 
@Override public Insert value(String column,Object value){   ContentValues values=new ContentValues()    Utils.addToContentValues(column,value,values)    return new Insert(mTable,values)  } 
public long perform(SQLiteDatabase db){   return db.insert(mTable,null,mValues)  } 
public long performOrThrow(SQLiteDatabase db){   return db.insertOrThrow(mTable,null,mValues)  } 
InsertWithSelect(String table,RawQuery query,List<String> queryFormColumns){   mTable=table    mQuery=query    mQueryFormColumns=queryFormColumns  } 
public long perform(SQLiteDatabase db){   StringBuilder builder=new StringBuilder()    builder.append("INSERT INTO ").append(mTable).append(" ")    if (!mQueryFormColumns.isEmpty()) {     builder.append("(").append(Joiner.on(", ").join(mQueryFormColumns)).append(") ")    }   builder.append(mQuery.mRawQuery)    SQLiteStatement statement=db.compileStatement(builder.toString())    try {     int argIndex=1      for (    String arg : mQuery.mRawQueryArgs) {       Utils.bindContentValueArg(statement,argIndex++,arg)      }     return statement.executeInsert()    }   finally {     statement.close()    } } 
public long performOrThrow(SQLiteDatabase db){   long result=perform(db)    if (result == -1) {     throw new RuntimeException("Insert failed")    }   return result  } 
private DefaultValuesInsert(String table,String nullColumnHack){   mTable=table    mNullColumnHack=nullColumnHack  } 
public long perform(SQLiteDatabase db){   return db.insert(mTable,mNullColumnHack,null)  } 
public long performOrThrow(SQLiteDatabase db){   return db.insertOrThrow(mTable,mNullColumnHack,null)  } 
@Override public Insert values(ContentValues values){   mValues.putAll(values)    return this  } 
@Override public Insert value(String column,Object value){   Utils.addToContentValues(column,value,mValues)    return this  } 
DefaultValuesInsert defaultValues(String nullColumnHack)  
InsertSubqueryForm columns(String... columns)  
InsertWithSelect resultOf(Query query)  
InsertWithSelect resultOf(QueryBuilder queryBuilder)  
InsertFormSelector into(String table)  
Insert values(ContentValues values)  
Insert value(String column,Object value)  
private Query(QueryBuilderImpl queryBuilder){   mQueryBuilder=queryBuilder  } 
public FluentCursor perform(SQLiteDatabase db){   return mQueryBuilder.perform(db)  } 
public RawQuery toRawQuery(){   return mQueryBuilder.toRawQuery()  } 
public QueryBuilder buildUpon(){   return mQueryBuilder.copy()  } 
public Set<String> getTables(){   return mQueryBuilder.getTables()  } 
private void getTables(ImmutableSet.Builder<String> builder){   builder.addAll(mQueryBuilder.getTables())  } 
@Override public String apply(String input){   return "(" + input + ")"  } 
public static QueryBuilder select(){   return new QueryBuilderImpl()  } 
public static CompoundQueryBuilder select(Query query){   return new CompoundQueryBuilderImpl(query)  } 
public static CompoundQueryBuilder select(QueryBuilder queryBuilder){   return select(queryBuilder.build())  } 
public static Query union(Query... queries){   Preconditions.checkNotNull(queries)    Preconditions.checkArgument(queries.length > 0)    if (queries.length == 1) {     return queries[0]    }   CompoundQueryBuilder builder=select(queries[0])    for (int i=1  i < queries.length  i++) {     builder=builder.union(queries[i])    }   return builder.build()  } 
public static Query unionAll(Query... queries){   Preconditions.checkNotNull(queries)    Preconditions.checkArgument(queries.length > 0)    if (queries.length == 1) {     return queries[0]    }   CompoundQueryBuilder builder=select(queries[0])    for (int i=1  i < queries.length  i++) {     builder=builder.unionAll(queries[i])    }   return builder.build()  } 
public static Query intersect(Query... queries){   Preconditions.checkNotNull(queries)    Preconditions.checkArgument(queries.length > 0)    if (queries.length == 1) {     return queries[0]    }   CompoundQueryBuilder builder=select(queries[0])    for (int i=1  i < queries.length  i++) {     builder=builder.intersect(queries[i])    }   return builder.build()  } 
CompoundQueryBuilder union(Query query)  
CompoundQueryBuilder union(QueryBuilder queryBuilder)  
CompoundQueryBuilder unionAll(Query query)  
CompoundQueryBuilder unionAll(QueryBuilder queryBuilder)  
CompoundQueryBuilder intersect(Query query)  
CompoundQueryBuilder intersect(QueryBuilder queryBuilder)  
CompoundQueryBuilder except(Query query)  
CompoundQueryBuilder except(QueryBuilder queryBuilder)  
Query build()  
CompoundOrderingTermBuilder orderBy(String expression)  
CompoundOrderingTermBuilder orderBy(Expression expression)  
CompoundOrderingDirectionSelector collate(String collation)  
CompoundOrderingDirectionSelector collate(CollatingSequence collation)  
CompoundQueryBuilder asc()  
CompoundQueryBuilder desc()  
CompoundLimitOffsetBuilder limit(String expression)  
CompoundLimitOffsetBuilder limit(int limit)  
CompoundQueryBuilder offset(String expression)  
CompoundQueryBuilder offset(int limit)  
private CompoundQueryBuilderImpl(Query query){   mQueryBuilder=query.mQueryBuilder.copy()    if (mQueryBuilder.isCompound()) {     mQueryBuilder.mCompoundQueryParts=Lists.newLinkedList()      mQueryBuilder.mCompoundQueryParts.add(new QueryOrOperator(query))    } } 
@Override public CompoundQueryBuilder offset(String expression){   mQueryBuilder.offset(expression)    return this  } 
@Override public CompoundQueryBuilder offset(int limit){   mQueryBuilder.offset(limit)    return this  } 
@Override public CompoundOrderingDirectionSelector collate(String collation){   mQueryBuilder.collate(collation)    return this  } 
@Override public CompoundOrderingDirectionSelector collate(CollatingSequence collation){   mQueryBuilder.collate(collation)    return this  } 
@Override public CompoundQueryBuilder asc(){   mQueryBuilder.asc()    return this  } 
@Override public CompoundQueryBuilder desc(){   mQueryBuilder.desc()    return this  } 
private CompoundQueryBuilder withCompoundQueryPart(Query queryPart,String operation){   if (!mQueryBuilder.mCurrentQueryPart.isEmpty()) {     mQueryBuilder.mCompoundQueryParts.add(new QueryOrOperator(new QueryBuilderImpl(mQueryBuilder.mCurrentQueryPart).build()))    }   mQueryBuilder.mCompoundQueryParts.add(new QueryOrOperator(operation))    mQueryBuilder.mCompoundQueryParts.add(new QueryOrOperator(queryPart))    mQueryBuilder.mCurrentQueryPart=new QueryBuilderImpl.CompoundQueryPart()    return this  } 
@Override public CompoundQueryBuilder union(Query query){   return withCompoundQueryPart(query,"UNION")  } 
@Override public CompoundQueryBuilder union(QueryBuilder queryBuilder){   return union(queryBuilder.build())  } 
@Override public CompoundQueryBuilder unionAll(Query query){   return withCompoundQueryPart(query,"UNION ALL")  } 
@Override public CompoundQueryBuilder unionAll(QueryBuilder queryBuilder){   return unionAll(queryBuilder.build())  } 
@Override public CompoundQueryBuilder intersect(Query query){   return withCompoundQueryPart(query,"INTERSECT")  } 
@Override public CompoundQueryBuilder intersect(QueryBuilder queryBuilder){   return intersect(queryBuilder.build())  } 
@Override public CompoundQueryBuilder except(Query query){   return withCompoundQueryPart(query,"EXCEPT")  } 
@Override public CompoundQueryBuilder except(QueryBuilder queryBuilder){   return except(queryBuilder.build())  } 
@Override public Query build(){   return new Query(mQueryBuilder.copy())  } 
@Override public CompoundLimitOffsetBuilder limit(String expression){   mQueryBuilder.limit(expression)    return this  } 
@Override public CompoundLimitOffsetBuilder limit(int limit){   mQueryBuilder.limit(limit)    return this  } 
@Override public CompoundOrderingTermBuilder orderBy(String expression){   mQueryBuilder.orderBy(expression)    return this  } 
@Override public CompoundOrderingTermBuilder orderBy(Expression expression){   mQueryBuilder.orderBy(expression)    return this  } 
@Override public Query build(){   buildPendingOrderByClause()    return new Query(copy())  } 
private boolean isEmpty(){   return mProjection.isEmpty() && mColumnWithPotentialAlias == null && mColumnsWithPotentialTable.isEmpty() && mColumnsListsTableWithPotentialAlias == null && mGroupByExpressions.isEmpty() && mHaving.isEmpty() && mSelection.isEmpty() && mArgs.isEmpty() && mPendingTable == null && mTables.isEmpty() && Strings.isNullOrEmpty(mPendingJoinType) && mPendingJoin == null && mJoins.isEmpty()  } 
CompoundQueryPart(){ } 
CompoundQueryPart(CompoundQueryPart other){   mIsDistinct=other.mIsDistinct    mProjection.addAll(other.mProjection)    mColumnWithPotentialAlias=other.mColumnWithPotentialAlias    mColumnsWithPotentialTable.addAll(other.mColumnsWithPotentialTable)    mColumnsListsTableWithPotentialAlias=other.mColumnsListsTableWithPotentialAlias    mGroupByExpressions.addAll(other.mGroupByExpressions)    mHaving.addAll(other.mHaving)    mSelection.addAll(other.mSelection)    mArgs.putAll(other.mArgs)    mPendingTable=other.mPendingTable    mTables.putAll(other.mTables)    mPendingJoinType=other.mPendingJoinType    mPendingJoin=other.mPendingJoin != null ? new JoinSpec(other.mPendingJoin) : null    mJoins=Lists.newArrayListWithCapacity(other.mJoins.size())    for (  JoinSpec join : other.mJoins) {     mJoins.add(new JoinSpec(join))    }   mTablesUsedInExpressions.addAll(other.mTablesUsedInExpressions)  } 
private void addPendingColumn(){   if (mColumnWithPotentialAlias != null) {     mProjection.add(mColumnWithPotentialAlias)      mColumnWithPotentialAlias=null    } } 
private void addPendingColumns(){   if (mColumnsListsTableWithPotentialAlias != null) {     for (    String column : mColumnsWithPotentialTable) {       mProjection.add(mColumnsListsTableWithPotentialAlias + "." + column)      }   }  else {     mProjection.addAll(mColumnsWithPotentialTable)    }   mColumnsListsTableWithPotentialAlias=null    mColumnsWithPotentialTable.clear()  } 
private void addPendingTable(String alias){   if (mPendingTable != null) {     mTables.put(mPendingTable,alias)      mPendingTable=null    } } 
private void addPendingJoin(){   if (mPendingJoin != null) {     mJoins.add(mPendingJoin)      mPendingJoin=null    } } 
private void processPendingParts(){   addPendingColumn()    addPendingColumns()    addPendingTable(null)    addPendingJoin()  } 
RawQuery toRawQuery(){   processPendingParts()    Preconditions.checkState(!(!mHaving.isEmpty() && mGroupByExpressions.isEmpty()),"a GROUP BY clause is required when using HAVING clause")    List<String> args=Lists.newArrayList()    StringBuilder builder=new StringBuilder()    builder.append("SELECT ")    if (mIsDistinct) {     builder.append("DISTINCT ")    }   if (!mProjection.isEmpty()) {     builder.append(Joiner.on(", ").join(mProjection))    }  else {     builder.append("*")    }   args.addAll(Collections2.transform(mArgs.get(QueryPart.PROJECTION),Functions.toStringFunction()))    if (!mTables.isEmpty()) {     builder.append(" FROM ")      List<String> tables=Lists.newArrayList()      for (    Entry<TableOrSubquery,String> tableEntry : mTables.entrySet()) {       TableOrSubquery tableOrSubquery=tableEntry.getKey()        String alias=tableEntry.getValue()        String tableString        if (tableOrSubquery.mTable != null) {         tableString=tableOrSubquery.mTable        }  else {         RawQuery rawSubquery=tableOrSubquery.mSubquery.toRawQuery()          tableString=SURROUND_WITH_PARENS.apply(rawSubquery.mRawQuery)          args.addAll(rawSubquery.mRawQueryArgs)        }       if (alias != null) {         tableString+=" AS " + alias        }       tables.add(tableString)      }     builder.append(Joiner.on(", ").join(tables))    }   for (  JoinSpec join : mJoins) {     builder.append(" ")      builder.append(join.mJoinType)      builder.append("JOIN ")      if (join.mJoinSource.mTable != null) {       builder.append(join.mJoinSource.mTable)      }  else {       final RawQuery rawQuery=join.mJoinSource.mSubquery.toRawQuery()        builder.append(SURROUND_WITH_PARENS.apply(rawQuery.mRawQuery))        args.addAll(rawQuery.mRawQueryArgs)      }     if (join.mAlias != null) {       builder.append(" AS ")        builder.append(join.mAlias)      }     if (join.mUsingColumns != null) {       builder.append(" USING ")        builder.append("(")        builder.append(Joiner.on(", ").join(join.mUsingColumns))        builder.append(")")      }  else     if (!join.mConstraints.isEmpty()) {       builder.append(" ON ")        builder.append(Joiner.on(" AND ").join(Collections2.transform(join.mConstraints,SURROUND_WITH_PARENS)))        args.addAll(Collections2.transform(join.mConstraintsArgs,Functions.toStringFunction()))      }   }   if (!mSelection.isEmpty()) {     builder.append(" WHERE ")      builder.append(Joiner.on(" AND ").join(Collections2.transform(mSelection,SURROUND_WITH_PARENS)))      args.addAll(Collections2.transform(mArgs.get(QueryPart.SELECTION),Functions.toStringFunction()))    }   if (!mGroupByExpressions.isEmpty()) {     builder.append(" GROUP BY ")      builder.append(Joiner.on(", ").join(mGroupByExpressions))      args.addAll(Collections2.transform(mArgs.get(QueryPart.GROUP_BY),Functions.toStringFunction()))      if (!mHaving.isEmpty()) {       builder.append(" HAVING ")        builder.append(Joiner.on(" AND ").join(Collections2.transform(mHaving,SURROUND_WITH_PARENS)))        args.addAll(Collections2.transform(mArgs.get(QueryPart.HAVING),Functions.toStringFunction()))      }   }   return new RawQuery(builder.toString(),args)  } 
public void getTables(ImmutableSet.Builder<String> builder){   addTableOrSubquery(builder,mPendingTable)    for (  TableOrSubquery tableOrSubquery : mTables.keySet()) {     addTableOrSubquery(builder,tableOrSubquery)    }   if (mPendingJoin != null) {     addTableOrSubquery(builder,mPendingJoin.mJoinSource)    }   for (  JoinSpec join : mJoins) {     addTableOrSubquery(builder,join.mJoinSource)    }   builder.addAll(mTablesUsedInExpressions)  } 
public boolean isCompound(){   int queryPartsCount=(mCurrentQueryPart.isEmpty() ? 0 : 1) + mCompoundQueryParts.size()    return queryPartsCount > 1  } 
private QueryBuilderImpl(){ } 
private QueryBuilderImpl(QueryBuilderImpl other){   mLimit=other.mLimit    mOffset=other.mOffset    mOrderByExpression=other.mOrderByExpression    mOrderByCollation=other.mOrderByCollation    mOrderByOrder=other.mOrderByOrder    mOrderClauses=Lists.newCopyOnWriteArrayList(other.mOrderClauses)    mOrderByArgs=Lists.newCopyOnWriteArrayList(other.mOrderByArgs)    mTablesUsedInExpressions=Sets.newHashSet(other.mTablesUsedInExpressions)    mCurrentQueryPart=new CompoundQueryPart(other.mCurrentQueryPart)    mCompoundQueryParts=Lists.newLinkedList(other.mCompoundQueryParts)  } 
private QueryBuilderImpl(CompoundQueryPart compoundQueryPart){   mCurrentQueryPart=new CompoundQueryPart(compoundQueryPart)  } 
QueryBuilderImpl copy(){   return new QueryBuilderImpl(this)  } 
@Override public Set<String> getTables(){   Builder<String> builder=ImmutableSet.builder()    mCurrentQueryPart.getTables(builder)    for (  QueryOrOperator part : mCompoundQueryParts) {     if (part.isQuery()) {       part.mQuery.getTables(builder)      }   }   builder.addAll(mTablesUsedInExpressions)    return builder.build()  } 
private static void addTableOrSubquery(ImmutableSet.Builder<String> builder,TableOrSubquery tableOrSubquery){   if (tableOrSubquery != null) {     if (tableOrSubquery.mSubquery != null) {       builder.addAll(tableOrSubquery.mSubquery.getTables())      }  else {       builder.add(tableOrSubquery.mTable)      }   } } 
@Override public RawQuery toRawQuery(){   boolean currentPartIsNotEmpty=!mCurrentQueryPart.isEmpty()    Preconditions.checkState(currentPartIsNotEmpty || mCompoundQueryParts.size() > 1)    buildPendingOrderByClause()    List<String> args=Lists.newArrayList()    StringBuilder builder=new StringBuilder()    for (  QueryOrOperator part : mCompoundQueryParts) {     if (part.isOperator()) {       builder.append(" ")        builder.append(part.mOperator)        builder.append(" ")      }  else {       Query query=part.mQuery        RawQuery partRawQuery=query.toRawQuery()        if (query.mQueryBuilder.isCompound()) {         builder.append("SELECT * FROM (")        }       builder.append(partRawQuery.mRawQuery)        if (query.mQueryBuilder.isCompound()) {         builder.append(")")        }       args.addAll(partRawQuery.mRawQueryArgs)      }   }   if (currentPartIsNotEmpty) {     RawQuery lastQueryPart=mCurrentQueryPart.toRawQuery()      args.addAll(lastQueryPart.mRawQueryArgs)      builder.append(lastQueryPart.mRawQuery)    }   if (!mOrderClauses.isEmpty()) {     builder.append(" ORDER BY ")      builder.append(Joiner.on(", ").join(mOrderClauses))    }   args.addAll(Collections2.transform(mOrderByArgs,Functions.toStringFunction()))    if (mLimit != null) {     builder.append(" LIMIT ")      builder.append(mLimit)      if (mOffset != null) {       builder.append(" OFFSET ")        builder.append(mOffset)      }   }   return new RawQuery(builder.toString(),args)  } 
@Override public FluentCursor perform(SQLiteDatabase db){   RawQuery rawQuery=toRawQuery()    return new FluentCursor(db.rawQuery(rawQuery.mRawQuery,rawQuery.mRawQueryArgs.toArray(new String[rawQuery.mRawQueryArgs.size()])))  } 
@Override public ColumnAliasBuilder column(String column){   return expr(Expressions.column(column))  } 
@Override public ColumnAliasBuilder column(String table,String column){   return expr(Expressions.column(table,column))  } 
@Override public ColumnAliasBuilder literal(Number number){   return expr(Expressions.literal(number))  } 
@Override public ColumnAliasBuilder literal(Object object){   return expr(Expressions.literal(object))  } 
@Override public ColumnAliasBuilder nul(){   return expr(Expressions.nul())  } 
@Override public ColumnAliasBuilder expr(Expression expression){   mCurrentQueryPart.addPendingColumns()    mCurrentQueryPart.addPendingColumn()    mCurrentQueryPart.mColumnWithPotentialAlias=expression.getSql()    mCurrentQueryPart.mTablesUsedInExpressions.addAll(expression.getTables())    if (expression.getArgsCount() > 0) {     mCurrentQueryPart.mArgs.putAll(QueryPart.PROJECTION,Arrays.asList(expression.getMergedArgs()))    }   return this  } 
@Override public QueryBuilder as(String alias){   Preconditions.checkState(mCurrentQueryPart.mColumnWithPotentialAlias != null)    mCurrentQueryPart.mProjection.add(mCurrentQueryPart.mColumnWithPotentialAlias + " AS " + alias)    mCurrentQueryPart.mColumnWithPotentialAlias=null    return this  } 
@Override public ColumnListTableSelector columns(String... columns){   mCurrentQueryPart.addPendingColumn()    mCurrentQueryPart.addPendingColumns()    if (columns != null) {     Collections.addAll(mCurrentQueryPart.mColumnsWithPotentialTable,columns)    }   return this  } 
@Override public ColumnsTableSelector allColumns(){   mCurrentQueryPart.addPendingColumn()    mCurrentQueryPart.addPendingColumns()    mCurrentQueryPart.mColumnsWithPotentialTable.add("*")    return mColumnsTableSelectorHelper  } 
@Override public ColumnsListAliasBuilder of(String table){   mCurrentQueryPart.mColumnsListsTableWithPotentialAlias=table    return this  } 
@Override public QueryBuilder asColumnNames(){   for (  String column : mCurrentQueryPart.mColumnsWithPotentialTable) {     mCurrentQueryPart.mProjection.add(mCurrentQueryPart.mColumnsListsTableWithPotentialAlias + "." + column+ " AS "+ column)    }   mCurrentQueryPart.mColumnsListsTableWithPotentialAlias=null    mCurrentQueryPart.mColumnsWithPotentialTable.clear()    return this  } 
@Override public QueryBuilder distinct(){   mCurrentQueryPart.mIsDistinct=true    return this  } 
@Override public QueryBuilder all(){   mCurrentQueryPart.mIsDistinct=false    return this  } 
private ColumnsTableSelectorHelper(QueryBuilder delegate){   super(delegate)  } 
@Override public QueryBuilder of(String table){   for (  String column : mCurrentQueryPart.mColumnsWithPotentialTable) {     mCurrentQueryPart.mProjection.add(table + "." + column)    }   mCurrentQueryPart.mColumnsWithPotentialTable.clear()    return QueryBuilderImpl.this  } 
@Override public UnionTypeSelector union(){   return mCompoundQueryHelper.withOperation("UNION")  } 
@Override public NextQueryPartStart intersect(){   return mCompoundQueryHelper.withOperation("INTERSECT")  } 
@Override public NextQueryPartStart except(){   return mCompoundQueryHelper.withOperation("EXCEPT")  } 
public CompoundQueryHelper withOperation(String operation){   mOperation=operation    return this  } 
@Override public NextQueryPartStart all(){   return withOperation("UNION ALL")  } 
@Override public QueryBuilder select(){   mCompoundQueryParts.add(new QueryOrOperator(new QueryBuilderImpl(mCurrentQueryPart).build()))    mCompoundQueryParts.add(new QueryOrOperator(mOperation))    mCurrentQueryPart=new CompoundQueryPart()    return QueryBuilderImpl.this  } 
@Override public QueryBuilder groupBy(String expression){   mCurrentQueryPart.mGroupByExpressions.add(expression)    return this  } 
@Override public QueryBuilder groupBy(Expression expression){   mCurrentQueryPart.mTablesUsedInExpressions.addAll(expression.getTables())    if (expression.getArgsCount() > 0) {     mCurrentQueryPart.mArgs.putAll(QueryPart.GROUP_BY,Arrays.asList(expression.getMergedArgs()))    }   return groupBy(expression.getSql())  } 
@Override public QueryBuilder having(String having,Object... havingArgs){   mCurrentQueryPart.mHaving.add(having)    if (havingArgs != null) {     mCurrentQueryPart.mArgs.putAll(QueryPart.HAVING,Arrays.asList(havingArgs))    }   return this  } 
@Override public QueryBuilder having(Expression having,Object... havingArgs){   mCurrentQueryPart.mTablesUsedInExpressions.addAll(having.getTables())    return having(having.getSql(),having.getMergedArgs(havingArgs))  } 
@Override public JoinTypeBuilder natural(){   mCurrentQueryPart.mPendingJoinType="NATURAL "    return this  } 
@Override public JoinBuilder left(){   mCurrentQueryPart.mPendingJoinType+="LEFT "    return this  } 
@Override public JoinBuilder cross(){   mCurrentQueryPart.mPendingJoinType+="CROSS "    return this  } 
@Override public JoinAliasBuilder join(String table){   mCurrentQueryPart.addPendingJoin()    mCurrentQueryPart.mPendingJoin=new JoinSpec(mCurrentQueryPart.mPendingJoinType,new TableOrSubquery(table))    mCurrentQueryPart.mPendingJoinType=""    return mJoinHelper  } 
@Override public JoinAliasBuilder join(Query subquery){   mCurrentQueryPart.addPendingJoin()    mCurrentQueryPart.mPendingJoin=new JoinSpec(mCurrentQueryPart.mPendingJoinType,new TableOrSubquery(subquery))    mCurrentQueryPart.mPendingJoinType=""    return mJoinHelper  } 
@Override public JoinAliasBuilder join(QueryBuilder subqueryBuilder){   return join(subqueryBuilder.build())  } 
private JoinHelper(QueryBuilder delegate){   super(delegate)  } 
@Override public JoinConstraintBuilder as(String alias){   mCurrentQueryPart.mPendingJoin.mAlias=alias    return this  } 
@Override public QueryBuilder using(String... columns){   Preconditions.checkArgument(columns != null,"Column list in USING clause cannot be null")    Preconditions.checkArgument(columns.length > 0,"Column list in USING clause cannot be empty")    mCurrentQueryPart.mPendingJoin.mUsingColumns=columns    mCurrentQueryPart.addPendingJoin()    return QueryBuilderImpl.this  } 
@Override public JoinOnConstraintBuilder on(String constraint,Object... constraintArgs){   mCurrentQueryPart.mPendingJoin.mConstraints.add(constraint)    if (constraintArgs != null) {     Collections.addAll(mCurrentQueryPart.mPendingJoin.mConstraintsArgs,constraintArgs)    }   return this  } 
@Override public JoinOnConstraintBuilder on(Expression constraint,Object... constraintArgs){   mCurrentQueryPart.mTablesUsedInExpressions.addAll(constraint.getTables())    mCurrentQueryPart.mPendingJoin.mConstraints.add(constraint.getSql())    Collections.addAll(mCurrentQueryPart.mPendingJoin.mConstraintsArgs,constraint.getMergedArgs(constraintArgs))    return this  } 
private JoinSpec(String joinType,TableOrSubquery joinSource){   mJoinType=joinType    mJoinSource=joinSource  } 
private JoinSpec(JoinSpec other){   mJoinType=other.mJoinType    mJoinSource=other.mJoinSource    mAlias=other.mAlias    mUsingColumns=other.mUsingColumns != null ? Arrays.copyOf(other.mUsingColumns,other.mUsingColumns.length) : null    mConstraints.addAll(other.mConstraints)    mConstraintsArgs.addAll(other.mConstraintsArgs)  } 
@Override public LimitOffsetBuilder limit(String expression){   Preconditions.checkState(mLimit == null,"LIMIT can be set only once")    mLimit=expression    return this  } 
@Override public LimitOffsetBuilder limit(int limit){   return limit(String.valueOf(limit))  } 
@Override public QueryBuilder offset(String expression){   Preconditions.checkState(mLimit != null)    Preconditions.checkState(mOffset == null)    mOffset=expression    return this  } 
@Override public QueryBuilder offset(int limit){   return offset(String.valueOf(limit))  } 
@Override public OrderingTermBuilder orderBy(String expression){   buildPendingOrderByClause()    mOrderByExpression=expression    return this  } 
@Override public OrderingTermBuilder orderBy(Expression expression){   mTablesUsedInExpressions.addAll(expression.getTables())    Collections.addAll(mOrderByArgs,expression.getMergedArgs())    return orderBy(expression.getSql())  } 
@Override public OrderingDirectionSelector collate(String collation){   mOrderByCollation=collation    return this  } 
@Override public OrderingDirectionSelector collate(CollatingSequence collation){   mOrderByCollation=collation.name()    return this  } 
@Override public QueryBuilder asc(){   mOrderByOrder=" ASC"    return this  } 
@Override public QueryBuilder desc(){   mOrderByOrder=" DESC"    return this  } 
private void buildPendingOrderByClause(){   if (mOrderByExpression != null) {     String orderByClause=mOrderByExpression      if (mOrderByCollation != null) {       orderByClause+=" COLLATE " + mOrderByCollation      }     if (mOrderByOrder != null) {       orderByClause+=mOrderByOrder      }     mOrderByExpression=null      mOrderByCollation=null      mOrderByOrder=null      mOrderClauses.add(orderByClause)    } } 
@SafeVarargs @Override public final <T>QueryBuilder where(String selection,T... selectionArgs){   if (!Strings.isNullOrEmpty(selection)) {     mCurrentQueryPart.mSelection.add(selection)      if (selectionArgs != null) {       mCurrentQueryPart.mArgs.putAll(QueryPart.SELECTION,Arrays.asList(selectionArgs))      }   }   return this  } 
@SafeVarargs @Override public final <T>QueryBuilder where(Expression selection,T... selectionArgs){   if (selection != null) {     mCurrentQueryPart.mTablesUsedInExpressions.addAll(selection.getTables())      where(selection.getSql(),selection.getMergedArgs(selectionArgs))    }   return this  } 
private TableAliasBuilderImpl(QueryBuilder delegate){   super(delegate)  } 
@Override public QueryBuilder as(String alias){   mCurrentQueryPart.addPendingTable(alias)    return QueryBuilderImpl.this  } 
@Override public TableAliasBuilder from(String table){   mCurrentQueryPart.addPendingTable(null)    mCurrentQueryPart.mPendingTable=new TableOrSubquery(table)    return mTableAliasBuilder  } 
@Override public TableAliasBuilder from(Query subquery){   mCurrentQueryPart.addPendingTable(null)    mCurrentQueryPart.mPendingTable=new TableOrSubquery(subquery)    return mTableAliasBuilder  } 
@Override public TableAliasBuilder from(QueryBuilder subqueryBuilder){   return from(subqueryBuilder.build())  } 
private TableOrSubquery(String table){   mTable=table    mSubquery=null  } 
private TableOrSubquery(Query subquery){   mTable=null    mSubquery=subquery  } 
private QueryOrOperator(String operator){   mOperator=operator    mQuery=null  } 
private QueryOrOperator(Query query){   mOperator=null    mQuery=query  } 
private boolean isOperator(){   return mOperator != null  } 
private boolean isQuery(){   return mQuery != null  } 
Query build()  
RawQuery toRawQuery()  
Set<String> getTables()  
FluentCursor perform(SQLiteDatabase db)  
private QueryBuilderProxy(QueryBuilder delegate){   mDelegate=delegate  } 
@Override public ColumnAliasBuilder column(String column){   return mDelegate.column(column)  } 
@Override public ColumnAliasBuilder column(String table,String column){   return mDelegate.column(table,column)  } 
@Override public ColumnAliasBuilder literal(Number number){   return mDelegate.literal(number)  } 
@Override public ColumnAliasBuilder literal(Object object){   return mDelegate.literal(object)  } 
@Override public ColumnAliasBuilder nul(){   return mDelegate.nul()  } 
@Override public ColumnListTableSelector columns(String... columns){   return mDelegate.columns(columns)  } 
@Override public ColumnsTableSelector allColumns(){   return mDelegate.allColumns()  } 
@Override public ColumnAliasBuilder expr(Expression expression){   return mDelegate.expr(expression)  } 
@Override public UnionTypeSelector union(){   return mDelegate.union()  } 
@Override public NextQueryPartStart intersect(){   return mDelegate.intersect()  } 
@Override public NextQueryPartStart except(){   return mDelegate.except()  } 
@Override public QueryBuilder groupBy(String expression){   return mDelegate.groupBy(expression)  } 
@Override public QueryBuilder groupBy(Expression expression){   return mDelegate.groupBy(expression)  } 
@Override public QueryBuilder having(String having,Object... havingArgs){   return mDelegate.having(having,havingArgs)  } 
@Override public QueryBuilder having(Expression having,Object... havingArgs){   return mDelegate.having(having,havingArgs)  } 
@Override public JoinBuilder left(){   return mDelegate.left()  } 
@Override public JoinBuilder cross(){   return mDelegate.cross()  } 
@Override public JoinAliasBuilder join(String table){   return mDelegate.join(table)  } 
@Override public JoinAliasBuilder join(Query subquery){   return mDelegate.join(subquery)  } 
@Override public JoinAliasBuilder join(QueryBuilder subqueryBuilder){   return mDelegate.join(subqueryBuilder)  } 
@Override public LimitOffsetBuilder limit(String expression){   return mDelegate.limit(expression)  } 
@Override public LimitOffsetBuilder limit(int limit){   return mDelegate.limit(limit)  } 
@Override public JoinTypeBuilder natural(){   return mDelegate.natural()  } 
@Override public OrderingTermBuilder orderBy(String expression){   return mDelegate.orderBy(expression)  } 
@Override public OrderingTermBuilder orderBy(Expression expression){   return mDelegate.orderBy(expression)  } 
@SafeVarargs @Override public final <T>QueryBuilder where(String selection,T... selectionArgs){   return mDelegate.where(selection,selectionArgs)  } 
@SafeVarargs @Override public final <T>QueryBuilder where(Expression selection,T... selectionArgs){   return mDelegate.where(selection,selectionArgs)  } 
@Override public TableAliasBuilder from(String table){   return mDelegate.from(table)  } 
@Override public TableAliasBuilder from(Query subquery){   return mDelegate.from(subquery)  } 
@Override public TableAliasBuilder from(QueryBuilder subqueryBuilder){   return mDelegate.from(subqueryBuilder)  } 
@Override public Query build(){   return mDelegate.build()  } 
@Override public RawQuery toRawQuery(){   return mDelegate.toRawQuery()  } 
@Override public Set<String> getTables(){   return mDelegate.getTables()  } 
@Override public FluentCursor perform(SQLiteDatabase db){   return mDelegate.perform(db)  } 
@Override public QueryBuilder distinct(){   return mDelegate.distinct()  } 
@Override public QueryBuilder all(){   return mDelegate.all()  } 
TableAliasBuilder from(String table)  
TableAliasBuilder from(Query subquery)  
TableAliasBuilder from(QueryBuilder subqueryBuilder)  
QueryBuilder distinct()  
QueryBuilder all()  
QueryBuilder as(String alias)  
ColumnAliasBuilder column(String column)  
ColumnAliasBuilder column(String table,String column)  
ColumnAliasBuilder literal(Number number)  
ColumnAliasBuilder literal(Object object)  
ColumnAliasBuilder nul()  
ColumnListTableSelector columns(String... columns)  
ColumnsTableSelector allColumns()  
ColumnAliasBuilder expr(Expression expression)  
QueryBuilder of(String table)  
ColumnsListAliasBuilder of(String table)  
QueryBuilder asColumnNames()  
QueryBuilder as(String alias)  
<T>QueryBuilder where(String selection,T... selectionArgs)  
<T>QueryBuilder where(Expression selection,T... selectionArgs)  
JoinBuilder left()  
JoinBuilder cross()  
JoinTypeBuilder natural()  
JoinAliasBuilder join(String table)  
JoinAliasBuilder join(Query subquery)  
JoinAliasBuilder join(QueryBuilder subqueryBuilder)  
JoinConstraintBuilder as(String alias)  
QueryBuilder using(String... columns)  
JoinOnConstraintBuilder on(String constraint,Object... constraintArgs)  
JoinOnConstraintBuilder on(Expression constraint,Object... constraintArgs)  
QueryBuilder groupBy(String expression)  
QueryBuilder groupBy(Expression expression)  
QueryBuilder having(String having,Object... havingArgs)  
QueryBuilder having(Expression having,Object... havingArgs)  
OrderingTermBuilder orderBy(String expression)  
OrderingTermBuilder orderBy(Expression expression)  
OrderingDirectionSelector collate(String collation)  
OrderingDirectionSelector collate(CollatingSequence collation)  
QueryBuilder asc()  
QueryBuilder desc()  
LimitOffsetBuilder limit(String expression)  
LimitOffsetBuilder limit(int limit)  
QueryBuilder offset(String expression)  
QueryBuilder offset(int limit)  
UnionTypeSelector union()  
NextQueryPartStart intersect()  
NextQueryPartStart except()  
NextQueryPartStart all()  
QueryBuilder select()  
public RawQuery(String rawQuery,List<String> rawQueryArgs){   mRawQuery=rawQuery    mRawQueryArgs=rawQueryArgs  } 
private Update(){ } 
public static UpdateTableSelector update(){   return new Update()  } 
public int perform(SQLiteDatabase db){   String mSelection=Joiner.on(" AND ").join(mSelections)    if (mCustomExpressions.isEmpty()) {     return db.update(mTable,mValues,mSelection,FluentIterable.from(mSelectionArgs).transform(Functions.toStringFunction()).toArray(String.class))    }  else {     return performUpdateWithCustomExpressions(db,mSelection)    } } 
@SuppressWarnings("NewApi") private int performUpdateWithCustomExpressions(SQLiteDatabase db,String selection){   List<Object> args=Lists.newArrayList()    StringBuilder builder=new StringBuilder()    builder.append("UPDATE ").append(mTable).append(" SET ").append(Joiner.on(", ").join(Collections2.transform(mCustomExpressions.entrySet(),new Function<Entry<String,String>,String>(){     @Override public String apply(    Entry<String,String> entry){       return entry.getKey() + "=" + entry.getValue()      }   } )))    if (mValues.size() != 0) {     builder.append(", ")    }   Set<Entry<String,Object>> values=mValues.valueSet()    builder.append(Joiner.on(", ").join(Collections2.transform(values,new Function<Entry<String,Object>,Object>(){     @Override public Object apply(    Entry<String,Object> value){       return value.getKey() + "=?"      }   } )))    args.addAll(Collections2.transform(values,new Function<Entry<String,Object>,Object>(){     @Override public Object apply(    Entry<String,Object> value){       return value.getValue()      }   } ))    args.addAll(mSelectionArgs)    if (!Strings.isNullOrEmpty(selection)) {     builder.append(" WHERE ").append(selection)    }   SQLiteStatement statement=db.compileStatement(builder.toString())    try {     int argIndex=1      for (    String customColumn : mCustomExpressions.keySet()) {       for (      Object arg : mCustomExpressionsArgs.get(customColumn)) {         Utils.bindContentValueArg(statement,argIndex++,arg)        }     }     for (    Object arg : args) {       Utils.bindContentValueArg(statement,argIndex++,arg)      }     return statement.executeUpdateDelete()    }   finally {     statement.close()    } } 
@Override public String apply(Entry<String,String> entry){   return entry.getKey() + "=" + entry.getValue()  } 
@Override public Object apply(Entry<String,Object> value){   return value.getKey() + "=?"  } 
@Override public Object apply(Entry<String,Object> value){   return value.getValue()  } 
@Override public Update table(String table){   mTable=checkNotNull(table)    return this  } 
public Update values(ContentValues values){   for (  Entry<String,Object> value : values.valueSet()) {     mCustomExpressions.remove(value.getKey())    }   mValues.putAll(values)    return this  } 
public Update value(String column,Object value){   mCustomExpressions.remove(column)    mCustomExpressionsArgs.removeAll(column)    Utils.addToContentValues(column,value,mValues)    return this  } 
@TargetApi(HONEYCOMB) public Update setColumn(String column,String expression){   mValues.remove(column)    mCustomExpressionsArgs.removeAll(column)    mCustomExpressions.put(column,"(" + expression + ")")    return this  } 
@TargetApi(HONEYCOMB) public Update setColumn(String column,Expression expression){   setColumn(column,expression.getSql())    mCustomExpressionsArgs.putAll(column,Arrays.asList(expression.getMergedArgs()))    return this  } 
@SafeVarargs public final <T>Update where(String selection,T... selectionArgs){   if (selection != null) {     mSelections.add("(" + selection + ")")      if (selectionArgs != null) {       Collections.addAll(mSelectionArgs,selectionArgs)      }   }  else {     Preconditions.checkArgument(selectionArgs == null || selectionArgs.length == 0,"Cannot use not null arguments with null selection")    }   return this  } 
@SafeVarargs public final <T>Update where(Expression expression,T... selectionArgs){   return where(expression.getSql(),expression.getMergedArgs(selectionArgs))  } 
Update table(String table)  
private ViewActions(){ } 
public static ViewSelector<ViewSelectStatementChooser> create(){   return new CreateViewAction()  } 
public static ViewSelector<ViewAction> dropIfExists(){   return new DropViewAction()  } 
DropViewAction(){ } 
@Override public void perform(SQLiteDatabase db){   db.execSQL("DROP VIEW IF EXISTS " + mView)  } 
@Override public ViewAction view(String view){   mView=checkNotNull(view)    return this  } 
CreateViewAction(){ } 
@Override public void perform(SQLiteDatabase db){   db.execSQL("CREATE VIEW " + mView + " AS "+ mQuery.mRawQuery)  } 
@Override public ViewAction as(Query query){   checkNotNull(query)    mQuery=query.toRawQuery()    checkArgument(mQuery.mRawQueryArgs.isEmpty(),"Cannot use query with bound args for View creation")    return this  } 
@Override public ViewAction as(QueryBuilder queryBuilder){   checkNotNull(queryBuilder)    return as(queryBuilder.build())  } 
@Override public ViewSelectStatementChooser view(String view){   mView=checkNotNull(view)    return this  } 
T view(String view)  
void perform(SQLiteDatabase db)  
ViewAction as(Query query)  
ViewAction as(QueryBuilder queryBuilder)  
public AbstractLoader(Context context){   super(context)  } 
@Override public void deliverResult(T result){   if (isReset()) {     releaseResources(result)      return    }   T oldResult=mResult    mResult=result    if (isStarted()) {     if (oldResult != result) {       try {         onNewDataDelivered(result)        }  catch (      Throwable t) {         throw new RuntimeException("Error occurred on delivering new data in loader: " + this,t)        }     }     super.deliverResult(result)    }   if (oldResult != result && oldResult != null) {     releaseResources(oldResult)    } } 
@Override public void onCanceled(T result){   super.onCanceled(result)    releaseResources(result)  } 
@Override protected void onReset(){   super.onReset()    onStopLoading()    releaseResources(mResult)    mResult=null  } 
@Override protected void onStartLoading(){   if (mResult != null) {     deliverResult(mResult)    }   if (takeContentChanged() || mResult == null) {     forceLoad()    } } 
@Override protected void onStopLoading(){   cancelLoad()  } 
/**   * Subclasses may implement this to take care of releasing resources held by  {@code result}. This will always be called from the process's main thread.  */ protected void releaseResources(T result){ } 
/**   * Subclasses may implement this to perform some action when new data is delivered for the first time. For example you might want to register some observers which would trigger reloading of the data. You do not want to do this in onStartLoading, because the user would never get any data if the loading time was longer than interval between forceLoad triggers from observer. This will always be called from the process's main thread.  */ protected void onNewDataDelivered(T data){ } 
@Override protected void onStartLoading(){   mObserver.setEnabled(true)    super.onStartLoading()  } 
@Override public T loadInBackground(){   try {     final Cursor cursor=loadCursorInBackground()      final T result=mCursorTransformation.apply(cursor)      Preconditions.checkNotNull(result,"Function passed to this loader should never return null.")      if (cursorsForResults.get(result) != null) {       releaseCursor(cursor)      }  else {       cursorsForResults.put(result,cursor)      }     return result    }  catch (  Throwable t) {     throw new RuntimeException("Error occurred when running loader: " + this,t)    } } 
private Cursor loadCursorInBackground(){   Cursor cursor=getContext().getContentResolver().query(mUri,mProjection,mSelection,mSelectionArgs,mSortOrder)    if (cursor != null) {     cursor.getCount()    }   return cursor  } 
@Override protected void onNewDataDelivered(T data){   cursorsForResults.get(data).registerContentObserver(mObserver)    if (!mAdditionalUrisRegistered) {     ContentResolver resolver=getContext().getContentResolver()      for (    Uri notificationUri : mNotificationUris) {       resolver.registerContentObserver(notificationUri,true,mObserver)      }     mAdditionalUrisRegistered=true    } } 
public ComposedCursorLoader(Context context,QueryData queryData,ImmutableList<Uri> notificationUris,Function<Cursor,T> cursorTransformation){   super(context)    mObserver=new DisableableContentObserver(new ForceLoadContentObserver())    mUri=queryData.getUri()    mProjection=queryData.getProjection()    mSelection=queryData.getSelection()    mSelectionArgs=queryData.getSelectionArgs()    mSortOrder=queryData.getOrderBy()    mCursorTransformation=cursorTransformation    mNotificationUris=notificationUris  } 
@Override protected void onAbandon(){   mObserver.setEnabled(false)    unregisterAdditionalUris()  } 
@Override protected void onReset(){   mObserver.setEnabled(false)    unregisterAdditionalUris()    super.onReset()  } 
@Override protected void releaseResources(T result){   releaseCursor(cursorsForResults.remove(result))  } 
private void unregisterAdditionalUris(){   if (mAdditionalUrisRegistered) {     getContext().getContentResolver().unregisterContentObserver(mObserver)      mAdditionalUrisRegistered=false    } } 
private void releaseCursor(@Nullable Cursor cursor){   if (cursor != null && !cursor.isClosed()) {     cursor.close()    } } 
@Override public void dump(String prefix,FileDescriptor fd,PrintWriter writer,String[] args){   super.dump(prefix,fd,writer,args)    writer.print(prefix)    writer.print("mUri=")    writer.println(mUri)    writer.print(prefix)    writer.print("mProjection=")    writer.println(Arrays.toString(mProjection))    writer.print(prefix)    writer.print("mSelection=")    writer.println(mSelection)    writer.print(prefix)    writer.print("mSelectionArgs=")    writer.println(Arrays.toString(mSelectionArgs))    writer.print(prefix)    writer.print("mSortOrder=")    writer.println(mSortOrder)    writer.print(prefix)    writer.print("mResult=")    writer.println(mResult)  } 
@Override public String toString(){   return MoreObjects.toStringHelper(this).add("mId",getId()).add("mUri",mUri).add("mProjection",Arrays.toString(mProjection)).add("mSelection",mSelection).add("mSelectionArgs",Arrays.toString(mSelectionArgs)).add("mSortOrder",mSortOrder).toString()  } 
public static CursorLoaderBuilder forUri(Uri uri){   return new CursorLoaderBuilder(uri)  } 
private CursorLoaderBuilder(Uri uri){   this.query=ProviderAction.query(uri)  } 
public CursorLoaderBuilder projection(String... projection){   query.projection(projection)    return this  } 
@SafeVarargs public final <T>CursorLoaderBuilder where(String selection,T... selectionArgs){   query.where(selection,selectionArgs)    return this  } 
public <T>CursorLoaderBuilder whereIn(String column,Collection<T> collection){   query.whereIn(column,collection)    return this  } 
public CursorLoaderBuilder orderBy(String orderBy){   query.orderBy(orderBy)    return this  } 
public CursorLoaderBuilder addNotificationUri(Uri uri){   notificationUris.add(uri)    return this  } 
public <Out>TransformedRowLoaderBuilder<Out> transformRow(Function<Cursor,Out> rowTransformer){   return new TransformedRowLoaderBuilder<>(query.getQueryData(),ImmutableList.copyOf(notificationUris),rowTransformer)  } 
public <Out>TransformedLoaderBuilder<Out> transform(Function<Cursor,Out> transformer){   return new TransformedLoaderBuilder<>(query.getQueryData(),ImmutableList.copyOf(notificationUris),transformer)  } 
public Loader<Cursor> build(Context context){   return new ComposedCursorLoader<>(context,query.getQueryData(),ImmutableList.copyOf(notificationUris),Functions.<Cursor>identity())  } 
public DisableableContentObserver(ContentObserver wrappedObserver){   super(new Handler())    mWrappedObserver=wrappedObserver  } 
@Override public void onChange(boolean selfChange){   if (mIsEnabled) {     mWrappedObserver.onChange(selfChange)    } } 
public void setEnabled(boolean isEnabled){   mIsEnabled=isEnabled  } 
private Entry(Key key,Value value){   this.key=key    this.value=value  } 
public synchronized V put(K key,V value){   final int index=findIndexOf(key)    if (index == -1) {     entries.add(new Entry<>(key,value))      return null    }  else {     Entry<K,V> entry=entries.get(index)      V oldValue=entry.value      entry.value=value      return oldValue    } } 
public synchronized V remove(K keyToRemove){   final int index=findIndexOf(keyToRemove)    if (index != -1) {     return entries.remove(index).value    }  else {     return null    } } 
private int findIndexOf(K keyToFind){   int i=0    for (  Entry<K,V> entry : entries) {     if (entry.key == keyToFind) {       return i      }     i++    }   return -1  } 
public synchronized V get(K key){   final int indexOf=findIndexOf(key)    if (indexOf != -1) {     return entries.get(indexOf).value    }   return null  } 
public LazyCursorList(final Cursor cursor,final Function<? super Cursor,T> function){   this.cursor=Cursors.returnSameOrEmptyIfNull(cursor)    cache=new LruCache<Integer,T>(256){     @Override protected T create(    Integer key){       cursor.moveToPosition(key)        return function.apply(cursor)      }   }   } 
@Override protected T create(Integer key){   cursor.moveToPosition(key)    return function.apply(cursor)  } 
@Override public T get(int i){   return cache.get(i)  } 
@Override public int size(){   return cursor.getCount()  } 
@Override public void close(){   cursor.close()  } 
public LoaderHelper(int id){   mId=id  } 
public final void destroyLoader(Fragment fragment){   fragment.getLoaderManager().destroyLoader(mId)  } 
public final void destroyLoader(FragmentActivity activity){   activity.getSupportLoaderManager().destroyLoader(mId)  } 
public final Loader<T> restartLoader(Fragment fragment,Bundle args,LoaderDataCallbacks<T> callbacks){   return restartLoader(fragment.getLoaderManager(),fragment.getActivity(),args,callbacks)  } 
public final Loader<T> restartLoader(FragmentActivity activity,Bundle args,LoaderDataCallbacks<T> callbacks){   return restartLoader(activity.getSupportLoaderManager(),activity,args,callbacks)  } 
private Loader<T> restartLoader(LoaderManager loaderManager,Context context,Bundle args,LoaderDataCallbacks<T> callbacks){   return loaderManager.restartLoader(mId,args,wrapCallbacks(context.getApplicationContext(),callbacks))  } 
public final Loader<T> initLoader(Fragment fragment,Bundle args,LoaderDataCallbacks<T> callbacks){   return initLoader(fragment.getLoaderManager(),fragment.getActivity(),args,callbacks)  } 
public final Loader<T> initLoader(FragmentActivity activity,Bundle args,LoaderDataCallbacks<T> callbacks){   return initLoader(activity.getSupportLoaderManager(),activity,args,callbacks)  } 
private Loader<T> initLoader(LoaderManager loaderManager,Context context,Bundle args,LoaderDataCallbacks<T> callbacks){   return loaderManager.initLoader(mId,args,wrapCallbacks(context.getApplicationContext(),callbacks))  } 
private LoaderCallbacks<T> wrapCallbacks(final Context applicationContext,final LoaderDataCallbacks<T> callbacks){   return new LoaderCallbacks<T>(){     @Override public Loader<T> onCreateLoader(    int id,    Bundle args){       Preconditions.checkArgument(id == mId)        return LoaderHelper.this.onCreateLoader(applicationContext,args)      }     @Override public void onLoadFinished(    Loader<T> loader,    T data){       callbacks.onLoadFinished(loader,data)      }     @Override public void onLoaderReset(    Loader<T> loader){       callbacks.onLoaderReset(loader)      }   }   } 
@Override public Loader<T> onCreateLoader(int id,Bundle args){   Preconditions.checkArgument(id == mId)    return LoaderHelper.this.onCreateLoader(applicationContext,args)  } 
@Override public void onLoadFinished(Loader<T> loader,T data){   callbacks.onLoadFinished(loader,data)  } 
@Override public void onLoaderReset(Loader<T> loader){   callbacks.onLoaderReset(loader)  } 
protected abstract Loader<T> onCreateLoader(Context context,Bundle args)  
public void onLoadFinished(Loader<T> loader,T data)  
public void onLoaderReset(Loader<T> loader)  
public TransformedLoaderBuilder(QueryData queryData,ImmutableList<Uri> notificationUris,Function<Cursor,To> wrapperFunction){   this.queryData=queryData    this.notificationUris=notificationUris    this.wrapperFunction=wrapperFunction  } 
public TransformedLoaderBuilder<To> addNotificationUri(Uri uri){   return new TransformedLoaderBuilder<>(queryData,ImmutableList.<Uri>builder().addAll(notificationUris).add(uri).build(),wrapperFunction)  } 
public <NewTo>TransformedLoaderBuilder<NewTo> transform(Function<To,NewTo> wrapper){   return new TransformedLoaderBuilder<>(queryData,notificationUris,Functions.compose(wrapper,wrapperFunction))  } 
public Loader<To> build(Context context){   return new ComposedCursorLoader<>(context,queryData,notificationUris,wrapperFunction)  } 
public TransformedRowLoaderBuilder(QueryData queryData,ImmutableList<Uri> notificationUris,Function<Cursor,T> transformation){   this.queryData=queryData    this.notificationUris=notificationUris    this.cursorTransformation=transformation  } 
public <Out>TransformedRowLoaderBuilder<Out> transformRow(final Function<T,Out> rowTransformer){   return new TransformedRowLoaderBuilder<>(queryData,notificationUris,Functions.compose(rowTransformer,cursorTransformation))  } 
public TransformedLoaderBuilder<List<T>> lazy(){   return new TransformedLoaderBuilder<>(queryData,notificationUris,getLazyTransformationFunction())  } 
public <Out>TransformedLoaderBuilder<Out> transform(final Function<List<T>,Out> transformer){   return new TransformedLoaderBuilder<>(queryData,notificationUris,Functions.compose(transformer,getEagerTransformationFunction()))  } 
public TransformedRowLoaderBuilder<T> addNotificationUri(Uri uri){   return new TransformedRowLoaderBuilder<>(queryData,ImmutableList.<Uri>builder().addAll(notificationUris).add(uri).build(),cursorTransformation)  } 
public Loader<List<T>> build(Context context){   return new ComposedCursorLoader<>(context,queryData,ImmutableList.copyOf(notificationUris),getEagerTransformationFunction())  } 
private Function<Cursor,List<T>> getEagerTransformationFunction(){   return new Function<Cursor,List<T>>(){     @Override public List<T> apply(    Cursor input){       return Lists.newArrayList(Cursors.toFluentIterable(input,cursorTransformation))      }   }   } 
@Override public List<T> apply(Cursor input){   return Lists.newArrayList(Cursors.toFluentIterable(input,cursorTransformation))  } 
private Function<Cursor,List<T>> getLazyTransformationFunction(){   return new Function<Cursor,List<T>>(){     @Override public List<T> apply(    Cursor cursor){       return new LazyCursorList<>(cursor,cursorTransformation)      }   }   } 
@Override public List<T> apply(Cursor cursor){   return new LazyCursorList<>(cursor,cursorTransformation)  } 
public BackRefBuilder(BatcherImpl batcher,Iterable<ConvertibleToOperation> convertibles){   super(batcher)    this.batcher=batcher    this.convertibles=convertibles  } 
public BackRefBuilder(BatcherImpl batcher,ConvertibleToOperation... convertible){   this(batcher,Arrays.asList(convertible))  } 
public BackRefBuilder withValueBackReference(Insert previousInsert,String columnName){   for (  ConvertibleToOperation convertible : convertibles) {     batcher.putValueBackRef(convertible,new ValueBackRef(previousInsert,columnName))    }   return this  } 
public BackRefBuilder withSelectionBackReference(Insert previousInsert,int selectionArgumentIndex){   for (  ConvertibleToOperation convertible : convertibles) {     batcher.putSelectionBackRef(convertible,new SelectionBackRef(previousInsert,selectionArgumentIndex))    }   return this  } 
public static Batcher begin(){   return new BatcherImpl()  } 
public abstract BackRefBuilder append(ConvertibleToOperation... convertibles)  
public abstract BackRefBuilder append(Iterable<ConvertibleToOperation> convertibles)  
public abstract Batcher decorateUrisWith(UriDecorator uriDecorator)  
public abstract ArrayList<ContentProviderOperation> operations()  
public final ContentProviderResult[] applyBatch(ContentProvider provider){   return applyBatchOrThrow(null,new ContentProviderCrudHandler(provider))  } 
public final ContentProviderResult[] applyBatch(ContentProviderClient providerClient) throws RemoteException, OperationApplicationException {   return applyBatch(null,new ContentProviderClientCrudHandler(providerClient))  } 
public final ContentProviderResult[] applyBatch(String authority,ContentResolver resolver) throws RemoteException, OperationApplicationException {   return applyBatch(authority,new ContentResolverCrudHandler(resolver))  } 
public final ContentProviderResult[] applyBatch(String authority,CrudHandler crudHandler) throws RemoteException, OperationApplicationException {   return crudHandler.applyBatch(authority,operations())  } 
public final ContentProviderResult[] applyBatchOrThrow(String authority,ContentProvider provider){   return applyBatchOrThrow(authority,new ContentProviderCrudHandler(provider))  } 
public final ContentProviderResult[] applyBatchOrThrow(String authority,ContentResolver resolver){   return applyBatchOrThrow(authority,new ContentResolverCrudHandler(resolver))  } 
public final ContentProviderResult[] applyBatchOrThrow(ContentProviderClient client){   return applyBatchOrThrow(null,new ContentProviderClientCrudHandler(client))  } 
public final ContentProviderResult[] applyBatchOrThrow(String authority,CrudHandler crudHandler){   try {     return applyBatch(authority,crudHandler)    }  catch (  RemoteException e) {     throw new RuntimeException("An Exception was returned from applyBatch",e)    } } 
ValueBackRef(Insert parent,String column){   this.parent=parent    this.column=column  } 
SelectionBackRef(Insert parent,int selectionArgumentIndex){   this.parent=parent    this.selectionArgumentIndex=selectionArgumentIndex  } 
@Override public BackRefBuilder append(ConvertibleToOperation... convertibles){   Collections.addAll(operations,convertibles)    return new BackRefBuilder(this,convertibles)  } 
@Override public BackRefBuilder append(Iterable<ConvertibleToOperation> convertibles){   Iterables.addAll(operations,convertibles)    return new BackRefBuilder(this,convertibles)  } 
@Override public Batcher decorateUrisWith(UriDecorator uriDecorator){   mUriDecorator=MoreObjects.firstNonNull(uriDecorator,Utils.DUMMY_URI_DECORATOR)    return this  } 
@Override public ArrayList<ContentProviderOperation> operations(){   ArrayList<ContentProviderOperation> providerOperations=Lists.newArrayListWithCapacity(operations.size())    BackRefResolver backRefResolver=getBackRefResolver()    for (  ConvertibleToOperation convertible : operations) {     final Builder builder=convertible.toContentProviderOperationBuilder(mUriDecorator)      backRefResolver.resolveBackRefs(convertible,builder)      providerOperations.add(builder.build())    }   return providerOperations  } 
public void putValueBackRef(ConvertibleToOperation convertible,ValueBackRef valueBackRef){   if (mValueBackRefs == null) {     mValueBackRefs=HashMultimap.create()    }   mValueBackRefs.put(convertible,valueBackRef)  } 
public void putSelectionBackRef(ConvertibleToOperation convertible,SelectionBackRef selectionBackRef){   if (mSelectionBackRefs == null) {     mSelectionBackRefs=HashMultimap.create()    }   mSelectionBackRefs.put(convertible,selectionBackRef)  } 
private BackRefResolver getBackRefResolver(){   if (mValueBackRefs == null && mSelectionBackRefs == null) {     return DUMMY_BACK_REF_RESOLVER    }  else {     return new BackRefResolverImpl(mValueBackRefs,mSelectionBackRefs)    } } 
void resolveBackRefs(ConvertibleToOperation convertible,Builder builder)  
public BackRefResolverImpl(Multimap<ConvertibleToOperation,ValueBackRef> valueBackRefs,Multimap<ConvertibleToOperation,SelectionBackRef> selectionBackRefs){   mValueBackRefs=valueBackRefs    mSelectionBackRefs=selectionBackRefs    mParentsPosition=HashMultimap.create()  } 
@Override public void resolveBackRefs(ConvertibleToOperation convertible,Builder builder){   if (mValueBackRefs != null && mValueBackRefs.containsKey(convertible)) {     ContentValues values=new ContentValues()      for (    ValueBackRef valueBackRef : mValueBackRefs.get(convertible)) {       values.put(valueBackRef.column,getParentPosition(valueBackRef.parent))      }     builder.withValueBackReferences(values)    }   if (mSelectionBackRefs != null) {     for (    SelectionBackRef selectionBackRef : mSelectionBackRefs.get(convertible)) {       builder.withSelectionBackReference(selectionBackRef.selectionArgumentIndex,getParentPosition(selectionBackRef.parent))      }   }   mParentsPosition.put(convertible,mParentsPosition.size())  } 
private int getParentPosition(ConvertibleToOperation parent){   Collection<Integer> positions=mParentsPosition.get(parent)    if (positions.isEmpty()) {     throw new IllegalStateException("Could not find operation used in back reference.")    }  else   if (positions.size() > 1) {     throw new IllegalStateException("Ambiguous back reference  referenced operation was added to Batcher more than once.")    }   return Iterables.getOnlyElement(positions)  } 
@Override public void resolveBackRefs(ConvertibleToOperation convertible,Builder builder){ } 
BatcherWrapper(Batcher realBatcher){   this.realBatcher=realBatcher  } 
@Override public BackRefBuilder append(ConvertibleToOperation... convertibles){   return realBatcher.append(convertibles)  } 
@Override public BackRefBuilder append(Iterable<ConvertibleToOperation> convertibles){   return realBatcher.append(convertibles)  } 
@Override public Batcher decorateUrisWith(UriDecorator uriDecorator){   return realBatcher.decorateUrisWith(uriDecorator)  } 
@Override public ArrayList<ContentProviderOperation> operations(){   return realBatcher.operations()  } 
ContentProviderClientCrudHandler(ContentProviderClient contentProviderClient){   this.contentProviderClient=contentProviderClient  } 
@Override public Cursor query(Uri url,String[] projection,String selection,String[] selectionArgs,String sortOrder) throws RemoteException {   return contentProviderClient.query(url,projection,selection,selectionArgs,sortOrder)  } 
@Override public int delete(Uri url,String selection,String[] selectionArgs) throws RemoteException {   return contentProviderClient.delete(url,selection,selectionArgs)  } 
@Override public int update(Uri url,ContentValues values,String selection,String[] selectionArgs) throws RemoteException {   return contentProviderClient.update(url,values,selection,selectionArgs)  } 
@Override public Uri insert(Uri url,ContentValues initialValues) throws RemoteException {   return contentProviderClient.insert(url,initialValues)  } 
@Override public ContentProviderResult[] applyBatch(String authority,ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException {   return contentProviderClient.applyBatch(operations)  } 
public ContentProviderCrudHandler(ContentProvider contentProvider){   this.contentProvider=contentProvider  } 
@Override public Cursor query(Uri url,String[] projection,String selection,String[] selectionArgs,String sortOrder) throws RemoteException {   return contentProvider.query(url,projection,selection,selectionArgs,sortOrder)  } 
@Override public int delete(Uri url,String selection,String[] selectionArgs) throws RemoteException {   return contentProvider.delete(url,selection,selectionArgs)  } 
@Override public int update(Uri url,ContentValues values,String selection,String[] selectionArgs) throws RemoteException {   return contentProvider.update(url,values,selection,selectionArgs)  } 
@Override public Uri insert(Uri url,ContentValues initialValues) throws RemoteException {   return contentProvider.insert(url,initialValues)  } 
@Override public ContentProviderResult[] applyBatch(String authority,ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException {   return contentProvider.applyBatch(operations)  } 
ContentResolverCrudHandler(ContentResolver contentResolver){   this.contentResolver=contentResolver  } 
@Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String orderBy){   return contentResolver.query(uri,projection,selection,selectionArgs,orderBy)  } 
@Override public Uri insert(Uri uri,ContentValues values){   return contentResolver.insert(uri,values)  } 
@Override public ContentProviderResult[] applyBatch(String authority,ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException {   return contentResolver.applyBatch(authority,operations)  } 
@Override public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs){   return contentResolver.update(uri,values,selection,selectionArgs)  } 
@Override public int delete(Uri uri,String selection,String[] selectionArgs){   return contentResolver.delete(uri,selection,selectionArgs)  } 
ContentProviderOperation.Builder toContentProviderOperationBuilder(UriDecorator uriDecorator)  
ContentProviderOperation toContentProviderOperation(UriDecorator uriDecorator)  
public Cursor query(Uri url,String[] projection,String selection,String[] selectionArgs,String sortOrder) throws RemoteException   
public int delete(Uri url,String selection,String[] selectionArgs) throws RemoteException   
public int update(Uri url,ContentValues values,String selection,String[] selectionArgs) throws RemoteException   
public Uri insert(Uri url,ContentValues initialValues) throws RemoteException   
public ContentProviderResult[] applyBatch(String authority,ArrayList<ContentProviderOperation> operations) throws RemoteException, OperationApplicationException   
Delete(Uri uri){   super(uri)  } 
@SafeVarargs public final <T>Delete where(String selection,T... selectionArgs){   this.selection.append(selection,selectionArgs)    return this  } 
public <T>Delete whereIn(String column,Collection<T> collection){   this.selection.append(column + " IN (" + Joiner.on(",").join(Collections2.transform(collection,Utils.toEscapedSqlFunction()))+ ")")    return this  } 
@Override public Integer perform(CrudHandler crudHandler) throws RemoteException {   return crudHandler.delete(getUri(),selection.getSelection(),selection.getSelectionArgs())  } 
@Override public ContentProviderOperation toContentProviderOperation(UriDecorator uriDecorator){   return toContentProviderOperationBuilder(uriDecorator).build()  } 
@Override public Builder toContentProviderOperationBuilder(UriDecorator uriDecorator){   return ContentProviderOperation.newDelete(uriDecorator.decorate(getUri())).withSelection(selection.getSelection(),selection.getSelectionArgs())  } 
Insert(Uri uri){   super(uri)  } 
public Insert values(ContentValues contentValues){   this.contentValues.putAll(contentValues)    return this  } 
public Insert value(String key,Object value){   Utils.addToContentValues(key,value,contentValues)    return this  } 
@Override public Uri perform(CrudHandler crudHandler) throws RemoteException {   return crudHandler.insert(getUri(),contentValues)  } 
@Override public ContentProviderOperation toContentProviderOperation(UriDecorator uriDecorator){   return toContentProviderOperationBuilder(uriDecorator).build()  } 
@Override public Builder toContentProviderOperationBuilder(UriDecorator uriDecorator){   return ContentProviderOperation.newInsert(uriDecorator.decorate(getUri())).withValues(contentValues)  } 
void append(String... projection){   Collections.addAll(this.projection,projection)  } 
String[] getProjection(){   if (!projection.isEmpty()) {     return projection.toArray(new String[projection.size()])    }   return null  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    Projection other=(Projection)o    return Objects.equal(projection,other.projection)  } 
@Override public int hashCode(){   return projection.hashCode()  } 
public static Query query(Uri uri){   return new Query(uri)  } 
public static Insert insert(Uri uri){   return new Insert(uri)  } 
public static Delete delete(Uri uri){   return new Delete(uri)  } 
public static Update update(Uri uri){   return new Update(uri)  } 
protected ProviderAction(Uri uri){   mUri=uri  } 
protected Uri getUri(){   return mUri  } 
public T perform(ContentProvider contentProvider){   try {     return perform(new ContentProviderCrudHandler(contentProvider))    }  catch (  RemoteException e) {     throw new RuntimeException("Unexpected exception",e)    } } 
public T perform(Context context){   return perform(context.getContentResolver())  } 
public T perform(ContentResolver contentResolver){   try {     return perform(new ContentResolverCrudHandler(contentResolver))    }  catch (  RemoteException e) {     throw new RuntimeException("Unexpected exception: ",e)    } } 
public T perform(ContentProviderClient contentProviderClient) throws RemoteException {   return perform(new ContentProviderClientCrudHandler(contentProviderClient))  } 
protected abstract T perform(CrudHandler crudHandler) throws RemoteException   
Query(Uri uri){   super(uri)  } 
public Query projection(String... projection){   this.projection.append(projection)    return this  } 
@SafeVarargs public final <T>Query where(String selection,T... selectionArgs){   this.selection.append(selection,selectionArgs)    return this  } 
public <T>Query whereIn(String column,Collection<T> collection){   this.selection.append(column + " IN (" + Joiner.on(",").join(Collections2.transform(collection,Utils.toEscapedSqlFunction()))+ ")")    return this  } 
public Query orderBy(String orderBy){   this.orderBy=orderBy    return this  } 
public QueryData getQueryData(){   return new QueryData(getUri(),projection.getProjection(),selection.getSelection(),selection.getSelectionArgs(),orderBy)  } 
@Override public FluentCursor perform(CrudHandler crudHandler) throws RemoteException {   final Cursor queryResult=crudHandler.query(getUri(),projection.getProjection(),selection.getSelection(),selection.getSelectionArgs(),orderBy)    return new FluentCursor(queryResult)  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    Query query=(Query)o    return Objects.equal(getUri(),query.getUri()) && Objects.equal(orderBy,query.orderBy) && Objects.equal(projection,query.projection)&& Objects.equal(selection,query.selection)  } 
@Override public int hashCode(){   return Objects.hashCode(getUri(),projection,selection,orderBy)  } 
@Override public String apply(String input){   return "(" + input + ")"  } 
@SafeVarargs final <T>void append(String selection,T... selectionArgs){   Preconditions.checkArgument(selection != null || selectionArgs == null || selectionArgs.length == 0,"selection cannot be null when arguments are provided")    if (selection != null) {     this.selection.add(selection)      if (selectionArgs != null) {       Collections.addAll(this.selectionArgs,selectionArgs)      }   } } 
String getSelection(){   if (selection.isEmpty()) {     return null    }   return Joiner.on(" AND ").join(Collections2.transform(selection,SURROUND_WITH_PARENS))  } 
String[] getSelectionArgs(){   if (selectionArgs.isEmpty()) {     return null    }   return Collections2.transform(selectionArgs,Functions.toStringFunction()).toArray(new String[selectionArgs.size()])  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    Selection other=(Selection)o    return Objects.equal(selection,other.selection) && Objects.equal(selectionArgs,other.selectionArgs)  } 
@Override public int hashCode(){   return Objects.hashCode(selection,selectionArgs)  } 
Update(Uri uri){   super(uri)  } 
public Update values(ContentValues values){   this.values.putAll(values)    return this  } 
public Update value(String key,Object value){   Utils.addToContentValues(key,value,values)    return this  } 
@SafeVarargs public final <T>Update where(String selection,T... selectionArgs){   this.selection.append(selection,selectionArgs)    return this  } 
public <T>Update whereIn(String column,Collection<T> collection){   this.selection.append(column + " IN (" + Joiner.on(",").join(Collections2.transform(collection,Utils.toEscapedSqlFunction()))+ ")")    return this  } 
@Override public Integer perform(CrudHandler crudHandler) throws RemoteException {   return crudHandler.update(getUri(),values,selection.getSelection(),selection.getSelectionArgs())  } 
@Override public ContentProviderOperation toContentProviderOperation(UriDecorator uriDecorator){   return toContentProviderOperationBuilder(uriDecorator).build()  } 
@Override public Builder toContentProviderOperationBuilder(UriDecorator uriDecorator){   return ContentProviderOperation.newUpdate(uriDecorator.decorate(getUri())).withSelection(selection.getSelection(),selection.getSelectionArgs()).withValues(values)  } 
Uri decorate(Uri uri)  
private Utils(){ } 
@Override public Uri decorate(Uri uri){   return uri  } 
public static void addToContentValues(String key,Object value,ContentValues contentValues){   if (value == null) {     contentValues.putNull(key)    }  else   if (value instanceof String) {     contentValues.put(key,(String)value)    }  else   if (value instanceof Byte) {     contentValues.put(key,(Byte)value)    }  else   if (value instanceof Short) {     contentValues.put(key,(Short)value)    }  else   if (value instanceof Integer) {     contentValues.put(key,(Integer)value)    }  else   if (value instanceof Long) {     contentValues.put(key,(Long)value)    }  else   if (value instanceof Float) {     contentValues.put(key,(Float)value)    }  else   if (value instanceof Double) {     contentValues.put(key,(Double)value)    }  else   if (value instanceof Boolean) {     contentValues.put(key,(Boolean)value)    }  else   if (value instanceof byte[]) {     contentValues.put(key,(byte[])value)    }  else {     throw new IllegalArgumentException("bad value type: " + value.getClass().getName())    } } 
public static void bindContentValueArg(SQLiteStatement statement,int index,Object value){   if (value == null) {     statement.bindNull(index)    }  else   if (value instanceof String) {     statement.bindString(index,(String)value)    }  else   if (value instanceof Byte) {     statement.bindLong(index,Long.valueOf((Byte)value))    }  else   if (value instanceof Short) {     statement.bindLong(index,Long.valueOf((Short)value))    }  else   if (value instanceof Integer) {     statement.bindLong(index,Long.valueOf((Integer)value))    }  else   if (value instanceof Long) {     statement.bindLong(index,(Long)value)    }  else   if (value instanceof Float) {     statement.bindDouble(index,(Float)value)    }  else   if (value instanceof Double) {     statement.bindDouble(index,(Double)value)    }  else   if (value instanceof Boolean) {     statement.bindLong(index,(Boolean)value ? 1 : 0)    }  else   if (value instanceof byte[]) {     statement.bindBlob(index,(byte[])value)    }  else {     throw new IllegalArgumentException("bad value type: " + value.getClass().getName())    } } 
public static Object escapeSqlArg(Object arg){   if (arg == null) {     return null    }   if (arg instanceof Boolean) {     return (Boolean)arg ? 1 : 0    }   if (arg instanceof Number) {     return arg    }   return DatabaseUtils.sqlEscapeString(arg.toString())  } 
public static <T>Function<T,Object> toEscapedSqlFunction(){   return new Function<T,Object>(){     @Nullable @Override public Object apply(    @Nullable T arg){       return escapeSqlArg(arg)      }   }   } 
@Nullable @Override public Object apply(@Nullable T arg){   return escapeSqlArg(arg)  } 
@Test public void shouldSurviveNullPassedToFluentIterable() throws Exception {   final Cursor cursor=null    final FluentIterable<Object> objects=Cursors.toFluentIterable(cursor,new Function<Cursor,Object>(){     @Override public Object apply(    Cursor cursor){       return null      }   } )    assertThat(objects).isEmpty()  } 
@Override public Object apply(Cursor cursor){   return null  } 
@Test public void shouldCloseCursorProperly() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{"column1"})    Cursors.closeQuietly(cursor)    assertThat(cursor.isClosed()).isTrue()  } 
@Test public void shouldSurviveNullPassedToCloseQuietly() throws Exception {   Cursors.closeQuietly(null)  } 
@Test public void shouldNotTryToCloseAlreadyClosedCursor() throws Exception {   Cursor cursor=mock(Cursor.class)    when(cursor.isClosed()).thenReturn(true)    Cursors.closeQuietly(cursor)    verify(cursor,never()).close()  } 
@Override public Object apply(Cursor input){   throw new RuntimeException()  } 
@Test public void shouldCloseCursorAfterItIsTransformed() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{TEST_COLUMN})    final FluentCursor fluentCursor=new FluentCursor(cursor)    fluentCursor.toFluentIterable(Functions.constant(null))    assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldApplyGivenFunctionOnEverySingleRow() throws Exception {   final MatrixCursor cursor=buildMatrixCursor(10)    final FluentCursor fluentCursor=new FluentCursor(cursor)    final FluentIterable<Long> transformed=fluentCursor.toFluentIterable(new Function<Cursor,Long>(){     @Override public Long apply(    Cursor cursor){       return cursor.getLong(cursor.getColumnIndexOrThrow(TEST_COLUMN))      }   } )    assertThat(transformed).hasSize(cursor.getCount())    assertThat(transformed.allMatch(new Predicate<Long>(){     @Override public boolean apply(    Long aLong){       return aLong.equals(18L)      }   } )).isTrue()  } 
@Override public Long apply(Cursor cursor){   return cursor.getLong(cursor.getColumnIndexOrThrow(TEST_COLUMN))  } 
@Override public boolean apply(Long aLong){   return aLong.equals(18L)  } 
@Test public void shouldRecognizeNullAsAnEmptyCursor() throws Exception {   final FluentCursor cursor=new FluentCursor(null)    assertThat(cursor.getCount()).isEqualTo(0)  } 
@Test public void shouldBeAbleToCloseQuietlyFluentCursorWrappingNull() throws Exception {   final FluentCursor cursor=new FluentCursor(null)    cursor.close()  } 
@Test public void shouldBeAbleToGetColumnIndexFromFluentCursorWrappingNull() throws Exception {   final FluentCursor cursor=new FluentCursor(null)    cursor.getColumnIndexOrThrow(TEST_COLUMN)    cursor.getColumnIndex(TEST_COLUMN)  } 
@Test public void shouldAlwaysCloseCursorAfterCallingToFluentIterable() throws Exception {   final FluentCursor fluentCursor=new FluentCursor(buildMatrixCursor(10))    try {     fluentCursor.toFluentIterable(KABOOM)    }  catch (  Throwable t) {   }   assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldSuccessfullyTransformToMultimap() throws Exception {   final MatrixCursor cursor=buildMatrixCursor(10)    final FluentCursor fluentCursor=new FluentCursor(cursor)    final LinkedHashMultimap<Integer,Long> transformed=fluentCursor.toMultimap(SingleRowTransforms.getColumn(OTHER_COLUMN).asInteger(),SingleRowTransforms.getColumn(TEST_COLUMN).asLong())    assertThat(transformed.size()).isEqualTo(cursor.getCount())    assertThat(transformed.keySet()).containsExactly(ContiguousSet.create(Range.closed(0,9),DiscreteDomain.integers()).toArray())    assertThat(transformed.values()).containsExactlyElementsIn(Collections.nCopies(10,18L))  } 
@Test public void shouldTransformToMultimapWithTheSameIterationOrderAsCursorRows() throws Exception {   final MatrixCursor cursor=buildMatrixCursor(3)    final FluentCursor fluentCursor=new FluentCursor(cursor)    final LinkedHashMultimap<Integer,Long> transformed=fluentCursor.toMultimap(SingleRowTransforms.getColumn(OTHER_COLUMN).asInteger(),SingleRowTransforms.getColumn(TEST_COLUMN).asLong())    assertThat(Lists.newArrayList(transformed.keySet())).containsExactly(0,1,2)  } 
@Test public void shouldCloseCursorAfterItIsTransformedToMultimap() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{TEST_COLUMN})    final FluentCursor fluentCursor=new FluentCursor(cursor)    fluentCursor.toMultimap(Functions.constant(null),Functions.constant(null))    assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldAlwaysCloseCursorAfterCallingToMultimap() throws Exception {   final FluentCursor fluentCursor=new FluentCursor(buildMatrixCursor(10))    try {     fluentCursor.toMultimap(KABOOM,KABOOM)    }  catch (  Throwable t) {   }   assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldSuccessfullyTransformToMap() throws Exception {   final MatrixCursor cursor=buildMatrixCursor(10)    final FluentCursor fluentCursor=new FluentCursor(cursor)    final Map<Integer,Long> transformed=fluentCursor.toMap(SingleRowTransforms.getColumn(OTHER_COLUMN).asInteger(),SingleRowTransforms.getColumn(TEST_COLUMN).asLong())    assertThat(transformed.size()).isEqualTo(cursor.getCount())    assertThat(transformed.keySet()).containsExactly(ContiguousSet.create(Range.closed(0,9),DiscreteDomain.integers()).toArray())    assertThat(transformed.values()).containsExactlyElementsIn(Collections.nCopies(10,18L))  } 
@Test(expected=IllegalArgumentException.class) public void shouldFailIfCursorTransformedToMapContainsDuplicateKey() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{OTHER_COLUMN,TEST_COLUMN})    cursor.addRow(new Object[]{10,18L})    cursor.addRow(new Object[]{10,18L})    final FluentCursor fluentCursor=new FluentCursor(cursor)    fluentCursor.toMap(SingleRowTransforms.getColumn(OTHER_COLUMN).asInteger(),SingleRowTransforms.getColumn(TEST_COLUMN).asLong())  } 
@Test public void shouldTransformToMapWithTheSameIterationOrderAsCursorRows() throws Exception {   final MatrixCursor cursor=buildMatrixCursor(3)    final FluentCursor fluentCursor=new FluentCursor(cursor)    final Map<Integer,Long> transformed=fluentCursor.toMap(SingleRowTransforms.getColumn(OTHER_COLUMN).asInteger(),SingleRowTransforms.getColumn(TEST_COLUMN).asLong())    assertThat(Lists.newArrayList(transformed.keySet())).containsExactly(0,1,2)  } 
@Test public void shouldCloseCursorAfterItIsTransformedToMap() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{TEST_COLUMN})    final FluentCursor fluentCursor=new FluentCursor(cursor)    fluentCursor.toMap(Functions.constant(null),Functions.constant(null))    assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldAlwaysCloseCursorAfterCallingToMap() throws Exception {   final FluentCursor fluentCursor=new FluentCursor(buildMatrixCursor(10))    try {     fluentCursor.toMap(KABOOM,KABOOM)    }  catch (  Throwable t) {   }   assertThat(fluentCursor.isClosed()).isTrue()  } 
@Test public void shouldAcceptFunctionsOperatingOnObject() throws Exception {   new FluentCursor(null).toFluentIterable(Functions.constant(1L))  } 
@Test public void shouldCloseCursorWhenGettingRowCount() throws Exception {   Cursor mock=mock(Cursor.class)    new FluentCursor(mock).toRowCount()    verify(mock).close()  } 
@Test public void shouldConvertToCorrectRowCount() throws Exception {   Cursor mock=mock(Cursor.class)    when(mock.getCount()).thenReturn(42)    assertThat(new FluentCursor(mock).toRowCount()).isEqualTo(42)  } 
@Test public void shouldCloseCursorAfterTransformingToOnlyElement() throws Exception {   MatrixCursor cursor=buildMatrixCursor(1)    new FluentCursor(cursor).toOnlyElement(Functions.constant(null))    assertThat(cursor).isClosed()  } 
@Test public void shouldCloseCursorAfterTransformingToOnlyElementWithDefaultValue() throws Exception {   MatrixCursor cursor=buildMatrixCursor(0)    new FluentCursor(cursor).toOnlyElement(Functions.constant(null),null)    assertThat(cursor).isClosed()  } 
@Test(expected=NoSuchElementException.class) public void shouldThrowAnExceptionWhenTransformingEmptyCursorToOnlyElement() throws Exception {   new FluentCursor(buildMatrixCursor(0)).toOnlyElement(Functions.constant(null))  } 
@Test public void shouldReturnDefaultValueWhenTransformingEmptyCursorToOnlyElementWithDefaultValue() throws Exception {   Integer shouldBeDefault=new FluentCursor(buildMatrixCursor(0)).toOnlyElement(Functions.constant(1500),2900)    assertThat(shouldBeDefault).isEqualTo(2900)  } 
@Test(expected=IllegalArgumentException.class) public void shouldThrowAnExceptionWhenTransformingCursorWithMultipleToOnlyElement() throws Exception {   new FluentCursor(buildMatrixCursor(10)).toOnlyElement(Functions.constant(null))  } 
@Test(expected=IllegalArgumentException.class) public void shouldThrowAnExceptionWhenTransformingCursorWithMultipleToOnlyElementWithDefaultValue() throws Exception {   new FluentCursor(buildMatrixCursor(10)).toOnlyElement(Functions.constant(null),null)  } 
@Test public void shouldApplyGivenFunctionWhenTransformingCursorToOnlyElement() throws Exception {   MatrixCursor cursor=buildMatrixCursor(1)    Integer onlyElement=new FluentCursor(cursor).toOnlyElement(Functions.constant(1500))    assertThat(onlyElement).isEqualTo(1500)  } 
@Test public void shouldApplyGivenFunctionWhenTransformingCursorToOnlyElementWithDefaultValue() throws Exception {   MatrixCursor cursor=buildMatrixCursor(1)    Integer onlyElement=new FluentCursor(cursor).toOnlyElement(Functions.constant(1500),2900)    assertThat(onlyElement).isEqualTo(1500)  } 
@Test public void shouldNotIterateOverCursorWhenTransformingCursorToOnlyElement() throws Exception {   Cursor cursor=spy(buildMatrixCursor(1))    new FluentCursor(cursor).toOnlyElement(Functions.constant(null))    verify(cursor,never()).moveToNext()    verify(cursor,never()).moveToLast()    verify(cursor,never()).moveToPrevious()    verify(cursor,never()).moveToPosition(intThat(not(equalTo(0))))  } 
@Test public void shouldNotIterateOverCursorWhenTransformingCursorToOnlyElementWithDefaultValue() throws Exception {   Cursor cursor=spy(buildMatrixCursor(0))    new FluentCursor(cursor).toOnlyElement(Functions.constant(null),null)    verify(cursor,never()).moveToNext()    verify(cursor,never()).moveToLast()    verify(cursor,never()).moveToPrevious()    verify(cursor,never()).moveToPosition(intThat(not(equalTo(0))))  } 
@Test public void shouldNotIterateOverCursorWhenTransformingCursorToRowCount() throws Exception {   Cursor mock=mock(Cursor.class)    new FluentCursor(mock).toRowCount()    verify(mock,never()).moveToFirst()    verify(mock,never()).moveToNext()    verify(mock,never()).moveToLast()    verify(mock,never()).moveToPrevious()    verify(mock,never()).moveToPosition(anyInt())  } 
private MatrixCursor buildMatrixCursor(int count){   final MatrixCursor cursor=new MatrixCursor(new String[]{OTHER_COLUMN,TEST_COLUMN})    for (int i=0  i < count  i++) {     cursor.addRow(new Object[]{i,18L})    }   return cursor  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)    when(cursorMock.getColumnIndexOrThrow(COLUMN)).thenReturn(1)  } 
@Test public void shouldCacheGetColumnIndexResult() throws Exception {   Cursor c=mock(Cursor.class)    Function<Cursor,Integer> transform=SingleRowTransforms.getColumn(COLUMN).asInteger()    transform.apply(c)    transform.apply(c)    verify(c,times(1)).getColumnIndexOrThrow(anyString())  } 
@Test public void shouldHandleGracefullyUsingWithMultipleCursors() throws Exception {   Cursor c1=mock(Cursor.class)    when(c1.getColumnIndexOrThrow(COLUMN)).thenReturn(1)    when(c1.isNull(1)).thenReturn(false)    when(c1.getInt(1)).thenReturn(42)    when(c1.isNull(2)).thenThrow(new IllegalArgumentException())    when(c1.getInt(2)).thenThrow(new IllegalArgumentException())    Cursor c2=mock(Cursor.class)    when(c2.getColumnIndexOrThrow(COLUMN)).thenReturn(2)    when(c2.isNull(2)).thenReturn(false)    when(c2.getInt(2)).thenReturn(666)    when(c2.isNull(1)).thenThrow(new IllegalArgumentException())    when(c2.getInt(1)).thenThrow(new IllegalArgumentException())    Function<Cursor,Integer> transform=SingleRowTransforms.getColumn(COLUMN).asInteger()    assertThat(transform.apply(c1)).isEqualTo(42)    assertThat(transform.apply(c2)).isEqualTo(666)    assertThat(transform.apply(c1)).isEqualTo(42)  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectCursorWithoutSpecifiedColumn() throws Exception {   MatrixCursor cursor=new MatrixCursor(new String[]{COLUMN})    cursor.addRow(new Object[]{42})    cursor.moveToFirst()    SingleRowTransforms.getColumn("lol").asInteger().apply(cursor)  } 
@Test public void shouldGetShortForExistingColumn() throws Exception {   short expected=42    when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getShort(1)).thenReturn(expected)    assertThat(SingleRowTransforms.getColumn(COLUMN).asShort().apply(cursorMock)).isEqualTo(expected)  } 
@Test public void shouldGetNullForExistingShortColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asShort().apply(cursorMock)).isNull()  } 
@Test public void shouldGetIntForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getInt(1)).thenReturn(42)    assertThat(SingleRowTransforms.getColumn(COLUMN).asInteger().apply(cursorMock)).isEqualTo(42)  } 
@Test public void shouldGetNullForExistingIntColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asInteger().apply(cursorMock)).isNull()  } 
@Test public void shouldGetLongForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getLong(1)).thenReturn(42L)    assertThat(SingleRowTransforms.getColumn(COLUMN).asLong().apply(cursorMock)).isEqualTo(42L)  } 
@Test public void shouldGetNullForExistingLongColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asLong().apply(cursorMock)).isNull()  } 
@Test public void shouldGetFloatForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getFloat(1)).thenReturn(42f)    assertThat(SingleRowTransforms.getColumn(COLUMN).asFloat().apply(cursorMock)).isEqualTo(42f)  } 
@Test public void shouldGetNullForExistingFloatColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asFloat().apply(cursorMock)).isNull()  } 
@Test public void shouldGetDoubleForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getDouble(1)).thenReturn(42d)    assertThat(SingleRowTransforms.getColumn(COLUMN).asDouble().apply(cursorMock)).isWithin(0e-6).of(42d)  } 
@Test public void shouldGetNullForExistingDoubleColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asDouble().apply(cursorMock)).isNull()  } 
@Test public void shouldGetTrueBooleanForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getInt(1)).thenReturn(1)    assertThat(SingleRowTransforms.getColumn(COLUMN).asBoolean().apply(cursorMock)).isTrue()  } 
@Test public void shouldGetFalseBooleanForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getInt(1)).thenReturn(0)    assertThat(SingleRowTransforms.getColumn(COLUMN).asBoolean().apply(cursorMock)).isFalse()  } 
@Test public void shouldGetNullForExistingBooleanColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asBoolean().apply(cursorMock)).isNull()  } 
@Test public void shouldGetStringForExistingColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(false)    when(cursorMock.getString(1)).thenReturn("wat?")    assertThat(SingleRowTransforms.getColumn(COLUMN).asString().apply(cursorMock)).isEqualTo("wat?")  } 
@Test public void shouldGetNullForExistingStringColumn() throws Exception {   when(cursorMock.isNull(1)).thenReturn(true)    assertThat(SingleRowTransforms.getColumn(COLUMN).asString().apply(cursorMock)).isNull()  } 
public CustomRobolectricTestRunner(Class<?> testClass) throws InitializationError {   super(testClass)  } 
@Override protected ShadowMap createShadowMap(){   return super.createShadowMap().newBuilder().addShadowClass(ShadowAsyncTaskLoader.class).build()  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldBuildUnionQuery() throws Exception {   select(select().allColumns().from("table_a")).union(select().allColumns().from("table_b")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildUnionAllQuery() throws Exception {   select(select().allColumns().from("table_a")).unionAll(select().allColumns().from("table_b")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION ALL SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildIntersectQuery() throws Exception {   select(select().allColumns().from("table_a")).intersect(select().allColumns().from("table_b")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a INTERSECT SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildExceptQuery() throws Exception {   select(select().allColumns().from("table_a")).except(select().allColumns().from("table_b")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a EXCEPT SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildCompoundQueryWithOrderByAndLimit() throws Exception {   select(select().allColumns().from("table_a")).union(select().allColumns().from("table_b")).orderBy("column_a").collate("UNICODE").asc().limit(1500).offset(2900).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT * FROM table_b ORDER BY column_a COLLATE UNICODE ASC LIMIT 1500 OFFSET 2900"),eq(new String[0]))  } 
@Test public void shouldGetCorrectTablesFromTheCompoundQuery() throws Exception {   final Query query=select(select().allColumns().from("table_a")).union(select().allColumns().from("table_b")).build()    assertThat(query.getTables()).containsExactly("table_a","table_b")  } 
@Test(expected=NullPointerException.class) public void shouldRejectNullQueryArrayFromUnionConvenienceMethod() throws Exception {   union((Query[])null)  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectEmptyQueryArrayFromUnionConvenienceMethod() throws Exception {   union()  } 
@Test public void shouldBuildUnionQueryWithConvenienceMethod() throws Exception {   Query union=union(select().allColumns().from("table_a").build(),select().allColumns().from("table_b").build())    union.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT * FROM table_b"),eq(new String[0]))  } 
@Test(expected=NullPointerException.class) public void shouldRejectNullQueryArrayFromUnionAllConvenienceMethod() throws Exception {   unionAll((Query[])null)  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectEmptyQueryArrayFromUnionAllConvenienceMethod() throws Exception {   unionAll()  } 
@Test public void shouldBuildUnionAllQueryWithConvenienceMethod() throws Exception {   Query unionAll=unionAll(select().allColumns().from("table_a").build(),select().allColumns().from("table_b").build())    unionAll.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION ALL SELECT * FROM table_b"),eq(new String[0]))  } 
@Test(expected=NullPointerException.class) public void shouldRejectNullQueryArrayFromIntersectConvenienceMethod() throws Exception {   intersect((Query[])null)  } 
@Test public void shouldBuildIntersectQueryWithConvenienceMethod() throws Exception {   Query intersection=intersect(select().allColumns().from("table_a").build(),select().allColumns().from("table_b").build())    intersection.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a INTERSECT SELECT * FROM table_b"),eq(new String[0]))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectEmptyQueryArrayFromIntersectConvenienceMethod() throws Exception {   intersect()  } 
@Test public void shouldBuildNestedCompoundQueries() throws Exception {   Query intersection=intersect(select().allColumns().from("table_a").build(),union(select().allColumns().from("table_b").build(),select().allColumns().from("table_c").build()),select().allColumns().from("table_d").build())    intersection.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a INTERSECT SELECT * FROM (SELECT * FROM table_b UNION SELECT * FROM table_c) INTERSECT SELECT * FROM table_d"),eq(new String[0]))  } 
@Test public void shouldBuildNestedCompoundQueriesStartingWithCompoundQuery() throws Exception {   Query intersection=intersect(union(select().allColumns().from("table_b").build(),select().allColumns().from("table_c").build()),select().allColumns().from("table_d").build(),unionAll(select().allColumns().from("table_e").build(),select().allColumns().from("table_f").build()))    intersection.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM (SELECT * FROM table_b UNION SELECT * FROM table_c) INTERSECT SELECT * FROM table_d INTERSECT SELECT * FROM (SELECT * FROM table_e UNION ALL SELECT * FROM table_f)"),eq(new String[0]))  } 
@Test public void shouldBuildIntersectionWithSingleCompoundQuery() throws Exception {   Query query=intersect(select().from("table_a").union().select().from("table_b").build())    query.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildIntersectionWithIntersection() throws Exception {   Query query=intersect(intersect(select().from("table_a").build(),select().from("table_b").build()))    query.perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a INTERSECT SELECT * FROM table_b"),eq(new String[0]))  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldBuildTheDeleteWithoutSelection() throws Exception {   delete().from("A").perform(mDb)    verify(mDb).delete(eq("A"),anyString(),any(String[].class))  } 
@Test public void shouldBuildTheDeleteWithSingleSelection() throws Exception {   delete().from("A").where("a IS NULL").perform(mDb)    verify(mDb).delete(anyString(),eq("(a IS NULL)"),any(String[].class))  } 
@Test public void shouldBuildTheDeleteWithSingleSelectionBuiltFromExpressions() throws Exception {   delete().from("A").where(column("a").is().nul()).perform(mDb)    verify(mDb).delete(anyString(),eq("(a IS NULL)"),any(String[].class))  } 
@Test public void shouldBuildTheDeleteWithMultipleSelections() throws Exception {   delete().from("A").where("a IS NULL").where("b IS NULL").perform(mDb)    verify(mDb).delete(anyString(),eq("(a IS NULL) AND (b IS NULL)"),any(String[].class))  } 
@Test public void shouldBuildTheDeleteWithBoundParams() throws Exception {   delete().from("A").where("a=?",0).perform(mDb)    verify(mDb).delete(anyString(),eq("(a=?)"),eq(new String[]{"0"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooManyArgsPlaceholders() throws Exception {   delete().from("A").where(column("col2").eq().arg())  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooFewArgsPlaceholders() throws Exception {   delete().from("A").where(column("col2").eq().arg(),1,2)  } 
@Test public void shouldBuildSelectionFromExpressionWithArgsPlaceholders() throws Exception {   delete().from("A").where(column("col2").eq().arg(),"val2").perform(mDb)    verify(mDb).delete(anyString(),eq("(col2 == ?)"),eq(new String[]{"val2"}))  } 
@Test public void shouldBuildSelectionFromExpressionWithBoundArgs() throws Exception {   delete().from("A").where(column("col2").in(select().column("id").from("B").where("status=?","new").build())).perform(mDb)    verify(mDb).delete(anyString(),anyString(),eq(new String[]{"new"}))  } 
@Test public void shouldAllowUsingNullArgumentsForSelection() throws Exception {   delete().from("table_a").where("col_a IS NULL",(Object[])null).perform(mDb)    verify(mDb).delete(eq("table_a"),eq("(col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionWithExpression() throws Exception {   delete().from("table_a").where(column("col_a").is().nul(),(Object[])null).perform(mDb)    verify(mDb).delete(eq("table_a"),eq("(col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullSelectionWithNullArguments() throws Exception {   delete().from("table_a").where((String)null).perform(mDb)  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingNullSelectionWithArguments() throws Exception {   delete().from("table_a").where((String)null,"I shall fail").perform(mDb)  } 
public ExpressionsArgsCountTest(int actual,int expected){   mActual=actual    mExpected=expected  } 
@Parameters public static Collection<Object[]> data(){   return FluentIterable.from(TEST_CASES.entrySet()).transform(new Function<Entry<Expression,Integer>,Object[]>(){     @Override public Object[] apply(    Entry<Expression,Integer> input){       return new Object[]{input.getKey().getArgsCount(),input.getValue()}      }   } ).toList()  } 
@Override public Object[] apply(Entry<Expression,Integer> input){   return new Object[]{input.getKey().getArgsCount(),input.getValue()}  } 
@Test public void shouldCountExpressionArgsSql() throws Exception {   assertThat(mActual).isEqualTo(mExpected)  } 
public ExpressionsBuilderTest(String actual,String expected){   mActual=actual    mExpected=expected  } 
@Parameters public static Collection<Object[]> data(){   return FluentIterable.from(TEST_CASES.entrySet()).transform(new Function<Entry<Expression,String>,Object[]>(){     @Override public Object[] apply(    Entry<Expression,String> input){       return new Object[]{input.getKey().getSql(),input.getValue()}      }   } ).toList()  } 
@Override public Object[] apply(Entry<Expression,String> input){   return new Object[]{input.getKey().getSql(),input.getValue()}  } 
@Test public void shouldBuildCorrectSql() throws Exception {   assertThat(mActual).isEqualTo(mExpected)  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectCoalesceWithNoArguments() throws Exception {   coalesce()  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectCoalesceWithOneArguments() throws Exception {   coalesce(literal(666))  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowMergingExpressionWithPlaceholdersWithNullArgsList() throws Exception {   addExpressionArgs(Lists.newArrayList(),arg(),(Object[])null)  } 
@Test public void shouldReturnBoundArgsFromSubqueries() throws Exception {   Expression expression=column("deleted").eq(arg()).and().column("id").in(select().column("id").from("table_a").where(column("name").eq().arg(),"Smith").build()).and().column("priority").eq().arg()    assertThat(expression.getBoundArgs()).isEqualTo(ImmutableMap.of(1,"Smith"))  } 
@Test(expected=IllegalStateException.class) public void shouldNotAllowGettingRawSqlFromExpressionWithBoundArgs() throws Exception {   column("id").in(select().column("id").from("table_a").where(column("name").eq().arg(),"Smith").build()).toRawSql()  } 
@Test public void shouldGetRawSqlForExpression() throws Exception {   String rawSql=column("id").eq().literal(0).toRawSql()    assertThat(rawSql).isEqualTo("id == 0")  } 
@Test(expected=NullPointerException.class) public void shouldFailToConvertNullNumbersArrayIntoExpressions() throws Exception {   literals((Number[])null)  } 
@Test public void shouldConvertNumbersArrayIntoExpressions() throws Exception {   String rawSql=column("id").in(literals(1,2,3)).toRawSql()    assertThat(rawSql).isEqualTo("id IN (1, 2, 3)")  } 
@Test public void shouldConvertEmptyNumbersArrayIntoExpressions() throws Exception {   String rawSql=column("id").in(literals(new Number[0])).toRawSql()    assertThat(rawSql).isEqualTo("id IN ()")  } 
@Test(expected=NullPointerException.class) public void shouldFailToConvertNullObjectsArrayIntoExpressions() throws Exception {   literals((Number[])null)  } 
@Test public void shouldConvertObjectsArrayIntoExpressions() throws Exception {   String rawSql=column("id").in(literals("a","b","c")).toRawSql()    assertThat(rawSql).isEqualTo("id IN ('a', 'b', 'c')")  } 
@Test public void shouldConvertEmptyObjectsArrayIntoExpressions() throws Exception {   String rawSql=column("id").in(literals(new Object[0])).toRawSql()    assertThat(rawSql).isEqualTo("id IN ()")  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)    when(mDb.compileStatement(anyString())).thenReturn(mStatement)  } 
@Test public void shouldUseTableSpecifiedInIntoStepInInsertForDefaultValues() throws Exception {   DefaultValuesInsert insert=insert().into("A").defaultValues("nullable_col")    assertThat(insert.mTable).isEqualTo("A")  } 
@Test public void shouldUseTableSpecifiedInIntoStepInInsertWithValues() throws Exception {   Insert insert=insert().into("A").value("nullable_col",null)    assertThat(insert.mTable).isEqualTo("A")  } 
@Test public void shouldBuildTheInsertForDefaultValues() throws Exception {   DefaultValuesInsert insert=insert().into("A").defaultValues("nullable_col")    assertThat(insert.mNullColumnHack).isEqualTo("nullable_col")  } 
@Test public void shouldBuildTheInsertInSelectFormWithoutSpecifiedColumns() throws Exception {   Query query=select().allColumns().from("B").build()    insert().into("A").resultOf(query).perform(mDb)    verify(mDb).compileStatement(eq("INSERT INTO A " + query.toRawQuery().mRawQuery))    verify(mStatement).executeInsert()  } 
@Test public void shouldAllowUsingQueryWithBoundArgsForInsertInSelectForm() throws Exception {   insert().into("A").resultOf(select().allColumns().from("B").where("col=?",0).build()).perform(mDb)    verify(mDb).compileStatement(eq("INSERT INTO A SELECT * FROM B WHERE (col=?)"))    verify(mStatement).bindString(eq(1),eq("0"))    verify(mStatement).executeInsert()  } 
@Test public void shouldBuildTheInsertInSelectFormWithSpecifiedColumns() throws Exception {   Query query=select().allColumns().from("B").build()    insert().into("A").columns("a","b","c").resultOf(query).perform(mDb)    verify(mDb).compileStatement(eq("INSERT INTO A (a, b, c) " + query.toRawQuery().mRawQuery))    verify(mStatement).executeInsert()  } 
@Test public void shouldConcatenateSpecifiedColumnsForInsertInSelectForm() throws Exception {   Query query=select().allColumns().from("B").build()    insert().into("A").columns("a","b").columns("c").resultOf(query).perform(mDb)    verify(mDb).compileStatement(eq("INSERT INTO A (a, b, c) " + query.toRawQuery().mRawQuery))    verify(mStatement).executeInsert()  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectNullColumnsListInInsertInSelectForm() throws Exception {   Query query=select().allColumns().from("B").build()    insert().into("A").columns((String[])null).resultOf(query).perform(mDb)  } 
@Test public void shouldBuildInsertWithSingleValue() throws Exception {   Insert insert=insert().into("A").value("col1","val1")    assertThat(insert.mValues).contains(entry("col1","val1"))  } 
@Test public void shouldNotModifyPassedContentValues() throws Exception {   ContentValues values=new ContentValues()    insert().into("A").values(values).value("key","value")    assertThat(values.containsKey("key")).isFalse()    ContentValues valuesToConcatenate=new ContentValues()    valuesToConcatenate.put("another_key","another_value")    insert().into("A").values(values).values(valuesToConcatenate)    assertThat(values.containsKey("another_key")).isFalse()  } 
@Test public void shouldBuildInsertWithConcatenatedContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    ContentValues secondValues=new ContentValues()    secondValues.put("col2","val2")    Insert insert=insert().into("A").values(firstValues).values(secondValues)    assertThat(insert.mValues).contains(entry("col1","val1"),entry("col2","val2"))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenBySingleValue() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    values.put("col2","val2")    Insert insert=insert().into("A").values(values).value("col2",null)    assertThat(insert.mValues).contains(entry("col1","val1"),entry("col2",null))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenByOtherContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    firstValues.put("col2","val2")    ContentValues secondValues=new ContentValues()    secondValues.putNull("col2")    secondValues.put("col3","val3")    Insert insert=insert().into("A").values(firstValues).values(secondValues)    assertThat(insert.mValues).contains(entry("col1","val1"),entry("col3","val3"),entry("col2",null))  } 
@Test public void shouldPerformInsertWithDefaultValues() throws Exception {   insert().into("A").defaultValues("nullable_col").perform(mDb)    verify(mDb).insert(eq("A"),eq("nullable_col"),isNull(ContentValues.class))  } 
@Test public void shouldPerformInsertWithValues() throws Exception {   insert().into("A").value("col_a",42).perform(mDb)    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    verify(mDb).insert(eq("A"),isNull(String.class),contentValuesArgument.capture())    assertThat(contentValuesArgument.getValue()).contains(entry("col_a",42))  } 
@Test(expected=RuntimeException.class) public void shouldCrashIfPerformOrThrowFailsForInsertWithResultOf() throws Exception {   when(mStatement.executeInsert()).thenReturn(-1L)    Query query=select().allColumns().from("B").build()    insert().into("A").columns("c").resultOf(query).performOrThrow(mDb)  } 
@Test public void shouldReturnInsertedIdIfEverythingGoesFine() throws Exception {   when(mStatement.executeInsert()).thenReturn(5L)    Query query=select().allColumns().from("B").build()    long result=insert().into("A").columns("c").resultOf(query).performOrThrow(mDb)    assertThat(result).isEqualTo(5L)  } 
@Test public void shouldUseInsertOrThrowWithinPerformOfThrowOfCommonInsert() throws Exception {   ContentValues contentValues=new ContentValues()    contentValues.put("col_a",42)    insert().into("A").values(contentValues).performOrThrow(mDb)    verify(mDb).insertOrThrow(eq("A"),isNull(String.class),eq(contentValues))  } 
@Test public void shouldReturnSameResultAsInsertOrThrowForCommonInsert() throws Exception {   when(mDb.insertOrThrow(anyString(),anyString(),any(ContentValues.class))).thenReturn(10L)    long res=insert().into("A").value("col_a",42).performOrThrow(mDb)    assertThat(res).isEqualTo(10L)  } 
@Test public void shouldUseInsertOrThrowWithinPerformOfThrowOfDefaultValuesInsert() throws Exception {   insert().into("A").defaultValues("nullable_col").performOrThrow(mDb)    verify(mDb).insertOrThrow(eq("A"),eq("nullable_col"),isNull(ContentValues.class))  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldBuildTheSimpleSelect() throws Exception {   select().allColumns().from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildTheSimpleDistinctSelect() throws Exception {   Query.select().distinct().allColumns().from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT DISTINCT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildTheUnionCompoundQuery() throws Exception {   select().allColumns().from("table_a").union().select().allColumns().from("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheUnionCompoundQueryWithDistinctSelect() throws Exception {   select().allColumns().from("table_a").union().select().distinct().allColumns().from("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION SELECT DISTINCT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheUnionAllCompoundQuery() throws Exception {   select().allColumns().from("table_a").union().all().select().allColumns().from("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a UNION ALL SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheExceptCompoundQuery() throws Exception {   select().allColumns().from("table_a").except().select().allColumns().from("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a EXCEPT SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheIntersectCompoundQuery() throws Exception {   select().allColumns().from("table_a").intersect().select().allColumns().from("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a INTERSECT SELECT * FROM table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithSelection() throws Exception {   select().allColumns().from("table_a").where("column=?",0).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (column=?)"),eq(new String[]{"0"}))  } 
@Test public void shouldBuildTheQueryWithMultipleSelections() throws Exception {   select().allColumns().from("table_a").where("column=?",0).where("other_column=?",1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (column=?) AND (other_column=?)"),eq(new String[]{"0","1"}))  } 
@Test public void shouldBuildTheQueryWithLeftJoin() throws Exception {   select().allColumns().from("table_a").left().join("table_b").on("column_a=?",0).where("column_b=?",1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a LEFT JOIN table_b ON (column_a=?) WHERE (column_b=?)"),eq(new String[]{"0","1"}))  } 
@Test public void shouldBuildTheQueryWithCrossJoin() throws Exception {   select().allColumns().from("table_a").cross().join("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a CROSS JOIN table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithNaturalJoin() throws Exception {   select().allColumns().from("table_a").natural().join("table_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a NATURAL JOIN table_b"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithAliasedJoin() throws Exception {   select().allColumns().from("table_a").join("table_b").as("b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b AS b"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryJoinedWithSubquery() throws Exception {   select().allColumns().from("table_a").join(select().allColumns().from("table_b").build()).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN (SELECT * FROM table_b)"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithMultipleInnerJoins() throws Exception {   select().from("table_a").join("table_b").join("table_c").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b JOIN table_c"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithMultipleJoins() throws Exception {   select().from("table_a").join("table_b").left().join("table_c").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b LEFT JOIN table_c"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryFromSubquery() throws Exception {   select().allColumns().from(select().allColumns().from("table_a").build()).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM (SELECT * FROM table_a)"),eq(new String[0]))  } 
@Test public void shouldBuildTheQueryWithJoinUsingColumnList() throws Exception {   select().allColumns().from("table_a").join("table_b").using("col_b","col_c").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b USING (col_b, col_c)"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithSingleColumnProjection() throws Exception {   select().column("a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithAliasedColumnProjection() throws Exception {   select().column("a").as("aaa").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT a AS aaa FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithAliasedColumnListProjection() throws Exception {   select().columns("a","b","c").of("table_a").asColumnNames().from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.a AS a, table_a.b AS b, table_a.c AS c FROM table_a"),eq(new String[0]))  } 
@Test public void shouldConcatenateProjections() throws Exception {   select().column("a").column("b").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT a, b FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryForAllColumnsFromSpecifiedTable() throws Exception {   select().allColumns().of("table_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.* FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithAliasedTable() throws Exception {   select().from("table_a").as("a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a AS a"),eq(new String[0]))  } 
@Test public void shouldAcceptEmptyProjection() throws Exception {   select().column("a").columns().from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldAcceptNullProjection() throws Exception {   select().columns((String[])null).from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldSelectAllColumnsWhenProjectionIsNotSpecified() throws Exception {   select().from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldAcceptNullSelection() throws Exception {   select().from("table_a").where((String)null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldAcceptNullExpressionSelection() throws Exception {   select().from("table_a").where((Expression)null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldAcceptNullSortOrder() throws Exception {   select().from("table_a").orderBy((String)null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithNumericLimit() throws Exception {   select().from("table_a").limit(1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a LIMIT 1"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionLimit() throws Exception {   select().from("table_a").limit("1+1").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a LIMIT 1+1"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithNumericLimitOffset() throws Exception {   select().from("table_a").limit(1).offset(1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a LIMIT 1 OFFSET 1"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionLimitOffset() throws Exception {   select().from("table_a").limit(1).offset("1+1").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a LIMIT 1 OFFSET 1+1"),eq(new String[0]))  } 
@Test(expected=IllegalStateException.class) public void shouldAllowSettingTheLimitOnlyOnce() throws Exception {   select().from("table_a").limit(1).limit(1)  } 
@Test public void shouldBuildQueryWithoutAnyTables() throws Exception {   select().column("1500").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT 1500"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithGroupByClause() throws Exception {   select().from("table_a").groupBy("col_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithMultipleGroupByClauses() throws Exception {   select().from("table_a").groupBy("col_a").groupBy("col_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a, col_b"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithGroupByAndHavingClause() throws Exception {   select().from("table_a").groupBy("col_a").having("col_b=?",1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_b=?)"),eq(new String[]{"1"}))  } 
@Test public void shouldBuildQueryWithGroupByAndMultipleHavingClauses() throws Exception {   select().from("table_a").groupBy("col_a").having("col_b=?",1).having("col_c=?",2).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_b=?) AND (col_c=?)"),eq(new String[]{"1","2"}))  } 
@Test public void shouldIgnoreNullLimit() throws Exception {   select().from("table_a").limit(null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test(expected=IllegalStateException.class) public void shouldNotAllowSettingValidNumericalOffsetAfterNullLimit() throws Exception {   select().from("table_a").limit(null).offset(1)  } 
@Test(expected=IllegalStateException.class) public void shouldNotAllowSettingValidExpressionOffsetAfterNullLimit() throws Exception {   select().from("table_a").limit(null).offset("1+1")  } 
@Test(expected=IllegalStateException.class) public void shouldNotAllowHavingClauseWithoutGroupByClause() throws Exception {   select().from("table_a").having("col_a=?",1).build().perform(mDb)  } 
@Test public void shouldBuildQueryWithOrderByWithoutSpecifiedSorting() throws Exception {   select().from("table_a").orderBy("col_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithOrderByWithAscSort() throws Exception {   select().from("table_a").orderBy("col_a").asc().build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a ASC"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithOrderByWithDescSort() throws Exception {   select().from("table_a").orderBy("col_a").desc().build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a DESC"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithMultipleOrderByClauses() throws Exception {   select().from("table_a").orderBy("col_a").orderBy("col_b").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a, col_b"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithOrderByWithSpecifiedCollation() throws Exception {   select().from("table_a").orderBy("col_a").collate("NOCASE").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a COLLATE NOCASE"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithOrderByWithSpecifiedCollationUsingCollatingSequence() throws Exception {   select().from("table_a").orderBy("col_a").collate(CollatingSequence.NOCASE).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a COLLATE NOCASE"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInProjection() throws Exception {   select().expr(column("col_a")).from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT col_a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInOrderBy() throws Exception {   select().from("table_a").orderBy(column("col_a")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInSelection() throws Exception {   select().from("table_a").where(column("col_a").is().not().nul()).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (col_a IS NOT NULL)"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInJoinConstraint() throws Exception {   select().from("table_a").join("table_b").on(column("table_a","id").eq().column("table_b","id_a")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (table_a.id == table_b.id_a)"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInGroupByClause() throws Exception {   select().from("table_a").groupBy(column("col_a")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithExpressionInHavingClause() throws Exception {   select().from("table_a").groupBy("col_a").having(sum(column("col_b")).gt().literal(0)).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (SUM(col_b) > 0)"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithMultipleColumnsFromSingleTable() throws Exception {   select().columns("col_a","col_b","col_c").of("table_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a, table_a.col_b, table_a.col_c FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithProjectionContainingNullBuildByConvenienceMethod() throws Exception {   select().nul().as("col_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT NULL AS col_a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithProjectionContainingNumericLiteralBuildByConvenienceMethod() throws Exception {   select().literal(1500).as("col_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT 1500 AS col_a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithProjectionContainingObjectLiteralBuildByConvenienceMethod() throws Exception {   select().literal("test").as("col_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT 'test' AS col_a FROM table_a"),eq(new String[0]))  } 
@Test public void shouldBuildQueryWithProjectionContainingFullyQualifiedTableBuildByConvenienceMethod() throws Exception {   select().column("table_a","col_a").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a"),eq(new String[0]))  } 
private QueryBuilder buildComplexQuery(){   return select().column("table_a","col_a").from("table_a").left().join("table_b").as("b").on("b.id > ?",1).groupBy(column("b","id")).having(column("col_a").lt().arg(),2).limit(10).offset(20).orderBy(column("table_a","col_a")).except().select().distinct().column("col_a").from("table_a").where(column("col_a").eq().literal(-1))  } 
@Test public void shouldCopyQuery() throws Exception {   Query originalQuery=buildComplexQuery().build()    originalQuery.perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))    QueryBuilder copy=originalQuery.buildUpon()    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))  } 
@Test public void shouldNotChangeOriginalQueryWhenChangingACopy() throws Exception {   Query originalQuery=buildComplexQuery().build()    originalQuery.perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))    QueryBuilder copy=originalQuery.buildUpon()    copy.where(column("a").is().not().nul())    copy.build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) AND (a IS NOT NULL) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))    originalQuery.perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))  } 
@Test public void shouldNotChangeACopyWhenChangingTheOriginalQuery() throws Exception {   QueryBuilder originalQueryBuilder=buildComplexQuery()    Query originalQuery=originalQueryBuilder.build()    originalQuery.perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))    QueryBuilder copy=originalQuery.buildUpon()    originalQueryBuilder.where(column("a").is().not().nul())    originalQueryBuilder.build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) AND (a IS NOT NULL) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT table_a.col_a FROM table_a LEFT JOIN table_b AS b ON (b.id > ?) GROUP BY b.id HAVING (col_a < ?) EXCEPT SELECT DISTINCT col_a FROM table_a WHERE (col_a == -1) ORDER BY table_a.col_a LIMIT 10 OFFSET 20"),eq(new String[]{"1","2"}))  } 
@Test public void shouldCopyTheQueryWithIncompleteJoinStatement() throws Exception {   Query originalQuery=select().from("table_a").join("table_b").build()    QueryBuilder copy=originalQuery.buildUpon()    originalQuery.perform(mDb)    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT * FROM table_a JOIN table_b"),eq(new String[0]))  } 
@Test public void shouldCopyTheQueryWithMultipleJoinStatements() throws Exception {   Query originalQuery=select().from("table_a").join("table_b").join("table_c").build()    QueryBuilder copy=originalQuery.buildUpon()    originalQuery.perform(mDb)    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT * FROM table_a JOIN table_b JOIN table_c"),eq(new String[0]))  } 
@Test public void shouldOverrideSelectDistinctWithLaterCallToSelectAll() throws Exception {   select().distinct().from("table_a").all().build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldCopyTheQueryWithJoinStatementWithConstraint() throws Exception {   Query originalQuery=select().from("table_a").join("table_b").on(column("id").eq().column("id_a")).build()    QueryBuilder copy=originalQuery.buildUpon()    originalQuery.perform(mDb)    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (id == id_a)"),eq(new String[0]))  } 
@Test public void shouldCopyTheQueryWithJoinStatementWithUsingClause() throws Exception {   Query originalQuery=select().from("table_a").left().join("table_b").using("id").build()    QueryBuilder copy=originalQuery.buildUpon()    originalQuery.perform(mDb)    copy.build().perform(mDb)    verify(mDb,times(2)).rawQuery(eq("SELECT * FROM table_a LEFT JOIN table_b USING (id)"),eq(new String[0]))  } 
@Test public void shouldGetListOfTablesForSimpleQuery() throws Exception {   Set<String> tables=select().from("table_a").getTables()    assertThat(tables).containsExactly("table_a")  } 
@Test public void shouldGetListOfTablesFromSubqueries() throws Exception {   Set<String> tables=select().from(select().from("table_a").build()).getTables()    assertThat(tables).containsExactly("table_a")  } 
@Test public void shouldGetListOfTablesFromJoins() throws Exception {   Set<String> tables=select().from("table_a").join("table_b").getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetListOfTablesFromMultipleJoins() throws Exception {   Set<String> tables=select().from("table_a").join("table_b").join("table_c").getTables()    assertThat(tables).containsExactly("table_a","table_b","table_c")  } 
@Test public void shouldGetListOfTablesFromJoinedSubqueries() throws Exception {   Set<String> tables=select().from("table_a").join(select().from("table_b").build()).getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetListOfTablesForCompoundQuery() throws Exception {   Set<String> tables=select().from("table_a").union().select().from("table_b").getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetTablesFromInExpressionInSelection() throws Exception {   Set<String> tables=select().from("table_a").where(column("col_a").in(select().column("id_a").from("table_b").build())).getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetTablesFromInExpressionInHavingClause() throws Exception {   Set<String> tables=select().from("table_a").groupBy("col_b").having(column("col_a").in(select().column("id_a").from("table_b").build())).getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetTablesFromInExpressionInProjection() throws Exception {   Set<String> tables=select().expr(column("col_a").in(select().column("id_a").from("table_b").build())).from("table_a").getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetTablesFromInExpressionInOrderBy() throws Exception {   Set<String> tables=select().from("table_a").orderBy(column("col_a").in(select().column("id_a").from("table_b").build())).getTables()    assertThat(tables).containsExactly("table_a","table_b")  } 
@Test public void shouldGetTablesFromInExpressionInJoinConstraints() throws Exception {   Set<String> tables=select().from("table_a").join("table_b").on(column("table_b","col_a").in(select().column("id_a").from("table_c").build())).getTables()    assertThat(tables).containsExactly("table_a","table_b","table_c")  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectExpressionInProjectionWithUnboundArgsPlaceholders() throws Exception {   select().expr(column("col2").eq().arg())  } 
@Test public void shouldBuildProjectionFromExpressionWithBoundArgs() throws Exception {   select().expr(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT col_a IN (SELECT id FROM table_b WHERE (status=?)) FROM table_a"),eq(new String[]{"new"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooManyArgsPlaceholders() throws Exception {   select().where(column("col2").eq().arg())  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooFewArgsPlaceholders() throws Exception {   select().where(column("col2").eq().arg(),1,2)  } 
@Test public void shouldBuildSelectionFromExpressionWithArgsPlaceholders() throws Exception {   select().from("table_a").where(column("col_a").eq().arg(),"val2").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (col_a == ?)"),eq(new String[]{"val2"}))  } 
@Test public void shouldBuildSelectionFromExpressionWithBoundArgs() throws Exception {   select().from("table_a").where(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (col_a IN (SELECT id FROM table_b WHERE (status=?)))"),eq(new String[]{"new"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectJoinConstraintWithExpressionWithTooManyArgsPlaceholders() throws Exception {   select().from("table_a").join("table_b").on(column("col2").eq().arg())  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectJoinConstraintWithExpressionWithTooFewArgsPlaceholders() throws Exception {   select().from("table_a").join("table_b").on(column("col2").eq().arg(),1,2)  } 
@Test public void shouldBuildJoinConstraintFromExpressionWithArgsPlaceholders() throws Exception {   select().from("table_a").join("table_b").on(column("col_a").eq().arg(),"val2").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (col_a == ?)"),eq(new String[]{"val2"}))  } 
@Test public void shouldBuildJoinConstraintFromExpressionWithBoundArgs() throws Exception {   select().from("table_a").join("table_b").on(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (col_a IN (SELECT id FROM table_b WHERE (status=?)))"),eq(new String[]{"new"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectHavingClauseWithExpressionWithTooManyArgsPlaceholders() throws Exception {   select().from("table_a").groupBy("col_a").having(column("col2").eq().arg())  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectHavingClauseWithExpressionWithTooFewArgsPlaceholders() throws Exception {   select().from("table_a").groupBy("col_a").having(column("col2").eq().arg(),1,2)  } 
@Test public void shouldBuildHavingClauseFromExpressionWithArgsPlaceholders() throws Exception {   select().from("table_a").groupBy("col_a").having(column("col_b").eq().arg(),"val2").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_b == ?)"),eq(new String[]{"val2"}))  } 
@Test public void shouldBuildHavingClauseFromExpressionWithBoundArgs() throws Exception {   select().from("table_a").groupBy("col_a").having(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_a IN (SELECT id FROM table_b WHERE (status=?)))"),eq(new String[]{"new"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectExpressionInGroupByWithUnboundArgsPlaceholders() throws Exception {   select().groupBy(column("col2").eq().arg())  } 
@Test public void shouldBuildGroupByFromExpressionWithBoundArgs() throws Exception {   select().from("table_a").groupBy(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a IN (SELECT id FROM table_b WHERE (status=?))"),eq(new String[]{"new"}))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectExpressionInOrderByWithUnboundArgsPlaceholders() throws Exception {   select().orderBy(column("col2").eq().arg())  } 
@Test public void shouldBuildOrderByFromExpressionWithBoundArgs() throws Exception {   select().from("table_a").orderBy(column("col_a").in(select().column("id").from("table_b").where("status=?","new").build())).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a ORDER BY col_a IN (SELECT id FROM table_b WHERE (status=?))"),eq(new String[]{"new"}))  } 
@Test public void shouldAllowUsingNullArgumentsForSelection() throws Exception {   select().from("table_a").where("col_a IS NULL",(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionWithExpression() throws Exception {   select().from("table_a").where(column("col_a").is().nul(),(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a WHERE (col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForHaving() throws Exception {   select().from("table_a").groupBy("col_a").having("col_b IS NULL",(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_b IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForHavingWithExpression() throws Exception {   select().from("table_a").groupBy("col_a").having(column("col_b").is().nul(),(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a GROUP BY col_a HAVING (col_b IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForJoinConstraint() throws Exception {   select().from("table_a").join("table_b").on("col_b IS NULL",(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (col_b IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForJoinConstraintWithExpression() throws Exception {   select().from("table_a").join("table_b").on(column("col_b").is().nul(),(Object[])null).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN table_b ON (col_b IS NULL)"),eq(new String[0]))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectNullColumnListInJoinUsingClause() throws Exception {   select().from("table_a").join("table_b").using((String[])null).build().perform(mDb)  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectEmptyColumnListInJoinUsingClause() throws Exception {   select().from("table_a").join("table_b").using(new String[0]).build().perform(mDb)  } 
@Test public void shouldPreserveOrderOfSpecifiedColumns() throws Exception {   select().column("a").columns("b","c").column("d").from("table_a").build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT a, b, c, d FROM table_a"),eq(new String[0]))  } 
@SuppressWarnings("ConstantConditions") @Test public void shouldGracefullyHandleNullsInVariousPlaces() throws Exception {   String[] projection=null    String selection=null    String selectionArgs=null    String sortOrder=null    select().columns(projection).from("table_a").where(selection,selectionArgs).orderBy(sortOrder).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a"),eq(new String[0]))  } 
@Test public void shouldNotLoseArgumentsInJoinedSubqueries() throws Exception {   select().allColumns().from("table_a").join(select().column("col_a").from("table_b").where(column("col_b").eq().arg(),"1500")).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT * FROM table_a JOIN (SELECT col_a FROM table_b WHERE (col_b == ?))"),eq(new String[]{"1500"}))  } 
@Test(expected=IllegalStateException.class) public void shouldFailIfNoTablesOrLiteralsWereSpecified() throws Exception {   select().build().perform(mDb)  } 
@Test public void shouldAllowQueryingSimpleLiteral() throws Exception {   select().literal(1).build().perform(mDb)    verify(mDb).rawQuery(eq("SELECT 1"),eq(new String[0]))  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)    when(mDb.compileStatement(anyString())).thenReturn(mStatement)  } 
@Test public void shouldUpdateCorrectTableWhenDoingSimpleUpdate() throws Exception {   update().table("test").value("num",666).where("num=?",0).perform(mDb)    verify(mDb).update(eq("test"),any(ContentValues.class),anyString(),any(String[].class))  } 
@Test public void shouldPassCorrectValuesWhenDoingSimpleUpdate() throws Exception {   update().table("test").value("num",666).where("num=?",0).perform(mDb)    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    verify(mDb).update(anyString(),contentValuesArgument.capture(),anyString(),any(String[].class))    assertThat(contentValuesArgument.getValue()).contains(entry("num",666))  } 
@Test public void shouldUseCorrectSelectionAndArgsWhenDoingSimpleUpdate() throws Exception {   update().table("test").value("num",666).where("num=?",0).perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),eq("(num=?)"),eq(new String[]{"0"}))  } 
@Test public void shouldConcatenateSelectionAndArgs() throws Exception {   update().table("test").value("num",666).where("num=?",0).where("t=?","test").perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),eq("(num=?) AND (t=?)"),eq(new String[]{"0","test"}))  } 
@Test public void shouldBuildSelectionFromExpression() throws Exception {   update().table("test").value("num",666).where(column("num").eq().arg(),0).perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),eq("(num == ?)"),eq(new String[]{"0"}))  } 
@Test public void shouldUseSQLiteStatementWhenColumnExpressionIsUsed() throws Exception {   update().table("test").setColumn("num","666").perform(mDb)    verify(mDb,never()).update(anyString(),any(ContentValues.class),anyString(),any(String[].class))    verify(mDb).compileStatement(anyString())  } 
@Test public void shouldCopyColumnExpressionsDirectlyIntoStatement() throws Exception {   update().table("test").setColumn("num","666").perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET num=(666)"))  } 
@Test public void shouldBuildColumnExpressionsWithSelection() throws Exception {   update().table("test").setColumn("num","666").where("t=?","test").perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET num=(666) WHERE (t=?)"))  } 
@Test public void shouldBuildColumnExpressionsFromExpression() throws Exception {   update().table("test").setColumn("num",Expressions.literal(666)).perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET num=(666)"))  } 
@Test public void shouldPassContentValuesArgsAsBoundArgsWhenCustomColumnExpressionsIsUsed() throws Exception {   update().table("test").setColumn("num","666").value("t","666").perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET num=(666), t=?"))  } 
@Test public void shouldOverrideContentValuesAddedEarlierWithCustomColumnExpressionForTheSameColumn() throws Exception {   update().table("test").value("num","667").value("t","666").setColumn("num","666").perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET num=(666), t=?"))  } 
@Test public void shouldOverrideCustomColumnExpressionAddedEarlierWithContentValuesForTheSameColumn() throws Exception {   update().table("test").setColumn("t","666").setColumn("num","666").value("num","667").perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET t=(666), num=?"))  } 
@Test public void shouldRevertToSimpleUpdateWhenAllCustomColumnExpressionsAreOverridden() throws Exception {   update().table("test").setColumn("num","666").value("num","667").value("t","666").perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),anyString(),any(String[].class))    verify(mDb,never()).compileStatement(anyString())  } 
@Test public void shouldNotModifyPassedContentValues() throws Exception {   ContentValues values=new ContentValues()    update().table("A").values(values).value("key","value")    assertThat(values.containsKey("key")).isFalse()    ContentValues valuesToConcatenate=new ContentValues()    valuesToConcatenate.put("another_key","another_value")    update().table("A").values(values).values(valuesToConcatenate)    assertThat(values.containsKey("another_key")).isFalse()  } 
@Test public void shouldBuildInsertWithConcatenatedContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    ContentValues secondValues=new ContentValues()    secondValues.put("col2","val2")    update().table("A").values(firstValues).values(secondValues).perform(mDb)    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    verify(mDb).update(anyString(),contentValuesArgument.capture(),anyString(),any(String[].class))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2","val2"))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenBySingleValue() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    values.put("col2","val2")    update().table("A").values(values).value("col2",null).perform(mDb)    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    verify(mDb).update(anyString(),contentValuesArgument.capture(),anyString(),any(String[].class))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2",null))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenByOtherContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    firstValues.put("col2","val2")    ContentValues secondValues=new ContentValues()    secondValues.putNull("col2")    secondValues.put("col3","val3")    update().table("A").values(firstValues).values(secondValues).perform(mDb)    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    verify(mDb).update(anyString(),contentValuesArgument.capture(),anyString(),any(String[].class))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col3","val3"),entry("col2",null))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectColumnExpressionWithUnboundArgsPlaceholders() throws Exception {   update().table("A").setColumn("id",arg())  } 
@Test public void shouldUseBoundArgsFromColumnExpressions() throws Exception {   update().table("test").setColumn("col_a",column("col_b").in(select().column("id").from("B").where("status=?","new").build())).perform(mDb)    verify(mDb).compileStatement(eq("UPDATE test SET col_a=(col_b IN (SELECT id FROM B WHERE (status=?)))"))    verify(mStatement).bindString(eq(1),eq("new"))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooManyArgsPlaceholders() throws Exception {   update().table("A").value("col1","val1").where(column("col2").eq().arg())  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectSelectionWithExpressionWithTooFewArgsPlaceholders() throws Exception {   update().table("A").value("col1","val1").where(column("col2").eq().arg(),1,2)  } 
@Test public void shouldBuildSelectionFromExpressionWithArgsPlaceholders() throws Exception {   update().table("A").value("col1","val1").where(column("col2").eq().arg(),"val2").perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),eq("(col2 == ?)"),eq(new String[]{"val2"}))  } 
@Test public void shouldBuildSelectionFromExpressionWithBoundArgs() throws Exception {   update().table("A").value("col1","val1").where(column("col2").in(select().column("id").from("B").where("status=?","new").build())).perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),anyString(),eq(new String[]{"new"}))  } 
@Test public void shouldNotUseBoundArgsFromColumnExpressionsOverriddenByContentValues() throws Exception {   update().table("test").setColumn("col_a",column("col_b").in(select().column("id").from("B").where("status=?","new").build())).value("col_a",666).perform(mDb)    verify(mDb).update(anyString(),any(ContentValues.class),anyString(),eq(new String[0]))  } 
@Test public void shouldOverrideBoundArgsFromColumnExpressionsIfTheExpressionForTheSameColumnIsSpecifiedTwice() throws Exception {   update().table("test").setColumn("col_a",column("col_b").in(select().column("id").from("B").where("status=?","new").build())).setColumn("col_a",column("col_b").in(select().column("id").from("B").where("status=?","old").build())).perform(mDb)    verify(mStatement).bindString(eq(1),eq("old"))  } 
@Test public void shouldOverrideBoundArgsFromColumnExpressionsWithSimpleColumnExpression() throws Exception {   update().table("test").setColumn("col_a",column("col_b").in(select().column("id").from("B").where("status=?","new").build())).setColumn("col_a","666").perform(mDb)    verify(mStatement).executeUpdateDelete()    verify(mStatement).close()    verifyNoMoreInteractions(mStatement)  } 
@Test public void shouldAllowUsingNullArgumentsForSelection() throws Exception {   update().table("table_a").where("col_a IS NULL",(Object[])null).perform(mDb)    verify(mDb).update(eq("table_a"),any(ContentValues.class),eq("(col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionWithExpression() throws Exception {   update().table("table_a").where(column("col_a").is().nul(),(Object[])null).perform(mDb)    verify(mDb).update(eq("table_a"),any(ContentValues.class),eq("(col_a IS NULL)"),eq(new String[0]))  } 
@Test public void shouldAllowUsingNullSelectionWithNullArguments() throws Exception {   update().table("table_a").where((String)null).perform(mDb)  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingNullSelectionWithArguments() throws Exception {   update().table("table_a").where((String)null,"I shall fail").perform(mDb)  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldCreateViewFromProvidedQuery() throws Exception {   ViewActions.create().view("view_a").as(select().from("table_a").build()).perform(db)    Mockito.verify(db).execSQL("CREATE VIEW view_a AS SELECT * FROM table_a")  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingQueryWithBoundArgs() throws Exception {   ViewActions.create().view("view_a").as(select().from("table_a").where(column("col_a").eq().arg(),"test").build())  } 
@Test public void shouldDropSpecifiedView() throws Exception {   ViewActions.dropIfExists().view("view_a").perform(db)    Mockito.verify(db).execSQL("DROP VIEW IF EXISTS view_a")  } 
@Override public String apply(Cursor input){   return BOOM  } 
@Override public String apply(Cursor input){   throw new AssertionError("boom")  } 
@Override public String apply(Cursor cursor){   return cursor.getString(0)  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)    ShadowContentResolver.registerProvider(FAKE_AUTHORITY,providerMock)    cursor=buildCursor()    makeProviderReturn(cursor)    Robolectric.getBackgroundScheduler().pause()  } 
private MatrixCursor buildCursor(){   MatrixCursor cursor=new MatrixCursor(new String[]{"name"})    cursor.addRow(new Object[]{"my_name"})    cursor.addRow(new Object[]{"my_second_name"})    cursor.setNotificationUri(Robolectric.application.getContentResolver(),TEST_URI)    return cursor  } 
private void makeProviderReturn(Cursor cursor){   when(providerMock.query(eq(TEST_URI),(String[])isNull(),(String)isNull(),(String[])isNull(),(String)isNull())).thenReturn(cursor)  } 
@Test public void shouldApplyTransformFunctionInDoInBackground() throws Exception {   final Loader<List<String>> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).build(Robolectric.application)    loader.startLoading()    final Loader.OnLoadCompleteListener<List<String>> listenerMock=mock(Loader.OnLoadCompleteListener.class)    loader.registerListener(0,listenerMock)    Robolectric.getBackgroundScheduler().runOneTask()    verify(listenerMock).onLoadComplete(same(loader),eq(Lists.newArrayList("my_name","my_second_name")))  } 
@Test public void shouldNotCloseJustReturnedCursor() throws Exception {   final Loader<List<String>> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    assertThat(cursor.isClosed()).isFalse()  } 
@Test public void shouldCloseOldCursorIfNewOneAppears() throws Exception {   final Loader<List<String>> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    final MatrixCursor secondCursor=new MatrixCursor(cursor.getColumnNames())    loader.reset()    Robolectric.getBackgroundScheduler().runOneTask()    makeProviderReturn(secondCursor)    assertThat(cursor.isClosed()).isTrue()    assertThat(secondCursor.isClosed()).isFalse()  } 
@Test public void shouldTransformCursorProperly() throws Exception {   final Loader<MyCustomWrapper> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).transform(new Function<List<String>,MyCustomWrapper>(){     @Override public MyCustomWrapper apply(    List<String> strings){       return new MyCustomWrapper(strings)      }   } ).build(Robolectric.application)    loader.startLoading()    final Loader.OnLoadCompleteListener<MyCustomWrapper> listenerMock=mock(Loader.OnLoadCompleteListener.class)    loader.registerListener(0,listenerMock)    Robolectric.getBackgroundScheduler().runOneTask()    verify(listenerMock).onLoadComplete(same(loader),eq(new MyCustomWrapper(Lists.newArrayList("my_name","my_second_name"))))  } 
@Override public MyCustomWrapper apply(List<String> strings){   return new MyCustomWrapper(strings)  } 
@Test public void shouldNotPerformLazyTransformIfNotNecessary() throws Exception {   final Loader<List<String>> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(FAILING_FUNCTION).lazy().build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()  } 
@Ignore @Test public void shouldNotCloseOldCursorInCaseItsSameAsNewOne() throws Exception {   final Loader<MyCustomWrapper> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).transform(new Function<List<String>,MyCustomWrapper>(){     @Override public MyCustomWrapper apply(    List<String> strings){       return new MyCustomWrapper(strings)      }   } ).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    Robolectric.application.getContentResolver().notifyChange(TEST_URI,null)    Robolectric.getBackgroundScheduler().runOneTask()    assertThat(cursor.isClosed()).isFalse()  } 
@Override public MyCustomWrapper apply(List<String> strings){   return new MyCustomWrapper(strings)  } 
private int numberOfOpenedCursors(Cursor... cursors){   int openedCursorsCount=0    for (  Cursor cursor : cursors) {     if (!cursor.isClosed()) {       openedCursorsCount++      }   }   return openedCursorsCount  } 
@Test public void shouldNotCloseOldCursorWhenItsTransformedToTheEqualObjectAsOldOne() throws Exception {   final Loader<MyCustomWrapper> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).transform(new Function<List<String>,MyCustomWrapper>(){     @Override public MyCustomWrapper apply(    List<String> strings){       return new MyCustomWrapper(strings)      }   } ).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    Robolectric.application.getContentResolver().notifyChange(TEST_URI,null)    MatrixCursor nextCursor=buildCursor()    makeProviderReturn(nextCursor)    Robolectric.getBackgroundScheduler().runOneTask()    assertThat(numberOfOpenedCursors(cursor,nextCursor)).isEqualTo(1)  } 
@Override public MyCustomWrapper apply(List<String> strings){   return new MyCustomWrapper(strings)  } 
@Test public void shouldNotCloseOldCursorWhenItsTransformedToTheSameObjectAsOldOne() throws Exception {   final Loader<String> loader=CursorLoaderBuilder.forUri(TEST_URI).transform(CONST_FUNCTION).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    Robolectric.application.getContentResolver().notifyChange(TEST_URI,null)    MatrixCursor nextCursor=buildCursor()    makeProviderReturn(nextCursor)    Robolectric.getBackgroundScheduler().runOneTask()    assertThat(numberOfOpenedCursors(cursor,nextCursor)).isEqualTo(1)  } 
@Test public void shouldCloseOldCursorDeliveredEarlierTwice() throws Exception {   final Loader<MyCustomWrapper> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).transform(new Function<List<String>,MyCustomWrapper>(){     @Override public MyCustomWrapper apply(    List<String> strings){       return new MyCustomWrapper(strings)      }   } ).build(Robolectric.application)    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    loader.startLoading()    Robolectric.getBackgroundScheduler().runOneTask()    loader.reset()    Robolectric.getBackgroundScheduler().runOneTask()    assertThat(cursor.isClosed()).isTrue()  } 
@Override public MyCustomWrapper apply(List<String> strings){   return new MyCustomWrapper(strings)  } 
@Test public void shouldNotDeliverResultIfLoaderHasBeenResetAlready() throws Exception {   final Loader<MyCustomWrapper> loader=CursorLoaderBuilder.forUri(TEST_URI).transformRow(genericToStringFunction).transform(new Function<List<String>,MyCustomWrapper>(){     @Override public MyCustomWrapper apply(    List<String> strings){       return new MyCustomWrapper(strings)      }   } ).build(Robolectric.application)    final Loader.OnLoadCompleteListener<MyCustomWrapper> listenerMock=mock(Loader.OnLoadCompleteListener.class)    loader.registerListener(0,listenerMock)    loader.startLoading()    loader.reset()    Robolectric.getBackgroundScheduler().runTasks(1)    makeProviderReturn(new MatrixCursor(cursor.getColumnNames()))    loader.startLoading()    Robolectric.getBackgroundScheduler().runTasks(1)    verify(listenerMock,times(1)).onLoadComplete(same(loader),eq(new MyCustomWrapper(Lists.<String>newArrayList())))  } 
@Override public MyCustomWrapper apply(List<String> strings){   return new MyCustomWrapper(strings)  } 
private MyCustomWrapper(List<String> strings){   this.strings=strings  } 
@Override public boolean equals(Object o){   if (this == o)   return true    if (o == null || getClass() != o.getClass())   return false    MyCustomWrapper that=(MyCustomWrapper)o    return Objects.equal(strings,that.strings)  } 
@Override public int hashCode(){   return strings != null ? strings.hashCode() : 0  } 
@Test public void shouldAccessProperRow() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{"name"})    for (int i=0  i < 10  i++) {     cursor.addRow(new Object[]{"Name" + i})    }   final LazyCursorList<String> list=new LazyCursorList<String>(cursor,new Function<Cursor,String>(){     @Override public String apply(    Cursor cursor){       return cursor.getString(0)      }   } )    assertThat(list.get(5)).isEqualTo("Name" + 5)  } 
@Override public String apply(Cursor cursor){   return cursor.getString(0)  } 
@Test public void shouldContainProperSize() throws Exception {   final MatrixCursor cursor=new MatrixCursor(new String[]{"name"})    for (int i=0  i < 10  i++) {     cursor.addRow(new Object[]{"Name" + i})    }   final LazyCursorList<String> list=new LazyCursorList<String>(cursor,new Function<Cursor,String>(){     @Override public String apply(    Cursor cursor){       return null      }   } )    assertThat(list.size()).isEqualTo(cursor.getCount())  } 
@Override public String apply(Cursor cursor){   return null  } 
@Test public void shouldSurviveNullCursor() throws Exception {   final LazyCursorList<String> list=new LazyCursorList<String>(null,new Function<Cursor,String>(){     @Override public String apply(    Cursor cursor){       return cursor.getString(0)      }   } )    assertThat(list).isEmpty()  } 
@Override public String apply(Cursor cursor){   return cursor.getString(0)  } 
@Test public void shouldWorkFineWithValueBackReferences() throws Exception {   final Insert firstInsert=ProviderAction.insert(Uri.EMPTY)    final Insert secondInsert=ProviderAction.insert(Uri.EMPTY)    final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(firstInsert).append(secondInsert).append(ProviderAction.insert(Uri.EMPTY)).withValueBackReference(firstInsert,BaseColumns._ID).withValueBackReference(secondInsert,"contact_id").operations()    assertThat(operations).hasSize(3)    final ContentProviderOperation lastOperation=operations.get(2)    ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(lastOperation)    final ContentValues backRefs=shadowOperation.getValuesBackReferences()    assertThat(backRefs.get("_id")).isEqualTo(0)    assertThat(backRefs.get("contact_id")).isEqualTo(1)  } 
@Test public void shouldResolveSelectionBackReferences() throws Exception {   final Insert firstInsert=ProviderAction.insert(Uri.EMPTY)    final Insert secondInsert=ProviderAction.insert(Uri.EMPTY)    final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(firstInsert).append(secondInsert).append(ProviderAction.update(Uri.EMPTY).value("test",1L).where(BaseColumns._ID + "=? AND contact_id=?")).withSelectionBackReference(firstInsert,0).withSelectionBackReference(secondInsert,1).operations()    assertThat(operations).hasSize(3)    final ContentProviderOperation lastOperation=operations.get(2)    ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(lastOperation)    final Map<Integer,Integer> backRefs=shadowOperation.getSelectionArgsBackReferences()    assertThat(backRefs).containsEntry(0,0)    assertThat(backRefs).containsEntry(1,1)  } 
@Test public void shouldGenerateProperListOfContentProviderOperations() throws Exception {   final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(ProviderAction.insert(createFakeUri("first"))).append(ProviderAction.insert(createFakeUri("second"))).append(ProviderAction.update(createFakeUri("third")).value("test",1L)).operations()    assertThat(operations).hasSize(3)    operationAssert(operations.get(0),createFakeUri("first"),ShadowContentProviderOperation.TYPE_INSERT)    operationAssert(operations.get(1),createFakeUri("second"),ShadowContentProviderOperation.TYPE_INSERT)    operationAssert(operations.get(2),createFakeUri("third"),ShadowContentProviderOperation.TYPE_UPDATE)  } 
@Test public void shouldTakeCareAboutContentValuesInBatch() throws Exception {   ContentValues values=new ContentValues()    values.put("test1",1L)    values.put("test2","blah")    final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(ProviderAction.insert(createFakeUri("first")).values(values)).operations()    final ShadowContentProviderOperation contentProviderOperation=Robolectric.shadowOf(operations.get(0))    assertThat(contentProviderOperation.getContentValues()).isEqualTo(values)  } 
@Test public void shouldGenerateEmptyOperations() throws Exception {   assertThat(Batcher.begin().operations()).isEmpty()  } 
@Test public void shouldMapToProperInsertEvenIfTheyHaveIdenticalState() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("only"))    final Insert second=ProviderAction.insert(createFakeUri("only"))    final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(first).append(second).append(ProviderAction.insert(createFakeUri("only"))).withValueBackReference(first,"column").operations()    assertThat(operations).hasSize(3)    final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(Iterables.getLast(operations))    final ContentValues backRefs=shadowOperation.getValuesBackReferences()    assertThat(backRefs.get("column")).isEqualTo(0)  } 
@Test(expected=IllegalStateException.class) public void shouldThrowAnExceptionIfRequestingForPreviousWhenItsDuplicated() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("only"))    Batcher.begin().append(first).append(first).append(ProviderAction.insert(createFakeUri("only"))).withValueBackReference(first,"column").operations()  } 
@Test(expected=IllegalStateException.class) public void shouldThrowAnExceptionInCaseReferencedInsertDoesNotExistInBatcher() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("only"))    Batcher.begin().append(ProviderAction.insert(createFakeUri("only"))).withValueBackReference(first,"column").operations()  } 
@Test(expected=IllegalStateException.class) public void shouldThrowAnExceptionIfPreviousInsertForSelectionBackReferenceIsDuplicated() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("only"))    Batcher.begin().append(first).append(first).append(ProviderAction.delete(createFakeUri("only")).where(BaseColumns._ID + "=?")).withSelectionBackReference(first,0).operations()  } 
@Test(expected=IllegalStateException.class) public void shouldThrowAnExceptionPreviousInsertForSelectionBackReferenceWasNotAddedToBatcher() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("only"))    Batcher.begin().append(ProviderAction.delete(createFakeUri("only")).where(BaseColumns._ID + "=?")).withSelectionBackReference(first,0).operations()  } 
@Test public void shouldResolveValueBackReferencesForAllConvertiblesWithinIterable() throws Exception {   final Insert first=ProviderAction.insert(createFakeUri("fake"))    final Insert second=ProviderAction.insert(createFakeUri("second"))    final int copies=5    final List<ConvertibleToOperation> firstDependants=Collections.<ConvertibleToOperation>nCopies(copies,ProviderAction.insert(createFakeUri("another")))    final List<ConvertibleToOperation> secondDependants=Collections.<ConvertibleToOperation>nCopies(copies,ProviderAction.insert(createFakeUri("yetAnother")))    final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(first).append(second).append(firstDependants).withValueBackReference(first,"parent_id").withValueBackReference(second,"another_parent_id").append(secondDependants).withValueBackReference(second,"parent_id").withValueBackReference(first,"another_parent_id").operations()    assertThat(operations).hasSize(copies * 2 + 2)    for (  ContentProviderOperation contentProviderOperation : operations.subList(2,2 + copies)) {     final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(contentProviderOperation)      final ContentValues refs=shadowOperation.getValuesBackReferences()      assertThat(refs.get("parent_id")).isEqualTo(0)      assertThat(refs.get("another_parent_id")).isEqualTo(1)    }   for (  ContentProviderOperation contentProviderOperation : operations.subList(2 + copies,operations.size())) {     final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(contentProviderOperation)      final ContentValues refs=shadowOperation.getValuesBackReferences()      assertThat(refs.get("parent_id")).isEqualTo(1)      assertThat(refs.get("another_parent_id")).isEqualTo(0)    } } 
@Test(expected=RuntimeException.class) public void shouldThrowRuntimeExceptionIfRemoteExceptionOccurInResolver() throws Exception {   throwAnExceptionInsideResolversApplyBatch(OperationApplicationException.class)  } 
@Test(expected=RuntimeException.class) public void shouldThrowRuntimeExceptionIfOperationApplicationExceptionOccurInResolver() throws Exception {   throwAnExceptionInsideResolversApplyBatch(OperationApplicationException.class)  } 
@Test(expected=SecurityException.class) public void ifExceptionThrownFromApplyBatchIsNotCheckedThenJustThrowItInResolver() throws Exception {   throwAnExceptionInsideResolversApplyBatch(SecurityException.class)  } 
@Test(expected=RuntimeException.class) public void shouldThrowRuntimeExceptionIfRemoteExceptionOccurInProviderClient() throws Exception {   throwAnExceptionInsideClientsApplyBatch(OperationApplicationException.class)  } 
@Test(expected=RuntimeException.class) public void shouldThrowRuntimeExceptionIfOperationApplicationExceptionOccurInProviderClient() throws Exception {   throwAnExceptionInsideClientsApplyBatch(OperationApplicationException.class)  } 
@Test(expected=SecurityException.class) public void ifExceptionThrownFromApplyBatchIsNotCheckedThenJustThrowItInProviderClient() throws Exception {   throwAnExceptionInsideClientsApplyBatch(SecurityException.class)  } 
@Test public void shouldDecorateOperationsUrisIfSpecified() throws Exception {   final ArrayList<ContentProviderOperation> operations=Batcher.begin().append(ProviderAction.insert(createFakeUri("first"))).append(ProviderAction.update(createFakeUri("second")).value("test",1L)).append(ProviderAction.delete(createFakeUri("third"))).decorateUrisWith(new UriDecorator(){     @Override public Uri decorate(    Uri uri){       return Uri.withAppendedPath(uri,"boom")      }   } ).operations()    assertThat(operations).hasSize(3)    operationAssert(operations.get(0),createFakeUri("first","boom"),ShadowContentProviderOperation.TYPE_INSERT)    operationAssert(operations.get(1),createFakeUri("second","boom"),ShadowContentProviderOperation.TYPE_UPDATE)    operationAssert(operations.get(2),createFakeUri("third","boom"),ShadowContentProviderOperation.TYPE_DELETE)  } 
@Override public Uri decorate(Uri uri){   return Uri.withAppendedPath(uri,"boom")  } 
@SuppressWarnings("unchecked") private void throwAnExceptionInsideResolversApplyBatch(Class<? extends Exception> applyBatchException) throws RemoteException, OperationApplicationException {   final ContentResolver resolver=mock(ContentResolver.class)    when(resolver.applyBatch(anyString(),any(ArrayList.class))).thenThrow(applyBatchException)    Batcher.begin().append(ProviderAction.insert(createFakeUri("fake"))).applyBatchOrThrow("com.fakedomain.base",resolver)  } 
@SuppressWarnings("unchecked") private void throwAnExceptionInsideClientsApplyBatch(Class<? extends Exception> applyBatchException) throws RemoteException, OperationApplicationException {   final ContentProviderClient client=mock(ContentProviderClient.class)    when(client.applyBatch(any(ArrayList.class))).thenThrow(applyBatchException)    Batcher.begin().append(ProviderAction.insert(createFakeUri("fake"))).applyBatchOrThrow(client)  } 
private static Uri createFakeUri(String... pathSegments){   Builder builder=Uri.parse("content://com.fakedomain.base").buildUpon()    for (  String path : pathSegments) {     builder.appendPath(path)    }   return builder.build()  } 
private static void operationAssert(ContentProviderOperation operation,Uri uri,int type){   final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(operation)    assertThat(operation.getUri()).isEqualTo(uri)    assertThat(shadowOperation.getType()).isEqualTo(type)  } 
@Test public void shouldConstructInsertOperation() throws Exception {   ContentValues values=new ContentValues()    values.put("key","value")    values.put("second",2L)    final ContentProviderOperation operation=ProviderAction.insert(createFakeUri("endpoint")).values(values).toContentProviderOperation(Utils.DUMMY_URI_DECORATOR)    final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(operation)    assertThat(operation.getUri()).isEqualTo(createFakeUri("endpoint"))    assertThat(shadowOperation.getType()).isEqualTo(ShadowContentProviderOperation.TYPE_INSERT)    assertThat(shadowOperation.getContentValues()).isEqualTo(values)  } 
@Test public void shouldConstructUpdateOperation() throws Exception {   final ContentProviderOperation operation=ProviderAction.update(createFakeUri("endpoint")).value("key","value").where("key=?","hello").toContentProviderOperation(Utils.DUMMY_URI_DECORATOR)    final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(operation)    assertThat(operation.getUri()).isEqualTo(createFakeUri("endpoint"))    assertThat(shadowOperation.getType()).isEqualTo(ShadowContentProviderOperation.TYPE_UPDATE)    assertThat(shadowOperation.getSelection()).isEqualTo("(key=?)")    assertThat(shadowOperation.getSelectionArgs()).isEqualTo(new String[]{"hello"})  } 
@Test public void shouldConstructDeleteOperation() throws Exception {   final ContentProviderOperation operation=ProviderAction.delete(createFakeUri("endpoint")).where("key=?","hello").toContentProviderOperation(Utils.DUMMY_URI_DECORATOR)    final ShadowContentProviderOperation shadowOperation=Robolectric.shadowOf(operation)    assertThat(operation.getUri()).isEqualTo(createFakeUri("endpoint"))    assertThat(shadowOperation.getType()).isEqualTo(ShadowContentProviderOperation.TYPE_DELETE)    assertThat(shadowOperation.getSelection()).isEqualTo("(key=?)")    assertThat(shadowOperation.getSelectionArgs()).isEqualTo(new String[]{"hello"})  } 
private static Uri createFakeUri(String suffix){   return Uri.parse("content://com.fakedomain.base").buildUpon().appendPath(suffix).build()  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldPassNullsEverywhere() throws Exception {   ProviderAction.query(TEST_URI).perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq((String)null),eq((String[])null),eq((String)null))  } 
@Test public void shouldUseProjectionWhenQuery() throws Exception {   ProviderAction.query(TEST_URI).projection("COL1").perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq(new String[]{"COL1"}),eq((String)null),eq((String[])null),eq((String)null))  } 
@Test public void shouldAppendProjection() throws Exception {   ProviderAction.query(TEST_URI).projection("COL1").projection("COL2").perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq(new String[]{"COL1","COL2"}),eq((String)null),eq((String[])null),eq((String)null))  } 
@Test public void shouldConcatenateSelectionProperlyWhenQuerying() throws Exception {   ProviderAction.query(TEST_URI).where("COL1 = ?","arg").where("COL2 = ?","arg2").perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq("(COL1 = ?) AND (COL2 = ?)"),eq(new String[]{"arg","arg2"}),eq((String)null))  } 
@Test public void shouldAddParenthesesForEachWhereWhenQuerying() throws Exception {   ProviderAction.query(TEST_URI).where("COL1 = ? OR COL1 = ?","arg","argh").where("COL2 = ?","arg2").perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq("(COL1 = ? OR COL1 = ?) AND (COL2 = ?)"),eq(new String[]{"arg","argh","arg2"}),eq((String)null))  } 
@Test public void shouldAddParenthesesForEachWhereWhenDeleting() throws Exception {   ProviderAction.delete(TEST_URI).where("COL1 = ? OR COL1 = ?","arg","argh").where("COL2 = ?","arg2").perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),eq("(COL1 = ? OR COL1 = ?) AND (COL2 = ?)"),eq(new String[]{"arg","argh","arg2"}))  } 
@Test public void shouldAddParenthesesForEachWhereWhenUpdating() throws Exception {   ProviderAction.update(TEST_URI).where("COL1 = ? OR COL1 = ?","arg","argh").where("COL2 = ?","arg2").perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),any(ContentValues.class),eq("(COL1 = ? OR COL1 = ?) AND (COL2 = ?)"),eq(new String[]{"arg","argh","arg2"}))  } 
@Test public void shouldUseOrderBy() throws Exception {   ProviderAction.query(TEST_URI).orderBy("COL1 DESC").perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq((String)null),eq((String[])null),eq("COL1 DESC"))  } 
@Test public void shouldPerformProperInsert() throws Exception {   ContentValues values=new ContentValues()    values.put("asdf","value")    ProviderAction.insert(TEST_URI).values(values).perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),eq(values))  } 
@Test public void shouldPerformInsertWithSingleValue() throws Exception {   ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.insert(TEST_URI).value("col1","val1").perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),contentValuesArgument.capture())    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"))  } 
@Test public void insertShouldNotModifyPassedContentValues() throws Exception {   ContentValues values=new ContentValues()    ProviderAction.insert(TEST_URI).values(values).value("key","value").perform(contentResolverMock)    assertThat(values.containsKey("key")).isFalse()    ContentValues valuesToConcatenate=new ContentValues()    valuesToConcatenate.put("another_key","another_value")    ProviderAction.insert(TEST_URI).values(values).values(valuesToConcatenate).perform(contentResolverMock)    assertThat(values.containsKey("another_key")).isFalse()  } 
@Test public void shouldPerformInsertWithConcatenatedContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    ContentValues secondValues=new ContentValues()    secondValues.put("col2","val2")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.insert(TEST_URI).values(firstValues).values(secondValues).perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),contentValuesArgument.capture())    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2","val2"))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenBySingleValue() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    values.put("col2","val2")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.insert(TEST_URI).values(values).value("col2",null).perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),contentValuesArgument.capture())    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2",null))  } 
@Test public void shouldPerformInsertWithContentValuesOverriddenByOtherContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    firstValues.put("col2","val2")    ContentValues secondValues=new ContentValues()    secondValues.putNull("col2")    secondValues.put("col3","val3")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.insert(TEST_URI).values(firstValues).values(secondValues).perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),contentValuesArgument.capture())    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col3","val3"),entry("col2",null))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectInsertWithSingleValueOfUnsupportedType() throws Exception {   ProviderAction.insert(TEST_URI).value("col1",new Object())  } 
@Test public void shouldPerformUpdateWithValues() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    ProviderAction.update(TEST_URI).values(values).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),eq(values),eq((String)null),eq((String[])null))  } 
@Test public void shouldPerformUpdateWithSingleValue() throws Exception {   ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.update(TEST_URI).value("col1","val1").perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),contentValuesArgument.capture(),eq((String)null),eq((String[])null))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"))  } 
@Test public void shouldPerformUpdateWithConcatenatedContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    ContentValues secondValues=new ContentValues()    secondValues.put("col2","val2")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.update(TEST_URI).values(firstValues).values(secondValues).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),contentValuesArgument.capture(),eq((String)null),eq((String[])null))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2","val2"))  } 
@Test public void shouldPerformUpdateWithContentValuesOverriddenBySingleValue() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    values.put("col2","val2")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.update(TEST_URI).values(values).value("col2",null).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),contentValuesArgument.capture(),eq((String)null),eq((String[])null))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col2",null))  } 
@Test public void shouldPerformUpdateWithContentValuesOverriddenByOtherContentValues() throws Exception {   ContentValues firstValues=new ContentValues()    firstValues.put("col1","val1")    firstValues.put("col2","val2")    ContentValues secondValues=new ContentValues()    secondValues.putNull("col2")    secondValues.put("col3","val3")    ArgumentCaptor<ContentValues> contentValuesArgument=ArgumentCaptor.forClass(ContentValues.class)    ProviderAction.update(TEST_URI).values(firstValues).values(secondValues).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),contentValuesArgument.capture(),eq((String)null),eq((String[])null))    assertThat(contentValuesArgument.getValue()).contains(entry("col1","val1"),entry("col3","val3"),entry("col2",null))  } 
@Test(expected=IllegalArgumentException.class) public void shouldRejectUpdateWithSingleValueOfUnsupportedType() throws Exception {   ProviderAction.update(TEST_URI).value("col1",new Object())  } 
@Test public void shouldPerformUpdateWithSelectionAndSelectionArgs() throws Exception {   ContentValues values=new ContentValues()    values.put("col1","val1")    ProviderAction.update(TEST_URI).values(values).where("col2 = ?","blah").perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),eq(values),eq("(col2 = ?)"),eq(new String[]{"blah"}))  } 
@Test public void updateShouldNotModifyPassedContentValues() throws Exception {   ContentValues values=new ContentValues()    ProviderAction.update(TEST_URI).values(values).value("key","value").perform(contentResolverMock)    assertThat(values.containsKey("key")).isFalse()    ContentValues valuesToConcatenate=new ContentValues()    valuesToConcatenate.put("another_key","another_value")    ProviderAction.update(TEST_URI).values(values).values(valuesToConcatenate).perform(contentResolverMock)    assertThat(values.containsKey("another_key")).isFalse()  } 
@Test public void shouldPerformDeleteOnUri() throws Exception {   ProviderAction.delete(TEST_URI).perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),eq((String)null),eq((String[])null))  } 
@Test public void shouldCareAboutSelectionAndSelectionArgsWhenDeleting() throws Exception {   ProviderAction.delete(TEST_URI).where("col1 = ?","val1").perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),eq("(col1 = ?)"),eq(new String[]{"val1"}))  } 
@Test public void shouldBeAbleToUseNonStringObjectsInSelectionArgs() throws Exception {   ProviderAction.query(TEST_URI).where("col1 > ?",18).perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq("(col1 > ?)"),eq(new String[]{"18"}),eq((String)null))  } 
@Test public void shouldBeAbleToCreateASelectionWithWhereIn() throws Exception {   final List<?> inSet=Lists.newArrayList(1L,"two",3L)    ProviderAction.query(TEST_URI).whereIn("col1",inSet).perform(contentResolverMock)    final String expectedSelection="(" + "col1 IN (" + Joiner.on(",").join(Collections2.transform(inSet,Utils.toEscapedSqlFunction())) + ")"+ ")"    verify(contentResolverMock).query(eq(TEST_URI),eq((String[])null),eq(expectedSelection),eq((String[])null),eq((String)null))  } 
@Test public void shouldBeAbleToCreateAnUpdateWithWhereIn() throws Exception {   final List<Object> inSet=Lists.<Object>newArrayList(1L,"two",3L)    ProviderAction.update(TEST_URI).whereIn("col1",inSet).perform(contentResolverMock)    final String expectedSelection="(" + "col1 IN (" + Joiner.on(",").join(Collections2.transform(inSet,Utils.toEscapedSqlFunction())) + ")"+ ")"    verify(contentResolverMock).update(eq(TEST_URI),any(ContentValues.class),eq(expectedSelection),eq((String[])null))  } 
@Test public void shouldBeAbleToCreateADeleteWithWhereIn() throws Exception {   final List<Object> inSet=Lists.<Object>newArrayList(1L,"two",3L)    ProviderAction.delete(TEST_URI).whereIn("col1",inSet).perform(contentResolverMock)    final String expectedSelection="(" + "col1 IN (" + Joiner.on(",").join(Collections2.transform(inSet,Utils.toEscapedSqlFunction())) + ")"+ ")"    verify(contentResolverMock).delete(eq(TEST_URI),eq(expectedSelection),eq((String[])null))  } 
@Test public void shouldAlwaysPassNonNullContentValuesOnInsert() throws Exception {   ProviderAction.insert(TEST_URI).perform(contentResolverMock)    verify(contentResolverMock).insert(eq(TEST_URI),isNotNull(ContentValues.class))  } 
@Test public void shouldAlwaysPassNonNullContentValuesOnUpdate() throws Exception {   ProviderAction.update(TEST_URI).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),isNotNull(ContentValues.class),isNull(String.class),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullSelectionOnQuery() throws Exception {   ProviderAction.query(TEST_URI).where(null).perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),isNull(String[].class),isNull(String.class),isNull(String[].class),isNull(String.class))  } 
@Test public void shouldAllowUsingNullSelectionOnUpdate() throws Exception {   ProviderAction.update(TEST_URI).where(null).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),any(ContentValues.class),isNull(String.class),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullSelectionOnDelete() throws Exception {   ProviderAction.delete(TEST_URI).where(null).perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),isNull(String.class),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionOnQuery() throws Exception {   ProviderAction.query(TEST_URI).where("col1 IS NULL",NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),isNull(String[].class),eq("(col1 IS NULL)"),isNull(String[].class),isNull(String.class))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionOnUpdate() throws Exception {   ProviderAction.update(TEST_URI).where("col1 IS NULL",NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),any(ContentValues.class),eq("(col1 IS NULL)"),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullArgumentsForSelectionOnDelete() throws Exception {   ProviderAction.delete(TEST_URI).where("col1 IS NULL",NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),eq("(col1 IS NULL)"),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullSelectionAndArgumentsOnQuery() throws Exception {   ProviderAction.query(TEST_URI).where(null,NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).query(eq(TEST_URI),isNull(String[].class),isNull(String.class),isNull(String[].class),isNull(String.class))  } 
@Test public void shouldAllowUsingNullSelectionAndArgumentsOnUpdate() throws Exception {   ProviderAction.update(TEST_URI).where(null,NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).update(eq(TEST_URI),any(ContentValues.class),isNull(String.class),isNull(String[].class))  } 
@Test public void shouldAllowUsingNullSelectionAndArgumentsOnDelete() throws Exception {   ProviderAction.delete(TEST_URI).where(null,NULL_ARGS).perform(contentResolverMock)    verify(contentResolverMock).delete(eq(TEST_URI),isNull(String.class),isNull(String[].class))  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingNonNullArgumentsWithNullSelectionOnQuery() throws Exception {   ProviderAction.query(TEST_URI).where(null,"arg1")  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingNonNullArgumentsWithNullSelectionOnUpdate() throws Exception {   ProviderAction.update(TEST_URI).where(null,"arg1")  } 
@Test(expected=IllegalArgumentException.class) public void shouldNotAllowUsingNonNullArgumentsWithNullSelectionOnDelete() throws Exception {   ProviderAction.delete(TEST_URI).where(null,"arg1")  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void shouldBindStringArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,"test")    verify(mStatement).bindString(eq(1),eq("test"))  } 
@Test public void shouldBindByteArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,(byte)42)    verify(mStatement).bindLong(eq(1),eq(42L))  } 
@Test public void shouldBindShortArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,(short)42)    verify(mStatement).bindLong(eq(1),eq(42L))  } 
@Test public void shouldBindIntegerArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,42)    verify(mStatement).bindLong(eq(1),eq(42L))  } 
@Test public void shouldBindLongArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,42L)    verify(mStatement).bindLong(eq(1),eq(42L))  } 
@Test public void shouldBindFloatArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,0.5f)    verify(mStatement).bindDouble(eq(1),eq(0.5d))  } 
@Test public void shouldBindDoubleArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,0.5d)    verify(mStatement).bindDouble(eq(1),eq(0.5d))  } 
@Test public void shouldBindTrueArgAsLongEqual1() throws Exception {   Utils.bindContentValueArg(mStatement,1,true)    verify(mStatement).bindLong(eq(1),eq(1L))  } 
@Test public void shouldBindFalseArgAsLongEqual0() throws Exception {   Utils.bindContentValueArg(mStatement,1,false)    verify(mStatement).bindLong(eq(1),eq(0L))  } 
@Test public void shouldBindNullArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,null)    verify(mStatement).bindNull(eq(1))  } 
@Test public void shouldBindBlobArgs() throws Exception {   Utils.bindContentValueArg(mStatement,1,new byte[42])    verify(mStatement).bindBlob(eq(1),eq(new byte[42]))  } 
@Test(expected=IllegalArgumentException.class) public void shouldFailToBindArgsOfOtherType() throws Exception {   Utils.bindContentValueArg(mStatement,1,new Object())  } 
@Test public void shouldReturnNull() throws Exception {   assertThat(Utils.escapeSqlArg(null)).isNull()  } 
@Test public void shouldReturnSqlBoolean() throws Exception {   assertThat(Utils.escapeSqlArg(true)).isEqualTo(1)  } 
@Test public void shouldReturnNumber() throws Exception {   assertThat(Utils.escapeSqlArg(1L)).isEqualTo(1L)  } 
@Test public void shouldReturnEscapedString() throws Exception {   assertThat(Utils.escapeSqlArg("test")).isEqualTo("'test'")  } 
@Implementation public void executePendingTask(){   new AsyncTask<Void,Void,T>(){     @Override protected T doInBackground(    Void... voids){       return realLoader.loadInBackground()      }     @Override protected void onPostExecute(    T result){       realLoader.deliverResult(result)      }   } .execute()  } 
@Override protected T doInBackground(Void... voids){   return realLoader.loadInBackground()  } 
@Override protected void onPostExecute(T result){   realLoader.deliverResult(result)  } 
public UtilityClassesTest(Class<?> klass){   mKlass=klass  } 
@Parameters(name="{0}") public static Collection<Object[]> data(){   return Arrays.asList(new Object[][]{{Cursors.class},{SingleRowTransforms.class},{Utils.class}})  } 
@Test public void shouldBeWellDefined() throws Exception {   assertThat(mKlass.getSuperclass()).isEqualTo(Object.class)    assertThat(Modifier.isFinal(mKlass.getModifiers())).isTrue()    assertThat(mKlass.getDeclaredConstructors()).hasLength(1)    final Constructor<?> constructor=mKlass.getDeclaredConstructor()    assertThat(constructor.isAccessible()).isFalse()    assertThat(Modifier.isPrivate(constructor.getModifiers())).isTrue()    for (  final Method method : mKlass.getDeclaredMethods()) {     assertThat(Modifier.isStatic(method.getModifiers())).named(method.getName()).isTrue()    } } 
@Override public void onCreate(@Nullable Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setupActionBar()    setContentView(R.layout.directory_chooser_activity)    final DirectoryChooserConfig config=getIntent().getParcelableExtra(EXTRA_CONFIG)    if (config == null) {     throw new IllegalArgumentException("You must provide EXTRA_CONFIG when starting the DirectoryChooserActivity.")    }   if (savedInstanceState == null) {     final FragmentManager fragmentManager=getFragmentManager()      final DirectoryChooserFragment fragment=DirectoryChooserFragment.newInstance(config)      fragmentManager.beginTransaction().add(R.id.main,fragment).commit()    } } 
void setupActionBar(){   @SuppressLint("AppCompatMethod") final ActionBar actionBar=getActionBar()    if (actionBar != null) {     actionBar.setDisplayHomeAsUpEnabled(true)    } } 
@Override public boolean onOptionsItemSelected(MenuItem item){   final int itemId=item.getItemId()    if (itemId == android.R.id.home) {     setResult(RESULT_CANCELED)      finish()      return true    }   return super.onOptionsItemSelected(item)  } 
@Override public void onSelectDirectory(@NonNull String path){   final Intent intent=new Intent()    intent.putExtra(RESULT_SELECTED_DIR,path)    setResult(RESULT_CODE_DIR_SELECTED,intent)    finish()  } 
@Override public void onCancelChooser(){   setResult(RESULT_CANCELED)    finish()  } 
/**   * @return Builder for a new DirectoryChooserConfig.  */ public static Builder builder(){   return new AutoParcel_DirectoryChooserConfig.Builder().initialDirectory("").allowNewDirectoryNameModification(false).allowReadOnlyDirectory(false)  } 
/**   * Name of the directory to create. User can change this name when he creates the folder. To avoid this use  {@link #allowNewDirectoryNameModification} argument.  */ abstract String newDirectoryName()  
/**   * Optional argument to define the path of the directory that will be shown first. If it is not sent or if path denotes a non readable/writable directory or it is not a directory, it defaults to {@link android.os.Environment#getExternalStorageDirectory()}  */ abstract String initialDirectory()  
/**   * Argument to define whether or not the directory chooser allows read-only paths to be chosen. If it false only directories with read-write access can be chosen.  */ abstract boolean allowReadOnlyDirectory()  
/**   * Argument to define whether or not the directory chooser allows modification of provided new directory name.  */ abstract boolean allowNewDirectoryNameModification()  
public abstract Builder newDirectoryName(String s)  
public abstract Builder initialDirectory(String s)  
public abstract Builder allowReadOnlyDirectory(boolean b)  
public abstract Builder allowNewDirectoryNameModification(boolean b)  
public abstract DirectoryChooserConfig build()  
public DirectoryChooserFragment(){ } 
/**   * To create the config, make use of the provided {@link DirectoryChooserConfig#builder()}.  * @return A new instance of DirectoryChooserFragment.  */ public static DirectoryChooserFragment newInstance(@NonNull final DirectoryChooserConfig config){   final DirectoryChooserFragment fragment=new DirectoryChooserFragment()    final Bundle args=new Bundle()    args.putParcelable(ARG_CONFIG,config)    fragment.setArguments(args)    return fragment  } 
@Override public void onSaveInstanceState(@NonNull final Bundle outState){   super.onSaveInstanceState(outState)    if (mSelectedDir != null) {     outState.putString(KEY_CURRENT_DIRECTORY,mSelectedDir.getAbsolutePath())    } } 
@Override public void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    if (getArguments() == null) {     throw new IllegalArgumentException("You must create DirectoryChooserFragment via newInstance().")    }   mConfig=getArguments().getParcelable(ARG_CONFIG)    if (mConfig == null) {     throw new NullPointerException("No ARG_CONFIG provided for DirectoryChooserFragment " + "creation.")    }   mNewDirectoryName=mConfig.newDirectoryName()    mInitialDirectory=mConfig.initialDirectory()    if (savedInstanceState != null) {     mInitialDirectory=savedInstanceState.getString(KEY_CURRENT_DIRECTORY)    }   if (getShowsDialog()) {     setStyle(DialogFragment.STYLE_NO_TITLE,0)    }  else {     setHasOptionsMenu(true)    }   if (!mConfig.allowNewDirectoryNameModification() && TextUtils.isEmpty(mNewDirectoryName)) {     throw new IllegalArgumentException("New directory name must have a strictly positive " + "length (not zero) when user is not allowed to modify it.")    } } 
@Override public View onCreateView(final LayoutInflater inflater,final ViewGroup container,final Bundle savedInstanceState){ } 
private void adjustResourceLightness(){   int color=0xFFFFFF    final Resources.Theme theme=getActivity().getTheme()    if (theme != null) {     final TypedArray backgroundAttributes=theme.obtainStyledAttributes(new int[]{android.R.attr.colorBackground})      if (backgroundAttributes != null) {       color=backgroundAttributes.getColor(0,0xFFFFFF)        backgroundAttributes.recycle()      }   }   if (color != 0xFFFFFF && 0.21 * Color.red(color) + 0.72 * Color.green(color) + 0.07 * Color.blue(color) < 128) {     mBtnNavUp.setImageResource(R.drawable.navigation_up_light)      mBtnCreateFolder.setImageResource(R.drawable.ic_action_create_light)    } } 
@Override public void onAttach(final Activity activity){   super.onAttach(activity)    if (activity instanceof OnFragmentInteractionListener) {     mListener=Option.some((OnFragmentInteractionListener)activity)    }  else {     Fragment owner=getTargetFragment()      if (owner instanceof OnFragmentInteractionListener) {       mListener=Option.some((OnFragmentInteractionListener)owner)      }   } } 
@Override public void onDetach(){   super.onDetach()    mListener=null  } 
@Override public void onPause(){   super.onPause()    if (mFileObserver != null) {     mFileObserver.stopWatching()    } } 
@Override public void onResume(){   super.onResume()    if (mFileObserver != null) {     mFileObserver.startWatching()    } } 
@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){   inflater.inflate(R.menu.directory_chooser,menu)    final MenuItem menuItem=menu.findItem(R.id.new_folder_item)    if (menuItem == null) {     return    }   menuItem.setVisible(isValidFile(mSelectedDir) && mNewDirectoryName != null)  } 
@Override public boolean onOptionsItemSelected(final MenuItem item){   final int itemId=item.getItemId()    if (itemId == R.id.new_folder_item) {     openNewFolderDialog()      return true    }   return super.onOptionsItemSelected(item)  } 
/**   * Shows a confirmation dialog that asks the user if he wants to create a new folder. User can modify provided name, if it was not disallowed.  */ private void openNewFolderDialog(){   @SuppressLint("InflateParams") final View dialogView=getActivity().getLayoutInflater().inflate(R.layout.dialog_new_folder,null)    final TextView msgView=(TextView)dialogView.findViewById(R.id.msgText)    final EditText editText=(EditText)dialogView.findViewById(R.id.editText)    editText.setText(mNewDirectoryName)    msgView.setText(getString(R.string.create_folder_msg,mNewDirectoryName))    final AlertDialog alertDialog=new AlertDialog.Builder(getActivity()).setTitle(R.string.create_folder_label).setView(dialogView).setNegativeButton(R.string.cancel_label,new DialogInterface.OnClickListener(){     @Override public void onClick(    final DialogInterface dialog,    final int which){       dialog.dismiss()      }   } ).setPositiveButton(R.string.confirm_label,new DialogInterface.OnClickListener(){     @Override public void onClick(    final DialogInterface dialog,    final int which){       dialog.dismiss()        mNewDirectoryName=editText.getText().toString()        final int msg=createFolder()        Toast.makeText(getActivity(),msg,Toast.LENGTH_SHORT).show()      }   } ).show()    alertDialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(editText.getText().length() != 0)    editText.addTextChangedListener(new TextWatcher(){     @Override public void beforeTextChanged(    final CharSequence charSequence,    final int i,    final int i2,    final int i3){     }     @Override public void onTextChanged(    final CharSequence charSequence,    final int i,    final int i2,    final int i3){       final boolean textNotEmpty=charSequence.length() != 0        alertDialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(textNotEmpty)        msgView.setText(getString(R.string.create_folder_msg,charSequence.toString()))      }     @Override public void afterTextChanged(    final Editable editable){     }   } )    editText.setVisibility(mConfig.allowNewDirectoryNameModification() ? View.VISIBLE : View.GONE)  } 
@Override public void onClick(final DialogInterface dialog,final int which){   dialog.dismiss()  } 
@Override public void onClick(final DialogInterface dialog,final int which){   dialog.dismiss()    mNewDirectoryName=editText.getText().toString()    final int msg=createFolder()    Toast.makeText(getActivity(),msg,Toast.LENGTH_SHORT).show()  } 
@Override public void beforeTextChanged(final CharSequence charSequence,final int i,final int i2,final int i3){ } 
@Override public void onTextChanged(final CharSequence charSequence,final int i,final int i2,final int i3){   final boolean textNotEmpty=charSequence.length() != 0    alertDialog.getButton(DialogInterface.BUTTON_POSITIVE).setEnabled(textNotEmpty)    msgView.setText(getString(R.string.create_folder_msg,charSequence.toString()))  } 
@Override public void afterTextChanged(final Editable editable){ } 
private static void debug(final String message,final Object... args){   Log.d(TAG,String.format(message,args))  } 
/**   * Change the directory that is currently being displayed.  * @param dir The file the activity should switch to. This File must benon-null and a directory, otherwise the displayed directory will not be changed  */ private void changeDirectory(final File dir){   if (dir == null) {     debug("Could not change folder: dir was null")    }  else   if (!dir.isDirectory()) {     debug("Could not change folder: dir is no directory")    }  else {     final File[] contents=dir.listFiles()      if (contents != null) {       int numDirectories=0        for (      final File f : contents) {         if (f.isDirectory()) {           numDirectories++          }       }       mFilesInDir=new File[numDirectories]        mFilenames.clear()        for (int i=0, counter=0  i < numDirectories  counter++) {         if (contents[counter].isDirectory()) {           mFilesInDir[i]=contents[counter]            mFilenames.add(contents[counter].getName())            i++          }       }       Arrays.sort(mFilesInDir)        Collections.sort(mFilenames)        mSelectedDir=dir        mTxtvSelectedFolder.setText(dir.getAbsolutePath())        mListDirectoriesAdapter.notifyDataSetChanged()        mFileObserver=createFileObserver(dir.getAbsolutePath())        mFileObserver.startWatching()        debug("Changed directory to %s",dir.getAbsolutePath())      }  else {       debug("Could not change folder: contents of dir were null")      }   }   refreshButtonState()  } 
/**   * Changes the state of the buttons depending on the currently selected file or folder.  */ private void refreshButtonState(){   final Activity activity=getActivity()    if (activity != null && mSelectedDir != null) {     mBtnConfirm.setEnabled(isValidFile(mSelectedDir))      getActivity().invalidateOptionsMenu()    } } 
/**   * Refresh the contents of the directory that is currently shown.  */ private void refreshDirectory(){   if (mSelectedDir != null) {     changeDirectory(mSelectedDir)    } } 
/**   * Sets up a FileObserver to watch the current directory.  */ private FileObserver createFileObserver(final String path){   return new FileObserver(path,FileObserver.CREATE | FileObserver.DELETE | FileObserver.MOVED_FROM| FileObserver.MOVED_TO){     @Override public void onEvent(    final int event,    final String path){       debug("FileObserver received event %d",event)        final Activity activity=getActivity()        if (activity != null) {         activity.runOnUiThread(new Runnable(){           @Override public void run(){             refreshDirectory()            }         } )        }     }   }   } 
@Override public void onEvent(final int event,final String path){   debug("FileObserver received event %d",event)    final Activity activity=getActivity()    if (activity != null) {     activity.runOnUiThread(new Runnable(){       @Override public void run(){         refreshDirectory()        }     } )    } } 
@Override public void run(){   refreshDirectory()  } 
/**   * Returns the selected folder as a result to the activity the fragment's attached to. The selected folder can also be null.  */ private void returnSelectedFolder(){   if (mSelectedDir != null) {     debug("Returning %s as result",mSelectedDir.getAbsolutePath())      mListener.foreach(new UnitFunction<OnFragmentInteractionListener>(){       @Override public void apply(      final OnFragmentInteractionListener f){         f.onSelectDirectory(mSelectedDir.getAbsolutePath())        }     } )    }  else {     mListener.foreach(new UnitFunction<OnFragmentInteractionListener>(){       @Override public void apply(      final OnFragmentInteractionListener f){         f.onCancelChooser()        }     } )    } } 
@Override public void apply(final OnFragmentInteractionListener f){   f.onSelectDirectory(mSelectedDir.getAbsolutePath())  } 
@Override public void apply(final OnFragmentInteractionListener f){   f.onCancelChooser()  } 
/**   * Creates a new folder in the current directory with the name CREATE_DIRECTORY_NAME.  */ private int createFolder(){   if (mNewDirectoryName != null && mSelectedDir != null && mSelectedDir.canWrite()) {     final File newDir=new File(mSelectedDir,mNewDirectoryName)      if (newDir.exists()) {       return R.string.create_folder_error_already_exists      }  else {       final boolean result=newDir.mkdir()        if (result) {         return R.string.create_folder_success        }  else {         return R.string.create_folder_error        }     }   }  else   if (mSelectedDir != null && !mSelectedDir.canWrite()) {     return R.string.create_folder_error_no_write_access    }  else {     return R.string.create_folder_error    } } 
/**   * Returns true if the selected file or directory would be valid selection.  */ private boolean isValidFile(final File file){   return (file != null && file.isDirectory() && file.canRead() && (mConfig.allowNewDirectoryNameModification() || file.canWrite()))  } 
@Nullable public OnFragmentInteractionListener getDirectoryChooserListener(){   return mListener.get()  } 
public void setDirectoryChooserListener(@Nullable final OnFragmentInteractionListener listener){   mListener=Option.option(listener)  } 
/**   * Triggered when the user successfully selected their destination directory.  */ void onSelectDirectory(@NonNull String path)  
/**   * Advices the activity to remove the current fragment.  */ void onCancelChooser()  
@Before public void setup(){   activity=Mockito.mock(DirectoryChooserActivity.class)    Mockito.doNothing().when(activity).setupActionBar()    launchIntent=new Intent()    Mockito.doReturn(launchIntent).when(activity).getIntent()  } 
@Test public void testSmokeInit(){   activity.onCreate(null)  } 
@Test public void testSmokeInitWithExtras(){   final DirectoryChooserConfig config=DirectoryChooserConfig.builder().newDirectoryName("my dir").build()    launchIntent.putExtra(DirectoryChooserActivity.EXTRA_CONFIG,config)    activity.onCreate(null)  } 
@TargetApi(Build.VERSION_CODES.HONEYCOMB) public static void startFragment(@NonNull final Fragment fragment,@Nullable Class activityClass){   final Activity activity=(Activity)Robolectric.buildActivity(activityClass == null ? Activity.class : activityClass).create().start().resume().get()    final FragmentManager fragmentManager=activity.getFragmentManager()    final FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction()    fragmentTransaction.add(R.id.main,fragment)    fragmentTransaction.commit()    fragmentManager.executePendingTransactions()  } 
@TargetApi(Build.VERSION_CODES.HONEYCOMB) @Test public void testWithDirectory(){   final DirectoryChooserFragment fragment=DirectoryChooserFragment.newInstance(DirectoryChooserConfig.builder().newDirectoryName("mydir").build())    startFragment(fragment,DirectoryChooserActivityMock.class)    final View chooseBtn=fragment.getActivity().findViewById(R.id.btnConfirm)    assertThat(chooseBtn).isEnabled()    assertThat(chooseBtn.performClick()).isTrue()    assertThat(((DirectoryChooserActivityMock)fragment.getActivity()).selectedDirectory).isNotNull()  } 
@Test public void testCreateDirectoryDialogAllowFolderNameModification(){   final String directoryName="mydir"    final DirectoryChooserFragment fragment=DirectoryChooserFragment.newInstance(DirectoryChooserConfig.builder().newDirectoryName(directoryName).initialDirectory("").allowReadOnlyDirectory(false).allowNewDirectoryNameModification(true).build())    startFragment(fragment,DirectoryChooserActivityMock.class)    fragment.onOptionsItemSelected(new TestMenuItem(){     @Override public int getItemId(){       return R.id.new_folder_item      }   } )    final AlertDialog dialog=(AlertDialog)ShadowDialog.getLatestDialog()    final ShadowAlertDialog shadowAlertDialog=Shadows.shadowOf(dialog)    assertThat(shadowAlertDialog.getTitle()).isEqualTo("Create folder")    assertThat(ShadowDialog.getShownDialogs()).contains(dialog)    final TextView msgView=(TextView)dialog.findViewById(R.id.msgText)    assertThat(msgView).hasText("Create new folder with name \"mydir\"?")    final EditText editText=(EditText)dialog.findViewById(R.id.editText)    assertThat(editText).isVisible()    assertThat(editText).hasTextString(directoryName)  } 
@Override public int getItemId(){   return R.id.new_folder_item  } 
@Test public void testCreateDirectoryDialogDisallowFolderNameModification(){   final String directoryName="mydir"    final DirectoryChooserFragment fragment=DirectoryChooserFragment.newInstance(DirectoryChooserConfig.builder().newDirectoryName(directoryName).initialDirectory("").allowReadOnlyDirectory(false).allowNewDirectoryNameModification(false).build())    startFragment(fragment,DirectoryChooserActivityMock.class)    fragment.onOptionsItemSelected(new TestMenuItem(){     @Override public int getItemId(){       return R.id.new_folder_item      }   } )    final AlertDialog dialog=(AlertDialog)ShadowDialog.getLatestDialog()    final ShadowAlertDialog shadowAlertDialog=Shadows.shadowOf(dialog)    assertThat(shadowAlertDialog.getTitle()).isEqualTo("Create folder")    assertThat(ShadowDialog.getShownDialogs()).contains(dialog)    final TextView msgView=(TextView)dialog.findViewById(R.id.msgText)    assertThat(msgView).hasText("Create new folder with name \"mydir\"?")    final EditText editText=(EditText)dialog.findViewById(R.id.editText)    assertThat(editText).isGone()  } 
@Override public int getItemId(){   return R.id.new_folder_item  } 
@TargetApi(Build.VERSION_CODES.HONEYCOMB) @Test public void testWithCustomListener(){   final DirectoryChooserFragment fragment=DirectoryChooserFragment.newInstance(DirectoryChooserConfig.builder().newDirectoryName("mydir").build())    startFragment(fragment,CustomDirectoryChooserActivity.class)    final CustomDirectoryChooserListener listener=new CustomDirectoryChooserListener()    fragment.setDirectoryChooserListener(listener)    final View chooseBtn=fragment.getActivity().findViewById(R.id.btnConfirm)    assertThat(chooseBtn).isEnabled()    assertThat(chooseBtn.performClick()).isTrue()    assertThat(listener.selectedDirectory).isNotNull()  } 
@Override public void onCreate(@Nullable final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.directory_chooser_activity)  } 
@Override public void onSelectDirectory(@NonNull final String path){   selectedDirectory=path  } 
@Override public void onCancelChooser(){ } 
@Override protected void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.directory_chooser_activity)  } 
@Override public void onSelectDirectory(@NonNull final String path){   selectedDirectory=path  } 
@Override public void onCancelChooser(){   selectedDirectory=null  } 
@Override public int getItemId(){   return 0  } 
@Override public int getGroupId(){   return 0  } 
@Override public int getOrder(){   return 0  } 
@Override public MenuItem setTitle(CharSequence title){   return null  } 
@Override public MenuItem setTitle(int title){   return null  } 
@Override public CharSequence getTitle(){   return null  } 
@Override public MenuItem setTitleCondensed(CharSequence title){   return null  } 
@Override public CharSequence getTitleCondensed(){   return null  } 
@Override public MenuItem setIcon(Drawable icon){   return null  } 
@Override public MenuItem setIcon(int iconRes){   return null  } 
@Override public Drawable getIcon(){   return null  } 
@Override public MenuItem setIntent(Intent intent){   return null  } 
@Override public Intent getIntent(){   return null  } 
@Override public MenuItem setShortcut(char numericChar,char alphaChar){   return null  } 
@Override public MenuItem setNumericShortcut(char numericChar){   return null  } 
@Override public char getNumericShortcut(){   return 0  } 
@Override public MenuItem setAlphabeticShortcut(char alphaChar){   return null  } 
@Override public char getAlphabeticShortcut(){   return 0  } 
@Override public MenuItem setCheckable(boolean checkable){   return null  } 
@Override public boolean isCheckable(){   return false  } 
@Override public MenuItem setChecked(boolean checked){   return null  } 
@Override public boolean isChecked(){   return false  } 
@Override public MenuItem setVisible(boolean visible){   return null  } 
@Override public boolean isVisible(){   return false  } 
@Override public MenuItem setEnabled(boolean enabled){   return null  } 
@Override public boolean isEnabled(){   return false  } 
@Override public boolean hasSubMenu(){   return false  } 
@Override public SubMenu getSubMenu(){   return null  } 
@Override public MenuItem setOnMenuItemClickListener(OnMenuItemClickListener menuItemClickListener){   return null  } 
@Override public ContextMenu.ContextMenuInfo getMenuInfo(){   return null  } 
@Override public void setShowAsAction(int actionEnum){ } 
@Override public MenuItem setShowAsActionFlags(int actionEnum){   return null  } 
@Override public MenuItem setActionView(View view){   return null  } 
@Override public MenuItem setActionView(int resId){   return null  } 
@Override public View getActionView(){   return null  } 
@Override public MenuItem setActionProvider(ActionProvider actionProvider){   return null  } 
@Override public ActionProvider getActionProvider(){   return null  } 
@Override public boolean expandActionView(){   return false  } 
@Override public boolean collapseActionView(){   return false  } 
@Override public boolean isActionViewExpanded(){   return false  } 
@Override public MenuItem setOnActionExpandListener(OnActionExpandListener listener){   return null  } 
@Override protected void onCreate(@Nullable final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.dialog)    final DirectoryChooserConfig config=DirectoryChooserConfig.builder().newDirectoryName("DialogSample").build()    mDialog=DirectoryChooserFragment.newInstance(config)    mDirectoryTextView=(TextView)findViewById(R.id.textDirectory)    findViewById(R.id.btnChoose).setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       mDialog.show(getFragmentManager(),null)      }   } )  } 
@Override public void onClick(View v){   mDialog.show(getFragmentManager(),null)  } 
@Override public void onSelectDirectory(@NonNull final String path){   mDirectoryTextView.setText(path)    mDialog.dismiss()  } 
@Override public void onCancelChooser(){   mDialog.dismiss()  } 
/**   * Called when the activity is first created.  */ @Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.main)    mDirectoryTextView=(TextView)findViewById(R.id.textDirectory)    findViewById(R.id.btnChoose).setOnClickListener(new OnClickListener(){     @Override public void onClick(    View v){       final Intent chooserIntent=new Intent(DirChooserSample.this,DirectoryChooserActivity.class)        final DirectoryChooserConfig config=DirectoryChooserConfig.builder().newDirectoryName("DirChooserSample").allowReadOnlyDirectory(true).allowNewDirectoryNameModification(true).build()        chooserIntent.putExtra(DirectoryChooserActivity.EXTRA_CONFIG,config)        startActivityForResult(chooserIntent,REQUEST_DIRECTORY)      }   } )    findViewById(R.id.btnChange).setOnClickListener(new OnClickListener(){     @Override public void onClick(    View v){       final Intent fragmentSampleIntent=new Intent(DirChooserSample.this,DirChooserFragmentSample.class)        startActivity(fragmentSampleIntent)      }   } )  } 
@Override public void onClick(View v){   final Intent chooserIntent=new Intent(DirChooserSample.this,DirectoryChooserActivity.class)    final DirectoryChooserConfig config=DirectoryChooserConfig.builder().newDirectoryName("DirChooserSample").allowReadOnlyDirectory(true).allowNewDirectoryNameModification(true).build()    chooserIntent.putExtra(DirectoryChooserActivity.EXTRA_CONFIG,config)    startActivityForResult(chooserIntent,REQUEST_DIRECTORY)  } 
@Override public void onClick(View v){   final Intent fragmentSampleIntent=new Intent(DirChooserSample.this,DirChooserFragmentSample.class)    startActivity(fragmentSampleIntent)  } 
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){   super.onActivityResult(requestCode,resultCode,data)    if (requestCode == REQUEST_DIRECTORY) {     Log.i(TAG,String.format("Return from DirChooser with result %d",resultCode))      if (resultCode == DirectoryChooserActivity.RESULT_CODE_DIR_SELECTED) {       mDirectoryTextView.setText(data.getStringExtra(DirectoryChooserActivity.RESULT_SELECTED_DIR))      }  else {       mDirectoryTextView.setText("nothing selected")      }   } } 
/**   * Instantiates a new GPUImage object.  * @param context the context  */ public GPUImage(final Context context){   if (!supportsOpenGLES2(context)) {     throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.")    }   mContext=context    mFilter=new GPUImageFilter()    mRenderer=new GPUImageRenderer(mFilter)  } 
/**   * Checks if OpenGL ES 2.0 is supported on the current device.  * @param context the context  * @return true, if successful  */ private boolean supportsOpenGLES2(final Context context){   final ActivityManager activityManager=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE)    final ConfigurationInfo configurationInfo=activityManager.getDeviceConfigurationInfo()    return configurationInfo.reqGlEsVersion >= 0x20000  } 
/**   * Sets the GLSurfaceView which will display the preview.  * @param view the GLSurfaceView  */ public void setGLSurfaceView(final GLSurfaceView view){   mGlSurfaceView=view    mGlSurfaceView.setEGLContextClientVersion(2)    mGlSurfaceView.setEGLConfigChooser(8,8,8,8,16,0)    mGlSurfaceView.getHolder().setFormat(PixelFormat.RGBA_8888)    mGlSurfaceView.setRenderer(mRenderer)    mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY)    mGlSurfaceView.requestRender()  } 
/**   * Sets the background color  * @param red red color value  * @param green green color value  * @param blue red color value  */ public void setBackgroundColor(float red,float green,float blue){   mRenderer.setBackgroundColor(red,green,blue)  } 
/**   * Request the preview to be rendered again.  */ public void requestRender(){   if (mGlSurfaceView != null) {     mGlSurfaceView.requestRender()    } } 
/**   * Sets the up camera to be connected to GPUImage to get a filtered preview.  * @param camera the camera  */ public void setUpCamera(final Camera camera){   setUpCamera(camera,0,false,false)  } 
/**   * Sets the up camera to be connected to GPUImage to get a filtered preview.  * @param camera the camera  * @param degrees by how many degrees the image should be rotated  * @param flipHorizontal if the image should be flipped horizontally  * @param flipVertical if the image should be flipped vertically  */ public void setUpCamera(final Camera camera,final int degrees,final boolean flipHorizontal,final boolean flipVertical){   mGlSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY)    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1) {     setUpCameraGingerbread(camera)    }  else {     camera.setPreviewCallback(mRenderer)      camera.startPreview()    }   Rotation rotation=Rotation.NORMAL  switch (degrees) { case 90:     rotation=Rotation.ROTATION_90    break  case 180: rotation=Rotation.ROTATION_180  break  case 270: rotation=Rotation.ROTATION_270  break  } mRenderer.setRotationCamera(rotation,flipHorizontal,flipVertical)  } 
@TargetApi(11) private void setUpCameraGingerbread(final Camera camera){   mRenderer.setUpSurfaceTexture(camera)  } 
/**   * Sets the filter which should be applied to the image which was (or will be) set by setImage(...).  * @param filter the new filter  */ public void setFilter(final GPUImageFilter filter){   mFilter=filter    mRenderer.setFilter(mFilter)    requestRender()  } 
/**   * Sets the image on which the filter should be applied.  * @param bitmap the new image  */ public void setImage(final Bitmap bitmap){   mCurrentBitmap=bitmap    mRenderer.setImageBitmap(bitmap,false)    requestRender()  } 
/**   * This sets the scale type of GPUImage. This has to be run before setting the image. If image is set and scale type changed, image needs to be reset.  * @param scaleType The new ScaleType  */ public void setScaleType(ScaleType scaleType){   mScaleType=scaleType    mRenderer.setScaleType(scaleType)    mRenderer.deleteImage()    mCurrentBitmap=null    requestRender()  } 
/**   * Sets the rotation of the displayed image.  * @param rotation new rotation  */ public void setRotation(Rotation rotation){   mRenderer.setRotation(rotation)  } 
/**   * Sets the rotation of the displayed image with flip options.  * @param rotation new rotation  */ public void setRotation(Rotation rotation,boolean flipHorizontal,boolean flipVertical){   mRenderer.setRotation(rotation,flipHorizontal,flipVertical)  } 
/**   * Deletes the current image.  */ public void deleteImage(){   mRenderer.deleteImage()    mCurrentBitmap=null    requestRender()  } 
/**   * Sets the image on which the filter should be applied from a Uri.  * @param uri the uri of the new image  */ public void setImage(final Uri uri){   new LoadImageUriTask(this,uri).execute()  } 
/**   * Sets the image on which the filter should be applied from a File.  * @param file the file of the new image  */ public void setImage(final File file){   new LoadImageFileTask(this,file).execute()  } 
private String getPath(final Uri uri){   String[] projection={MediaStore.Images.Media.DATA}    Cursor cursor=mContext.getContentResolver().query(uri,projection,null,null,null)    int pathIndex=cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)    String path=null    if (cursor.moveToFirst()) {     path=cursor.getString(pathIndex)    }   cursor.close()    return path  } 
/**   * Gets the current displayed image with applied filter as a Bitmap.  * @return the current image with filter applied  */ public Bitmap getBitmapWithFilterApplied(){   return getBitmapWithFilterApplied(mCurrentBitmap)  } 
/**   * Gets the given bitmap with current filter applied as a Bitmap.  * @param bitmap the bitmap on which the current filter should be applied  * @return the bitmap with filter applied  */ public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap){   if (mGlSurfaceView != null) {     mRenderer.deleteImage()      mRenderer.runOnDraw(new Runnable(){       @Override public void run(){ synchronized (mFilter) {           mFilter.destroy()            mFilter.notify()          }       }     } )  synchronized (mFilter) {       requestRender()        try {         mFilter.wait()        }  catch (      InterruptedException e) {         e.printStackTrace()        }     }   }   GPUImageRenderer renderer=new GPUImageRenderer(mFilter)    renderer.setRotation(Rotation.NORMAL,mRenderer.isFlippedHorizontally(),mRenderer.isFlippedVertically())    renderer.setScaleType(mScaleType)    PixelBuffer buffer=new PixelBuffer(bitmap.getWidth(),bitmap.getHeight())    buffer.setRenderer(renderer)    renderer.setImageBitmap(bitmap,false)    Bitmap result=buffer.getBitmap()    mFilter.destroy()    renderer.deleteImage()    buffer.destroy()    mRenderer.setFilter(mFilter)    if (mCurrentBitmap != null) {     mRenderer.setImageBitmap(mCurrentBitmap,false)    }   requestRender()    return result  } 
@Override public void run(){ synchronized (mFilter) {     mFilter.destroy()      mFilter.notify()    } } 
/**   * Gets the images for multiple filters on a image. This can be used to quickly get thumbnail images for filters. <br> Whenever a new Bitmap is ready, the listener will be called with the bitmap. The order of the calls to the listener will be the same as the filter order.  * @param bitmap the bitmap on which the filters will be applied  * @param filters the filters which will be applied on the bitmap  * @param listener the listener on which the results will be notified  */ public static void getBitmapForMultipleFilters(final Bitmap bitmap,final List<GPUImageFilter> filters,final ResponseListener<Bitmap> listener){   if (filters.isEmpty()) {     return    }   GPUImageRenderer renderer=new GPUImageRenderer(filters.get(0))    renderer.setImageBitmap(bitmap,false)    PixelBuffer buffer=new PixelBuffer(bitmap.getWidth(),bitmap.getHeight())    buffer.setRenderer(renderer)    for (  GPUImageFilter filter : filters) {     renderer.setFilter(filter)      listener.response(buffer.getBitmap())      filter.destroy()    }   renderer.deleteImage()    buffer.destroy()  } 
/**   * Deprecated: Please use {@link GPUImageView#saveToPictures(String,String,jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}Save current image with applied filter to Pictures. It will be stored on the default Picture folder on the phone below the given folderName and fileName. <br> This method is async and will notify when the image was saved through the listener.  * @param folderName the folder name  * @param fileName the file name  * @param listener the listener  */ @Deprecated public void saveToPictures(final String folderName,final String fileName,final OnPictureSavedListener listener){   saveToPictures(mCurrentBitmap,folderName,fileName,listener)  } 
/**   * Deprecated: Please use {@link GPUImageView#saveToPictures(String,String,jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}Apply and save the given bitmap with applied filter to Pictures. It will be stored on the default Picture folder on the phone below the given folerName and fileName. <br> This method is async and will notify when the image was saved through the listener.  * @param bitmap the bitmap  * @param folderName the folder name  * @param fileName the file name  * @param listener the listener  */ @Deprecated public void saveToPictures(final Bitmap bitmap,final String folderName,final String fileName,final OnPictureSavedListener listener){   new SaveTask(bitmap,folderName,fileName,listener).execute()  } 
/**   * Runs the given Runnable on the OpenGL thread.  * @param runnable The runnable to be run on the OpenGL thread.  */ void runOnGLThread(Runnable runnable){   mRenderer.runOnDrawEnd(runnable)  } 
private int getOutputWidth(){   if (mRenderer != null && mRenderer.getFrameWidth() != 0) {     return mRenderer.getFrameWidth()    }  else   if (mCurrentBitmap != null) {     return mCurrentBitmap.getWidth()    }  else {     WindowManager windowManager=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE)      Display display=windowManager.getDefaultDisplay()      return display.getWidth()    } } 
private int getOutputHeight(){   if (mRenderer != null && mRenderer.getFrameHeight() != 0) {     return mRenderer.getFrameHeight()    }  else   if (mCurrentBitmap != null) {     return mCurrentBitmap.getHeight()    }  else {     WindowManager windowManager=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE)      Display display=windowManager.getDefaultDisplay()      return display.getHeight()    } } 
public SaveTask(final Bitmap bitmap,final String folderName,final String fileName,final OnPictureSavedListener listener){   mBitmap=bitmap    mFolderName=folderName    mFileName=fileName    mListener=listener    mHandler=new Handler()  } 
@Override protected Void doInBackground(final Void... params){   Bitmap result=getBitmapWithFilterApplied(mBitmap)    saveImage(mFolderName,mFileName,result)    return null  } 
private void saveImage(final String folderName,final String fileName,final Bitmap image){   File path=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)    File file=new File(path,folderName + "/" + fileName)    try {     file.getParentFile().mkdirs()      image.compress(CompressFormat.JPEG,80,new FileOutputStream(file))      MediaScannerConnection.scanFile(mContext,new String[]{file.toString()},null,new MediaScannerConnection.OnScanCompletedListener(){       @Override public void onScanCompleted(      final String path,      final Uri uri){         if (mListener != null) {           mHandler.post(new Runnable(){             @Override public void run(){               mListener.onPictureSaved(uri)              }           } )          }       }     } )    }  catch (  FileNotFoundException e) {     e.printStackTrace()    } } 
@Override public void onScanCompleted(final String path,final Uri uri){   if (mListener != null) {     mHandler.post(new Runnable(){       @Override public void run(){         mListener.onPictureSaved(uri)        }     } )    } } 
@Override public void run(){   mListener.onPictureSaved(uri)  } 
void onPictureSaved(Uri uri)  
public LoadImageUriTask(GPUImage gpuImage,Uri uri){   super(gpuImage)    mUri=uri  } 
@Override protected Bitmap decode(BitmapFactory.Options options){   try {     InputStream inputStream      if (mUri.getScheme().startsWith("http") || mUri.getScheme().startsWith("https")) {       inputStream=new URL(mUri.toString()).openStream()      }  else {       inputStream=mContext.getContentResolver().openInputStream(mUri)      }     return BitmapFactory.decodeStream(inputStream,null,options)    }  catch (  Exception e) {     e.printStackTrace()    }   return null  } 
@Override protected int getImageOrientation() throws IOException {   Cursor cursor=mContext.getContentResolver().query(mUri,new String[]{MediaStore.Images.ImageColumns.ORIENTATION},null,null,null)    if (cursor == null || cursor.getCount() != 1) {     return 0    }   cursor.moveToFirst()    int orientation=cursor.getInt(0)    cursor.close()    return orientation  } 
public LoadImageFileTask(GPUImage gpuImage,File file){   super(gpuImage)    mImageFile=file  } 
@Override protected Bitmap decode(BitmapFactory.Options options){   return BitmapFactory.decodeFile(mImageFile.getAbsolutePath(),options)  } 
@Override protected int getImageOrientation() throws IOException {   ExifInterface exif=new ExifInterface(mImageFile.getAbsolutePath())    int orientation=exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,1)  switch (orientation) { case ExifInterface.ORIENTATION_NORMAL:     return 0  case ExifInterface.ORIENTATION_ROTATE_90:   return 90  case ExifInterface.ORIENTATION_ROTATE_180: return 180  case ExifInterface.ORIENTATION_ROTATE_270: return 270  default : return 0  } } 
@SuppressWarnings("deprecation") public LoadImageTask(final GPUImage gpuImage){   mGPUImage=gpuImage  } 
@Override protected Bitmap doInBackground(Void... params){   if (mRenderer != null && mRenderer.getFrameWidth() == 0) {     try { synchronized (mRenderer.mSurfaceChangedWaiter) {         mRenderer.mSurfaceChangedWaiter.wait(3000)        }     }  catch (    InterruptedException e) {       e.printStackTrace()      }   }   mOutputWidth=getOutputWidth()    mOutputHeight=getOutputHeight()    return loadResizedImage()  } 
@Override protected void onPostExecute(Bitmap bitmap){   super.onPostExecute(bitmap)    mGPUImage.deleteImage()    mGPUImage.setImage(bitmap)  } 
protected abstract Bitmap decode(BitmapFactory.Options options)  
private Bitmap loadResizedImage(){   BitmapFactory.Options options=new BitmapFactory.Options()    options.inJustDecodeBounds=true    decode(options)    int scale=1    while (checkSize(options.outWidth / scale > mOutputWidth,options.outHeight / scale > mOutputHeight)) {     scale++    }   scale--    if (scale < 1) {     scale=1    }   options=new BitmapFactory.Options()    options.inSampleSize=scale    options.inPreferredConfig=Bitmap.Config.RGB_565    options.inPurgeable=true    options.inTempStorage=new byte[32 * 1024]    Bitmap bitmap=decode(options)    if (bitmap == null) {     return null    }   bitmap=rotateImage(bitmap)    bitmap=scaleBitmap(bitmap)    return bitmap  } 
private Bitmap scaleBitmap(Bitmap bitmap){   int width=bitmap.getWidth()    int height=bitmap.getHeight()    int[] newSize=getScaleSize(width,height)    Bitmap workBitmap=Bitmap.createScaledBitmap(bitmap,newSize[0],newSize[1],true)    if (workBitmap != bitmap) {     bitmap.recycle()      bitmap=workBitmap      System.gc()    }   if (mScaleType == ScaleType.CENTER_CROP) {     int diffWidth=newSize[0] - mOutputWidth      int diffHeight=newSize[1] - mOutputHeight      workBitmap=Bitmap.createBitmap(bitmap,diffWidth / 2,diffHeight / 2,newSize[0] - diffWidth,newSize[1] - diffHeight)      if (workBitmap != bitmap) {       bitmap.recycle()        bitmap=workBitmap      }   }   return bitmap  } 
/**   * Retrieve the scaling size for the image dependent on the ScaleType.<br> <br> If CROP: sides are same size or bigger than output's sides<br> Else   : sides are same size or smaller than output's sides  */ private int[] getScaleSize(int width,int height){   float newWidth    float newHeight    float withRatio=(float)width / mOutputWidth    float heightRatio=(float)height / mOutputHeight    boolean adjustWidth=mScaleType == ScaleType.CENTER_CROP ? withRatio > heightRatio : withRatio < heightRatio    if (adjustWidth) {     newHeight=mOutputHeight      newWidth=(newHeight / height) * width    }  else {     newWidth=mOutputWidth      newHeight=(newWidth / width) * height    }   return new int[]{Math.round(newWidth),Math.round(newHeight)}  } 
private boolean checkSize(boolean widthBigger,boolean heightBigger){   if (mScaleType == ScaleType.CENTER_CROP) {     return widthBigger && heightBigger    }  else {     return widthBigger || heightBigger    } } 
private Bitmap rotateImage(final Bitmap bitmap){   if (bitmap == null) {     return null    }   Bitmap rotatedBitmap=bitmap    try {     int orientation=getImageOrientation()      if (orientation != 0) {       Matrix matrix=new Matrix()        matrix.postRotate(orientation)        rotatedBitmap=Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,true)        bitmap.recycle()      }   }  catch (  IOException e) {     e.printStackTrace()    }   return rotatedBitmap  } 
protected abstract int getImageOrientation() throws IOException   
void response(T item)  
/**   * Instantiates a new GPUimage3x3ConvolutionFilter with default values, that will look like the original image.   */ public GPUImage3x3ConvolutionFilter(){   this(new float[]{0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f})  } 
/**   * Instantiates a new GPUimage3x3ConvolutionFilter with given convolution kernel.  * @param convolutionKernel the convolution kernel  */ public GPUImage3x3ConvolutionFilter(final float[] convolutionKernel){   super(THREE_X_THREE_TEXTURE_SAMPLING_FRAGMENT_SHADER)    mConvolutionKernel=convolutionKernel  } 
@Override public void onInit(){   super.onInit()    mUniformConvolutionMatrix=GLES20.glGetUniformLocation(getProgram(),"convolutionMatrix")    setConvolutionKernel(mConvolutionKernel)  } 
/**   * Sets the convolution kernel.  * @param convolutionKernel the new convolution kernel  */ public void setConvolutionKernel(final float[] convolutionKernel){   mConvolutionKernel=convolutionKernel    setUniformMatrix3f(mUniformConvolutionMatrix,mConvolutionKernel)  } 
public GPUImage3x3TextureSamplingFilter(){   this(NO_FILTER_VERTEX_SHADER)  } 
public GPUImage3x3TextureSamplingFilter(final String fragmentShader){   super(THREE_X_THREE_TEXTURE_SAMPLING_VERTEX_SHADER,fragmentShader)  } 
@Override public void onInit(){   super.onInit()    mUniformTexelWidthLocation=GLES20.glGetUniformLocation(getProgram(),"texelWidth")    mUniformTexelHeightLocation=GLES20.glGetUniformLocation(getProgram(),"texelHeight")    if (mTexelWidth != 0) {     updateTexelValues()    } } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    if (!mHasOverriddenImageSizeFactor) {     setLineSize(mLineSize)    } } 
public void setTexelWidth(final float texelWidth){   mHasOverriddenImageSizeFactor=true    mTexelWidth=texelWidth    setFloat(mUniformTexelWidthLocation,texelWidth)  } 
public void setTexelHeight(final float texelHeight){   mHasOverriddenImageSizeFactor=true    mTexelHeight=texelHeight    setFloat(mUniformTexelHeightLocation,texelHeight)  } 
public void setLineSize(final float size){   mLineSize=size    mTexelWidth=size / getOutputWidth()    mTexelHeight=size / getOutputHeight()    updateTexelValues()  } 
private void updateTexelValues(){   setFloat(mUniformTexelWidthLocation,mTexelWidth)    setFloat(mUniformTexelHeightLocation,mTexelHeight)  } 
public GPUImageAddBlendFilter(){   super(ADD_BLEND_FRAGMENT_SHADER)  } 
public GPUImageAlphaBlendFilter(){   super(ALPHA_BLEND_FRAGMENT_SHADER)  } 
public GPUImageAlphaBlendFilter(float mix){   super(ALPHA_BLEND_FRAGMENT_SHADER,mix)  } 
public GPUImageBilateralFilter(){   this(8.0f)  } 
public GPUImageBilateralFilter(final float distanceNormalizationFactor){   super(BILATERAL_VERTEX_SHADER,BILATERAL_FRAGMENT_SHADER)    mDistanceNormalizationFactor=distanceNormalizationFactor  } 
@Override public void onInit(){   super.onInit()    mDisFactorLocation=GLES20.glGetUniformLocation(getProgram(),"distanceNormalizationFactor")    mSingleStepOffsetLocation=GLES20.glGetUniformLocation(getProgram(),"singleStepOffset")  } 
@Override public void onInitialized(){   super.onInitialized()    setDistanceNormalizationFactor(mDistanceNormalizationFactor)  } 
public void setDistanceNormalizationFactor(final float newValue){   mDistanceNormalizationFactor=newValue    setFloat(mDisFactorLocation,newValue)  } 
private void setTexelSize(final float w,final float h){   setFloatVec2(mSingleStepOffsetLocation,new float[]{1.0f / w,1.0f / h})  } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    setTexelSize(width,height)  } 
/**   * Construct new BoxBlurFilter with default blur size of 1.0.  */ public GPUImageBoxBlurFilter(){   this(1f)  } 
public GPUImageBoxBlurFilter(float blurSize){   super(VERTEX_SHADER,FRAGMENT_SHADER,VERTEX_SHADER,FRAGMENT_SHADER)    this.blurSize=blurSize  } 
/**   * A scaling for the size of the applied blur, default of 1.0  * @param blurSize  */ public void setBlurSize(float blurSize){   this.blurSize=blurSize    runOnDraw(new Runnable(){     @Override public void run(){       initTexelOffsets()      }   } )  } 
@Override public void run(){   initTexelOffsets()  } 
@Override public float getVerticalTexelOffsetRatio(){   return blurSize  } 
@Override public float getHorizontalTexelOffsetRatio(){   return blurSize  } 
public GPUImageBrightnessFilter(){   this(0.0f)  } 
public GPUImageBrightnessFilter(final float brightness){   super(NO_FILTER_VERTEX_SHADER,BRIGHTNESS_FRAGMENT_SHADER)    mBrightness=brightness  } 
@Override public void onInit(){   super.onInit()    mBrightnessLocation=GLES20.glGetUniformLocation(getProgram(),"brightness")  } 
@Override public void onInitialized(){   super.onInitialized()    setBrightness(mBrightness)  } 
public void setBrightness(final float brightness){   mBrightness=brightness    setFloat(mBrightnessLocation,mBrightness)  } 
public GPUImageBulgeDistortionFilter(){   this(0.25f,0.5f,new PointF(0.5f,0.5f))  } 
public GPUImageBulgeDistortionFilter(float radius,float scale,PointF center){   super(NO_FILTER_VERTEX_SHADER,BULGE_FRAGMENT_SHADER)    mRadius=radius    mScale=scale    mCenter=center  } 
@Override public void onInit(){   super.onInit()    mScaleLocation=GLES20.glGetUniformLocation(getProgram(),"scale")    mRadiusLocation=GLES20.glGetUniformLocation(getProgram(),"radius")    mCenterLocation=GLES20.glGetUniformLocation(getProgram(),"center")    mAspectRatioLocation=GLES20.glGetUniformLocation(getProgram(),"aspectRatio")  } 
@Override public void onInitialized(){   super.onInitialized()    setRadius(mRadius)    setScale(mScale)    setCenter(mCenter)  } 
@Override public void onOutputSizeChanged(int width,int height){   mAspectRatio=(float)height / width    setAspectRatio(mAspectRatio)    super.onOutputSizeChanged(width,height)  } 
private void setAspectRatio(float aspectRatio){   mAspectRatio=aspectRatio    setFloat(mAspectRatioLocation,aspectRatio)  } 
/**   * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25  * @param radius from 0.0 to 1.0, default 0.25  */ public void setRadius(float radius){   mRadius=radius    setFloat(mRadiusLocation,radius)  } 
/**   * The amount of distortion to apply, from -1.0 to 1.0, with a default of 0.5  * @param scale from -1.0 to 1.0, default 0.5  */ public void setScale(float scale){   mScale=scale    setFloat(mScaleLocation,scale)  } 
/**   * The center about which to apply the distortion, with a default of (0.5, 0.5)  * @param center default (0.5, 0.5)  */ public void setCenter(PointF center){   mCenter=center    setPoint(mCenterLocation,center)  } 
public GPUImageCGAColorspaceFilter(){   super(NO_FILTER_VERTEX_SHADER,CGACOLORSPACE_FRAGMENT_SHADER)  } 
public GPUImageChromaKeyBlendFilter(){   super(CHROMA_KEY_BLEND_FRAGMENT_SHADER)  } 
@Override public void onInit(){   super.onInit()    mThresholdSensitivityLocation=GLES20.glGetUniformLocation(getProgram(),"thresholdSensitivity")    mSmoothingLocation=GLES20.glGetUniformLocation(getProgram(),"smoothing")    mColorToReplaceLocation=GLES20.glGetUniformLocation(getProgram(),"colorToReplace")  } 
@Override public void onInitialized(){   super.onInitialized()    setSmoothing(mSmoothing)    setThresholdSensitivity(mThresholdSensitivity)    setColorToReplace(mColorToReplace[0],mColorToReplace[1],mColorToReplace[2])  } 
/**   * The degree of smoothing controls how gradually similar colors are replaced in the image The default value is 0.1  */ public void setSmoothing(final float smoothing){   mSmoothing=smoothing    setFloat(mSmoothingLocation,mSmoothing)  } 
/**   * The threshold sensitivity controls how similar pixels need to be colored to be replaced The default value is 0.3  */ public void setThresholdSensitivity(final float thresholdSensitivity){   mThresholdSensitivity=thresholdSensitivity    setFloat(mThresholdSensitivityLocation,mThresholdSensitivity)  } 
/**   * The color to be replaced is specified using individual red, green, and blue components (normalized to 1.0). The default is green: (0.0, 1.0, 0.0).  * @param redComponent Red component of color to be replaced  * @param greenComponent Green component of color to be replaced  * @param blueComponent Blue component of color to be replaced  */ public void setColorToReplace(float redComponent,float greenComponent,float blueComponent){   mColorToReplace=new float[]{redComponent,greenComponent,blueComponent}    setFloatVec3(mColorToReplaceLocation,mColorToReplace)  } 
public GPUImageColorBalanceFilter(){   super(NO_FILTER_VERTEX_SHADER,GPU_IMAGE_COLOR_BALANCE_FRAGMENT_SHADER)    this.showdows=new float[]{0.0f,0.0f,0.0f}    this.midtones=new float[]{0.0f,0.0f,0.0f}    this.highlights=new float[]{0.0f,0.0f,0.0f}    this.preserveLuminosity=true  } 
@Override public void onInit(){   super.onInit()    mShadowsLocation=GLES20.glGetUniformLocation(getProgram(),"shadowsShift")    mMidtonesLocation=GLES20.glGetUniformLocation(getProgram(),"midtonesShift")    mHighlightsLocation=GLES20.glGetUniformLocation(getProgram(),"highlightsShift")    mPreserveLuminosityLocation=GLES20.glGetUniformLocation(getProgram(),"preserveLuminosity")  } 
@Override public void onInitialized(){   super.onInitialized()    setMidtones(this.midtones)    setShowdows(this.showdows)    setHighlights(this.highlights)    setPreserveLuminosity(this.preserveLuminosity)  } 
public void setShowdows(float[] showdows){   this.showdows=showdows    setFloatVec3(mShadowsLocation,showdows)  } 
public void setMidtones(float[] midtones){   this.midtones=midtones    setFloatVec3(mMidtonesLocation,midtones)  } 
public void setHighlights(float[] highlights){   this.highlights=highlights    setFloatVec3(mHighlightsLocation,highlights)  } 
public void setPreserveLuminosity(boolean preserveLuminosity){   this.preserveLuminosity=preserveLuminosity    setInteger(mPreserveLuminosityLocation,preserveLuminosity ? 1 : 0)  } 
public GPUImageColorBlendFilter(){   super(COLOR_BLEND_FRAGMENT_SHADER)  } 
public GPUImageColorBurnBlendFilter(){   super(COLOR_BURN_BLEND_FRAGMENT_SHADER)  } 
public GPUImageColorDodgeBlendFilter(){   super(COLOR_DODGE_BLEND_FRAGMENT_SHADER)  } 
public GPUImageColorInvertFilter(){   super(NO_FILTER_VERTEX_SHADER,COLOR_INVERT_FRAGMENT_SHADER)  } 
public GPUImageColorMatrixFilter(){   this(1.0f,new float[]{1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f})  } 
public GPUImageColorMatrixFilter(final float intensity,final float[] colorMatrix){   super(NO_FILTER_VERTEX_SHADER,COLOR_MATRIX_FRAGMENT_SHADER)    mIntensity=intensity    mColorMatrix=colorMatrix  } 
@Override public void onInit(){   super.onInit()    mColorMatrixLocation=GLES20.glGetUniformLocation(getProgram(),"colorMatrix")    mIntensityLocation=GLES20.glGetUniformLocation(getProgram(),"intensity")  } 
@Override public void onInitialized(){   super.onInitialized()    setIntensity(mIntensity)    setColorMatrix(mColorMatrix)  } 
public void setIntensity(final float intensity){   mIntensity=intensity    setFloat(mIntensityLocation,intensity)  } 
public void setColorMatrix(final float[] colorMatrix){   mColorMatrix=colorMatrix    setUniformMatrix4f(mColorMatrixLocation,colorMatrix)  } 
public GPUImageContrastFilter(){   this(1.2f)  } 
public GPUImageContrastFilter(float contrast){   super(NO_FILTER_VERTEX_SHADER,CONTRAST_FRAGMENT_SHADER)    mContrast=contrast  } 
@Override public void onInit(){   super.onInit()    mContrastLocation=GLES20.glGetUniformLocation(getProgram(),"contrast")  } 
@Override public void onInitialized(){   super.onInitialized()    setContrast(mContrast)  } 
public void setContrast(final float contrast){   mContrast=contrast    setFloat(mContrastLocation,mContrast)  } 
/**   * Using default values of crossHatchSpacing: 0.03f and lineWidth: 0.003f.  */ public GPUImageCrosshatchFilter(){   this(0.03f,0.003f)  } 
public GPUImageCrosshatchFilter(float crossHatchSpacing,float lineWidth){   super(NO_FILTER_VERTEX_SHADER,CROSSHATCH_FRAGMENT_SHADER)    mCrossHatchSpacing=crossHatchSpacing    mLineWidth=lineWidth  } 
@Override public void onInit(){   super.onInit()    mCrossHatchSpacingLocation=GLES20.glGetUniformLocation(getProgram(),"crossHatchSpacing")    mLineWidthLocation=GLES20.glGetUniformLocation(getProgram(),"lineWidth")  } 
@Override public void onInitialized(){   super.onInitialized()    setCrossHatchSpacing(mCrossHatchSpacing)    setLineWidth(mLineWidth)  } 
/**   * The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.  * @param crossHatchSpacing default 0.03  */ public void setCrossHatchSpacing(final float crossHatchSpacing){   float singlePixelSpacing    if (getOutputWidth() != 0) {     singlePixelSpacing=1.0f / (float)getOutputWidth()    }  else {     singlePixelSpacing=1.0f / 2048.0f    }   if (crossHatchSpacing < singlePixelSpacing) {     mCrossHatchSpacing=singlePixelSpacing    }  else {     mCrossHatchSpacing=crossHatchSpacing    }   setFloat(mCrossHatchSpacingLocation,mCrossHatchSpacing)  } 
/**   * A relative width for the crosshatch lines. The default is 0.003.  * @param lineWidth default 0.003  */ public void setLineWidth(final float lineWidth){   mLineWidth=lineWidth    setFloat(mLineWidthLocation,mLineWidth)  } 
public GPUImageDarkenBlendFilter(){   super(DARKEN_BLEND_FRAGMENT_SHADER)  } 
public GPUImageDifferenceBlendFilter(){   super(DIFFERENCE_BLEND_FRAGMENT_SHADER)  } 
public GPUImageDilationFilter(){   this(1)  } 
/**   * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from the center, are 1, 2, 3, and 4.  * @param radius 1, 2, 3 or 4  */ public GPUImageDilationFilter(int radius){   this(getVertexShader(radius),getFragmentShader(radius))  } 
private GPUImageDilationFilter(String vertexShader,String fragmentShader){   super(vertexShader,fragmentShader,vertexShader,fragmentShader)  } 
private static String getVertexShader(int radius){ switch (radius) { case 0: case 1:     return VERTEX_SHADER_1  case 2:   return VERTEX_SHADER_2  case 3: return VERTEX_SHADER_3  default : return VERTEX_SHADER_4  } } 
private static String getFragmentShader(int radius){ switch (radius) { case 0: case 1:     return FRAGMENT_SHADER_1  case 2:   return FRAGMENT_SHADER_2  case 3: return FRAGMENT_SHADER_3  default : return FRAGMENT_SHADER_4  } } 
public GPUImageDirectionalSobelEdgeDetectionFilter(){   super(DIRECTIONAL_SOBEL_EDGE_DETECTION_FRAGMENT_SHADER)  } 
public GPUImageDissolveBlendFilter(){   super(DISSOLVE_BLEND_FRAGMENT_SHADER)  } 
public GPUImageDissolveBlendFilter(float mix){   super(DISSOLVE_BLEND_FRAGMENT_SHADER,mix)  } 
public GPUImageDivideBlendFilter(){   super(DIVIDE_BLEND_FRAGMENT_SHADER)  } 
public GPUImageEmbossFilter(){   this(1.0f)  } 
public GPUImageEmbossFilter(final float intensity){   super()    mIntensity=intensity  } 
@Override public void onInit(){   super.onInit()    setIntensity(mIntensity)  } 
public void setIntensity(final float intensity){   mIntensity=intensity    setConvolutionKernel(new float[]{intensity * (-2.0f),-intensity,0.0f,-intensity,1.0f,intensity,0.0f,intensity,intensity * 2.0f})  } 
public float getIntensity(){   return mIntensity  } 
public GPUImageExclusionBlendFilter(){   super(EXCLUSION_BLEND_FRAGMENT_SHADER)  } 
public GPUImageExposureFilter(){   this(1.0f)  } 
public GPUImageExposureFilter(final float exposure){   super(NO_FILTER_VERTEX_SHADER,EXPOSURE_FRAGMENT_SHADER)    mExposure=exposure  } 
@Override public void onInit(){   super.onInit()    mExposureLocation=GLES20.glGetUniformLocation(getProgram(),"exposure")  } 
@Override public void onInitialized(){   super.onInitialized()    setExposure(mExposure)  } 
public void setExposure(final float exposure){   mExposure=exposure    setFloat(mExposureLocation,mExposure)  } 
public GPUImageFalseColorFilter(){   this(0f,0f,0.5f,1f,0f,0f)  } 
public GPUImageFalseColorFilter(float firstRed,float firstGreen,float firstBlue,float secondRed,float secondGreen,float secondBlue){   this(new float[]{firstRed,firstGreen,firstBlue},new float[]{secondRed,secondGreen,secondBlue})  } 
public GPUImageFalseColorFilter(float[] firstColor,float[] secondColor){   super(NO_FILTER_VERTEX_SHADER,FALSECOLOR_FRAGMENT_SHADER)    mFirstColor=firstColor    mSecondColor=secondColor  } 
@Override public void onInit(){   super.onInit()    mFirstColorLocation=GLES20.glGetUniformLocation(getProgram(),"firstColor")    mSecondColorLocation=GLES20.glGetUniformLocation(getProgram(),"secondColor")  } 
@Override public void onInitialized(){   super.onInitialized()    setFirstColor(mFirstColor)    setSecondColor(mSecondColor)  } 
public void setFirstColor(final float[] firstColor){   mFirstColor=firstColor    setFloatVec3(mFirstColorLocation,firstColor)  } 
public void setSecondColor(final float[] secondColor){   mSecondColor=secondColor    setFloatVec3(mSecondColorLocation,secondColor)  } 
public GPUImageFilter(){   this(NO_FILTER_VERTEX_SHADER,NO_FILTER_FRAGMENT_SHADER)  } 
public GPUImageFilter(final String vertexShader,final String fragmentShader){   mRunOnDraw=new LinkedList<Runnable>()    mVertexShader=vertexShader    mFragmentShader=fragmentShader  } 
public final void init(){   onInit()    mIsInitialized=true    onInitialized()  } 
public void onInit(){   mGLProgId=OpenGlUtils.loadProgram(mVertexShader,mFragmentShader)    mGLAttribPosition=GLES20.glGetAttribLocation(mGLProgId,"position")    mGLUniformTexture=GLES20.glGetUniformLocation(mGLProgId,"inputImageTexture")    mGLAttribTextureCoordinate=GLES20.glGetAttribLocation(mGLProgId,"inputTextureCoordinate")    mIsInitialized=true  } 
public void onInitialized(){ } 
public final void destroy(){   mIsInitialized=false    GLES20.glDeleteProgram(mGLProgId)    onDestroy()  } 
public void onDestroy(){ } 
public void onOutputSizeChanged(final int width,final int height){   mOutputWidth=width    mOutputHeight=height  } 
public void onDraw(final int textureId,final FloatBuffer cubeBuffer,final FloatBuffer textureBuffer){   GLES20.glUseProgram(mGLProgId)    runPendingOnDrawTasks()    if (!mIsInitialized) {     return    }   cubeBuffer.position(0)    GLES20.glVertexAttribPointer(mGLAttribPosition,2,GLES20.GL_FLOAT,false,0,cubeBuffer)    GLES20.glEnableVertexAttribArray(mGLAttribPosition)    textureBuffer.position(0)    GLES20.glVertexAttribPointer(mGLAttribTextureCoordinate,2,GLES20.GL_FLOAT,false,0,textureBuffer)    GLES20.glEnableVertexAttribArray(mGLAttribTextureCoordinate)    if (textureId != OpenGlUtils.NO_TEXTURE) {     GLES20.glActiveTexture(GLES20.GL_TEXTURE0)      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,textureId)      GLES20.glUniform1i(mGLUniformTexture,0)    }   onDrawArraysPre()    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4)    GLES20.glDisableVertexAttribArray(mGLAttribPosition)    GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate)    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0)  } 
protected void onDrawArraysPre(){ } 
protected void runPendingOnDrawTasks(){   while (!mRunOnDraw.isEmpty()) {     mRunOnDraw.removeFirst().run()    } } 
public boolean isInitialized(){   return mIsInitialized  } 
public int getOutputWidth(){   return mOutputWidth  } 
public int getOutputHeight(){   return mOutputHeight  } 
public int getProgram(){   return mGLProgId  } 
public int getAttribPosition(){   return mGLAttribPosition  } 
public int getAttribTextureCoordinate(){   return mGLAttribTextureCoordinate  } 
public int getUniformTexture(){   return mGLUniformTexture  } 
protected void setInteger(final int location,final int intValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform1i(location,intValue)      }   } )  } 
@Override public void run(){   GLES20.glUniform1i(location,intValue)  } 
protected void setFloat(final int location,final float floatValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform1f(location,floatValue)      }   } )  } 
@Override public void run(){   GLES20.glUniform1f(location,floatValue)  } 
protected void setFloatVec2(final int location,final float[] arrayValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform2fv(location,1,FloatBuffer.wrap(arrayValue))      }   } )  } 
@Override public void run(){   GLES20.glUniform2fv(location,1,FloatBuffer.wrap(arrayValue))  } 
protected void setFloatVec3(final int location,final float[] arrayValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform3fv(location,1,FloatBuffer.wrap(arrayValue))      }   } )  } 
@Override public void run(){   GLES20.glUniform3fv(location,1,FloatBuffer.wrap(arrayValue))  } 
protected void setFloatVec4(final int location,final float[] arrayValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform4fv(location,1,FloatBuffer.wrap(arrayValue))      }   } )  } 
@Override public void run(){   GLES20.glUniform4fv(location,1,FloatBuffer.wrap(arrayValue))  } 
protected void setFloatArray(final int location,final float[] arrayValue){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniform1fv(location,arrayValue.length,FloatBuffer.wrap(arrayValue))      }   } )  } 
@Override public void run(){   GLES20.glUniform1fv(location,arrayValue.length,FloatBuffer.wrap(arrayValue))  } 
protected void setPoint(final int location,final PointF point){   runOnDraw(new Runnable(){     @Override public void run(){       float[] vec2=new float[2]        vec2[0]=point.x        vec2[1]=point.y        GLES20.glUniform2fv(location,1,vec2,0)      }   } )  } 
@Override public void run(){   float[] vec2=new float[2]    vec2[0]=point.x    vec2[1]=point.y    GLES20.glUniform2fv(location,1,vec2,0)  } 
protected void setUniformMatrix3f(final int location,final float[] matrix){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniformMatrix3fv(location,1,false,matrix,0)      }   } )  } 
@Override public void run(){   GLES20.glUniformMatrix3fv(location,1,false,matrix,0)  } 
protected void setUniformMatrix4f(final int location,final float[] matrix){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glUniformMatrix4fv(location,1,false,matrix,0)      }   } )  } 
@Override public void run(){   GLES20.glUniformMatrix4fv(location,1,false,matrix,0)  } 
protected void runOnDraw(final Runnable runnable){ synchronized (mRunOnDraw) {     mRunOnDraw.addLast(runnable)    } } 
public static String loadShader(String file,Context context){   try {     AssetManager assetManager=context.getAssets()      InputStream ims=assetManager.open(file)      String re=convertStreamToString(ims)      ims.close()      return re    }  catch (  Exception e) {     e.printStackTrace()    }   return ""  } 
public static String convertStreamToString(java.io.InputStream is){   java.util.Scanner s=new java.util.Scanner(is).useDelimiter("\\A")    return s.hasNext() ? s.next() : ""  } 
/**   * Instantiates a new GPUImageFilterGroup with no filters.  */ public GPUImageFilterGroup(){   this(null)  } 
/**   * Instantiates a new GPUImageFilterGroup with the given filters.  * @param filters the filters which represent this filter  */ public GPUImageFilterGroup(List<GPUImageFilter> filters){   mFilters=filters    if (mFilters == null) {     mFilters=new ArrayList<GPUImageFilter>()    }  else {     updateMergedFilters()    }   mGLCubeBuffer=ByteBuffer.allocateDirect(CUBE.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()    mGLCubeBuffer.put(CUBE).position(0)    mGLTextureBuffer=ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()    mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0)    float[] flipTexture=TextureRotationUtil.getRotation(Rotation.NORMAL,false,true)    mGLTextureFlipBuffer=ByteBuffer.allocateDirect(flipTexture.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()    mGLTextureFlipBuffer.put(flipTexture).position(0)  } 
public void addFilter(GPUImageFilter aFilter){   if (aFilter == null) {     return    }   mFilters.add(aFilter)    updateMergedFilters()  } 
@Override public void onInit(){   super.onInit()    for (  GPUImageFilter filter : mFilters) {     filter.init()    } } 
@Override public void onDestroy(){   destroyFramebuffers()    for (  GPUImageFilter filter : mFilters) {     filter.destroy()    }   super.onDestroy()  } 
private void destroyFramebuffers(){   if (mFrameBufferTextures != null) {     GLES20.glDeleteTextures(mFrameBufferTextures.length,mFrameBufferTextures,0)      mFrameBufferTextures=null    }   if (mFrameBuffers != null) {     GLES20.glDeleteFramebuffers(mFrameBuffers.length,mFrameBuffers,0)      mFrameBuffers=null    } } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    if (mFrameBuffers != null) {     destroyFramebuffers()    }   int size=mFilters.size()    for (int i=0  i < size  i++) {     mFilters.get(i).onOutputSizeChanged(width,height)    }   if (mMergedFilters != null && mMergedFilters.size() > 0) {     size=mMergedFilters.size()      mFrameBuffers=new int[size - 1]      mFrameBufferTextures=new int[size - 1]      for (int i=0  i < size - 1  i++) {       GLES20.glGenFramebuffers(1,mFrameBuffers,i)        GLES20.glGenTextures(1,mFrameBufferTextures,i)        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mFrameBufferTextures[i])        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,width,height,0,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,null)        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_LINEAR)        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_LINEAR)        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE)        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE)        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,mFrameBuffers[i])        GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D,mFrameBufferTextures[i],0)        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,0)        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0)      }   } } 
@SuppressLint("WrongCall") @Override public void onDraw(final int textureId,final FloatBuffer cubeBuffer,final FloatBuffer textureBuffer){   runPendingOnDrawTasks()    if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {     return    }   if (mMergedFilters != null) {     int size=mMergedFilters.size()      int previousTexture=textureId      for (int i=0  i < size  i++) {       GPUImageFilter filter=mMergedFilters.get(i)        boolean isNotLast=i < size - 1        if (isNotLast) {         GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,mFrameBuffers[i])          GLES20.glClearColor(0,0,0,0)        }       if (i == 0) {         filter.onDraw(previousTexture,cubeBuffer,textureBuffer)        }  else       if (i == size - 1) {         filter.onDraw(previousTexture,mGLCubeBuffer,(size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer)        }  else {         filter.onDraw(previousTexture,mGLCubeBuffer,mGLTextureBuffer)        }       if (isNotLast) {         GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER,0)          previousTexture=mFrameBufferTextures[i]        }     }   } } 
/**   * Gets the filters.  * @return the filters  */ public List<GPUImageFilter> getFilters(){   return mFilters  } 
public List<GPUImageFilter> getMergedFilters(){   return mMergedFilters  } 
public void updateMergedFilters(){   if (mFilters == null) {     return    }   if (mMergedFilters == null) {     mMergedFilters=new ArrayList<GPUImageFilter>()    }  else {     mMergedFilters.clear()    }   List<GPUImageFilter> filters    for (  GPUImageFilter filter : mFilters) {     if (filter instanceof GPUImageFilterGroup) {       ((GPUImageFilterGroup)filter).updateMergedFilters()        filters=((GPUImageFilterGroup)filter).getMergedFilters()        if (filters == null || filters.isEmpty())       continue        mMergedFilters.addAll(filters)        continue      }     mMergedFilters.add(filter)    } } 
public GPUImageGammaFilter(){   this(1.2f)  } 
public GPUImageGammaFilter(final float gamma){   super(NO_FILTER_VERTEX_SHADER,GAMMA_FRAGMENT_SHADER)    mGamma=gamma  } 
@Override public void onInit(){   super.onInit()    mGammaLocation=GLES20.glGetUniformLocation(getProgram(),"gamma")  } 
@Override public void onInitialized(){   super.onInitialized()    setGamma(mGamma)  } 
public void setGamma(final float gamma){   mGamma=gamma    setFloat(mGammaLocation,mGamma)  } 
public GPUImageGaussianBlurFilter(){   this(1f)  } 
public GPUImageGaussianBlurFilter(float blurSize){   super(VERTEX_SHADER,FRAGMENT_SHADER,VERTEX_SHADER,FRAGMENT_SHADER)    mBlurSize=blurSize  } 
@Override public float getVerticalTexelOffsetRatio(){   return mBlurSize  } 
@Override public float getHorizontalTexelOffsetRatio(){   return mBlurSize  } 
/**   * A multiplier for the blur size, ranging from 0.0 on up, with a default of 1.0  * @param blurSize from 0.0 on up, default 1.0  */ public void setBlurSize(float blurSize){   mBlurSize=blurSize    runOnDraw(new Runnable(){     @Override public void run(){       initTexelOffsets()      }   } )  } 
@Override public void run(){   initTexelOffsets()  } 
public GPUImageGlassSphereFilter(){   this(new PointF(0.5f,0.5f),0.25f,0.71f)  } 
public GPUImageGlassSphereFilter(PointF center,float radius,float refractiveIndex){   super(NO_FILTER_VERTEX_SHADER,SPHERE_FRAGMENT_SHADER)    mCenter=center    mRadius=radius    mRefractiveIndex=refractiveIndex  } 
@Override public void onInit(){   super.onInit()    mCenterLocation=GLES20.glGetUniformLocation(getProgram(),"center")    mRadiusLocation=GLES20.glGetUniformLocation(getProgram(),"radius")    mAspectRatioLocation=GLES20.glGetUniformLocation(getProgram(),"aspectRatio")    mRefractiveIndexLocation=GLES20.glGetUniformLocation(getProgram(),"refractiveIndex")  } 
@Override public void onInitialized(){   super.onInitialized()    setRadius(mRadius)    setCenter(mCenter)    setRefractiveIndex(mRefractiveIndex)  } 
@Override public void onOutputSizeChanged(int width,int height){   mAspectRatio=(float)height / width    setAspectRatio(mAspectRatio)    super.onOutputSizeChanged(width,height)  } 
private void setAspectRatio(float aspectRatio){   mAspectRatio=aspectRatio    setFloat(mAspectRatioLocation,aspectRatio)  } 
public void setRefractiveIndex(float refractiveIndex){   mRefractiveIndex=refractiveIndex    setFloat(mRefractiveIndexLocation,refractiveIndex)  } 
public void setCenter(PointF center){   mCenter=center    setPoint(mCenterLocation,center)  } 
public void setRadius(float radius){   mRadius=radius    setFloat(mRadiusLocation,radius)  } 
public GPUImageGrayscaleFilter(){   super(NO_FILTER_VERTEX_SHADER,GRAYSCALE_FRAGMENT_SHADER)  } 
public GPUImageHalftoneFilter(){   this(0.01f)  } 
public GPUImageHalftoneFilter(float fractionalWidthOfAPixel){   super(NO_FILTER_VERTEX_SHADER,HALFTONE_FRAGMENT_SHADER)    mFractionalWidthOfAPixel=fractionalWidthOfAPixel  } 
@Override public void onInit(){   super.onInit()    mFractionalWidthOfPixelLocation=GLES20.glGetUniformLocation(getProgram(),"fractionalWidthOfPixel")    mAspectRatioLocation=GLES20.glGetUniformLocation(getProgram(),"aspectRatio")    setFractionalWidthOfAPixel(mFractionalWidthOfAPixel)  } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    setAspectRatio((float)height / (float)width)  } 
public void setFractionalWidthOfAPixel(final float fractionalWidthOfAPixel){   mFractionalWidthOfAPixel=fractionalWidthOfAPixel    setFloat(mFractionalWidthOfPixelLocation,mFractionalWidthOfAPixel)  } 
public void setAspectRatio(final float aspectRatio){   mAspectRatio=aspectRatio    setFloat(mAspectRatioLocation,mAspectRatio)  } 
public GPUImageHardLightBlendFilter(){   super(HARD_LIGHT_BLEND_FRAGMENT_SHADER)  } 
public GPUImageHazeFilter(){   this(0.2f,0.0f)  } 
public GPUImageHazeFilter(float distance,float slope){   super(NO_FILTER_VERTEX_SHADER,HAZE_FRAGMENT_SHADER)    mDistance=distance    mSlope=slope  } 
@Override public void onInit(){   super.onInit()    mDistanceLocation=GLES20.glGetUniformLocation(getProgram(),"distance")    mSlopeLocation=GLES20.glGetUniformLocation(getProgram(),"slope")  } 
@Override public void onInitialized(){   super.onInitialized()    setDistance(mDistance)    setSlope(mSlope)  } 
/**   * Strength of the color applied. Default 0. Values between -.3 and .3 are best.  * @param distance -0.3 to 0.3 are best, default 0  */ public void setDistance(float distance){   mDistance=distance    setFloat(mDistanceLocation,distance)  } 
/**   * Amount of color change. Default 0. Values between -.3 and .3 are best.  * @param slope -0.3 to 0.3 are best, default 0  */ public void setSlope(float slope){   mSlope=slope    setFloat(mSlopeLocation,slope)  } 
public GPUImageHighlightShadowFilter(){   this(0.0f,1.0f)  } 
public GPUImageHighlightShadowFilter(final float shadows,final float highlights){   super(NO_FILTER_VERTEX_SHADER,HIGHLIGHT_SHADOW_FRAGMENT_SHADER)    mHighlights=highlights    mShadows=shadows  } 
@Override public void onInit(){   super.onInit()    mHighlightsLocation=GLES20.glGetUniformLocation(getProgram(),"highlights")    mShadowsLocation=GLES20.glGetUniformLocation(getProgram(),"shadows")  } 
@Override public void onInitialized(){   super.onInitialized()    setHighlights(mHighlights)    setShadows(mShadows)  } 
public void setHighlights(final float highlights){   mHighlights=highlights    setFloat(mHighlightsLocation,mHighlights)  } 
public void setShadows(final float shadows){   mShadows=shadows    setFloat(mShadowsLocation,mShadows)  } 
public GPUImageHueBlendFilter(){   super(HUE_BLEND_FRAGMENT_SHADER)  } 
public GPUImageHueFilter(){   this(90.0f)  } 
public GPUImageHueFilter(final float hue){   super(NO_FILTER_VERTEX_SHADER,HUE_FRAGMENT_SHADER)    mHue=hue  } 
@Override public void onInit(){   super.onInit()    mHueLocation=GLES20.glGetUniformLocation(getProgram(),"hueAdjust")  } 
@Override public void onInitialized(){   super.onInitialized()    setHue(mHue)  } 
public void setHue(final float hue){   mHue=hue    float hueAdjust=(mHue % 360.0f) * (float)Math.PI / 180.0f    setFloat(mHueLocation,hueAdjust)  } 
public GPUImageKuwaharaFilter(){   this(3)  } 
public GPUImageKuwaharaFilter(int radius){   super(NO_FILTER_VERTEX_SHADER,KUWAHARA_FRAGMENT_SHADER)    mRadius=radius  } 
@Override public void onInit(){   super.onInit()    mRadiusLocation=GLES20.glGetUniformLocation(getProgram(),"radius")  } 
@Override public void onInitialized(){   super.onInitialized()    setRadius(mRadius)  } 
/**   * The radius to sample from when creating the brush-stroke effect, with a default of 3. The larger the radius, the slower the filter.  * @param radius default 3  */ public void setRadius(final int radius){   mRadius=radius    setInteger(mRadiusLocation,radius)  } 
public GPUImageLaplacianFilter(){   this(new float[]{0.5f,1.0f,0.5f,1.0f,-6.0f,1.0f,0.5f,1.0f,0.5f})  } 
private GPUImageLaplacianFilter(final float[] convolutionKernel){   super(LAPLACIAN_FRAGMENT_SHADER)    mConvolutionKernel=convolutionKernel  } 
@Override public void onInit(){   super.onInit()    mUniformConvolutionMatrix=GLES20.glGetUniformLocation(getProgram(),"convolutionMatrix")    setConvolutionKernel(mConvolutionKernel)  } 
private void setConvolutionKernel(final float[] convolutionKernel){   mConvolutionKernel=convolutionKernel    setUniformMatrix3f(mUniformConvolutionMatrix,mConvolutionKernel)  } 
public GPUImageLevelsFilter(){   this(new float[]{0.0f,0.0f,0.0f},new float[]{1.0f,1.0f,1.0f},new float[]{1.0f,1.0f,1.0f},new float[]{0.0f,0.0f,0.0f},new float[]{1.0f,1.0f,1.0f})  } 
private GPUImageLevelsFilter(final float[] min,final float[] mid,final float[] max,final float[] minOUt,final float[] maxOut){   super(NO_FILTER_VERTEX_SHADER,LEVELS_FRAGMET_SHADER)    mMin=min    mMid=mid    mMax=max    mMinOutput=minOUt    mMaxOutput=maxOut    setMin(0.0f,1.0f,1.0f,0.0f,1.0f)  } 
@Override public void onInit(){   super.onInit()    mMinLocation=GLES20.glGetUniformLocation(getProgram(),"levelMinimum")    mMidLocation=GLES20.glGetUniformLocation(getProgram(),"levelMiddle")    mMaxLocation=GLES20.glGetUniformLocation(getProgram(),"levelMaximum")    mMinOutputLocation=GLES20.glGetUniformLocation(getProgram(),"minOutput")    mMaxOutputLocation=GLES20.glGetUniformLocation(getProgram(),"maxOutput")  } 
@Override public void onInitialized(){   super.onInitialized()    updateUniforms()  } 
public void updateUniforms(){   setFloatVec3(mMinLocation,mMin)    setFloatVec3(mMidLocation,mMid)    setFloatVec3(mMaxLocation,mMax)    setFloatVec3(mMinOutputLocation,mMinOutput)    setFloatVec3(mMaxOutputLocation,mMaxOutput)  } 
public void setMin(float min,float mid,float max,float minOut,float maxOut){   setRedMin(min,mid,max,minOut,maxOut)    setGreenMin(min,mid,max,minOut,maxOut)    setBlueMin(min,mid,max,minOut,maxOut)  } 
public void setMin(float min,float mid,float max){   setMin(min,mid,max,0.0f,1.0f)  } 
public void setRedMin(float min,float mid,float max,float minOut,float maxOut){   mMin[0]=min    mMid[0]=mid    mMax[0]=max    mMinOutput[0]=minOut    mMaxOutput[0]=maxOut    updateUniforms()  } 
public void setRedMin(float min,float mid,float max){   setRedMin(min,mid,max,0,1)  } 
public void setGreenMin(float min,float mid,float max,float minOut,float maxOut){   mMin[1]=min    mMid[1]=mid    mMax[1]=max    mMinOutput[1]=minOut    mMaxOutput[1]=maxOut    updateUniforms()  } 
public void setGreenMin(float min,float mid,float max){   setGreenMin(min,mid,max,0,1)  } 
public void setBlueMin(float min,float mid,float max,float minOut,float maxOut){   mMin[2]=min    mMid[2]=mid    mMax[2]=max    mMinOutput[2]=minOut    mMaxOutput[2]=maxOut    updateUniforms()  } 
public void setBlueMin(float min,float mid,float max){   setBlueMin(min,mid,max,0,1)  } 
public GPUImageLightenBlendFilter(){   super(LIGHTEN_BLEND_FRAGMENT_SHADER)  } 
public GPUImageLinearBurnBlendFilter(){   super(LINEAR_BURN_BLEND_FRAGMENT_SHADER)  } 
public GPUImageLookupFilter(){   this(1.0f)  } 
public GPUImageLookupFilter(final float intensity){   super(LOOKUP_FRAGMENT_SHADER)    mIntensity=intensity  } 
@Override public void onInit(){   super.onInit()    mIntensityLocation=GLES20.glGetUniformLocation(getProgram(),"intensity")  } 
@Override public void onInitialized(){   super.onInitialized()    setIntensity(mIntensity)  } 
public void setIntensity(final float intensity){   mIntensity=intensity    setFloat(mIntensityLocation,mIntensity)  } 
public GPUImageLuminosityBlendFilter(){   super(LUMINOSITY_BLEND_FRAGMENT_SHADER)  } 
public GPUImageMixBlendFilter(String fragmentShader){   this(fragmentShader,0.5f)  } 
public GPUImageMixBlendFilter(String fragmentShader,float mix){   super(fragmentShader)    mMix=mix  } 
@Override public void onInit(){   super.onInit()    mMixLocation=GLES20.glGetUniformLocation(getProgram(),"mixturePercent")  } 
@Override public void onInitialized(){   super.onInitialized()    setMix(mMix)  } 
/**   * @param mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level  */ public void setMix(final float mix){   mMix=mix    setFloat(mMixLocation,mMix)  } 
public GPUImageMonochromeFilter(){   this(1.0f,new float[]{0.6f,0.45f,0.3f,1.0f})  } 
public GPUImageMonochromeFilter(final float intensity,final float[] color){   super(NO_FILTER_VERTEX_SHADER,MONOCHROME_FRAGMENT_SHADER)    mIntensity=intensity    mColor=color  } 
@Override public void onInit(){   super.onInit()    mIntensityLocation=GLES20.glGetUniformLocation(getProgram(),"intensity")    mFilterColorLocation=GLES20.glGetUniformLocation(getProgram(),"filterColor")  } 
@Override public void onInitialized(){   super.onInitialized()    setIntensity(1.0f)    setColor(new float[]{0.6f,0.45f,0.3f,1.f})  } 
public void setIntensity(final float intensity){   mIntensity=intensity    setFloat(mIntensityLocation,mIntensity)  } 
public void setColor(final float[] color){   mColor=color    setColorRed(mColor[0],mColor[1],mColor[2])  } 
public void setColorRed(final float red,final float green,final float blue){   setFloatVec3(mFilterColorLocation,new float[]{red,green,blue})  } 
public GPUImageMultiplyBlendFilter(){   super(MULTIPLY_BLEND_FRAGMENT_SHADER)  } 
public static native void YUVtoRBGA(byte[] yuv,int width,int height,int[] out)  
public static native void YUVtoARBG(byte[] yuv,int width,int height,int[] out)  
public GPUImageNonMaximumSuppressionFilter(){   super(NMS_FRAGMENT_SHADER)  } 
public GPUImageNormalBlendFilter(){   super(NORMAL_BLEND_FRAGMENT_SHADER)  } 
public GPUImageOpacityFilter(){   this(1.0f)  } 
public GPUImageOpacityFilter(final float opacity){   super(NO_FILTER_VERTEX_SHADER,OPACITY_FRAGMENT_SHADER)    mOpacity=opacity  } 
@Override public void onInit(){   super.onInit()    mOpacityLocation=GLES20.glGetUniformLocation(getProgram(),"opacity")  } 
@Override public void onInitialized(){   super.onInitialized()    setOpacity(mOpacity)  } 
public void setOpacity(final float opacity){   mOpacity=opacity    setFloat(mOpacityLocation,mOpacity)  } 
public GPUImageOverlayBlendFilter(){   super(OVERLAY_BLEND_FRAGMENT_SHADER)  } 
public GPUImagePixelationFilter(){   super(NO_FILTER_VERTEX_SHADER,PIXELATION_FRAGMENT_SHADER)    mPixel=1.0f  } 
@Override public void onInit(){   super.onInit()    mImageWidthFactorLocation=GLES20.glGetUniformLocation(getProgram(),"imageWidthFactor")    mImageHeightFactorLocation=GLES20.glGetUniformLocation(getProgram(),"imageHeightFactor")    mPixelLocation=GLES20.glGetUniformLocation(getProgram(),"pixel")    setPixel(mPixel)  } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    setFloat(mImageWidthFactorLocation,1.0f / width)    setFloat(mImageHeightFactorLocation,1.0f / height)  } 
public void setPixel(final float pixel){   mPixel=pixel    setFloat(mPixelLocation,mPixel)  } 
public GPUImagePosterizeFilter(){   this(10)  } 
public GPUImagePosterizeFilter(final int colorLevels){   super(GPUImageFilter.NO_FILTER_VERTEX_SHADER,POSTERIZE_FRAGMENT_SHADER)    mColorLevels=colorLevels  } 
@Override public void onInit(){   super.onInit()    mGLUniformColorLevels=GLES20.glGetUniformLocation(getProgram(),"colorLevels")    setColorLevels(mColorLevels)  } 
public void setColorLevels(final int colorLevels){   mColorLevels=colorLevels    setFloat(mGLUniformColorLevels,colorLevels)  } 
public GPUImageRenderer(final GPUImageFilter filter){   mFilter=filter    mRunOnDraw=new LinkedList<Runnable>()    mRunOnDrawEnd=new LinkedList<Runnable>()    mGLCubeBuffer=ByteBuffer.allocateDirect(CUBE.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()    mGLCubeBuffer.put(CUBE).position(0)    mGLTextureBuffer=ByteBuffer.allocateDirect(TEXTURE_NO_ROTATION.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()    setRotation(Rotation.NORMAL,false,false)  } 
@Override public void onSurfaceCreated(final GL10 unused,final EGLConfig config){   GLES20.glClearColor(mBackgroundRed,mBackgroundGreen,mBackgroundBlue,1)    GLES20.glDisable(GLES20.GL_DEPTH_TEST)    mFilter.init()  } 
@Override public void onSurfaceChanged(final GL10 gl,final int width,final int height){   mOutputWidth=width    mOutputHeight=height    GLES20.glViewport(0,0,width,height)    GLES20.glUseProgram(mFilter.getProgram())    mFilter.onOutputSizeChanged(width,height)    adjustImageScaling()  synchronized (mSurfaceChangedWaiter) {     mSurfaceChangedWaiter.notifyAll()    } } 
@Override public void onDrawFrame(final GL10 gl){   GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT)    runAll(mRunOnDraw)    mFilter.onDraw(mGLTextureId,mGLCubeBuffer,mGLTextureBuffer)    runAll(mRunOnDrawEnd)    if (mSurfaceTexture != null) {     mSurfaceTexture.updateTexImage()    } } 
/**   * Sets the background color  * @param red red color value  * @param green green color value  * @param blue red color value  */ public void setBackgroundColor(float red,float green,float blue){   mBackgroundRed=red    mBackgroundGreen=green    mBackgroundBlue=blue  } 
private void runAll(Queue<Runnable> queue){ synchronized (queue) {     while (!queue.isEmpty()) {       queue.poll().run()      }   } } 
@Override public void onPreviewFrame(final byte[] data,final Camera camera){   final Size previewSize=camera.getParameters().getPreviewSize()    if (mGLRgbBuffer == null) {     mGLRgbBuffer=IntBuffer.allocate(previewSize.width * previewSize.height)    }   if (mRunOnDraw.isEmpty()) {     runOnDraw(new Runnable(){       @Override public void run(){         GPUImageNativeLibrary.YUVtoRBGA(data,previewSize.width,previewSize.height,mGLRgbBuffer.array())          mGLTextureId=OpenGlUtils.loadTexture(mGLRgbBuffer,previewSize,mGLTextureId)          camera.addCallbackBuffer(data)          if (mImageWidth != previewSize.width) {           mImageWidth=previewSize.width            mImageHeight=previewSize.height            adjustImageScaling()          }       }     } )    } } 
@Override public void run(){   GPUImageNativeLibrary.YUVtoRBGA(data,previewSize.width,previewSize.height,mGLRgbBuffer.array())    mGLTextureId=OpenGlUtils.loadTexture(mGLRgbBuffer,previewSize,mGLTextureId)    camera.addCallbackBuffer(data)    if (mImageWidth != previewSize.width) {     mImageWidth=previewSize.width      mImageHeight=previewSize.height      adjustImageScaling()    } } 
public void setUpSurfaceTexture(final Camera camera){   runOnDraw(new Runnable(){     @Override public void run(){       int[] textures=new int[1]        GLES20.glGenTextures(1,textures,0)        mSurfaceTexture=new SurfaceTexture(textures[0])        try {         camera.setPreviewTexture(mSurfaceTexture)          camera.setPreviewCallback(GPUImageRenderer.this)          camera.startPreview()        }  catch (      IOException e) {         e.printStackTrace()        }     }   } )  } 
@Override public void run(){   int[] textures=new int[1]    GLES20.glGenTextures(1,textures,0)    mSurfaceTexture=new SurfaceTexture(textures[0])    try {     camera.setPreviewTexture(mSurfaceTexture)      camera.setPreviewCallback(GPUImageRenderer.this)      camera.startPreview()    }  catch (  IOException e) {     e.printStackTrace()    } } 
public void setFilter(final GPUImageFilter filter){   runOnDraw(new Runnable(){     @Override public void run(){       final GPUImageFilter oldFilter=mFilter        mFilter=filter        if (oldFilter != null) {         oldFilter.destroy()        }       mFilter.init()        GLES20.glUseProgram(mFilter.getProgram())        mFilter.onOutputSizeChanged(mOutputWidth,mOutputHeight)      }   } )  } 
@Override public void run(){   final GPUImageFilter oldFilter=mFilter    mFilter=filter    if (oldFilter != null) {     oldFilter.destroy()    }   mFilter.init()    GLES20.glUseProgram(mFilter.getProgram())    mFilter.onOutputSizeChanged(mOutputWidth,mOutputHeight)  } 
public void deleteImage(){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glDeleteTextures(1,new int[]{mGLTextureId},0)        mGLTextureId=NO_IMAGE      }   } )  } 
@Override public void run(){   GLES20.glDeleteTextures(1,new int[]{mGLTextureId},0)    mGLTextureId=NO_IMAGE  } 
public void setImageBitmap(final Bitmap bitmap){   setImageBitmap(bitmap,true)  } 
public void setImageBitmap(final Bitmap bitmap,final boolean recycle){   if (bitmap == null) {     return    }   runOnDraw(new Runnable(){     @Override public void run(){       Bitmap resizedBitmap=null        if (bitmap.getWidth() % 2 == 1) {         resizedBitmap=Bitmap.createBitmap(bitmap.getWidth() + 1,bitmap.getHeight(),Bitmap.Config.ARGB_8888)          Canvas can=new Canvas(resizedBitmap)          can.drawARGB(0x00,0x00,0x00,0x00)          can.drawBitmap(bitmap,0,0,null)          mAddedPadding=1        }  else {         mAddedPadding=0        }       mGLTextureId=OpenGlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap,mGLTextureId,recycle)        if (resizedBitmap != null) {         resizedBitmap.recycle()        }       mImageWidth=bitmap.getWidth()        mImageHeight=bitmap.getHeight()        adjustImageScaling()      }   } )  } 
@Override public void run(){   Bitmap resizedBitmap=null    if (bitmap.getWidth() % 2 == 1) {     resizedBitmap=Bitmap.createBitmap(bitmap.getWidth() + 1,bitmap.getHeight(),Bitmap.Config.ARGB_8888)      Canvas can=new Canvas(resizedBitmap)      can.drawARGB(0x00,0x00,0x00,0x00)      can.drawBitmap(bitmap,0,0,null)      mAddedPadding=1    }  else {     mAddedPadding=0    }   mGLTextureId=OpenGlUtils.loadTexture(resizedBitmap != null ? resizedBitmap : bitmap,mGLTextureId,recycle)    if (resizedBitmap != null) {     resizedBitmap.recycle()    }   mImageWidth=bitmap.getWidth()    mImageHeight=bitmap.getHeight()    adjustImageScaling()  } 
public void setScaleType(GPUImage.ScaleType scaleType){   mScaleType=scaleType  } 
protected int getFrameWidth(){   return mOutputWidth  } 
protected int getFrameHeight(){   return mOutputHeight  } 
private void adjustImageScaling(){   float outputWidth=mOutputWidth    float outputHeight=mOutputHeight    if (mRotation == Rotation.ROTATION_270 || mRotation == Rotation.ROTATION_90) {     outputWidth=mOutputHeight      outputHeight=mOutputWidth    }   float ratio1=outputWidth / mImageWidth    float ratio2=outputHeight / mImageHeight    float ratioMax=Math.max(ratio1,ratio2)    int imageWidthNew=Math.round(mImageWidth * ratioMax)    int imageHeightNew=Math.round(mImageHeight * ratioMax)    float ratioWidth=imageWidthNew / outputWidth    float ratioHeight=imageHeightNew / outputHeight    float[] cube=CUBE    float[] textureCords=TextureRotationUtil.getRotation(mRotation,mFlipHorizontal,mFlipVertical)    if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {     float distHorizontal=(1 - 1 / ratioWidth) / 2      float distVertical=(1 - 1 / ratioHeight) / 2      textureCords=new float[]{addDistance(textureCords[0],distHorizontal),addDistance(textureCords[1],distVertical),addDistance(textureCords[2],distHorizontal),addDistance(textureCords[3],distVertical),addDistance(textureCords[4],distHorizontal),addDistance(textureCords[5],distVertical),addDistance(textureCords[6],distHorizontal),addDistance(textureCords[7],distVertical)}    }  else {     cube=new float[]{CUBE[0] / ratioHeight,CUBE[1] / ratioWidth,CUBE[2] / ratioHeight,CUBE[3] / ratioWidth,CUBE[4] / ratioHeight,CUBE[5] / ratioWidth,CUBE[6] / ratioHeight,CUBE[7] / ratioWidth}    }   mGLCubeBuffer.clear()    mGLCubeBuffer.put(cube).position(0)    mGLTextureBuffer.clear()    mGLTextureBuffer.put(textureCords).position(0)  } 
private float addDistance(float coordinate,float distance){   return coordinate == 0.0f ? distance : 1 - distance  } 
public void setRotationCamera(final Rotation rotation,final boolean flipHorizontal,final boolean flipVertical){   setRotation(rotation,flipVertical,flipHorizontal)  } 
public void setRotation(final Rotation rotation){   mRotation=rotation    adjustImageScaling()  } 
public void setRotation(final Rotation rotation,final boolean flipHorizontal,final boolean flipVertical){   mFlipHorizontal=flipHorizontal    mFlipVertical=flipVertical    setRotation(rotation)  } 
public Rotation getRotation(){   return mRotation  } 
public boolean isFlippedHorizontally(){   return mFlipHorizontal  } 
public boolean isFlippedVertically(){   return mFlipVertical  } 
protected void runOnDraw(final Runnable runnable){ synchronized (mRunOnDraw) {     mRunOnDraw.add(runnable)    } } 
protected void runOnDrawEnd(final Runnable runnable){ synchronized (mRunOnDrawEnd) {     mRunOnDrawEnd.add(runnable)    } } 
public GPUImageRGBDilationFilter(){   this(1)  } 
/**   * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from the center, are 1, 2, 3, and 4.  * @param radius 1, 2, 3 or 4  */ public GPUImageRGBDilationFilter(int radius){   this(getVertexShader(radius),getFragmentShader(radius))  } 
private GPUImageRGBDilationFilter(String vertexShader,String fragmentShader){   super(vertexShader,fragmentShader,vertexShader,fragmentShader)  } 
private static String getVertexShader(int radius){ switch (radius) { case 0: case 1:     return VERTEX_SHADER_1  case 2:   return VERTEX_SHADER_2  case 3: return VERTEX_SHADER_3  default : return VERTEX_SHADER_4  } } 
private static String getFragmentShader(int radius){ switch (radius) { case 0: case 1:     return FRAGMENT_SHADER_1  case 2:   return FRAGMENT_SHADER_2  case 3: return FRAGMENT_SHADER_3  default : return FRAGMENT_SHADER_4  } } 
public GPUImageRGBFilter(){   this(1.0f,1.0f,1.0f)  } 
public GPUImageRGBFilter(final float red,final float green,final float blue){   super(NO_FILTER_VERTEX_SHADER,RGB_FRAGMENT_SHADER)    mRed=red    mGreen=green    mBlue=blue  } 
@Override public void onInit(){   super.onInit()    mRedLocation=GLES20.glGetUniformLocation(getProgram(),"red")    mGreenLocation=GLES20.glGetUniformLocation(getProgram(),"green")    mBlueLocation=GLES20.glGetUniformLocation(getProgram(),"blue")    mIsInitialized=true    setRed(mRed)    setGreen(mGreen)    setBlue(mBlue)  } 
public void setRed(final float red){   mRed=red    if (mIsInitialized) {     setFloat(mRedLocation,mRed)    } } 
public void setGreen(final float green){   mGreen=green    if (mIsInitialized) {     setFloat(mGreenLocation,mGreen)    } } 
public void setBlue(final float blue){   mBlue=blue    if (mIsInitialized) {     setFloat(mBlueLocation,mBlue)    } } 
public GPUImageSaturationBlendFilter(){   super(SATURATION_BLEND_FRAGMENT_SHADER)  } 
public GPUImageSaturationFilter(){   this(1.0f)  } 
public GPUImageSaturationFilter(final float saturation){   super(NO_FILTER_VERTEX_SHADER,SATURATION_FRAGMENT_SHADER)    mSaturation=saturation  } 
@Override public void onInit(){   super.onInit()    mSaturationLocation=GLES20.glGetUniformLocation(getProgram(),"saturation")  } 
@Override public void onInitialized(){   super.onInitialized()    setSaturation(mSaturation)  } 
public void setSaturation(final float saturation){   mSaturation=saturation    setFloat(mSaturationLocation,mSaturation)  } 
public GPUImageScreenBlendFilter(){   super(SCREEN_BLEND_FRAGMENT_SHADER)  } 
public GPUImageSepiaFilter(){   this(1.0f)  } 
public GPUImageSepiaFilter(final float intensity){   super(intensity,new float[]{0.3588f,0.7044f,0.1368f,0.0f,0.2990f,0.5870f,0.1140f,0.0f,0.2392f,0.4696f,0.0912f,0.0f,0f,0f,0f,1.0f})  } 
public GPUImageSharpenFilter(){   this(0.0f)  } 
public GPUImageSharpenFilter(final float sharpness){   super(SHARPEN_VERTEX_SHADER,SHARPEN_FRAGMENT_SHADER)    mSharpness=sharpness  } 
@Override public void onInit(){   super.onInit()    mSharpnessLocation=GLES20.glGetUniformLocation(getProgram(),"sharpness")    mImageWidthFactorLocation=GLES20.glGetUniformLocation(getProgram(),"imageWidthFactor")    mImageHeightFactorLocation=GLES20.glGetUniformLocation(getProgram(),"imageHeightFactor")    setSharpness(mSharpness)  } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    setFloat(mImageWidthFactorLocation,1.0f / width)    setFloat(mImageHeightFactorLocation,1.0f / height)  } 
public void setSharpness(final float sharpness){   mSharpness=sharpness    setFloat(mSharpnessLocation,mSharpness)  } 
public GPUImageSketchFilter(){   super()    addFilter(new GPUImageGrayscaleFilter())    addFilter(new GPUImage3x3TextureSamplingFilter(SKETCH_FRAGMENT_SHADER))  } 
/**   * Setup and Tear down  */ public GPUImageSmoothToonFilter(){   blurFilter=new GPUImageGaussianBlurFilter()    addFilter(blurFilter)    toonFilter=new GPUImageToonFilter()    addFilter(toonFilter)    getFilters().add(blurFilter)    setBlurSize(0.5f)    setThreshold(0.2f)    setQuantizationLevels(10.0f)  } 
/**   * Accessors  */ public void setTexelWidth(float value){   toonFilter.setTexelWidth(value)  } 
public void setTexelHeight(float value){   toonFilter.setTexelHeight(value)  } 
public void setBlurSize(float value){   blurFilter.setBlurSize(value)  } 
public void setThreshold(float value){   toonFilter.setThreshold(value)  } 
public void setQuantizationLevels(float value){   toonFilter.setQuantizationLevels(value)  } 
public GPUImageSobelEdgeDetection(){   super()    addFilter(new GPUImageGrayscaleFilter())    addFilter(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION))  } 
public void setLineSize(final float size){   ((GPUImage3x3TextureSamplingFilter)getFilters().get(1)).setLineSize(size)  } 
public GPUImageSobelThresholdFilter(){   this(0.9f)  } 
public GPUImageSobelThresholdFilter(float threshold){   super(SOBEL_THRESHOLD_EDGE_DETECTION)    mThreshold=threshold  } 
@Override public void onInit(){   super.onInit()    mUniformThresholdLocation=GLES20.glGetUniformLocation(getProgram(),"threshold")  } 
@Override public void onInitialized(){   super.onInitialized()    setThreshold(mThreshold)  } 
public void setThreshold(final float threshold){   mThreshold=threshold    setFloat(mUniformThresholdLocation,threshold)  } 
public GPUImageSoftLightBlendFilter(){   super(SOFT_LIGHT_BLEND_FRAGMENT_SHADER)  } 
public GPUImageSourceOverBlendFilter(){   super(SOURCE_OVER_BLEND_FRAGMENT_SHADER)  } 
public GPUImageSphereRefractionFilter(){   this(new PointF(0.5f,0.5f),0.25f,0.71f)  } 
public GPUImageSphereRefractionFilter(PointF center,float radius,float refractiveIndex){   super(NO_FILTER_VERTEX_SHADER,SPHERE_FRAGMENT_SHADER)    mCenter=center    mRadius=radius    mRefractiveIndex=refractiveIndex  } 
@Override public void onInit(){   super.onInit()    mCenterLocation=GLES20.glGetUniformLocation(getProgram(),"center")    mRadiusLocation=GLES20.glGetUniformLocation(getProgram(),"radius")    mAspectRatioLocation=GLES20.glGetUniformLocation(getProgram(),"aspectRatio")    mRefractiveIndexLocation=GLES20.glGetUniformLocation(getProgram(),"refractiveIndex")  } 
@Override public void onInitialized(){   super.onInitialized()    setRadius(mRadius)    setCenter(mCenter)    setRefractiveIndex(mRefractiveIndex)  } 
@Override public void onOutputSizeChanged(int width,int height){   mAspectRatio=(float)height / width    setAspectRatio(mAspectRatio)    super.onOutputSizeChanged(width,height)  } 
private void setAspectRatio(float aspectRatio){   mAspectRatio=aspectRatio    setFloat(mAspectRatioLocation,aspectRatio)  } 
/**   * The index of refraction for the sphere, with a default of 0.71  * @param refractiveIndex default 0.71  */ public void setRefractiveIndex(float refractiveIndex){   mRefractiveIndex=refractiveIndex    setFloat(mRefractiveIndexLocation,refractiveIndex)  } 
/**   * The center about which to apply the distortion, with a default of (0.5, 0.5)  * @param center default (0.5, 0.5)  */ public void setCenter(PointF center){   mCenter=center    setPoint(mCenterLocation,center)  } 
/**   * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25  * @param radius from 0.0 to 1.0, default 0.25  */ public void setRadius(float radius){   mRadius=radius    setFloat(mRadiusLocation,radius)  } 
public GPUImageSubtractBlendFilter(){   super(SUBTRACT_BLEND_FRAGMENT_SHADER)  } 
public GPUImageSwirlFilter(){   this(0.5f,1.0f,new PointF(0.5f,0.5f))  } 
public GPUImageSwirlFilter(float radius,float angle,PointF center){   super(NO_FILTER_VERTEX_SHADER,SWIRL_FRAGMENT_SHADER)    mRadius=radius    mAngle=angle    mCenter=center  } 
@Override public void onInit(){   super.onInit()    mAngleLocation=GLES20.glGetUniformLocation(getProgram(),"angle")    mRadiusLocation=GLES20.glGetUniformLocation(getProgram(),"radius")    mCenterLocation=GLES20.glGetUniformLocation(getProgram(),"center")  } 
@Override public void onInitialized(){   super.onInitialized()    setRadius(mRadius)    setAngle(mAngle)    setCenter(mCenter)  } 
/**   * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.5.  * @param radius from 0.0 to 1.0, default 0.5  */ public void setRadius(float radius){   mRadius=radius    setFloat(mRadiusLocation,radius)  } 
/**   * The amount of distortion to apply, with a minimum of 0.0 and a default of 1.0.  * @param angle minimum 0.0, default 1.0  */ public void setAngle(float angle){   mAngle=angle    setFloat(mAngleLocation,angle)  } 
/**   * The center about which to apply the distortion, with a default of (0.5, 0.5).  * @param center default (0.5, 0.5)  */ public void setCenter(PointF center){   mCenter=center    setPoint(mCenterLocation,center)  } 
public GPUImageThresholdEdgeDetection(){   super()    addFilter(new GPUImageGrayscaleFilter())    addFilter(new GPUImageSobelThresholdFilter())  } 
public void setLineSize(final float size){   ((GPUImage3x3TextureSamplingFilter)getFilters().get(1)).setLineSize(size)  } 
public void setThreshold(final float threshold){   ((GPUImageSobelThresholdFilter)getFilters().get(1)).setThreshold(threshold)  } 
public GPUImageToneCurveFilter(){   super(NO_FILTER_VERTEX_SHADER,TONE_CURVE_FRAGMENT_SHADER)    PointF[] defaultCurvePoints=new PointF[]{new PointF(0.0f,0.0f),new PointF(0.5f,0.5f),new PointF(1.0f,1.0f)}    mRgbCompositeControlPoints=defaultCurvePoints    mRedControlPoints=defaultCurvePoints    mGreenControlPoints=defaultCurvePoints    mBlueControlPoints=defaultCurvePoints  } 
@Override public void onInit(){   super.onInit()    mToneCurveTextureUniformLocation=GLES20.glGetUniformLocation(getProgram(),"toneCurveTexture")    GLES20.glActiveTexture(GLES20.GL_TEXTURE3)    GLES20.glGenTextures(1,mToneCurveTexture,0)    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mToneCurveTexture[0])    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_LINEAR)    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_LINEAR)    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE)    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE)  } 
@Override public void onInitialized(){   super.onInitialized()    setRgbCompositeControlPoints(mRgbCompositeControlPoints)    setRedControlPoints(mRedControlPoints)    setGreenControlPoints(mGreenControlPoints)    setBlueControlPoints(mBlueControlPoints)  } 
@Override protected void onDrawArraysPre(){   if (mToneCurveTexture[0] != OpenGlUtils.NO_TEXTURE) {     GLES20.glActiveTexture(GLES20.GL_TEXTURE3)      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mToneCurveTexture[0])      GLES20.glUniform1i(mToneCurveTextureUniformLocation,3)    } } 
public void setFromCurveFileInputStream(InputStream input){   try {     int version=readShort(input)      int totalCurves=readShort(input)      ArrayList<PointF[]> curves=new ArrayList<PointF[]>(totalCurves)      float pointRate=1.0f / 255      for (int i=0  i < totalCurves  i++) {       short pointCount=readShort(input)        PointF[] points=new PointF[pointCount]        for (int j=0  j < pointCount  j++) {         short y=readShort(input)          short x=readShort(input)          points[j]=new PointF(x * pointRate,y * pointRate)        }       curves.add(points)      }     input.close()      mRgbCompositeControlPoints=curves.get(0)      mRedControlPoints=curves.get(1)      mGreenControlPoints=curves.get(2)      mBlueControlPoints=curves.get(3)    }  catch (  IOException e) {     e.printStackTrace()    } } 
private short readShort(InputStream input) throws IOException {   return (short)(input.read() << 8 | input.read())  } 
public void setRgbCompositeControlPoints(PointF[] points){   mRgbCompositeControlPoints=points    mRgbCompositeCurve=createSplineCurve(mRgbCompositeControlPoints)    updateToneCurveTexture()  } 
public void setRedControlPoints(PointF[] points){   mRedControlPoints=points    mRedCurve=createSplineCurve(mRedControlPoints)    updateToneCurveTexture()  } 
public void setGreenControlPoints(PointF[] points){   mGreenControlPoints=points    mGreenCurve=createSplineCurve(mGreenControlPoints)    updateToneCurveTexture()  } 
public void setBlueControlPoints(PointF[] points){   mBlueControlPoints=points    mBlueCurve=createSplineCurve(mBlueControlPoints)    updateToneCurveTexture()  } 
private void updateToneCurveTexture(){   runOnDraw(new Runnable(){     @Override public void run(){       GLES20.glActiveTexture(GLES20.GL_TEXTURE3)        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mToneCurveTexture[0])        if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size() >= 256)&& (mRgbCompositeCurve.size() >= 256)) {         byte[] toneCurveByteArray=new byte[256 * 4]          for (int currentCurveIndex=0  currentCurveIndex < 256  currentCurveIndex++) {           toneCurveByteArray[currentCurveIndex * 4 + 2]=(byte)((int)Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)            toneCurveByteArray[currentCurveIndex * 4 + 1]=(byte)((int)Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)            toneCurveByteArray[currentCurveIndex * 4]=(byte)((int)Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)            toneCurveByteArray[currentCurveIndex * 4 + 3]=(byte)(255 & 0xff)          }         GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,256,1,0,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,ByteBuffer.wrap(toneCurveByteArray))        }     }   } )  } 
@Override public void run(){   GLES20.glActiveTexture(GLES20.GL_TEXTURE3)    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mToneCurveTexture[0])    if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size() >= 256)&& (mRgbCompositeCurve.size() >= 256)) {     byte[] toneCurveByteArray=new byte[256 * 4]      for (int currentCurveIndex=0  currentCurveIndex < 256  currentCurveIndex++) {       toneCurveByteArray[currentCurveIndex * 4 + 2]=(byte)((int)Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)        toneCurveByteArray[currentCurveIndex * 4 + 1]=(byte)((int)Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)        toneCurveByteArray[currentCurveIndex * 4]=(byte)((int)Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex),0),255) & 0xff)        toneCurveByteArray[currentCurveIndex * 4 + 3]=(byte)(255 & 0xff)      }     GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,256,1,0,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,ByteBuffer.wrap(toneCurveByteArray))    } } 
private ArrayList<Float> createSplineCurve(PointF[] points){   if (points == null || points.length <= 0) {     return null    }   PointF[] pointsSorted=points.clone()    Arrays.sort(pointsSorted,new Comparator<PointF>(){     @Override public int compare(    PointF point1,    PointF point2){       if (point1.x < point2.x) {         return -1        }  else       if (point1.x > point2.x) {         return 1        }  else {         return 0        }     }   } )    Point[] convertedPoints=new Point[pointsSorted.length]    for (int i=0  i < points.length  i++) {     PointF point=pointsSorted[i]      convertedPoints[i]=new Point((int)(point.x * 255),(int)(point.y * 255))    }   ArrayList<Point> splinePoints=createSplineCurve2(convertedPoints)    Point firstSplinePoint=splinePoints.get(0)    if (firstSplinePoint.x > 0) {     for (int i=firstSplinePoint.x  i >= 0  i--) {       splinePoints.add(0,new Point(i,0))      }   }   Point lastSplinePoint=splinePoints.get(splinePoints.size() - 1)    if (lastSplinePoint.x < 255) {     for (int i=lastSplinePoint.x + 1  i <= 255  i++) {       splinePoints.add(new Point(i,255))      }   }   ArrayList<Float> preparedSplinePoints=new ArrayList<Float>(splinePoints.size())    for (  Point newPoint : splinePoints) {     Point origPoint=new Point(newPoint.x,newPoint.x)      float distance=(float)Math.sqrt(Math.pow((origPoint.x - newPoint.x),2.0) + Math.pow((origPoint.y - newPoint.y),2.0))      if (origPoint.y > newPoint.y) {       distance=-distance      }     preparedSplinePoints.add(distance)    }   return preparedSplinePoints  } 
@Override public int compare(PointF point1,PointF point2){   if (point1.x < point2.x) {     return -1    }  else   if (point1.x > point2.x) {     return 1    }  else {     return 0    } } 
private ArrayList<Point> createSplineCurve2(Point[] points){   ArrayList<Double> sdA=createSecondDerivative(points)    int n=sdA.size()    if (n < 1) {     return null    }   double sd[]=new double[n]    for (int i=0  i < n  i++) {     sd[i]=sdA.get(i)    }   ArrayList<Point> output=new ArrayList<Point>(n + 1)    for (int i=0  i < n - 1  i++) {     Point cur=points[i]      Point next=points[i + 1]      for (int x=cur.x  x < next.x  x++) {       double t=(double)(x - cur.x) / (next.x - cur.x)        double a=1 - t        double b=t        double h=next.x - cur.x        double y=a * cur.y + b * next.y + (h * h / 6) * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1])        if (y > 255.0) {         y=255.0        }  else       if (y < 0.0) {         y=0.0        }       output.add(new Point(x,(int)Math.round(y)))      }   }   if (output.size() == 255) {     output.add(points[points.length - 1])    }   return output  } 
private ArrayList<Double> createSecondDerivative(Point[] points){   int n=points.length    if (n <= 1) {     return null    }   double matrix[][]=new double[n][3]    double result[]=new double[n]    matrix[0][1]=1    matrix[0][0]=0    matrix[0][2]=0    for (int i=1  i < n - 1  i++) {     Point P1=points[i - 1]      Point P2=points[i]      Point P3=points[i + 1]      matrix[i][0]=(double)(P2.x - P1.x) / 6      matrix[i][1]=(double)(P3.x - P1.x) / 3      matrix[i][2]=(double)(P3.x - P2.x) / 6      result[i]=(double)(P3.y - P2.y) / (P3.x - P2.x) - (double)(P2.y - P1.y) / (P2.x - P1.x)    }   result[0]=0    result[n - 1]=0    matrix[n - 1][1]=1    matrix[n - 1][0]=0    matrix[n - 1][2]=0    for (int i=1  i < n  i++) {     double k=matrix[i][0] / matrix[i - 1][1]      matrix[i][1]-=k * matrix[i - 1][2]      matrix[i][0]=0      result[i]-=k * result[i - 1]    }   for (int i=n - 2  i >= 0  i--) {     double k=matrix[i][2] / matrix[i + 1][1]      matrix[i][1]-=k * matrix[i + 1][0]      matrix[i][2]=0      result[i]-=k * result[i + 1]    }   ArrayList<Double> output=new ArrayList<Double>(n)    for (int i=0  i < n  i++)   output.add(result[i] / matrix[i][1])    return output  } 
public GPUImageToonFilter(){   this(0.2f,10.0f)  } 
public GPUImageToonFilter(float threshold,float quantizationLevels){   super(TOON_FRAGMENT_SHADER)    mThreshold=threshold    mQuantizationLevels=quantizationLevels  } 
@Override public void onInit(){   super.onInit()    mThresholdLocation=GLES20.glGetUniformLocation(getProgram(),"threshold")    mQuantizationLevelsLocation=GLES20.glGetUniformLocation(getProgram(),"quantizationLevels")  } 
@Override public void onInitialized(){   super.onInitialized()    setThreshold(mThreshold)    setQuantizationLevels(mQuantizationLevels)  } 
/**   * The threshold at which to apply the edges, default of 0.2.  * @param threshold default 0.2  */ public void setThreshold(final float threshold){   mThreshold=threshold    setFloat(mThresholdLocation,threshold)  } 
/**   * The levels of quantization for the posterization of colors within the scene, with a default of 10.0.  * @param quantizationLevels default 10.0  */ public void setQuantizationLevels(final float quantizationLevels){   mQuantizationLevels=quantizationLevels    setFloat(mQuantizationLevelsLocation,quantizationLevels)  } 
public GPUImageTransformFilter(){   super(TRANSFORM_VERTEX_SHADER,NO_FILTER_FRAGMENT_SHADER)    orthographicMatrix=new float[16]    Matrix.orthoM(orthographicMatrix,0,-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f)    transform3D=new float[16]    Matrix.setIdentityM(transform3D,0)  } 
@Override public void onInit(){   super.onInit()    transformMatrixUniform=GLES20.glGetUniformLocation(getProgram(),"transformMatrix")    orthographicMatrixUniform=GLES20.glGetUniformLocation(getProgram(),"orthographicMatrix")    setUniformMatrix4f(transformMatrixUniform,transform3D)    setUniformMatrix4f(orthographicMatrixUniform,orthographicMatrix)  } 
@Override public void onInitialized(){   super.onInitialized()  } 
@Override public void onOutputSizeChanged(final int width,final int height){   super.onOutputSizeChanged(width,height)    if (!ignoreAspectRatio) {     Matrix.orthoM(orthographicMatrix,0,-1.0f,1.0f,-1.0f * (float)height / (float)width,1.0f * (float)height / (float)width,-1.0f,1.0f)      setUniformMatrix4f(orthographicMatrixUniform,orthographicMatrix)    } } 
@Override public void onDraw(final int textureId,final FloatBuffer cubeBuffer,final FloatBuffer textureBuffer){   FloatBuffer vertBuffer=cubeBuffer    if (!ignoreAspectRatio) {     float[] adjustedVertices=new float[8]      cubeBuffer.position(0)      cubeBuffer.get(adjustedVertices)      float normalizedHeight=(float)getOutputHeight() / (float)getOutputWidth()      adjustedVertices[1]*=normalizedHeight      adjustedVertices[3]*=normalizedHeight      adjustedVertices[5]*=normalizedHeight      adjustedVertices[7]*=normalizedHeight      vertBuffer=ByteBuffer.allocateDirect(adjustedVertices.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer()      vertBuffer.put(adjustedVertices).position(0)    }   super.onDraw(textureId,vertBuffer,textureBuffer)  } 
public void setTransform3D(float[] transform3D){   this.transform3D=transform3D    setUniformMatrix4f(transformMatrixUniform,transform3D)  } 
public float[] getTransform3D(){   return transform3D  } 
public void setIgnoreAspectRatio(boolean ignoreAspectRatio){   this.ignoreAspectRatio=ignoreAspectRatio    if (ignoreAspectRatio) {     Matrix.orthoM(orthographicMatrix,0,-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f)      setUniformMatrix4f(orthographicMatrixUniform,orthographicMatrix)    }  else {     onOutputSizeChanged(getOutputWidth(),getOutputHeight())    } } 
public boolean ignoreAspectRatio(){   return ignoreAspectRatio  } 
public void setAnchorTopLeft(boolean anchorTopLeft){   this.anchorTopLeft=anchorTopLeft    setIgnoreAspectRatio(ignoreAspectRatio)  } 
public boolean anchorTopLeft(){   return anchorTopLeft  } 
public GPUImageTwoInputFilter(String fragmentShader){   this(VERTEX_SHADER,fragmentShader)  } 
public GPUImageTwoInputFilter(String vertexShader,String fragmentShader){   super(vertexShader,fragmentShader)    setRotation(Rotation.NORMAL,false,false)  } 
@Override public void onInit(){   super.onInit()    mFilterSecondTextureCoordinateAttribute=GLES20.glGetAttribLocation(getProgram(),"inputTextureCoordinate2")    mFilterInputTextureUniform2=GLES20.glGetUniformLocation(getProgram(),"inputImageTexture2")    GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute)    if (mBitmap != null && !mBitmap.isRecycled()) {     setBitmap(mBitmap)    } } 
public void setBitmap(final Bitmap bitmap){   if (bitmap != null && bitmap.isRecycled()) {     return    }   mBitmap=bitmap    if (mBitmap == null) {     return    }   runOnDraw(new Runnable(){     public void run(){       if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {         if (bitmap == null || bitmap.isRecycled()) {           return          }         GLES20.glActiveTexture(GLES20.GL_TEXTURE3)          mFilterSourceTexture2=OpenGlUtils.loadTexture(bitmap,OpenGlUtils.NO_TEXTURE,false)        }     }   } )  } 
public void run(){   if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {     if (bitmap == null || bitmap.isRecycled()) {       return      }     GLES20.glActiveTexture(GLES20.GL_TEXTURE3)      mFilterSourceTexture2=OpenGlUtils.loadTexture(bitmap,OpenGlUtils.NO_TEXTURE,false)    } } 
public Bitmap getBitmap(){   return mBitmap  } 
public void recycleBitmap(){   if (mBitmap != null && !mBitmap.isRecycled()) {     mBitmap.recycle()      mBitmap=null    } } 
public void onDestroy(){   super.onDestroy()    GLES20.glDeleteTextures(1,new int[]{mFilterSourceTexture2},0)    mFilterSourceTexture2=OpenGlUtils.NO_TEXTURE  } 
@Override protected void onDrawArraysPre(){   GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute)    GLES20.glActiveTexture(GLES20.GL_TEXTURE3)    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mFilterSourceTexture2)    GLES20.glUniform1i(mFilterInputTextureUniform2,3)    mTexture2CoordinatesBuffer.position(0)    GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute,2,GLES20.GL_FLOAT,false,0,mTexture2CoordinatesBuffer)  } 
public void setRotation(final Rotation rotation,final boolean flipHorizontal,final boolean flipVertical){   float[] buffer=TextureRotationUtil.getRotation(rotation,flipHorizontal,flipVertical)    ByteBuffer bBuffer=ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder())    FloatBuffer fBuffer=bBuffer.asFloatBuffer()    fBuffer.put(buffer)    fBuffer.flip()    mTexture2CoordinatesBuffer=bBuffer  } 
public GPUImageTwoPassFilter(String firstVertexShader,String firstFragmentShader,String secondVertexShader,String secondFragmentShader){   super(null)    addFilter(new GPUImageFilter(firstVertexShader,firstFragmentShader))    addFilter(new GPUImageFilter(secondVertexShader,secondFragmentShader))  } 
public GPUImageTwoPassTextureSamplingFilter(String firstVertexShader,String firstFragmentShader,String secondVertexShader,String secondFragmentShader){   super(firstVertexShader,firstFragmentShader,secondVertexShader,secondFragmentShader)  } 
@Override public void onInit(){   super.onInit()    initTexelOffsets()  } 
protected void initTexelOffsets(){   float ratio=getHorizontalTexelOffsetRatio()    GPUImageFilter filter=mFilters.get(0)    int texelWidthOffsetLocation=GLES20.glGetUniformLocation(filter.getProgram(),"texelWidthOffset")    int texelHeightOffsetLocation=GLES20.glGetUniformLocation(filter.getProgram(),"texelHeightOffset")    filter.setFloat(texelWidthOffsetLocation,ratio / mOutputWidth)    filter.setFloat(texelHeightOffsetLocation,0)    ratio=getVerticalTexelOffsetRatio()    filter=mFilters.get(1)    texelWidthOffsetLocation=GLES20.glGetUniformLocation(filter.getProgram(),"texelWidthOffset")    texelHeightOffsetLocation=GLES20.glGetUniformLocation(filter.getProgram(),"texelHeightOffset")    filter.setFloat(texelWidthOffsetLocation,0)    filter.setFloat(texelHeightOffsetLocation,ratio / mOutputHeight)  } 
@Override public void onOutputSizeChanged(int width,int height){   super.onOutputSizeChanged(width,height)    initTexelOffsets()  } 
public float getVerticalTexelOffsetRatio(){   return 1f  } 
public float getHorizontalTexelOffsetRatio(){   return 1f  } 
public GPUImageView(Context context){   super(context)    init(context,null)  } 
public GPUImageView(Context context,AttributeSet attrs){   super(context,attrs)    init(context,attrs)  } 
private void init(Context context,AttributeSet attrs){   mGLSurfaceView=new GPUImageGLSurfaceView(context,attrs)    addView(mGLSurfaceView)    mGPUImage=new GPUImage(getContext())    mGPUImage.setGLSurfaceView(mGLSurfaceView)  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   if (mRatio != 0.0f) {     int width=MeasureSpec.getSize(widthMeasureSpec)      int height=MeasureSpec.getSize(heightMeasureSpec)      int newHeight      int newWidth      if (width / mRatio < height) {       newWidth=width        newHeight=Math.round(width / mRatio)      }  else {       newHeight=height        newWidth=Math.round(height * mRatio)      }     int newWidthSpec=MeasureSpec.makeMeasureSpec(newWidth,MeasureSpec.EXACTLY)      int newHeightSpec=MeasureSpec.makeMeasureSpec(newHeight,MeasureSpec.EXACTLY)      super.onMeasure(newWidthSpec,newHeightSpec)    }  else {     super.onMeasure(widthMeasureSpec,heightMeasureSpec)    } } 
/**   * Retrieve the GPUImage instance used by this view.  * @return used GPUImage instance  */ public GPUImage getGPUImage(){   return mGPUImage  } 
/**   * Sets the background color  * @param red red color value  * @param green green color value  * @param blue red color value  */ public void setBackgroundColor(float red,float green,float blue){   mGPUImage.setBackgroundColor(red,green,blue)  } 
public void setRatio(float ratio){   mRatio=ratio    mGLSurfaceView.requestLayout()    mGPUImage.deleteImage()  } 
/**   * Set the scale type of GPUImage.  * @param scaleType the new ScaleType  */ public void setScaleType(GPUImage.ScaleType scaleType){   mGPUImage.setScaleType(scaleType)  } 
/**   * Sets the rotation of the displayed image.  * @param rotation new rotation  */ public void setRotation(Rotation rotation){   mGPUImage.setRotation(rotation)    requestRender()  } 
/**   * Set the filter to be applied on the image.  * @param filter Filter that should be applied on the image.  */ public void setFilter(GPUImageFilter filter){   mFilter=filter    mGPUImage.setFilter(filter)    requestRender()  } 
/**   * Get the current applied filter.  * @return the current filter  */ public GPUImageFilter getFilter(){   return mFilter  } 
/**   * Sets the image on which the filter should be applied.  * @param bitmap the new image  */ public void setImage(final Bitmap bitmap){   mGPUImage.setImage(bitmap)  } 
/**   * Sets the image on which the filter should be applied from a Uri.  * @param uri the uri of the new image  */ public void setImage(final Uri uri){   mGPUImage.setImage(uri)  } 
/**   * Sets the image on which the filter should be applied from a File.  * @param file the file of the new image  */ public void setImage(final File file){   mGPUImage.setImage(file)  } 
public void requestRender(){   mGLSurfaceView.requestRender()  } 
/**   * Save current image with applied filter to Pictures. It will be stored on the default Picture folder on the phone below the given folderName and fileName. <br> This method is async and will notify when the image was saved through the listener.  * @param folderName the folder name  * @param fileName the file name  * @param listener the listener  */ public void saveToPictures(final String folderName,final String fileName,final OnPictureSavedListener listener){   new SaveTask(folderName,fileName,listener).execute()  } 
/**   * Save current image with applied filter to Pictures. It will be stored on the default Picture folder on the phone below the given folderName and fileName. <br> This method is async and will notify when the image was saved through the listener.  * @param folderName the folder name  * @param fileName   the file name  * @param width      requested output width  * @param height     requested output height  * @param listener   the listener  */ public void saveToPictures(final String folderName,final String fileName,int width,int height,final OnPictureSavedListener listener){   new SaveTask(folderName,fileName,width,height,listener).execute()  } 
/**   * Retrieve current image with filter applied and given size as Bitmap.  * @param width  requested Bitmap width  * @param height requested Bitmap height  * @return Bitmap of picture with given size  * @throws InterruptedException  */ public Bitmap capture(final int width,final int height) throws InterruptedException {   if (Looper.myLooper() == Looper.getMainLooper()) {     throw new IllegalStateException("Do not call this method from the UI thread!")    }   mForceSize=new Size(width,height)    final Semaphore waiter=new Semaphore(0)    getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){     @Override public void onGlobalLayout(){       if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {         getViewTreeObserver().removeGlobalOnLayoutListener(this)        }  else {         getViewTreeObserver().removeOnGlobalLayoutListener(this)        }       waiter.release()      }   } )    post(new Runnable(){     @Override public void run(){       addView(new LoadingView(getContext()))        mGLSurfaceView.requestLayout()      }   } )    waiter.acquire()    mGPUImage.runOnGLThread(new Runnable(){     @Override public void run(){       waiter.release()      }   } )    requestRender()    waiter.acquire()    Bitmap bitmap=capture()    mForceSize=null    post(new Runnable(){     @Override public void run(){       mGLSurfaceView.requestLayout()      }   } )    requestRender()    postDelayed(new Runnable(){     @Override public void run(){       removeViewAt(1)      }   } ,300)    return bitmap  } 
@Override public void onGlobalLayout(){   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {     getViewTreeObserver().removeGlobalOnLayoutListener(this)    }  else {     getViewTreeObserver().removeOnGlobalLayoutListener(this)    }   waiter.release()  } 
@Override public void run(){   addView(new LoadingView(getContext()))    mGLSurfaceView.requestLayout()  } 
@Override public void run(){   waiter.release()  } 
@Override public void run(){   mGLSurfaceView.requestLayout()  } 
@Override public void run(){   removeViewAt(1)  } 
/**   * Capture the current image with the size as it is displayed and retrieve it as Bitmap.  * @return current output as Bitmap  * @throws InterruptedException  */ public Bitmap capture() throws InterruptedException {   final Semaphore waiter=new Semaphore(0)    final int width=mGLSurfaceView.getMeasuredWidth()    final int height=mGLSurfaceView.getMeasuredHeight()    final int[] pixelMirroredArray=new int[width * height]    mGPUImage.runOnGLThread(new Runnable(){     @Override public void run(){       final IntBuffer pixelBuffer=IntBuffer.allocate(width * height)        GLES20.glReadPixels(0,0,width,height,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,pixelBuffer)        int[] pixelArray=pixelBuffer.array()        for (int i=0  i < height  i++) {         for (int j=0  j < width  j++) {           pixelMirroredArray[(height - i - 1) * width + j]=pixelArray[i * width + j]          }       }       waiter.release()      }   } )    requestRender()    waiter.acquire()    Bitmap bitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888)    bitmap.copyPixelsFromBuffer(IntBuffer.wrap(pixelMirroredArray))    return bitmap  } 
@Override public void run(){   final IntBuffer pixelBuffer=IntBuffer.allocate(width * height)    GLES20.glReadPixels(0,0,width,height,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,pixelBuffer)    int[] pixelArray=pixelBuffer.array()    for (int i=0  i < height  i++) {     for (int j=0  j < width  j++) {       pixelMirroredArray[(height - i - 1) * width + j]=pixelArray[i * width + j]      }   }   waiter.release()  } 
/**   * Pauses the GLSurfaceView.  */ public void onPause(){   mGLSurfaceView.onPause()  } 
/**   * Resumes the GLSurfaceView.  */ public void onResume(){   mGLSurfaceView.onResume()  } 
public Size(int width,int height){   this.width=width    this.height=height  } 
public GPUImageGLSurfaceView(Context context){   super(context)  } 
public GPUImageGLSurfaceView(Context context,AttributeSet attrs){   super(context,attrs)  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   if (mForceSize != null) {     super.onMeasure(MeasureSpec.makeMeasureSpec(mForceSize.width,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mForceSize.height,MeasureSpec.EXACTLY))    }  else {     super.onMeasure(widthMeasureSpec,heightMeasureSpec)    } } 
public LoadingView(Context context){   super(context)    init()  } 
public LoadingView(Context context,AttributeSet attrs){   super(context,attrs)    init()  } 
public LoadingView(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)    init()  } 
private void init(){   ProgressBar view=new ProgressBar(getContext())    view.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,Gravity.CENTER))    addView(view)    setBackgroundColor(Color.BLACK)  } 
public SaveTask(final String folderName,final String fileName,final OnPictureSavedListener listener){   this(folderName,fileName,0,0,listener)  } 
public SaveTask(final String folderName,final String fileName,int width,int height,final OnPictureSavedListener listener){   mFolderName=folderName    mFileName=fileName    mWidth=width    mHeight=height    mListener=listener    mHandler=new Handler()  } 
@Override protected Void doInBackground(final Void... params){   try {     Bitmap result=mWidth != 0 ? capture(mWidth,mHeight) : capture()      saveImage(mFolderName,mFileName,result)    }  catch (  InterruptedException e) {     e.printStackTrace()    }   return null  } 
private void saveImage(final String folderName,final String fileName,final Bitmap image){   File path=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)    File file=new File(path,folderName + "/" + fileName)    try {     file.getParentFile().mkdirs()      image.compress(Bitmap.CompressFormat.JPEG,80,new FileOutputStream(file))      MediaScannerConnection.scanFile(getContext(),new String[]{file.toString()},null,new MediaScannerConnection.OnScanCompletedListener(){       @Override public void onScanCompleted(      final String path,      final Uri uri){         if (mListener != null) {           mHandler.post(new Runnable(){             @Override public void run(){               mListener.onPictureSaved(uri)              }           } )          }       }     } )    }  catch (  FileNotFoundException e) {     e.printStackTrace()    } } 
@Override public void onScanCompleted(final String path,final Uri uri){   if (mListener != null) {     mHandler.post(new Runnable(){       @Override public void run(){         mListener.onPictureSaved(uri)        }     } )    } } 
@Override public void run(){   mListener.onPictureSaved(uri)  } 
void onPictureSaved(Uri uri)  
public GPUImageVignetteFilter(){   this(new PointF(),new float[]{0.0f,0.0f,0.0f},0.3f,0.75f)  } 
public GPUImageVignetteFilter(final PointF vignetteCenter,final float[] vignetteColor,final float vignetteStart,final float vignetteEnd){   super(NO_FILTER_VERTEX_SHADER,VIGNETTING_FRAGMENT_SHADER)    mVignetteCenter=vignetteCenter    mVignetteColor=vignetteColor    mVignetteStart=vignetteStart    mVignetteEnd=vignetteEnd  } 
@Override public void onInit(){   super.onInit()    mVignetteCenterLocation=GLES20.glGetUniformLocation(getProgram(),"vignetteCenter")    mVignetteColorLocation=GLES20.glGetUniformLocation(getProgram(),"vignetteColor")    mVignetteStartLocation=GLES20.glGetUniformLocation(getProgram(),"vignetteStart")    mVignetteEndLocation=GLES20.glGetUniformLocation(getProgram(),"vignetteEnd")    setVignetteCenter(mVignetteCenter)    setVignetteColor(mVignetteColor)    setVignetteStart(mVignetteStart)    setVignetteEnd(mVignetteEnd)  } 
public void setVignetteCenter(final PointF vignetteCenter){   mVignetteCenter=vignetteCenter    setPoint(mVignetteCenterLocation,mVignetteCenter)  } 
public void setVignetteColor(final float[] vignetteColor){   mVignetteColor=vignetteColor    setFloatVec3(mVignetteColorLocation,mVignetteColor)  } 
public void setVignetteStart(final float vignetteStart){   mVignetteStart=vignetteStart    setFloat(mVignetteStartLocation,mVignetteStart)  } 
public void setVignetteEnd(final float vignetteEnd){   mVignetteEnd=vignetteEnd    setFloat(mVignetteEndLocation,mVignetteEnd)  } 
public GPUImageWeakPixelInclusionFilter(){   super(WEAKPIXEL_FRAGMENT_SHADER)  } 
public GPUImageWhiteBalanceFilter(){   this(5000.0f,0.0f)  } 
public GPUImageWhiteBalanceFilter(final float temperature,final float tint){   super(NO_FILTER_VERTEX_SHADER,WHITE_BALANCE_FRAGMENT_SHADER)    mTemperature=temperature    mTint=tint  } 
@Override public void onInit(){   super.onInit()    mTemperatureLocation=GLES20.glGetUniformLocation(getProgram(),"temperature")    mTintLocation=GLES20.glGetUniformLocation(getProgram(),"tint")    setTemperature(mTemperature)    setTint(mTint)  } 
public void setTemperature(final float temperature){   mTemperature=temperature    setFloat(mTemperatureLocation,mTemperature < 5000 ? (float)(0.0004 * (mTemperature - 5000.0)) : (float)(0.00006 * (mTemperature - 5000.0)))  } 
public void setTint(final float tint){   mTint=tint    setFloat(mTintLocation,(float)(mTint / 100.0))  } 
public static int loadTexture(final Bitmap img,final int usedTexId){   return loadTexture(img,usedTexId,true)  } 
public static int loadTexture(final Bitmap img,final int usedTexId,final boolean recycle){   int textures[]=new int[1]    if (usedTexId == NO_TEXTURE) {     GLES20.glGenTextures(1,textures,0)      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,textures[0])      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_LINEAR)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_LINEAR)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE)      GLUtils.texImage2D(GLES20.GL_TEXTURE_2D,0,img,0)    }  else {     GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,usedTexId)      GLUtils.texSubImage2D(GLES20.GL_TEXTURE_2D,0,0,0,img)      textures[0]=usedTexId    }   if (recycle) {     img.recycle()    }   return textures[0]  } 
public static int loadTexture(final IntBuffer data,final Size size,final int usedTexId){   int textures[]=new int[1]    if (usedTexId == NO_TEXTURE) {     GLES20.glGenTextures(1,textures,0)      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,textures[0])      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MAG_FILTER,GLES20.GL_LINEAR)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_MIN_FILTER,GLES20.GL_LINEAR)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_S,GLES20.GL_CLAMP_TO_EDGE)      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,GLES20.GL_TEXTURE_WRAP_T,GLES20.GL_CLAMP_TO_EDGE)      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D,0,GLES20.GL_RGBA,size.width,size.height,0,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,data)    }  else {     GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,usedTexId)      GLES20.glTexSubImage2D(GLES20.GL_TEXTURE_2D,0,0,0,size.width,size.height,GLES20.GL_RGBA,GLES20.GL_UNSIGNED_BYTE,data)      textures[0]=usedTexId    }   return textures[0]  } 
public static int loadTextureAsBitmap(final IntBuffer data,final Size size,final int usedTexId){   Bitmap bitmap=Bitmap.createBitmap(data.array(),size.width,size.height,Config.ARGB_8888)    return loadTexture(bitmap,usedTexId)  } 
public static int loadShader(final String strSource,final int iType){   int[] compiled=new int[1]    int iShader=GLES20.glCreateShader(iType)    GLES20.glShaderSource(iShader,strSource)    GLES20.glCompileShader(iShader)    GLES20.glGetShaderiv(iShader,GLES20.GL_COMPILE_STATUS,compiled,0)    if (compiled[0] == 0) {     Log.d("Load Shader Failed","Compilation\n" + GLES20.glGetShaderInfoLog(iShader))      return 0    }   return iShader  } 
public static int loadProgram(final String strVSource,final String strFSource){   int iVShader    int iFShader    int iProgId    int[] link=new int[1]    iVShader=loadShader(strVSource,GLES20.GL_VERTEX_SHADER)    if (iVShader == 0) {     Log.d("Load Program","Vertex Shader Failed")      return 0    }   iFShader=loadShader(strFSource,GLES20.GL_FRAGMENT_SHADER)    if (iFShader == 0) {     Log.d("Load Program","Fragment Shader Failed")      return 0    }   iProgId=GLES20.glCreateProgram()    GLES20.glAttachShader(iProgId,iVShader)    GLES20.glAttachShader(iProgId,iFShader)    GLES20.glLinkProgram(iProgId)    GLES20.glGetProgramiv(iProgId,GLES20.GL_LINK_STATUS,link,0)    if (link[0] <= 0) {     Log.d("Load Program","Linking Failed")      return 0    }   GLES20.glDeleteShader(iVShader)    GLES20.glDeleteShader(iFShader)    return iProgId  } 
public static float rnd(final float min,final float max){   float fRandNum=(float)Math.random()    return min + (max - min) * fRandNum  } 
public PixelBuffer(final int width,final int height){   mWidth=width    mHeight=height    int[] version=new int[2]    int[] attribList=new int[]{EGL_WIDTH,mWidth,EGL_HEIGHT,mHeight,EGL_NONE}    mEGL=(EGL10)EGLContext.getEGL()    mEGLDisplay=mEGL.eglGetDisplay(EGL_DEFAULT_DISPLAY)    mEGL.eglInitialize(mEGLDisplay,version)    mEGLConfig=chooseConfig()    int EGL_CONTEXT_CLIENT_VERSION=0x3098    int[] attrib_list={EGL_CONTEXT_CLIENT_VERSION,2,EGL10.EGL_NONE}    mEGLContext=mEGL.eglCreateContext(mEGLDisplay,mEGLConfig,EGL_NO_CONTEXT,attrib_list)    mEGLSurface=mEGL.eglCreatePbufferSurface(mEGLDisplay,mEGLConfig,attribList)    mEGL.eglMakeCurrent(mEGLDisplay,mEGLSurface,mEGLSurface,mEGLContext)    mGL=(GL10)mEGLContext.getGL()    mThreadOwner=Thread.currentThread().getName()  } 
public void setRenderer(final GLSurfaceView.Renderer renderer){   mRenderer=renderer    if (!Thread.currentThread().getName().equals(mThreadOwner)) {     Log.e(TAG,"setRenderer: This thread does not own the OpenGL context.")      return    }   mRenderer.onSurfaceCreated(mGL,mEGLConfig)    mRenderer.onSurfaceChanged(mGL,mWidth,mHeight)  } 
public Bitmap getBitmap(){   if (mRenderer == null) {     Log.e(TAG,"getBitmap: Renderer was not set.")      return null    }   if (!Thread.currentThread().getName().equals(mThreadOwner)) {     Log.e(TAG,"getBitmap: This thread does not own the OpenGL context.")      return null    }   mRenderer.onDrawFrame(mGL)    mRenderer.onDrawFrame(mGL)    convertToBitmap()    return mBitmap  } 
public void destroy(){   mRenderer.onDrawFrame(mGL)    mRenderer.onDrawFrame(mGL)    mEGL.eglMakeCurrent(mEGLDisplay,EGL10.EGL_NO_SURFACE,EGL10.EGL_NO_SURFACE,EGL10.EGL_NO_CONTEXT)    mEGL.eglDestroySurface(mEGLDisplay,mEGLSurface)    mEGL.eglDestroyContext(mEGLDisplay,mEGLContext)    mEGL.eglTerminate(mEGLDisplay)  } 
private EGLConfig chooseConfig(){   int[] attribList=new int[]{EGL_DEPTH_SIZE,0,EGL_STENCIL_SIZE,0,EGL_RED_SIZE,8,EGL_GREEN_SIZE,8,EGL_BLUE_SIZE,8,EGL_ALPHA_SIZE,8,EGL10.EGL_RENDERABLE_TYPE,4,EGL_NONE}    int[] numConfig=new int[1]    mEGL.eglChooseConfig(mEGLDisplay,attribList,null,0,numConfig)    int configSize=numConfig[0]    mEGLConfigs=new EGLConfig[configSize]    mEGL.eglChooseConfig(mEGLDisplay,attribList,mEGLConfigs,configSize,numConfig)    if (LIST_CONFIGS) {     listConfig()    }   return mEGLConfigs[0]  } 
private void listConfig(){   Log.i(TAG,"Config List {")    for (  EGLConfig config : mEGLConfigs) {     int d, s, r, g, b, a      d=getConfigAttrib(config,EGL_DEPTH_SIZE)      s=getConfigAttrib(config,EGL_STENCIL_SIZE)      r=getConfigAttrib(config,EGL_RED_SIZE)      g=getConfigAttrib(config,EGL_GREEN_SIZE)      b=getConfigAttrib(config,EGL_BLUE_SIZE)      a=getConfigAttrib(config,EGL_ALPHA_SIZE)      Log.i(TAG,"    <d,s,r,g,b,a> = <" + d + ","+ s+ ","+ r+ ","+ g+ ","+ b+ ","+ a+ ">")    }   Log.i(TAG,"}")  } 
private int getConfigAttrib(final EGLConfig config,final int attribute){   int[] value=new int[1]    return mEGL.eglGetConfigAttrib(mEGLDisplay,config,attribute,value) ? value[0] : 0  } 
private void convertToBitmap(){   int[] iat=new int[mWidth * mHeight]    IntBuffer ib=IntBuffer.allocate(mWidth * mHeight)    mGL.glReadPixels(0,0,mWidth,mHeight,GL_RGBA,GL_UNSIGNED_BYTE,ib)    int[] ia=ib.array()    for (int i=0  i < mHeight  i++) {     for (int j=0  j < mWidth  j++) {       iat[(mHeight - i - 1) * mWidth + j]=ia[i * mWidth + j]      }   }   mBitmap=Bitmap.createBitmap(mWidth,mHeight,Bitmap.Config.ARGB_8888)    mBitmap.copyPixelsFromBuffer(IntBuffer.wrap(iat))  } 
private TextureRotationUtil(){ } 
public static float[] getRotation(final Rotation rotation,final boolean flipHorizontal,final boolean flipVertical){   float[] rotatedTex  switch (rotation) { case ROTATION_90:     rotatedTex=TEXTURE_ROTATED_90    break  case ROTATION_180: rotatedTex=TEXTURE_ROTATED_180  break  case ROTATION_270: rotatedTex=TEXTURE_ROTATED_270  break  case NORMAL: default : rotatedTex=TEXTURE_NO_ROTATION  break  } if (flipHorizontal) { rotatedTex=new float[]{flip(rotatedTex[0]),rotatedTex[1],flip(rotatedTex[2]),rotatedTex[3],flip(rotatedTex[4]),rotatedTex[5],flip(rotatedTex[6]),rotatedTex[7]}  } if (flipVertical) { rotatedTex=new float[]{rotatedTex[0],flip(rotatedTex[1]),rotatedTex[2],flip(rotatedTex[3]),rotatedTex[4],flip(rotatedTex[5]),rotatedTex[6],flip(rotatedTex[7])}  } return rotatedTex  } 
private static float flip(final float i){   if (i == 0.0f) {     return 1.0f    }   return 0.0f  } 
@Override public void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_camera)    ((SeekBar)findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this)    findViewById(R.id.button_choose_filter).setOnClickListener(this)    findViewById(R.id.button_capture).setOnClickListener(this)    mGPUImage=new GPUImage(this)    mGPUImage.setGLSurfaceView((GLSurfaceView)findViewById(R.id.surfaceView))    mCameraHelper=new CameraHelper(this)    mCamera=new CameraLoader()    View cameraSwitchView=findViewById(R.id.img_switch_camera)    cameraSwitchView.setOnClickListener(this)    if (!mCameraHelper.hasFrontCamera() || !mCameraHelper.hasBackCamera()) {     cameraSwitchView.setVisibility(View.GONE)    } } 
@Override protected void onResume(){   super.onResume()    mCamera.onResume()  } 
@Override protected void onPause(){   mCamera.onPause()    super.onPause()  } 
@Override public void onClick(final View v){ switch (v.getId()) { case R.id.button_choose_filter:     GPUImageFilterTools.showDialog(this,new OnGpuImageFilterChosenListener(){       @Override public void onGpuImageFilterChosenListener(      final GPUImageFilter filter){         switchFilterTo(filter)        }     } )    break  case R.id.button_capture: if (mCamera.mCameraInstance.getParameters().getFocusMode().equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {   takePicture()  }  else {   mCamera.mCameraInstance.autoFocus(new Camera.AutoFocusCallback(){     @Override public void onAutoFocus(    final boolean success,    final Camera camera){       takePicture()      }   } )  } break  case R.id.img_switch_camera: mCamera.switchCamera()  break  } } 
@Override public void onGpuImageFilterChosenListener(final GPUImageFilter filter){   switchFilterTo(filter)  } 
@Override public void onAutoFocus(final boolean success,final Camera camera){   takePicture()  } 
private void takePicture(){   Camera.Parameters params=mCamera.mCameraInstance.getParameters()    params.setRotation(90)    mCamera.mCameraInstance.setParameters(params)    for (  Camera.Size size : params.getSupportedPictureSizes()) {     Log.i("ASDF","Supported: " + size.width + "x"+ size.height)    }   mCamera.mCameraInstance.takePicture(null,null,new Camera.PictureCallback(){     @Override public void onPictureTaken(    byte[] data,    final Camera camera){       final File pictureFile=getOutputMediaFile(MEDIA_TYPE_IMAGE)        if (pictureFile == null) {         Log.d("ASDF","Error creating media file, check storage permissions")          return        }       try {         FileOutputStream fos=new FileOutputStream(pictureFile)          fos.write(data)          fos.close()        }  catch (      FileNotFoundException e) {         Log.d("ASDF","File not found: " + e.getMessage())        } catch (      IOException e) {         Log.d("ASDF","Error accessing file: " + e.getMessage())        }       data=null        Bitmap bitmap=BitmapFactory.decodeFile(pictureFile.getAbsolutePath())        final GLSurfaceView view=(GLSurfaceView)findViewById(R.id.surfaceView)        view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY)        mGPUImage.saveToPictures(bitmap,"GPUImage",System.currentTimeMillis() + ".jpg",new OnPictureSavedListener(){         @Override public void onPictureSaved(        final Uri uri){           pictureFile.delete()            camera.startPreview()            view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY)          }       } )      }   } )  } 
@Override public void onPictureTaken(byte[] data,final Camera camera){   final File pictureFile=getOutputMediaFile(MEDIA_TYPE_IMAGE)    if (pictureFile == null) {     Log.d("ASDF","Error creating media file, check storage permissions")      return    }   try {     FileOutputStream fos=new FileOutputStream(pictureFile)      fos.write(data)      fos.close()    }  catch (  FileNotFoundException e) {     Log.d("ASDF","File not found: " + e.getMessage())    } catch (  IOException e) {     Log.d("ASDF","Error accessing file: " + e.getMessage())    }   data=null    Bitmap bitmap=BitmapFactory.decodeFile(pictureFile.getAbsolutePath())    final GLSurfaceView view=(GLSurfaceView)findViewById(R.id.surfaceView)    view.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY)    mGPUImage.saveToPictures(bitmap,"GPUImage",System.currentTimeMillis() + ".jpg",new OnPictureSavedListener(){     @Override public void onPictureSaved(    final Uri uri){       pictureFile.delete()        camera.startPreview()        view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY)      }   } )  } 
@Override public void onPictureSaved(final Uri uri){   pictureFile.delete()    camera.startPreview()    view.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY)  } 
private static File getOutputMediaFile(final int type){   File mediaStorageDir=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),"MyCameraApp")    if (!mediaStorageDir.exists()) {     if (!mediaStorageDir.mkdirs()) {       Log.d("MyCameraApp","failed to create directory")        return null      }   }   String timeStamp=new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date())    File mediaFile    if (type == MEDIA_TYPE_IMAGE) {     mediaFile=new File(mediaStorageDir.getPath() + File.separator + "IMG_"+ timeStamp+ ".jpg")    }  else   if (type == MEDIA_TYPE_VIDEO) {     mediaFile=new File(mediaStorageDir.getPath() + File.separator + "VID_"+ timeStamp+ ".mp4")    }  else {     return null    }   return mediaFile  } 
private void switchFilterTo(final GPUImageFilter filter){   if (mFilter == null || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {     mFilter=filter      mGPUImage.setFilter(mFilter)      mFilterAdjuster=new FilterAdjuster(mFilter)    } } 
@Override public void onProgressChanged(final SeekBar seekBar,final int progress,final boolean fromUser){   if (mFilterAdjuster != null) {     mFilterAdjuster.adjust(progress)    } } 
@Override public void onStartTrackingTouch(final SeekBar seekBar){ } 
@Override public void onStopTrackingTouch(final SeekBar seekBar){ } 
public void onResume(){   setUpCamera(mCurrentCameraId)  } 
public void onPause(){   releaseCamera()  } 
public void switchCamera(){   releaseCamera()    mCurrentCameraId=(mCurrentCameraId + 1) % mCameraHelper.getNumberOfCameras()    setUpCamera(mCurrentCameraId)  } 
private void setUpCamera(final int id){   mCameraInstance=getCameraInstance(id)    Parameters parameters=mCameraInstance.getParameters()    if (parameters.getSupportedFocusModes().contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {     parameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)    }   mCameraInstance.setParameters(parameters)    int orientation=mCameraHelper.getCameraDisplayOrientation(ActivityCamera.this,mCurrentCameraId)    CameraInfo2 cameraInfo=new CameraInfo2()    mCameraHelper.getCameraInfo(mCurrentCameraId,cameraInfo)    boolean flipHorizontal=cameraInfo.facing == CameraInfo.CAMERA_FACING_FRONT    mGPUImage.setUpCamera(mCameraInstance,orientation,flipHorizontal,false)  } 
/**   * A safe way to get an instance of the Camera object.   */ private Camera getCameraInstance(final int id){   Camera c=null    try {     c=mCameraHelper.openCamera(id)    }  catch (  Exception e) {     e.printStackTrace()    }   return c  } 
private void releaseCamera(){   mCameraInstance.setPreviewCallback(null)    mCameraInstance.release()    mCameraInstance=null  } 
@Override public void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_gallery)    ((SeekBar)findViewById(R.id.seekBar)).setOnSeekBarChangeListener(this)    findViewById(R.id.button_choose_filter).setOnClickListener(this)    findViewById(R.id.button_save).setOnClickListener(this)    mGPUImageView=(GPUImageView)findViewById(R.id.gpuimage)    Intent photoPickerIntent=new Intent(Intent.ACTION_PICK)    photoPickerIntent.setType("image/*")    startActivityForResult(photoPickerIntent,REQUEST_PICK_IMAGE)  } 
@Override protected void onActivityResult(final int requestCode,final int resultCode,final Intent data){ switch (requestCode) { case REQUEST_PICK_IMAGE:     if (resultCode == RESULT_OK) {       handleImage(data.getData())      }  else {       finish()      }   break  default : super.onActivityResult(requestCode,resultCode,data)  break  } } 
@Override public void onClick(final View v){ switch (v.getId()) { case R.id.button_choose_filter:     GPUImageFilterTools.showDialog(this,new OnGpuImageFilterChosenListener(){       @Override public void onGpuImageFilterChosenListener(      final GPUImageFilter filter){         switchFilterTo(filter)          mGPUImageView.requestRender()        }     } )    break  case R.id.button_save: saveImage()  break  default : break  } } 
@Override public void onGpuImageFilterChosenListener(final GPUImageFilter filter){   switchFilterTo(filter)    mGPUImageView.requestRender()  } 
@Override public void onPictureSaved(final Uri uri){   Toast.makeText(this,"Saved: " + uri.toString(),Toast.LENGTH_SHORT).show()  } 
private void saveImage(){   String fileName=System.currentTimeMillis() + ".jpg"    mGPUImageView.saveToPictures("GPUImage",fileName,this)  } 
private void switchFilterTo(final GPUImageFilter filter){   if (mFilter == null || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {     mFilter=filter      mGPUImageView.setFilter(mFilter)      mFilterAdjuster=new FilterAdjuster(mFilter)      findViewById(R.id.seekBar).setVisibility(mFilterAdjuster.canAdjust() ? View.VISIBLE : View.GONE)    } } 
@Override public void onProgressChanged(final SeekBar seekBar,final int progress,final boolean fromUser){   if (mFilterAdjuster != null) {     mFilterAdjuster.adjust(progress)    }   mGPUImageView.requestRender()  } 
@Override public void onStartTrackingTouch(final SeekBar seekBar){ } 
@Override public void onStopTrackingTouch(final SeekBar seekBar){ } 
private void handleImage(final Uri selectedImage){   mGPUImageView.setImage(selectedImage)  } 
@Override public void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    findViewById(R.id.button_gallery).setOnClickListener(this)    findViewById(R.id.button_camera).setOnClickListener(this)  } 
@Override public void onClick(final View v){   if (PermissionChecker.checkSelfPermission(this,Manifest.permission.CAMERA) == PackageManager.PERMISSION_DENIED) {     ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.CAMERA},v.getId())    }  else {     startActivity(v.getId())    } } 
@Override public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){   if (grantResults.length != 1 || grantResults[0] == PackageManager.PERMISSION_GRANTED) {     startActivity(requestCode)    }  else {     super.onRequestPermissionsResult(requestCode,permissions,grantResults)    } } 
private void startActivity(int id){ switch (id) { case R.id.button_gallery:     startActivity(new Intent(this,ActivityGallery.class))    break  case R.id.button_camera: startActivity(new Intent(this,ActivityCamera.class))  break  default : break  } } 
public static void showDialog(final Context context,final OnGpuImageFilterChosenListener listener){   final FilterList filters=new FilterList()    filters.addFilter("Contrast",FilterType.CONTRAST)    filters.addFilter("Invert",FilterType.INVERT)    filters.addFilter("Pixelation",FilterType.PIXELATION)    filters.addFilter("Hue",FilterType.HUE)    filters.addFilter("Gamma",FilterType.GAMMA)    filters.addFilter("Brightness",FilterType.BRIGHTNESS)    filters.addFilter("Sepia",FilterType.SEPIA)    filters.addFilter("Grayscale",FilterType.GRAYSCALE)    filters.addFilter("Sharpness",FilterType.SHARPEN)    filters.addFilter("Sobel Edge Detection",FilterType.SOBEL_EDGE_DETECTION)    filters.addFilter("3x3 Convolution",FilterType.THREE_X_THREE_CONVOLUTION)    filters.addFilter("Emboss",FilterType.EMBOSS)    filters.addFilter("Posterize",FilterType.POSTERIZE)    filters.addFilter("Grouped filters",FilterType.FILTER_GROUP)    filters.addFilter("Saturation",FilterType.SATURATION)    filters.addFilter("Exposure",FilterType.EXPOSURE)    filters.addFilter("Highlight Shadow",FilterType.HIGHLIGHT_SHADOW)    filters.addFilter("Monochrome",FilterType.MONOCHROME)    filters.addFilter("Opacity",FilterType.OPACITY)    filters.addFilter("RGB",FilterType.RGB)    filters.addFilter("White Balance",FilterType.WHITE_BALANCE)    filters.addFilter("Vignette",FilterType.VIGNETTE)    filters.addFilter("ToneCurve",FilterType.TONE_CURVE)    filters.addFilter("Blend (Difference)",FilterType.BLEND_DIFFERENCE)    filters.addFilter("Blend (Source Over)",FilterType.BLEND_SOURCE_OVER)    filters.addFilter("Blend (Color Burn)",FilterType.BLEND_COLOR_BURN)    filters.addFilter("Blend (Color Dodge)",FilterType.BLEND_COLOR_DODGE)    filters.addFilter("Blend (Darken)",FilterType.BLEND_DARKEN)    filters.addFilter("Blend (Dissolve)",FilterType.BLEND_DISSOLVE)    filters.addFilter("Blend (Exclusion)",FilterType.BLEND_EXCLUSION)    filters.addFilter("Blend (Hard Light)",FilterType.BLEND_HARD_LIGHT)    filters.addFilter("Blend (Lighten)",FilterType.BLEND_LIGHTEN)    filters.addFilter("Blend (Add)",FilterType.BLEND_ADD)    filters.addFilter("Blend (Divide)",FilterType.BLEND_DIVIDE)    filters.addFilter("Blend (Multiply)",FilterType.BLEND_MULTIPLY)    filters.addFilter("Blend (Overlay)",FilterType.BLEND_OVERLAY)    filters.addFilter("Blend (Screen)",FilterType.BLEND_SCREEN)    filters.addFilter("Blend (Alpha)",FilterType.BLEND_ALPHA)    filters.addFilter("Blend (Color)",FilterType.BLEND_COLOR)    filters.addFilter("Blend (Hue)",FilterType.BLEND_HUE)    filters.addFilter("Blend (Saturation)",FilterType.BLEND_SATURATION)    filters.addFilter("Blend (Luminosity)",FilterType.BLEND_LUMINOSITY)    filters.addFilter("Blend (Linear Burn)",FilterType.BLEND_LINEAR_BURN)    filters.addFilter("Blend (Soft Light)",FilterType.BLEND_SOFT_LIGHT)    filters.addFilter("Blend (Subtract)",FilterType.BLEND_SUBTRACT)    filters.addFilter("Blend (Chroma Key)",FilterType.BLEND_CHROMA_KEY)    filters.addFilter("Blend (Normal)",FilterType.BLEND_NORMAL)    filters.addFilter("Lookup (Amatorka)",FilterType.LOOKUP_AMATORKA)    filters.addFilter("Gaussian Blur",FilterType.GAUSSIAN_BLUR)    filters.addFilter("Crosshatch",FilterType.CROSSHATCH)    filters.addFilter("Box Blur",FilterType.BOX_BLUR)    filters.addFilter("CGA Color Space",FilterType.CGA_COLORSPACE)    filters.addFilter("Dilation",FilterType.DILATION)    filters.addFilter("Kuwahara",FilterType.KUWAHARA)    filters.addFilter("RGB Dilation",FilterType.RGB_DILATION)    filters.addFilter("Sketch",FilterType.SKETCH)    filters.addFilter("Toon",FilterType.TOON)    filters.addFilter("Smooth Toon",FilterType.SMOOTH_TOON)    filters.addFilter("Halftone",FilterType.HALFTONE)    filters.addFilter("Bulge Distortion",FilterType.BULGE_DISTORTION)    filters.addFilter("Glass Sphere",FilterType.GLASS_SPHERE)    filters.addFilter("Haze",FilterType.HAZE)    filters.addFilter("Laplacian",FilterType.LAPLACIAN)    filters.addFilter("Non Maximum Suppression",FilterType.NON_MAXIMUM_SUPPRESSION)    filters.addFilter("Sphere Refraction",FilterType.SPHERE_REFRACTION)    filters.addFilter("Swirl",FilterType.SWIRL)    filters.addFilter("Weak Pixel Inclusion",FilterType.WEAK_PIXEL_INCLUSION)    filters.addFilter("False Color",FilterType.FALSE_COLOR)    filters.addFilter("Color Balance",FilterType.COLOR_BALANCE)    filters.addFilter("Levels Min (Mid Adjust)",FilterType.LEVELS_FILTER_MIN)    filters.addFilter("Bilateral Blur",FilterType.BILATERAL_BLUR)    filters.addFilter("Transform (2-D)",FilterType.TRANSFORM2D)    AlertDialog.Builder builder=new AlertDialog.Builder(context)    builder.setTitle("Choose a filter")    builder.setItems(filters.names.toArray(new String[filters.names.size()]),new DialogInterface.OnClickListener(){     @Override public void onClick(    final DialogInterface dialog,    final int item){       listener.onGpuImageFilterChosenListener(createFilterForType(context,filters.filters.get(item)))      }   } )    builder.create().show()  } 
@Override public void onClick(final DialogInterface dialog,final int item){   listener.onGpuImageFilterChosenListener(createFilterForType(context,filters.filters.get(item)))  } 
private static GPUImageFilter createFilterForType(final Context context,final FilterType type){ switch (type) { case CONTRAST:     return new GPUImageContrastFilter(2.0f)  case GAMMA:   return new GPUImageGammaFilter(2.0f)  case INVERT: return new GPUImageColorInvertFilter()  case PIXELATION: return new GPUImagePixelationFilter()  case HUE: return new GPUImageHueFilter(90.0f)  case BRIGHTNESS: return new GPUImageBrightnessFilter(1.5f)  case GRAYSCALE: return new GPUImageGrayscaleFilter()  case SEPIA: return new GPUImageSepiaFilter()  case SHARPEN: GPUImageSharpenFilter sharpness=new GPUImageSharpenFilter()  sharpness.setSharpness(2.0f)  return sharpness  case SOBEL_EDGE_DETECTION: return new GPUImageSobelEdgeDetection()  case THREE_X_THREE_CONVOLUTION: GPUImage3x3ConvolutionFilter convolution=new GPUImage3x3ConvolutionFilter()  convolution.setConvolutionKernel(new float[]{-1.0f,0.0f,1.0f,-2.0f,0.0f,2.0f,-1.0f,0.0f,1.0f})  return convolution  case EMBOSS: return new GPUImageEmbossFilter()  case POSTERIZE: return new GPUImagePosterizeFilter()  case FILTER_GROUP: List<GPUImageFilter> filters=new LinkedList<GPUImageFilter>()  filters.add(new GPUImageContrastFilter())  filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter())  filters.add(new GPUImageGrayscaleFilter())  return new GPUImageFilterGroup(filters)  case SATURATION: return new GPUImageSaturationFilter(1.0f)  case EXPOSURE: return new GPUImageExposureFilter(0.0f)  case HIGHLIGHT_SHADOW: return new GPUImageHighlightShadowFilter(0.0f,1.0f)  case MONOCHROME: return new GPUImageMonochromeFilter(1.0f,new float[]{0.6f,0.45f,0.3f,1.0f})  case OPACITY: return new GPUImageOpacityFilter(1.0f)  case RGB: return new GPUImageRGBFilter(1.0f,1.0f,1.0f)  case WHITE_BALANCE: return new GPUImageWhiteBalanceFilter(5000.0f,0.0f)  case VIGNETTE: PointF centerPoint=new PointF()  centerPoint.x=0.5f  centerPoint.y=0.5f  return new GPUImageVignetteFilter(centerPoint,new float[]{0.0f,0.0f,0.0f},0.3f,0.75f)  case TONE_CURVE: GPUImageToneCurveFilter toneCurveFilter=new GPUImageToneCurveFilter()  toneCurveFilter.setFromCurveFileInputStream(context.getResources().openRawResource(R.raw.tone_cuver_sample))  return toneCurveFilter  case BLEND_DIFFERENCE: return createBlendFilter(context,GPUImageDifferenceBlendFilter.class)  case BLEND_SOURCE_OVER: return createBlendFilter(context,GPUImageSourceOverBlendFilter.class)  case BLEND_COLOR_BURN: return createBlendFilter(context,GPUImageColorBurnBlendFilter.class)  case BLEND_COLOR_DODGE: return createBlendFilter(context,GPUImageColorDodgeBlendFilter.class)  case BLEND_DARKEN: return createBlendFilter(context,GPUImageDarkenBlendFilter.class)  case BLEND_DISSOLVE: return createBlendFilter(context,GPUImageDissolveBlendFilter.class)  case BLEND_EXCLUSION: return createBlendFilter(context,GPUImageExclusionBlendFilter.class)  case BLEND_HARD_LIGHT: return createBlendFilter(context,GPUImageHardLightBlendFilter.class)  case BLEND_LIGHTEN: return createBlendFilter(context,GPUImageLightenBlendFilter.class)  case BLEND_ADD: return createBlendFilter(context,GPUImageAddBlendFilter.class)  case BLEND_DIVIDE: return createBlendFilter(context,GPUImageDivideBlendFilter.class)  case BLEND_MULTIPLY: return createBlendFilter(context,GPUImageMultiplyBlendFilter.class)  case BLEND_OVERLAY: return createBlendFilter(context,GPUImageOverlayBlendFilter.class)  case BLEND_SCREEN: return createBlendFilter(context,GPUImageScreenBlendFilter.class)  case BLEND_ALPHA: return createBlendFilter(context,GPUImageAlphaBlendFilter.class)  case BLEND_COLOR: return createBlendFilter(context,GPUImageColorBlendFilter.class)  case BLEND_HUE: return createBlendFilter(context,GPUImageHueBlendFilter.class)  case BLEND_SATURATION: return createBlendFilter(context,GPUImageSaturationBlendFilter.class)  case BLEND_LUMINOSITY: return createBlendFilter(context,GPUImageLuminosityBlendFilter.class)  case BLEND_LINEAR_BURN: return createBlendFilter(context,GPUImageLinearBurnBlendFilter.class)  case BLEND_SOFT_LIGHT: return createBlendFilter(context,GPUImageSoftLightBlendFilter.class)  case BLEND_SUBTRACT: return createBlendFilter(context,GPUImageSubtractBlendFilter.class)  case BLEND_CHROMA_KEY: return createBlendFilter(context,GPUImageChromaKeyBlendFilter.class)  case BLEND_NORMAL: return createBlendFilter(context,GPUImageNormalBlendFilter.class)  case LOOKUP_AMATORKA: GPUImageLookupFilter amatorka=new GPUImageLookupFilter()  amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(),R.drawable.lookup_amatorka))  return amatorka  case GAUSSIAN_BLUR: return new GPUImageGaussianBlurFilter()  case CROSSHATCH: return new GPUImageCrosshatchFilter()  case BOX_BLUR: return new GPUImageBoxBlurFilter()  case CGA_COLORSPACE: return new GPUImageCGAColorspaceFilter()  case DILATION: return new GPUImageDilationFilter()  case KUWAHARA: return new GPUImageKuwaharaFilter()  case RGB_DILATION: return new GPUImageRGBDilationFilter()  case SKETCH: return new GPUImageSketchFilter()  case TOON: return new GPUImageToonFilter()  case SMOOTH_TOON: return new GPUImageSmoothToonFilter()  case BULGE_DISTORTION: return new GPUImageBulgeDistortionFilter()  case GLASS_SPHERE: return new GPUImageGlassSphereFilter()  case HAZE: return new GPUImageHazeFilter()  case LAPLACIAN: return new GPUImageLaplacianFilter()  case NON_MAXIMUM_SUPPRESSION: return new GPUImageNonMaximumSuppressionFilter()  case SPHERE_REFRACTION: return new GPUImageSphereRefractionFilter()  case SWIRL: return new GPUImageSwirlFilter()  case WEAK_PIXEL_INCLUSION: return new GPUImageWeakPixelInclusionFilter()  case FALSE_COLOR: return new GPUImageFalseColorFilter()  case COLOR_BALANCE: return new GPUImageColorBalanceFilter()  case LEVELS_FILTER_MIN: GPUImageLevelsFilter levelsFilter=new GPUImageLevelsFilter()  levelsFilter.setMin(0.0f,3.0f,1.0f)  return levelsFilter  case HALFTONE: return new GPUImageHalftoneFilter()  case BILATERAL_BLUR: return new GPUImageBilateralFilter()  case TRANSFORM2D: return new GPUImageTransformFilter()  default : throw new IllegalStateException("No filter of that type!")  } } 
private static GPUImageFilter createBlendFilter(Context context,Class<? extends GPUImageTwoInputFilter> filterClass){   try {     GPUImageTwoInputFilter filter=filterClass.newInstance()      filter.setBitmap(BitmapFactory.decodeResource(context.getResources(),R.drawable.ic_launcher))      return filter    }  catch (  Exception e) {     e.printStackTrace()      return null    } } 
void onGpuImageFilterChosenListener(GPUImageFilter filter)  
public void addFilter(final String name,final FilterType filter){   names.add(name)    filters.add(filter)  } 
public FilterAdjuster(final GPUImageFilter filter){   if (filter instanceof GPUImageSharpenFilter) {     adjuster=new SharpnessAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageSepiaFilter) {     adjuster=new SepiaAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageContrastFilter) {     adjuster=new ContrastAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageGammaFilter) {     adjuster=new GammaAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageBrightnessFilter) {     adjuster=new BrightnessAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageSobelEdgeDetection) {     adjuster=new SobelAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageEmbossFilter) {     adjuster=new EmbossAdjuster().filter(filter)    }  else   if (filter instanceof GPUImage3x3TextureSamplingFilter) {     adjuster=new GPU3x3TextureAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageHueFilter) {     adjuster=new HueAdjuster().filter(filter)    }  else   if (filter instanceof GPUImagePosterizeFilter) {     adjuster=new PosterizeAdjuster().filter(filter)    }  else   if (filter instanceof GPUImagePixelationFilter) {     adjuster=new PixelationAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageSaturationFilter) {     adjuster=new SaturationAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageExposureFilter) {     adjuster=new ExposureAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageHighlightShadowFilter) {     adjuster=new HighlightShadowAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageMonochromeFilter) {     adjuster=new MonochromeAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageOpacityFilter) {     adjuster=new OpacityAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageRGBFilter) {     adjuster=new RGBAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageWhiteBalanceFilter) {     adjuster=new WhiteBalanceAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageVignetteFilter) {     adjuster=new VignetteAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageDissolveBlendFilter) {     adjuster=new DissolveBlendAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageGaussianBlurFilter) {     adjuster=new GaussianBlurAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageCrosshatchFilter) {     adjuster=new CrosshatchBlurAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageBulgeDistortionFilter) {     adjuster=new BulgeDistortionAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageGlassSphereFilter) {     adjuster=new GlassSphereAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageHazeFilter) {     adjuster=new HazeAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageSphereRefractionFilter) {     adjuster=new SphereRefractionAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageSwirlFilter) {     adjuster=new SwirlAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageColorBalanceFilter) {     adjuster=new ColorBalanceAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageLevelsFilter) {     adjuster=new LevelsMinMidAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageBilateralFilter) {     adjuster=new BilateralAdjuster().filter(filter)    }  else   if (filter instanceof GPUImageTransformFilter) {     adjuster=new RotateAdjuster().filter(filter)    }  else {     adjuster=null    } } 
public boolean canAdjust(){   return adjuster != null  } 
public void adjust(final int percentage){   if (adjuster != null) {     adjuster.adjust(percentage)    } } 
@SuppressWarnings("unchecked") public Adjuster<T> filter(final GPUImageFilter filter){   this.filter=(T)filter    return this  } 
public T getFilter(){   return filter  } 
public abstract void adjust(int percentage)  
protected float range(final int percentage,final float start,final float end){   return (end - start) * percentage / 100.0f + start  } 
protected int range(final int percentage,final int start,final int end){   return (end - start) * percentage / 100 + start  } 
@Override public void adjust(final int percentage){   getFilter().setSharpness(range(percentage,-4.0f,4.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setPixel(range(percentage,1.0f,100.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setHue(range(percentage,0.0f,360.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setContrast(range(percentage,0.0f,2.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setGamma(range(percentage,0.0f,3.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setBrightness(range(percentage,-1.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setIntensity(range(percentage,0.0f,2.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setLineSize(range(percentage,0.0f,5.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setIntensity(range(percentage,0.0f,4.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setColorLevels(range(percentage,1,50))  } 
@Override public void adjust(final int percentage){   getFilter().setLineSize(range(percentage,0.0f,5.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setSaturation(range(percentage,0.0f,2.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setExposure(range(percentage,-10.0f,10.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setShadows(range(percentage,0.0f,1.0f))    getFilter().setHighlights(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setIntensity(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setOpacity(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setRed(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setTemperature(range(percentage,2000.0f,8000.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setVignetteStart(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setMix(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setBlurSize(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setCrossHatchSpacing(range(percentage,0.0f,0.06f))    getFilter().setLineWidth(range(percentage,0.0f,0.006f))  } 
@Override public void adjust(final int percentage){   getFilter().setRadius(range(percentage,0.0f,1.0f))    getFilter().setScale(range(percentage,-1.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setRadius(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setDistance(range(percentage,-0.3f,0.3f))    getFilter().setSlope(range(percentage,-0.3f,0.3f))  } 
@Override public void adjust(final int percentage){   getFilter().setRadius(range(percentage,0.0f,1.0f))  } 
@Override public void adjust(final int percentage){   getFilter().setAngle(range(percentage,0.0f,2.0f))  } 
@Override public void adjust(int percentage){   getFilter().setMidtones(new float[]{range(percentage,0.0f,1.0f),range(percentage / 2,0.0f,1.0f),range(percentage / 3,0.0f,1.0f)})  } 
@Override public void adjust(int percentage){   getFilter().setMin(0.0f,range(percentage,0.0f,1.0f),1.0f)  } 
@Override public void adjust(final int percentage){   getFilter().setDistanceNormalizationFactor(range(percentage,0.0f,15.0f))  } 
@Override public void adjust(final int percentage){   float[] transform=new float[16]    Matrix.setRotateM(transform,0,360 * percentage / 100,0,0,1.0f)    getFilter().setTransform3D(transform)  } 
public CameraHelper(final Context context){   if (SDK_INT >= GINGERBREAD) {     mImpl=new CameraHelperGB()    }  else {     mImpl=new CameraHelperBase(context)    } } 
int getNumberOfCameras()  
Camera openCamera(int id)  
Camera openDefaultCamera()  
Camera openCameraFacing(int facing)  
boolean hasCamera(int cameraFacingFront)  
void getCameraInfo(int cameraId,CameraInfo2 cameraInfo)  
public int getNumberOfCameras(){   return mImpl.getNumberOfCameras()  } 
public Camera openCamera(final int id){   return mImpl.openCamera(id)  } 
public Camera openDefaultCamera(){   return mImpl.openDefaultCamera()  } 
public Camera openFrontCamera(){   return mImpl.openCameraFacing(CameraInfo.CAMERA_FACING_FRONT)  } 
public Camera openBackCamera(){   return mImpl.openCameraFacing(CameraInfo.CAMERA_FACING_BACK)  } 
public boolean hasFrontCamera(){   return mImpl.hasCamera(CameraInfo.CAMERA_FACING_FRONT)  } 
public boolean hasBackCamera(){   return mImpl.hasCamera(CameraInfo.CAMERA_FACING_BACK)  } 
public void getCameraInfo(final int cameraId,final CameraInfo2 cameraInfo){   mImpl.getCameraInfo(cameraId,cameraInfo)  } 
public void setCameraDisplayOrientation(final Activity activity,final int cameraId,final Camera camera){   int result=getCameraDisplayOrientation(activity,cameraId)    camera.setDisplayOrientation(result)  } 
public int getCameraDisplayOrientation(final Activity activity,final int cameraId){   int rotation=activity.getWindowManager().getDefaultDisplay().getRotation()    int degrees=0  switch (rotation) { case Surface.ROTATION_0:     degrees=0    break  case Surface.ROTATION_90: degrees=90  break  case Surface.ROTATION_180: degrees=180  break  case Surface.ROTATION_270: degrees=270  break  } int result  CameraInfo2 info=new CameraInfo2()  getCameraInfo(cameraId,info)  if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) { result=(info.orientation + degrees) % 360  }  else { result=(info.orientation - degrees + 360) % 360  } return result  } 
public CameraHelperBase(final Context context){   mContext=context  } 
@Override public int getNumberOfCameras(){   return hasCameraSupport() ? 1 : 0  } 
@Override public Camera openCamera(final int id){   return Camera.open()  } 
@Override public Camera openDefaultCamera(){   return Camera.open()  } 
@Override public boolean hasCamera(final int facing){   if (facing == CameraInfo.CAMERA_FACING_BACK) {     return hasCameraSupport()    }   return false  } 
@Override public Camera openCameraFacing(final int facing){   if (facing == CameraInfo.CAMERA_FACING_BACK) {     return Camera.open()    }   return null  } 
@Override public void getCameraInfo(final int cameraId,final CameraInfo2 cameraInfo){   cameraInfo.facing=Camera.CameraInfo.CAMERA_FACING_BACK    cameraInfo.orientation=90  } 
private boolean hasCameraSupport(){   return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)  } 
@Override public int getNumberOfCameras(){   return Camera.getNumberOfCameras()  } 
@Override public Camera openCamera(final int id){   return Camera.open(id)  } 
@Override public Camera openDefaultCamera(){   return Camera.open(0)  } 
@Override public boolean hasCamera(final int facing){   return getCameraId(facing) != -1  } 
@Override public Camera openCameraFacing(final int facing){   return Camera.open(getCameraId(facing))  } 
@Override public void getCameraInfo(final int cameraId,final CameraInfo2 cameraInfo){   CameraInfo info=new CameraInfo()    Camera.getCameraInfo(cameraId,info)    cameraInfo.facing=info.facing    cameraInfo.orientation=info.orientation  } 
private int getCameraId(final int facing){   int numberOfCameras=Camera.getNumberOfCameras()    CameraInfo info=new CameraInfo()    for (int id=0  id < numberOfCameras  id++) {     Camera.getCameraInfo(id,info)      if (info.facing == facing) {       return id      }   }   return -1  } 
@Override public SourceVersion getSupportedSourceVersion(){   return SourceVersion.latest()  } 
@Override public boolean process(final Set<? extends TypeElement> annotations,final RoundEnvironment roundEnvironment){   final Set<? extends Element> annotatedElements=roundEnvironment.getElementsAnnotatedWith(Contract.class)    final Map<String,Set<Element>> grouped=getGroupElementsByContractClassName(annotatedElements)    for (  final Map.Entry<String,Set<Element>> groupedElements : grouped.entrySet()) {     final String targetClassName=groupedElements.getKey()      final Set<Element> classElements=groupedElements.getValue()      final boolean multipleClassesForContract=classElements.size() > 1      final String targetPackageName=targetClassName.substring(0,targetClassName.lastIndexOf('.'))      Writer out=null      try {       final JavaFileObject sourceFile=processingEnv.getFiler().createSourceFile(targetClassName,(Element[])null)        out=sourceFile.openWriter()        final JavaWriter writer=new JavaWriter(out)        writer.emitPackage(targetPackageName).emitImports("android.net.Uri").emitImports("android.content.ContentResolver").emitImports("android.provider.BaseColumns").emitEmptyLine()        final String defaultAuthority=targetPackageName        final String defaultMimeTypeName=targetPackageName + "." + MIMETYPE_NAME_SUFFIX        if (multipleClassesForContract) {         writer.beginType(targetClassName,"class",EnumSet.of(PUBLIC,FINAL)).emitField("String",CONTRACT_AUTHORITY,EnumSet.of(STATIC,PRIVATE,FINAL),JavaWriter.stringLiteral(defaultAuthority)).emitField("String",CONTRACT_MIME_TYPE_NAME,EnumSet.of(STATIC,PRIVATE,FINAL),JavaWriter.stringLiteral(defaultMimeTypeName)).emitEmptyLine().beginMethod(null,targetClassName,EnumSet.of(PRIVATE)).endMethod().emitEmptyLine()        }       final Iterator<Element> iterator=classElements.iterator()        while (iterator.hasNext()) {         final Element classElement=iterator.next()          writeContractClass(writer,classElement,multipleClassesForContract,targetClassName,defaultAuthority,defaultMimeTypeName)          if (iterator.hasNext()) {           writer.emitEmptyLine()          }       }       if (multipleClassesForContract) {         writer.endType()        }       writer.emitEmptyLine()        writer.close()      }  catch (    IOException e) {       e.printStackTrace()        for (      final Element element : classElements) {         processingEnv.getMessager().printMessage(Kind.ERROR,"can't open java file " + targetClassName,element)        }     }  finally {       if (out != null) {         try {           out.close()          }  catch (        IOException e) {           e.printStackTrace()          }       }     }   }   return true  } 
private void writeContractClass(JavaWriter writer,Element classElement,boolean multipleClassesForContract,String targetClassName,String defaultAuthority,String defaultMimeTypeName) throws IOException {   String writer_table_name=""    String databaseTableName=""    final DatabaseTable databaseTable=classElement.getAnnotation(DatabaseTable.class)    if (databaseTable != null) {     databaseTableName=databaseTable.tableName()    }   if (databaseTableName == null || databaseTableName.length() == 0) {     databaseTableName=classElement.getSimpleName().toString()    }   writer_table_name=JavaWriter.stringLiteral(databaseTableName)    String contractClassName=""    EnumSet<Modifier> classModifiers=null    if (multipleClassesForContract) {     contractClassName=classElement.getSimpleName().toString()      classModifiers=EnumSet.of(STATIC,PUBLIC,FINAL)    }  else {     contractClassName=targetClassName.substring(targetClassName.lastIndexOf('.') + 1,targetClassName.length())      classModifiers=EnumSet.of(PUBLIC,FINAL)    }   String writer_content_uri_path=""    final DefaultContentUri defaultContentUriAnnotation=classElement.getAnnotation(DefaultContentUri.class)    String contentUriPath=""    String contentUriAuthority=""    if (defaultContentUriAnnotation != null) {     contentUriPath=defaultContentUriAnnotation.path()      contentUriAuthority=defaultContentUriAnnotation.authority()    }  else {     contentUriPath=databaseTableName.toLowerCase()      contentUriAuthority=defaultAuthority    }   writer_content_uri_path=JavaWriter.stringLiteral(contentUriPath)    String writer_authority=""    if (multipleClassesForContract) {     if (contentUriAuthority == null || contentUriAuthority.length() == 0) {       writer_authority=CONTRACT_AUTHORITY      }  else     if (defaultAuthority.equals(contentUriAuthority)) {       writer_authority=CONTRACT_AUTHORITY      }  else {       writer_authority=JavaWriter.stringLiteral(contentUriAuthority)      }   }  else {     if (contentUriAuthority == null || contentUriAuthority.length() == 0) {       writer_authority=JavaWriter.stringLiteral(defaultAuthority)      }  else {       writer_authority=JavaWriter.stringLiteral(contentUriAuthority)      }   }   String writer_mimetype_type=""    final DefaultContentMimeTypeVnd defaultContentMimeTypeVndAnnotation=classElement.getAnnotation(DefaultContentMimeTypeVnd.class)    String mimeTypeVndName=""    String mimeTypeVndType=""    if (defaultContentMimeTypeVndAnnotation != null) {     mimeTypeVndName=defaultContentMimeTypeVndAnnotation.name()      mimeTypeVndType=defaultContentMimeTypeVndAnnotation.type()    }   if (mimeTypeVndName == null || mimeTypeVndName.length() == 0) {     mimeTypeVndName=defaultMimeTypeName    }   if (mimeTypeVndType == null || mimeTypeVndType.length() == 0) {     mimeTypeVndType=databaseTableName.toLowerCase()    }   writer_mimetype_type=JavaWriter.stringLiteral(mimeTypeVndType)    String writer_mimetype_name=""    if (multipleClassesForContract) {     if (mimeTypeVndName == null || mimeTypeVndName.length() == 0) {       writer_mimetype_name=CONTRACT_MIME_TYPE_NAME      }  else     if (defaultMimeTypeName.equals(mimeTypeVndName)) {       writer_mimetype_name=CONTRACT_MIME_TYPE_NAME      }  else {       writer_mimetype_name=JavaWriter.stringLiteral(mimeTypeVndName)      }   }  else {     if (mimeTypeVndName == null || mimeTypeVndName.length() == 0) {       writer_mimetype_name=JavaWriter.stringLiteral(defaultMimeTypeName)      }  else {       writer_mimetype_name=JavaWriter.stringLiteral(mimeTypeVndName)      }   }   writer.beginType(contractClassName,"class",classModifiers,null,"BaseColumns").emitField("String","TABLE_NAME",EnumSet.of(STATIC,PUBLIC,FINAL),writer_table_name).emitEmptyLine().emitField("String","CONTENT_URI_PATH",EnumSet.of(STATIC,PUBLIC,FINAL),writer_content_uri_path).emitField("String","AUTHORITY",EnumSet.of(STATIC,PUBLIC,FINAL),writer_authority).emitEmptyLine().emitField("String","MIMETYPE_TYPE",EnumSet.of(STATIC,PUBLIC,FINAL),writer_mimetype_type).emitField("String","MIMETYPE_NAME",EnumSet.of(STATIC,PUBLIC,FINAL),writer_mimetype_name).emitEmptyLine().emitField("int","CONTENT_URI_PATTERN_MANY",EnumSet.of(STATIC,PUBLIC,FINAL),String.valueOf(patternCode++)).emitField("int","CONTENT_URI_PATTERN_ONE",EnumSet.of(STATIC,PUBLIC,FINAL),String.valueOf(patternCode++)).emitEmptyLine().emitField("Uri","CONTENT_URI",EnumSet.of(STATIC,PUBLIC,FINAL),DEFAULT_CONTENT_URI_STATEMENT).emitEmptyLine().beginMethod(null,contractClassName,EnumSet.of(PRIVATE)).endMethod().emitEmptyLine()    final List<Element> fields=getAllElementsAnnotatedWith(DatabaseField.class,classElement)    for (  final Element field : fields) {     final String fieldName=field.getSimpleName().toString()      if (!("_id".equals(fieldName) || "_id".equals(field.getAnnotation(DatabaseField.class).columnName()))) {       writer.emitField("String",fieldName.toUpperCase(),EnumSet.of(STATIC,PUBLIC,FINAL),JavaWriter.stringLiteral(fieldName))      }   }   writer.endType()  } 
@Override public int compare(final Element o1,final Element o2){   if (o1 != null) {     final String className1=o1.getSimpleName().toString()      final String className2=o2.getSimpleName().toString()      return className1.compareTo(className2)    }  else {     if (o2 == null) {       return 0      }  else {       return -1      }   } } 
public PackageElement getPackage(Element type){   while (type.getKind() != ElementKind.PACKAGE) {     type=type.getEnclosingElement()    }   return (PackageElement)type  } 
public List<Element> getAllElementsAnnotatedWith(final Class<? extends Annotation> class1,final Element classElement){   final List<Element> allFields=getEnclosedElements(classElement,ElementKind.FIELD)    final List<Element> result=new ArrayList<Element>(allFields.size())    for (  final Element fieldElement : allFields) {     if (fieldElement.getAnnotation(class1) != null) {       result.add(fieldElement)      }   }   return result  } 
public List<Element> getEnclosedElements(final Element element,final ElementKind elementKind){   final List<? extends Element> enclosedElements=element.getEnclosedElements()    final List<Element> list=new ArrayList<Element>(enclosedElements.size())    for (  final Element enclosedElement : enclosedElements) {     if (enclosedElement.getKind() == elementKind) {       list.add(enclosedElement)      }   }   return list  } 
public Map<String,Set<Element>> getGroupElementsByContractClassName(final Collection<? extends Element> classElements){   final Map<String,Set<Element>> result=new HashMap<String,Set<Element>>()    for (  final Element classElement : classElements) {     final Contract contractAnnotation=classElement.getAnnotation(Contract.class)      final String contractClassName=contractAnnotation.contractClassName()      final String targetClassName      if (contractClassName == null || contractClassName.isEmpty()) {       final PackageElement targetPackage=getPackage(classElement)        targetClassName=targetPackage.getQualifiedName().toString() + '.' + classElement.getSimpleName()+ CONTRACT_CLASS_SUFFIX      }  else {       targetClassName=contractClassName      }     if (result.containsKey(targetClassName)) {       result.get(targetClassName).add(classElement)      }  else {       final Set<Element> elements=new TreeSet<Element>(ELEMENT_COMPARATOR)        elements.add(classElement)        result.put(targetClassName,elements)      }   }   return result  } 
void CompilerOptions(String option,String parameter,String description){   this.option=option    this.parameter=parameter    this.description=description  } 
public String getOption(){   return option  } 
public String[] getOption(String parameterValue){   if (parameter != null) {     String[] result=new String[2]      int index=option.indexOf(parameter)      result[0]=option.substring(0,index).trim()      result[1]=parameterValue      return result    }   return new String[]{getOption()}  } 
public String getDescription(){   return description  } 
/**   * @return the processor instances that should be tested  */ protected abstract Collection<Processor> getProcessors()  
/**   * Attempts to compile the given compilation units using the Java Compiler API. <p> The compilation units and all their dependencies are expected to be on the classpath.  * @param compilationUnits the classes to compile  * @return the {@link Diagnostic diagnostics} returned by the compilation, as demonstrated inthe documentation for  {@link JavaCompiler}  * @see #compileTestCase(String)  */ protected List<Diagnostic<? extends JavaFileObject>> compileTestCase(Class<?>... compilationUnits){ } 
private static String toResourcePath(Class<?> clazz){   return ClassUtils.convertClassNameToResourcePath(clazz.getName()) + SOURCE_FILE_SUFFIX  } 
/**   * Attempts to compile the given compilation units using the Java Compiler API. <p> The compilation units and all their dependencies are expected to be on the classpath.  * @param compilationUnitPaths the paths of the source files to compile, as would be expected by {@link ClassLoader#getResource(String)}  * @return the {@link Diagnostic diagnostics} returned by the compilation, as demonstrated inthe documentation for  {@link JavaCompiler}  * @see #compileTestCase(Class)  */ protected List<Diagnostic<? extends JavaFileObject>> compileTestCase(String... compilationUnitPaths){ } 
private static Collection<File> findClasspathFiles(String[] filenames) throws IOException {   Collection<File> classpathFiles=new ArrayList<File>(filenames.length)    for (  String filename : filenames) {     classpathFiles.add(new ClassPathResource(filename).getFile())    }   return classpathFiles  } 
/**   * Asserts that the compilation produced no errors, i.e. no diagnostics of type {@link Kind#ERROR}.  * @param diagnostics the result of the compilation  * @see #assertCompilationReturned(Kind,long,List)  * @see #assertCompilationReturned(Kind[],long[],List)  */ protected static void assertCompilationSuccessful(List<Diagnostic<? extends JavaFileObject>> diagnostics){ } 
/**   * Asserts that the compilation produced results of the following  {@link Kind Kinds} at thegiven line numbers, where the <em>n</em>th kind is expected at the <em>n</em>th line number. <p> Does not check that these is the <em>only</em> diagnostic kinds returned!  * @param expectedDiagnosticKinds the kinds of diagnostic expected  * @param expectedLineNumber the line numbers at which the diagnostics are expected  * @param diagnostics the result of the compilation  * @see #assertCompilationSuccessful(List)  * @see #assertCompilationReturned(Kind,long,List)  */ protected static void assertCompilationReturned(Kind[] expectedDiagnosticKinds,long[] expectedLineNumbers,List<Diagnostic<? extends JavaFileObject>> diagnostics){ } 
/**   * Asserts that the compilation produced a result of the following  {@link Kind} at the givenline number. <p> Does not check that this is the <em>only</em> diagnostic kind returned!  * @param expectedDiagnosticKind the kind of diagnostic expected  * @param expectedLineNumber the line number at which the diagnostic is expected  * @param diagnostics the result of the compilation  * @see #assertCompilationSuccessful(List)  * @see #assertCompilationReturned(Kind[],long[],List)  */ protected static void assertCompilationReturned(Kind expectedDiagnosticKind,long expectedLineNumber,List<Diagnostic<? extends JavaFileObject>> diagnostics){ } 
private List<String> mergeCompilerOptions(List<String> options){   if (options == null) {     return Arrays.asList(getCompilerOptions())    }   List<String> result=new ArrayList<String>()    for (  String option : options) {     result.add(option)    }   for (  String option : getCompilerOptions()) {     result.add(option)    }   return result  } 
protected String[] getCompilerOptions(){   return CompilerOptions.GENERATED_SOURCES_DIRECTORY.getOption(ensureOutputDirectory().getAbsolutePath())  } 
protected File ensureOutputDirectory(){   File file=new File(OUTPUT_DIRECTORY)    if (!file.exists()) {     file.mkdirs()    }   return file  } 
protected static void assertOutput(File expectedResult,File output) throws IOException {   String[] expectedContent=getContents(expectedResult)    String[] outputContent=getContents(output)    assertEquals(expectedContent.length,outputContent.length)    for (int i=0  i < expectedContent.length  i++) {     assertEquals(expectedContent[i].trim(),outputContent[i].trim())    } } 
private static String[] getContents(File file) throws IOException {   List<String> content=new ArrayList<String>()    BufferedReader input=new BufferedReader(new FileReader(file))    try {     String line=null      while ((line=input.readLine()) != null) {       content.add(line)      }   }   finally {     input.close()    }   return content.toArray(new String[]{})  } 
protected String toPath(Package packageName){   return toPath(packageName.getName())  } 
protected String toPath(String packageName){   return packageName.replace(".","/")  } 
protected File getResourceFile(Class<?> clazz){   return new File(getClass().getResource("/" + toPath(clazz.getPackage()) + "/"+ clazz.getSimpleName()+ OUTPUT_FILE_SUFFIX).getFile())  } 
protected File getOutputFile(String file){   return new File(OUTPUT_DIRECTORY,file)  } 
@Override protected Collection<Processor> getProcessors(){   return Arrays.<Processor>asList(new ContractAnnotationProcessor())  } 
@Test public void a0100ValidVerySimpleContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(Pojo.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/PojoContract.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/PojoContract.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0101ValidLessSimpleContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(Pojo2.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/LessSimplePojoContract2.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/LessSimplePojoContract2.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0200ValidDefaultContentUriAndContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(Pojo3.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/Pojo3Contract.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/Pojo3Contract.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0201ValidDefaultContentUriAndDefaultContentMimeTypeVndContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(Pojo4.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/Pojo4Contract.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/Pojo4Contract.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0300ValidFieldsContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(PojoWithFields1.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/PojoWithFields1Contract.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/PojoWithFields1Contract.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0400ValidSuperPojo() throws IOException {   assertCompilationSuccessful(compileTestCase(CombinedPojo1.class,CombinedPojo2.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract1.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract1.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0401ValidSuperPojoWithDefaultContentUriAndDefaultContentMimeTypeVndContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(CombinedPojo3.class,CombinedPojo4.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract2.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract2.javasource"    assertOutput(new File(string),new File(string2))  } 
@Test public void a0402ValidSuperPojoMixedWithDefaultContentUriAndDefaultContentMimeTypeVndContractAnnotation() throws IOException {   assertCompilationSuccessful(compileTestCase(CombinedPojo5.class,CombinedPojo6.class))    final String string="build/source/generated-test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract3.java"    final String string2="build/resources/test/com/tojc/ormlite/android/compiler/sample/CombinedPojoContract3.javasource"    assertOutput(new File(string),new File(string2))  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    ContentValues values=new ContentValues()    values.clear()    values.put(AccountContract.NAME,"Yamada Tarou")    getContentResolver().insert(AccountContract.CONTENT_URI,values)    ContentValues[] contentValues=new ContentValues[TEST_ENTRY_COUNT]    for (int i=0  i < TEST_ENTRY_COUNT  i++) {     values=new ContentValues()      values.clear()      values.put(AccountContract.NAME,"Yamada Tarou: " + i)      contentValues[i]=values    }   getContentResolver().bulkInsert(AccountContract.CONTENT_URI,contentValues)    Cursor c=getContentResolver().query(AccountContract.CONTENT_URI,null,null,null,null)    c.moveToFirst()    do {     for (int i=0  i < c.getColumnCount()  i++) {       Log.d(getClass().getSimpleName(),c.getColumnName(i) + " : " + c.getString(i))      }   }  while (c.moveToNext())    c.close()    ArrayList<ContentProviderOperation> operations=new ArrayList<ContentProviderOperation>()    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,"Yamada Hanako 1").build())    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,"Yamada Hanako 2").build())    try {     getContentResolver().applyBatch(AccountContract.AUTHORITY,operations)    }  catch (  Exception e) {     e.printStackTrace()    }   ContentProviderClient client=getContentResolver().acquireContentProviderClient(AccountContract.CONTENT_URI)    Cursor c2=null    try {     c2=client.query(AccountContract.CONTENT_URI,null,null,null,null)      c2.moveToFirst()      do {       for (int i=0  i < c2.getColumnCount()  i++) {         Log.d(getClass().getSimpleName(),c2.getColumnName(i) + " : " + c2.getString(i))        }     }  while (c2.moveToNext())    }  catch (  RemoteException e) {     e.printStackTrace()    }  finally {     if (c2 != null) {       c2.close()      }   }   client.release()  } 
@Override public boolean onCreateOptionsMenu(Menu menu){   getMenuInflater().inflate(R.menu.activity_main,menu)    return true  } 
public Account(){ } 
public Account(String name){   this.id=0    this.name=name  } 
public int getId(){   return id  } 
public String getName(){   return name  } 
@Override protected Class<SampleHelper> getHelperClass(){   return SampleHelper.class  } 
@Override public boolean onCreate(){   setMatcherController(new MatcherController().add(Account.class,SubType.DIRECTORY,"",AccountContract.CONTENT_URI_PATTERN_MANY).add(Account.class,SubType.ITEM,"#",AccountContract.CONTENT_URI_PATTERN_ONE))    return true  } 
public SampleHelper(Context context){   super(context,"MyDatabase",null,1)  } 
@Override public void onCreate(SQLiteDatabase database,ConnectionSource connectionSource){   try {     TableUtils.createTableIfNotExists(connectionSource,Account.class)    }  catch (  SQLException e) {     e.printStackTrace()    } } 
@Override public void onUpgrade(SQLiteDatabase database,ConnectionSource connectionSource,int oldVersion,int newVersion){   try {     TableUtils.dropTable(connectionSource,Account.class,true)      TableUtils.createTable(connectionSource,Account.class)    }  catch (  SQLException e) {     e.printStackTrace()    } } 
/**   * Are treated the same as ASC. (dependent SQLite)  */ @Override public String toString(){   return ""  } 
public AnnotationInfoBase(){   validFlagOff()  } 
protected void validFlagOn(){   this.validFlag=true  } 
protected void validFlagOff(){   this.validFlag=false  } 
protected abstract boolean isValidValue()  
@Override public boolean isValid(){   return this.validFlag && isValidValue()  } 
@Override public boolean isValid(boolean throwException){   boolean result=this.isValid()    String message=this.getClass().getSimpleName() + " class status is abnormal."    thowIllegalStateExceptionUnderCondition(throwException && !result,message)    return result  } 
@Override public String toString(){   return "AnnotationInfoBase{" + "validFlag=" + validFlag + "} "+ super.toString()  } 
protected final void thowIllegalStateExceptionUnderCondition(boolean condition,String message){   if (condition) {     throw new IllegalStateException(message)    } } 
public ContentMimeTypeVndInfo(AnnotatedElement element){   DefaultContentMimeTypeVnd contentMimeTypeVnd=element.getAnnotation(DefaultContentMimeTypeVnd.class)    String name=null    String type=null    if (contentMimeTypeVnd != null) {     name=contentMimeTypeVnd.name()      type=contentMimeTypeVnd.type()    }   if (element instanceof Class<?>) {     Class<?> clazz=(Class<?>)element      if (TextUtils.isEmpty(name)) {       name=clazz.getPackage().getName() + PROVIDER_SUFFIX      }     if (TextUtils.isEmpty(type)) {       type=clazz.getSimpleName().toLowerCase()      }   }   initialize(name,type)  } 
public ContentMimeTypeVndInfo(String name,String type){   initialize(name,type)  } 
public String getName(){   return this.name  } 
public String getType(){   return this.type  } 
public String getVndProviderSpecificString(){   return VND + VND_SEPARATOR + this.name+ VND_SEPARATOR+ this.type  } 
@Override protected boolean isValidValue(){   return !TextUtils.isEmpty(this.name) && !TextUtils.isEmpty(this.type)  } 
private void initialize(String name,String type){   this.name=name    this.type=type    validFlagOn()  } 
@Override public String toString(){   return "ContentMimeTypeVndInfo{" + "name='" + name + '\''+ ", type='"+ type+ '\''+ "} "+ super.toString()  } 
public ContentUriInfo(AnnotatedElement element){   DefaultContentUri contentUri=element.getAnnotation(DefaultContentUri.class)    String authority=null    String path=null    if (contentUri != null) {     authority=contentUri.authority()      path=contentUri.path()    }   if (element instanceof Class<?>) {     Class<?> clazz=(Class<?>)element      if (TextUtils.isEmpty(authority)) {       authority=clazz.getPackage().getName()      }     if (TextUtils.isEmpty(path)) {       path=clazz.getSimpleName().toLowerCase()      }   }   initialize(authority,path)  } 
public ContentUriInfo(String authority,String path){   initialize(authority,path)  } 
public String getAuthority(){   return this.authority  } 
public String getPath(){   return this.path  } 
public Uri getContentUri(){   return new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(this.authority).appendPath(this.path).build()  } 
@Override protected boolean isValidValue(){   return !TextUtils.isEmpty(this.authority) && !TextUtils.isEmpty(this.path)  } 
private void initialize(String authority,String path){   this.authority=authority    this.path=path    validFlagOn()  } 
@Override public String toString(){   return "ContentUriInfo{" + "authority='" + authority + '\''+ ", path='"+ path+ '\''+ "} "+ super.toString()  } 
public ProjectionMapInfo(AnnotatedElement element){   ProjectionMap projectionMap=element.getAnnotation(ProjectionMap.class)    if (projectionMap != null) {     this.name=projectionMap.value()      validFlagOn()    } } 
public ProjectionMapInfo(String name){   this.name=name    validFlagOn()  } 
public String getName(){   return this.name  } 
@Override protected boolean isValidValue(){   return !TextUtils.isEmpty(name)  } 
@Override public String toString(){   return "ProjectionMapInfo{" + "name='" + name + '\''+ "} "+ super.toString()  } 
public SortOrderInfo(AnnotatedElement element){   DefaultSortOrder defaultSortOrder=element.getAnnotation(DefaultSortOrder.class)    if (defaultSortOrder != null) {     this.order=defaultSortOrder.order()      this.weight=defaultSortOrder.weight()      validFlagOn()    } } 
public SortOrderInfo(SortOrder order,int weight){   this.order=order    this.weight=weight    validFlagOn()  } 
public SortOrder getOrder(){   return this.order  } 
public int getWeight(){   return this.weight  } 
public String makeSqlOrderString(String fieldname){   StringBuilder result=new StringBuilder()    result.append(fieldname)    result.append(SQL_ORDER_SEPARATOR)    result.append(this.order.toString())    return result.toString().trim()  } 
@Override protected boolean isValidValue(){   return true  } 
@Override public String toString(){   return "SortOrderInfo{" + "order=" + order + ", weight="+ weight+ "} "+ super.toString()  } 
private OrmLiteAnnotationAccessor(){ } 
/**   * Gets the table name from DatabaseTable annotation. If the DatabaseTable#tableName is not specified, returns the class name.  * @param element Element to be evaluated.  * @return Returns the table name.  */ public static String getAnnotationTableName(AnnotatedElement element){   String result=""    result=DatabaseTableConfig.extractTableName((Class<?>)element)    return result  } 
/**   * Gets the column name from DatabaseField annotation. If the DatabaseField#columnName is not specified, returns the field name.  * @param element Element to be evaluated.  * @return Returns the column name.  */ public static String getAnnotationColumnName(AnnotatedElement element){   String result=""    DatabaseField databaseField=element.getAnnotation(DatabaseField.class)    if (databaseField != null) {     result=databaseField.columnName()      if (TextUtils.isEmpty(result)) {       result=((Field)element).getName()      }   }   return result  } 
public ColumnInfo(Field columnField){   if (!columnField.isAnnotationPresent(DatabaseField.class)) {     throw new IllegalArgumentException("Parameter does not implement the DatabaseField annotation.")    }   this.field=columnField    this.columnName=OrmLiteAnnotationAccessor.getAnnotationColumnName(columnField)    this.defaultSortOrderInfo=new SortOrderInfo(columnField)    this.projectionMapInfo=new ProjectionMapInfo(columnField)  } 
@Override public boolean isValid(){   return isValid(false)  } 
@Override public boolean isValid(boolean throwException){   boolean result=true    return result  } 
public Field getField(){   return this.field  } 
public String getColumnName(){   return this.columnName  } 
public String getProjectionColumnName(){   String result=this.columnName    if (this.projectionMapInfo.isValid()) {     result=this.projectionMapInfo.getName()    }   return result  } 
/**   * @see com.tojc.ormlite.android.framework.TableInfo#getDefaultSortOrderString()  * @return Gets the default value that is specified in the annotation. Thisrepresents the state of this column only. If you want to know about the table sort order, you refer to the TableInfo#getDefaultSortOrderString().  */ public SortOrderInfo getDefaultSortOrderInfo(){   return this.defaultSortOrderInfo  } 
/**   * @see com.tojc.ormlite.android.framework.TableInfo#getProjectionMap()  * @return Gets the default value that is specified in the annotation. Thisrepresents the state of this column only. If you want to know about the table ProjectionMap, you refer to the TableInfo#getProjectionMap()  */ public ProjectionMapInfo getProjectionMapInfo(){   return this.projectionMapInfo  } 
public MatcherController(){   this.matcher=new UriMatcher(UriMatcher.NO_MATCH)    this.tables=new HashMap<Class<?>,TableInfo>()    this.matcherPatterns=new ArrayList<MatcherPattern>()    this.lastAddTableInfo=null  } 
/**   * Register a class for table.  * @param tableClassType Register a class for table.  * @return Instance of the MatcherController class.  */ public MatcherController add(Class<?> tableClassType){   this.addTableClass(tableClassType)    return this  } 
/**   * Register a class for table. And registers a pattern for UriMatcher.  * @param tableClassType Register a class for table.  * @param subType Contents to be registered in the pattern, specify single or multiple. This is used in the MIME types. * ITEM : If the URI pattern is for a single row : vnd.android.cursor.item/ * DIRECTORY : If the URI pattern is for more than one row : vnd.android.cursor.dir/  * @param pattern registers a pattern for UriMatcher. Note: Must not contain the name of path here. ex) content://com.example.app.provider/table1 : pattern = "" content://com.example.app.provider/table1/# : pattern = "#" content://com.example.app.provider/table1/dataset2 : pattern = "dataset2"  * @param patternCode UriMatcher code is returned  * @return Instance of the MatcherController class.  */ public MatcherController add(Class<?> tableClassType,SubType subType,String pattern,int patternCode){   this.addTableClass(tableClassType)    this.addMatcherPattern(subType,pattern,patternCode)    return this  } 
/**   * Registers a pattern for UriMatcher. It refer to the class that was last registered from add method.  * @param subType Contents to be registered in the pattern, specify single or multiple. This is used in the MIME types. * ITEM : If the URI pattern is for a single row : vnd.android.cursor.item/ * DIRECTORY : If the URI pattern is for more than one row : vnd.android.cursor.dir/  * @param pattern registers a pattern for UriMatcher. Note: Must not contain the name of path here. ex) content://com.example.app.provider/table1 : pattern = "" content://com.example.app.provider/table1/# : pattern = "#" content://com.example.app.provider/table1/dataset2 : pattern = "dataset2"  * @param patternCode UriMatcher code is returned  * @return Instance of the MatcherController class.  */ public MatcherController add(SubType subType,String pattern,int patternCode){   this.addMatcherPattern(subType,pattern,patternCode)    return this  } 
/**   * Registers a pattern for UriMatcher. To register you have to create an instance of MatcherPattern.  * @param matcherPattern register MatcherPattern.  * @return Instance of the MatcherController class.  */ public MatcherController add(MatcherPattern matcherPattern){   int patternCode=matcherPattern.getPatternCode()    if (this.lastAddTableInfo == null) {     throw new IllegalStateException("There is a problem with the order of function call.")    }   if (findMatcherPattern(patternCode) != null) {     throw new IllegalArgumentException("patternCode has been specified already exists.")    }   this.matcherPatterns.add(matcherPattern)    return this  } 
/**   * Set the DefaultContentUri. If you did not use the DefaultContentUri annotation, you must call this method.  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentUri  * @param authority  * @param path  * @return Instance of the MatcherController class.  */ public MatcherController setDefaultContentUri(String authority,String path){   if (this.lastAddTableInfo == null) {     throw new IllegalStateException("There is a problem with the order of function call.")    }   this.lastAddTableInfo.setDefaultContentUriInfo(new ContentUriInfo(authority,path))    return this  } 
/**   * Set the DefaultContentMimeTypeVnd. If you did not use the DefaultContentMimeTypeVnd annotation, you must call this method.  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentMimeTypeVnd  * @param name  * @param type  * @return Instance of the MatcherController class.  */ public MatcherController setDefaultContentMimeTypeVnd(String name,String type){   if (this.lastAddTableInfo == null) {     throw new IllegalStateException("There is a problem with the order of function call.")    }   this.lastAddTableInfo.setDefaultContentMimeTypeVndInfo(new ContentMimeTypeVndInfo(name,type))    return this  } 
/**   * initialized with the contents that are registered by the add method. This method checks the registration details.  * @return Instance of the MatcherController class.  */ public MatcherController initialize(){   this.lastAddTableInfo=null    for (  Map.Entry<Class<?>,TableInfo> entry : this.tables.entrySet()) {     entry.getValue().isValid(true)    }   for (  MatcherPattern entry : matcherPatterns) {     entry.isValid(true)      this.matcher.addURI(entry.getTableInfo().getDefaultContentUriInfo().getAuthority(),entry.getPathAndPatternString(),entry.getPatternCode())      entry.initialize()    }   this.initialized=true    return this  } 
/**   * This will search the MatcherPattern that are registered based on the return code UriMatcher.  * @param patternCode UriMatcher code is returned  * @return Instance of the MatcherPattern class. if no match is found will return null.  */ public MatcherPattern findMatcherPattern(int patternCode){   MatcherPattern result=null    for (  MatcherPattern entry : this.matcherPatterns) {     if (entry.getPatternCode() == patternCode) {       result=entry        break      }   }   return result  } 
private TableInfo addTableClass(Class<?> tableClassType){   TableInfo result=null    if (this.tables.containsKey(tableClassType)) {     result=this.tables.get(tableClassType)    }  else {     result=new TableInfo(tableClassType)      this.tables.put(tableClassType,result)    }   this.lastAddTableInfo=result    return result  } 
private MatcherPattern addMatcherPattern(SubType subType,String pattern,int patternCode){   MatcherPattern result=null    if (this.lastAddTableInfo == null) {     throw new IllegalStateException("There is a problem with the order of function call.")    }   if (findMatcherPattern(patternCode) != null) {     throw new IllegalArgumentException("patternCode has been specified already exists.")    }   result=new MatcherPattern(this.lastAddTableInfo,subType,pattern,patternCode)    this.matcherPatterns.add(result)    return result  } 
public boolean hasPreinitialized(){   return this.initialized  } 
/**   * @return Return an instance of the UriMatcher.  */ public UriMatcher getUriMatcher(){   if (!this.initialized) {     throw new IllegalStateException("Controller has not been initialized.")    }   return this.matcher  } 
/**   * @return Return a map of tables that have been registered class.  */ public Map<Class<?>,TableInfo> getTables(){   if (!this.initialized) {     throw new IllegalStateException("Controller has not been initialized.")    }   return this.tables  } 
/**   * @return Return an instance of the UriMatcher.  */ public List<MatcherPattern> getMatcherPatterns(){   if (!this.initialized) {     throw new IllegalStateException("Controller has not been initialized.")    }   return this.matcherPatterns  } 
public MatcherPattern(TableInfo tableInfo,SubType subType,String pattern,int patternCode){   this.tableInfo=tableInfo    this.subType=subType    this.pattern=pattern    this.patternCode=patternCode    if (this.tableInfo.getDefaultContentUriInfo().isValid()) {     this.contentUriInfo=this.tableInfo.getDefaultContentUriInfo()    }  else {     this.contentUriInfo=null    }   if (this.tableInfo.getDefaultContentMimeTypeVndInfo().isValid()) {     this.contentMimeTypeVndInfo=this.tableInfo.getDefaultContentMimeTypeVndInfo()    }  else {     this.contentMimeTypeVndInfo=null    }   if (this.contentMimeTypeVndInfo != null) {     this.mimeTypeVnd=new MimeTypeVnd(this.subType,this.contentMimeTypeVndInfo)    }  else {     this.mimeTypeVnd=null    } } 
@Override public boolean isValid(){   return isValid(false)  } 
@Override public boolean isValid(boolean throwException){   boolean result=true    if (this.tableInfo == null) {     result=false      if (throwException && !result) {       throw new IllegalStateException("tableInfo is null.")      }   }  else   if (this.subType == null) {     result=false      if (throwException && !result) {       throw new IllegalStateException("subType is null.")      }   }  else   if (pattern == null) {     result=false      if (throwException && !result) {       throw new IllegalStateException("pattern is null.")      }   }  else   if (this.patternCode <= 0) {     result=false      if (throwException && !result) {       throw new IllegalStateException("patternCode is zero.")      }   }  else   if (this.contentUriInfo == null || !this.contentUriInfo.isValid()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("contentUriInfo is invalid.")      }   }  else   if (this.contentMimeTypeVndInfo == null || !this.contentMimeTypeVndInfo.isValid()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("contentMimeTypeVndInfo is invalid.")      }   }  else   if (this.mimeTypeVnd == null || !this.mimeTypeVnd.isValid()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("mimeTypeVnd is invalid.")      }   }   return result  } 
/**   * Do not call this method. This is only used MatcherController and tests.  * @see com.tojc.ormlite.android.framework.MatcherController#hasPreinitialized()  */ protected void initialize(){   this.initialized=true  } 
/**   * Set the ContentUri. This is used when you are not using the DefaultContentUri annotation, or want to override the setting of the DefaultContentUri annotation. This method can not be called after MatcherController#hasPreinitialized().  * @see com.tojc.ormlite.android.annotation.info.ContentUriInfo  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentUri  * @see com.tojc.ormlite.android.framework.MatcherController#hasPreinitialized()  * @param contentUriInfo  * @return Instance of the MatcherPattern class.  */ public MatcherPattern setContentUri(ContentUriInfo contentUriInfo){   if (this.initialized) {     throw new IllegalStateException("Can't change the settings after initialization.")    }   this.contentUriInfo=contentUriInfo    return this  } 
/**   * Set the ContentUri. This is used when you are not using the DefaultContentUri annotation, or want to override the setting of the DefaultContentUri annotation. This method can not be called after MatcherController#hasPreinitialized().  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentUri  * @see com.tojc.ormlite.android.framework.MatcherController#hasPreinitialized()  * @param authority  * @param path  * @return Instance of the MatcherPattern class.  */ public MatcherPattern setContentUri(String authority,String path){   return this.setContentUri(new ContentUriInfo(authority,path))  } 
/**   * Set the MIME types. This is used when you are not using the DefaultContentMimeTypeVnd annotation, or want to override the setting of the DefaultContentMimeTypeVnd annotation. This method can not be called after MatcherController#hasPreinitialized().  * @see com.tojc.ormlite.android.annotation.info.ContentMimeTypeVndInfo  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentMimeTypeVnd  * @see com.tojc.ormlite.android.framework.MatcherController#hasPreinitialized()  * @param contentMimeTypeVndInfo  * @return Instance of the MatcherPattern class.  */ public MatcherPattern setContentMimeTypeVnd(ContentMimeTypeVndInfo contentMimeTypeVndInfo){   if (this.initialized) {     throw new IllegalStateException("Can't change the settings after initialization.")    }   this.contentMimeTypeVndInfo=contentMimeTypeVndInfo    this.mimeTypeVnd=new MimeTypeVnd(this.subType,this.contentMimeTypeVndInfo)    return this  } 
/**   * Set the MIME types. This is used when you are not using the DefaultContentMimeTypeVnd annotation, or want to override the setting of the DefaultContentMimeTypeVnd annotation. This method can not be called after MatcherController#hasPreinitialized().  * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.DefaultContentMimeTypeVnd  * @see com.tojc.ormlite.android.framework.MatcherController#hasPreinitialized()  * @param name  * @param type  * @return Instance of the MatcherPattern class.  */ public MatcherPattern setContentMimeTypeVnd(String name,String type){   return this.setContentMimeTypeVnd(new ContentMimeTypeVndInfo(name,type))  } 
public TableInfo getTableInfo(){   return this.tableInfo  } 
public SubType getSubType(){   return this.subType  } 
public String getPattern(){   return this.pattern  } 
public int getPatternCode(){   return this.patternCode  } 
public ContentUriInfo getContentUriInfo(){   return this.contentUriInfo  } 
public MimeTypeVnd getMimeTypeVnd(){   return this.mimeTypeVnd  } 
/**   * @return Return the concatenation string of Path and Pattern from ContentUri. <br>ex)<br> <code> ContentUri = "content://com.example.app.provider/table2/dataset1"<br> Return = "table2/dataset1"<br> </code>  */ public String getPathAndPatternString(){   return this.contentUriInfo.getPath() + "/" + this.pattern  } 
/**   * @return Returns the full ContentUri.(Uri object)  */ public Uri getContentUriPattern(){   return Uri.parse(this.contentUriInfo.getContentUri() + "/" + this.pattern)  } 
/**   * @return Returns the full MIME types string. <br>ex)<br> <code> Return = "vnd.android.cursor.item/vnd.com.example.provider.table1"<br> </code>  */ public String getMimeTypeVndString(){   return this.mimeTypeVnd.getMimeTypeString()  } 
@Override public String toString(){   return getContentUriPattern().toString()  } 
private void SubType(String name){   this.name=name  } 
@Override public String toString(){   return this.name  } 
public MimeTypeVnd(SubType subType,ContentMimeTypeVndInfo providerSpecific){   this.subType=subType    this.providerSpecific=providerSpecific  } 
@Override public boolean isValid(){   return isValid(false)  } 
@Override public boolean isValid(boolean throwException){   boolean result=true    if (this.subType == null) {     result=false      if (throwException && !result) {       throw new IllegalStateException("subType is null.")      }   }  else   if (!this.providerSpecific.isValid()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("providerSpecific is invalid.")      }   }   return result  } 
public SubType getSubType(){   return this.subType  } 
public void setSubType(SubType subType){   this.subType=subType  } 
public ContentMimeTypeVndInfo getProviderSpecific(){   return this.providerSpecific  } 
public void setProviderSpecific(ContentMimeTypeVndInfo providerSpecific){   this.providerSpecific=providerSpecific  } 
public String getMimeTypeString(){   return this.subType.toString() + File.separator + this.providerSpecific.getVndProviderSpecificString()  } 
@Override public String toString(){   return getMimeTypeString()  } 
Uri getUri()  
String[] getProjection()  
String getSelection()  
String[] getSelectionArgs()  
String getSortOrder()  
ContentValues getValues()  
String getSelection()  
String[] getSelectionArgs()  
ContentValues getValues()  
String getSelection()  
String[] getSelectionArgs()  
public Parameter(){   this.clear()  } 
public void clear(){   this.uri=null    this.projection=null    this.selection=null    this.selectionArgs=null    this.sortOrder=null    this.values=null  } 
public Parameter(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){   this.clear()    this.uri=uri    if (projection != null) {     this.projection=projection.clone()    }   this.selection=selection    if (selectionArgs != null) {     this.selectionArgs=selectionArgs.clone()    }   this.sortOrder=sortOrder  } 
public Parameter(Uri uri,ContentValues values){   this.clear()    this.uri=uri    this.values=values  } 
public Parameter(Uri uri,String selection,String[] selectionArgs){   this.clear()    this.uri=uri    this.selection=selection    if (selectionArgs != null) {     this.selectionArgs=selectionArgs.clone()    } } 
public Parameter(Uri uri,ContentValues values,String selection,String[] selectionArgs){   this.clear()    this.uri=uri    this.values=values    this.selection=selection    if (selectionArgs != null) {     this.selectionArgs=selectionArgs.clone()    } } 
@Override public Uri getUri(){   return this.uri  } 
public void setUri(Uri uri){   this.uri=uri  } 
@Override public String[] getProjection(){   if (projection == null) {     return null    }   return this.projection.clone()  } 
public void setProjection(String[] projection){   if (projection == null) {     this.projection=null    }  else {     this.projection=projection.clone()    } } 
@Override public String getSelection(){   return this.selection  } 
public void setSelection(String selection){   this.selection=selection  } 
@Override public String[] getSelectionArgs(){   if (this.selectionArgs != null) {     return this.selectionArgs.clone()    }  else {     return null    } } 
public void setSelectionArgs(String[] selectionArgs){   if (selectionArgs == null) {     this.selectionArgs=null    }  else {     this.selectionArgs=selectionArgs.clone()    } } 
@Override public String getSortOrder(){   return this.sortOrder  } 
public void setSortOrder(String sortOrder){   this.sortOrder=sortOrder  } 
@Override public ContentValues getValues(){   return this.values  } 
public void setValues(ContentValues values){   this.values=values  } 
public TableInfo(Class<?> tableClassType){   this.classType=tableClassType    this.name=OrmLiteAnnotationAccessor.getAnnotationTableName(tableClassType)    this.defaultContentUriInfo=new ContentUriInfo(tableClassType)    this.defaultContentMimeTypeVndInfo=new ContentMimeTypeVndInfo(tableClassType)    this.columns=new HashMap<String,ColumnInfo>()    this.projectionMap=new HashMap<String,String>()    SortedMap<Integer,String> defaultSortOrderMap=new TreeMap<Integer,String>()    this.idColumnInfo=null    for (  Field classfield : tableClassType.getDeclaredFields()) {     if (classfield.isAnnotationPresent(DatabaseField.class)) {       classfield.setAccessible(true)        ColumnInfo columnInfo=new ColumnInfo(classfield)        this.columns.put(columnInfo.getColumnName(),columnInfo)        if (columnInfo.getColumnName().equals(BaseColumns._ID)) {         DatabaseField databaseField=classfield.getAnnotation(DatabaseField.class)          if (databaseField != null) {           if (databaseField.persisted()) {             boolean generatedId=databaseField.generatedId()              boolean id=databaseField.id()              if (generatedId || id) {               this.idColumnInfo=columnInfo              }           }         }       }       SortOrderInfo defaultSortOrderInfo=columnInfo.getDefaultSortOrderInfo()        if (defaultSortOrderInfo.isValid()) {         defaultSortOrderMap.put(defaultSortOrderInfo.getWeight(),defaultSortOrderInfo.makeSqlOrderString(columnInfo.getColumnName()))        }       this.projectionMap.put(columnInfo.getProjectionColumnName(),columnInfo.getColumnName())      }   }   if (this.idColumnInfo == null) {     throw new IllegalArgumentException("Proper ID is not defined for field.")    }   if (defaultSortOrderMap.size() >= 1) {     StringBuilder result=new StringBuilder()      String comma=""      for (    Map.Entry<Integer,String> entry : defaultSortOrderMap.entrySet()) {       result.append(comma)        result.append(entry.getValue())        comma=", "      }     this.defaultSortOrder=result.toString()    }  else {     this.defaultSortOrder=""    } } 
@Override public boolean isValid(){   return isValid(false)  } 
@Override public boolean isValid(boolean throwException){   boolean result=true    if (this.classType == null) {     result=false      if (throwException && !result) {       throw new IllegalStateException("classType is null.")      }   }  else   if (TextUtils.isEmpty(name)) {     result=false      if (throwException && !result) {       throw new IllegalStateException("name is zero string.")      }   }  else   if (this.columns.isEmpty()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("columns is zero size.")      }   }  else   if (this.columns.size() != this.projectionMap.size()) {     result=false      if (throwException && !result) {       throw new IllegalStateException("Number of columns and projectionMap do not match.")      }   }   return result  } 
public Class<?> getClassType(){   return this.classType  } 
public String getName(){   return this.name  } 
/**   * @see com.tojc.ormlite.android.framework.MatcherPattern#getContentUriInfo()  * @return Gets the default value that is specified in the annotation. Ifyou want to know the state to match the pattern, see MatcherPattern#getContentUriInfo.  */ public ContentUriInfo getDefaultContentUriInfo(){   return this.defaultContentUriInfo  } 
/**   * @see com.tojc.ormlite.android.framework.MatcherController#setDefaultContentUri(String,String)  * @see com.tojc.ormlite.android.framework.TableInfo#getDefaultContentUriInfo()  * @see com.tojc.ormlite.android.framework.MatcherPattern#getContentUriInfo()  * @param defaultContentUriInfo  */ public void setDefaultContentUriInfo(ContentUriInfo defaultContentUriInfo){   this.defaultContentUriInfo=defaultContentUriInfo  } 
/**   * @see com.tojc.ormlite.android.framework.MatcherPattern#getMimeTypeVnd()  * @return Gets the default value that is specified in the annotation. Ifyou want to know the state to match the pattern, see MatcherPattern#getMimeTypeVnd.  */ public ContentMimeTypeVndInfo getDefaultContentMimeTypeVndInfo(){   return this.defaultContentMimeTypeVndInfo  } 
/**   * @see com.tojc.ormlite.android.framework.MatcherController#setDefaultContentMimeTypeVnd(String,String)  * @see com.tojc.ormlite.android.framework.TableInfo#getDefaultContentMimeTypeVndInfo()  * @see com.tojc.ormlite.android.framework.MatcherPattern#getMimeTypeVnd()  * @param defaultContentMimeTypeVndInfo  */ public void setDefaultContentMimeTypeVndInfo(ContentMimeTypeVndInfo defaultContentMimeTypeVndInfo){   this.defaultContentMimeTypeVndInfo=defaultContentMimeTypeVndInfo  } 
/**   * @return Gets the default value that is specified in the annotation. Ifyou are specifying multiple fields, return the concatenated string. ex) "timestamp DESC, _id ASC"  */ public String getDefaultSortOrderString(){   return this.defaultSortOrder  } 
/**   * @return Get column information for column "_id".  */ public ColumnInfo getIdColumnInfo(){   return this.idColumnInfo  } 
/**   * @see com.tojc.ormlite.android.annotation.AdditionalAnnotation.ProjectionMap  * @return Return to generate the ProjectionMap. If you are not using theProjectionMap annotations need not be used. The Map is includes all columns.  */ public Map<String,String> getProjectionMap(){   return this.projectionMap  } 
boolean isValid()  
boolean isValid(boolean throwException)  
protected abstract Class<T> getHelperClass()  
/**   * Get a helper for this action. If you need to override, please consider createHelper().  * @see com.tojc.ormlite.android.OrmLiteBaseContentProvider#createHelper()  * @return Return an instance of the helper.  */ public T getHelper(){   if (this.helper == null) {     if (this.destroyed) {       throw new IllegalStateException("A call to shutdown has already been made and the helper cannot be used after that point")      }     this.helper=this.createHelper()      logger.trace("{}: got new helper {} from OpenHelperManager",this,this.helper)    }   return this.helper  } 
/**   * Create the Helper object. If you want to change function, please override this method.  * @see com.tojc.ormlite.android.OrmLiteBaseContentProvider#releaseHelper()  * @return Return an instance of the helper.  */ protected T createHelper(){   return OpenHelperManager.getHelper(this.getContext(),this.getHelperClass())  } 
/**   * Release the Helper object. If you want to change function, please override this method.  * @see com.tojc.ormlite.android.OrmLiteBaseContentProvider#createHelper()  */ protected void releaseHelper(){   OpenHelperManager.releaseHelper()  } 
/**   * Get a connection source for this action.  * @see com.j256.ormlite.support.ConnectionSource  * @return Return an instance of the ConnectionSource.  */ public ConnectionSource getConnectionSource(){   return getHelper().getConnectionSource()  } 
@Override public void shutdown(){   super.shutdown()    if (this.helper != null) {     this.helper.close()      this.helper=null      this.releaseHelper()      logger.trace("{}: helper {} was released, set to null",this,this.helper)      this.destroyed=true    } } 
@Override public String toString(){   return getClass().getSimpleName() + "@" + Integer.toHexString(super.hashCode())  } 
protected void setMatcherController(MatcherController controller){   this.controller=controller    controller.initialize()  } 
/**   * You implement this method. At the timing of query() method, which calls the onQuery().  * @param helper This is a helper object. It is the same as one that can be retrieved by this.getHelper().  * @param db This is a SQLiteDatabase object. Return the object obtained by helper.getReadableDatabase().  * @param target It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter Arguments passed to the query() method.  * @return Please set value to be returned in the original query() method.  */ public abstract Cursor onQuery(T helper,SQLiteDatabase db,MatcherPattern target,QueryParameters parameter)  
/**   * You implement this method. At the timing of insert() method, which calls the onInsert().  * @param helper This is a helper object. It is the same as one that can be retrieved by this.getHelper().  * @param db This is a SQLiteDatabase object. Return the object obtained by helper.getWritableDatabase().  * @param target It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter Arguments passed to the insert() method.  * @return Please set value to be returned in the original insert() method.  */ public abstract Uri onInsert(T helper,SQLiteDatabase db,MatcherPattern target,InsertParameters parameter)  
/**   * You implement this method. At the timing of delete() method, which calls the onDelete().  * @param helper This is a helper object. It is the same as one that can be retrieved by this.getHelper().  * @param db This is a SQLiteDatabase object. Return the object obtained by helper.getWritableDatabase().  * @param target It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter Arguments passed to the delete() method.  * @return Please set value to be returned in the original delete() method.  */ public abstract int onDelete(T helper,SQLiteDatabase db,MatcherPattern target,DeleteParameters parameter)  
/**   * You implement this method. At the timing of update() method, which calls the onUpdate().  * @param helper This is a helper object. It is the same as one that can be retrieved by this.getHelper().  * @param db This is a SQLiteDatabase object. Return the object obtained by helper.getWritableDatabase().  * @param target It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter Arguments passed to the update() method.  * @return Please set value to be returned in the original update() method.  */ public abstract int onUpdate(T helper,SQLiteDatabase db,MatcherPattern target,UpdateParameters parameter)  
@Override public String getType(Uri uri){   if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   return pattern.getMimeTypeVndString()  } 
@Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){   Cursor result=null    if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   Parameter parameter=new Parameter(uri,projection,selection,selectionArgs,sortOrder)    SQLiteDatabase db=this.getHelper().getReadableDatabase()    result=onQuery(this.getHelper(),db,pattern,parameter)    if (result != null) {     this.onQueryCompleted(result,uri,pattern,parameter)    }   return result  } 
/**   * This method is called after the onQuery processing has been handled. If you're a need, you can override this method.  * @param result This is the return value of onQuery method.  * @param uri This is the Uri of target.  * @param target This is identical to the argument of onQuery method. It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter This is identical to the argument of onQuery method. Arguments passed to the query() method.  * @since 1.0.4  */ protected void onQueryCompleted(Cursor result,Uri uri,MatcherPattern target,QueryParameters parameter){   result.setNotificationUri(this.getContext().getContentResolver(),uri)  } 
@Override public Uri insert(Uri uri,ContentValues values){   Uri result=null    if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   Parameter parameter=new Parameter(uri,values)    SQLiteDatabase db=this.getHelper().getWritableDatabase()    result=onInsert(this.getHelper(),db,pattern,parameter)    if (result != null) {     this.onInsertCompleted(result,uri,pattern,parameter)    }   return result  } 
/**   * This method is called after the onInsert processing has been handled. If you're a need, you can override this method.  * @param result This is the return value of onInsert method.  * @param uri This is the Uri of target.  * @param target This is identical to the argument of onInsert method. It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter This is identical to the argument of onInsert method. Arguments passed to the insert() method.  * @since 1.0.4  */ protected void onInsertCompleted(Uri result,Uri uri,MatcherPattern target,InsertParameters parameter){   this.getContext().getContentResolver().notifyChange(result,null)  } 
@Override public int delete(Uri uri,String selection,String[] selectionArgs){   int result=-1    if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   Parameter parameter=new Parameter(uri,selection,selectionArgs)    SQLiteDatabase db=this.getHelper().getWritableDatabase()    result=onDelete(this.getHelper(),db,pattern,parameter)    if (result >= 0) {     this.onDeleteCompleted(result,uri,pattern,parameter)    }   return result  } 
/**   * This method is called after the onDelete processing has been handled. If you're a need, you can override this method.  * @param result This is the return value of onDelete method.  * @param uri This is the Uri of target.  * @param target This is identical to the argument of onDelete method. It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter This is identical to the argument of onDelete method. Arguments passed to the delete() method.  * @since 1.0.4  */ protected void onDeleteCompleted(int result,Uri uri,MatcherPattern target,DeleteParameters parameter){   this.getContext().getContentResolver().notifyChange(uri,null)  } 
@Override public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs){   int result=-1    if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   Parameter parameter=new Parameter(uri,values,selection,selectionArgs)    SQLiteDatabase db=this.getHelper().getWritableDatabase()    result=onUpdate(this.getHelper(),db,pattern,parameter)    if (result >= 0) {     this.onUpdateCompleted(result,uri,pattern,parameter)    }   return result  } 
/**   * This method is called after the onUpdate processing has been handled. If you're a need, you can override this method.  * @param result This is the return value of onUpdate method.  * @param uri This is the Uri of target.  * @param target This is identical to the argument of onUpdate method. It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter This is identical to the argument of onUpdate method. Arguments passed to the update() method.  * @since 1.0.4  */ protected void onUpdateCompleted(int result,Uri uri,MatcherPattern target,UpdateParameters parameter){   this.getContext().getContentResolver().notifyChange(uri,null)  } 
@Override public int bulkInsert(Uri uri,ContentValues[] values){   int result=0    if (!controller.hasPreinitialized()) {     throw new IllegalStateException("Controller has not been initialized.")    }   int patternCode=controller.getUriMatcher().match(uri)    MatcherPattern pattern=controller.findMatcherPattern(patternCode)    if (pattern == null) {     throw new IllegalArgumentException("unknown uri : " + uri.toString())    }   SQLiteDatabase db=this.getHelper().getWritableDatabase()    db.beginTransaction()    try {     for (    ContentValues value : values) {       Parameter parameter=new Parameter(uri,value)        Uri resultBulkInsert=this.onBulkInsert(this.getHelper(),db,pattern,parameter)        if (resultBulkInsert != null) {         result++        }     }     db.setTransactionSuccessful()      if (result >= 1) {       this.onBulkInsertCompleted(result,uri)      }   }   finally {     db.endTransaction()    }   return result  } 
/**   * You implement this method. At the timing of bulkInsert() method, which calls the onBulkInsert(). Start the transaction, will be called for each record.  * @param helper This is a helper object. It is the same as one that can be retrieved by this.getHelper().  * @param db This is a SQLiteDatabase object. Return the object obtained by helper.getWritableDatabase().  * @param target It is MatcherPattern objects that match to evaluate Uri by UriMatcher. You can access information in the tables and columns, ContentUri, MimeType etc.  * @param parameter Arguments passed to the insert() method.  * @return Please set value to be returned in the original insert() method.  * @since 1.0.1  */ public Uri onBulkInsert(T helper,SQLiteDatabase db,MatcherPattern target,InsertParameters parameter){   return onInsert(helper,db,target,parameter)  } 
/**   * This method is called after the bulkInsert processing has been handled. If you're a need, you can override this method.  * @param result This is the return value of bulkInsert method.  * @param uri This is the Uri of target.  * @since 1.0.4  */ protected void onBulkInsertCompleted(int result,Uri uri){   this.getContext().getContentResolver().notifyChange(uri,null)  } 
@Override public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations) throws OperationApplicationException {   ContentProviderResult[] result=null    SQLiteDatabase db=this.getHelper().getWritableDatabase()    db.beginTransaction()    try {     result=super.applyBatch(operations)      db.setTransactionSuccessful()    }   finally {     db.endTransaction()    }   return result  } 
@Override public Cursor onQuery(T helper,SQLiteDatabase db,MatcherPattern target,QueryParameters parameter){   Cursor result=null    SQLiteQueryBuilder builder=new SQLiteQueryBuilder()    builder.setTables(target.getTableInfo().getName())    builder.setProjectionMap(target.getTableInfo().getProjectionMap())  switch (target.getMimeTypeVnd().getSubType()) { case ITEM:     builder.appendWhere(target.getTableInfo().getIdColumnInfo().getColumnName())    builder.appendWhere("=")  builder.appendWhere(parameter.getUri().getPathSegments().get(1))  break  case DIRECTORY: default : break  } String orderBy=getSortOrderStringForQuery(target,parameter)  result=builder.query(db,parameter.getProjection(),parameter.getSelection(),parameter.getSelectionArgs(),null,null,orderBy)  return result  } 
@Override public Uri onInsert(T helper,SQLiteDatabase db,MatcherPattern target,InsertParameters parameter){   Uri result=null    long id=db.insert(target.getTableInfo().getName(),null,parameter.getValues())    if (id >= 0) {     result=ContentUris.withAppendedId(target.getContentUriPattern(),id)    }  else {     throw new SQLException("Failed to insert row into : " + parameter.getUri().toString())    }   return result  } 
@Override public int onDelete(T helper,SQLiteDatabase db,MatcherPattern target,DeleteParameters parameter){   int result=-1  switch (target.getMimeTypeVnd().getSubType()) { case DIRECTORY:     result=db.delete(target.getTableInfo().getName(),parameter.getSelection(),parameter.getSelectionArgs())    break  case ITEM: String where=target.getTableInfo().getIdColumnInfo().getColumnName() + "=" + parameter.getUri().getPathSegments().get(1)  if (parameter.getSelection() != null && parameter.getSelection().length() >= 1) { where+=" AND ( " + parameter.getSelection() + " ) "  } result=db.delete(target.getTableInfo().getName(),where,parameter.getSelectionArgs())  break  default : break  } return result  } 
@Override public int onUpdate(T helper,SQLiteDatabase db,MatcherPattern target,UpdateParameters parameter){   int result=-1  switch (target.getMimeTypeVnd().getSubType()) { case DIRECTORY:     result=db.update(target.getTableInfo().getName(),parameter.getValues(),parameter.getSelection(),parameter.getSelectionArgs())    break  case ITEM: String where=target.getTableInfo().getIdColumnInfo().getColumnName() + "=" + parameter.getUri().getPathSegments().get(1)  if (parameter.getSelection() != null && parameter.getSelection().length() >= 1) { where+=" AND ( " + parameter.getSelection() + " ) "  } result=db.update(target.getTableInfo().getName(),parameter.getValues(),where,parameter.getSelectionArgs())  break  default : break  } return result  } 
/**   * This method gets the appropriate sort order.  * @param target Arguments passed to the onQuery() method.  * @param parameter Arguments passed to the onQuery() method.  * @return return an sort order string.  * @since 1.0.4  */ protected String getSortOrderStringForQuery(MatcherPattern target,QueryParameters parameter){   String result=""    if (parameter.getSortOrder() != null && parameter.getSortOrder().length() >= 1) {     result=parameter.getSortOrder()    }  else {     result=target.getTableInfo().getDefaultSortOrderString()    }   return result  } 
public void testIsValid_should_return_false_until_validated(){   dummyAnnotationInfoBase=new DummyAnnotationInfoBase(true)    assertFalse(dummyAnnotationInfoBase.isValid())    dummyAnnotationInfoBase.validate()    assertTrue(dummyAnnotationInfoBase.isValid())  } 
public void testIsValid_throws_exception_or_not(){   dummyAnnotationInfoBase=new DummyAnnotationInfoBase(true)    assertFalse(dummyAnnotationInfoBase.isValid(false))    try {     dummyAnnotationInfoBase.isValid(true)      fail()    }  catch (  Exception ex) {     assertTrue(true)    } } 
public DummyAnnotationInfoBase(boolean isValidValue){   this.isValidValue=isValidValue  } 
public void validate(){   validFlagOn()  } 
@Override protected boolean isValidValue(){   return isValidValue  } 
@Override public String toString(){   return "DummyAnnotationInfoBase{" + "isValidValue=" + isValidValue + "} "+ super.toString()  } 
public void testIsValidValue_returns_false_for_null_or_empty_package_or_class(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(null,null)    assertFalse(contentMimeTypeVndInfo.isValidValue())    contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(null,TEST_TYPE)    assertFalse(contentMimeTypeVndInfo.isValidValue())    contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,null)    assertFalse(contentMimeTypeVndInfo.isValidValue())    contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,EMPTY)    assertFalse(contentMimeTypeVndInfo.isValidValue())    contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(EMPTY,TEST_TYPE)    assertFalse(contentMimeTypeVndInfo.isValidValue())  } 
public void testIsValidValue_returns_true(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,TEST_TYPE)    assertTrue(contentMimeTypeVndInfo.isValidValue())  } 
public void testGetName(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,TEST_TYPE)    assertEquals(TEST_NAME,contentMimeTypeVndInfo.getName())  } 
public void testGetType(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,TEST_TYPE)    assertEquals(TEST_TYPE,contentMimeTypeVndInfo.getType())  } 
public void testGetVndProviderSpecificString(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(TEST_NAME,TEST_TYPE)    assertEquals(ContentMimeTypeVndInfo.VND + "." + TEST_NAME+ "."+ TEST_TYPE,contentMimeTypeVndInfo.getVndProviderSpecificString())  } 
public void testIsValidValue_returns_right_values_for_annotated_element_without_params(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(AnnotatedClassUnderTestNoParams.class)    assertEquals(AnnotatedClassUnderTestNoParams.class.getPackage().getName() + ContentMimeTypeVndInfo.PROVIDER_SUFFIX,contentMimeTypeVndInfo.getName())    assertEquals(AnnotatedClassUnderTestNoParams.class.getSimpleName().toLowerCase(Locale.ENGLISH),contentMimeTypeVndInfo.getType())    assertTrue(contentMimeTypeVndInfo.isValidValue())  } 
public void testIsValidValue_returns_right_values_for_annotated_element_with_params(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(AnnotatedClassUnderTestWithParams.class)    assertEquals(TEST_NAME,contentMimeTypeVndInfo.getName())    assertEquals(TEST_TYPE,contentMimeTypeVndInfo.getType())    assertTrue(contentMimeTypeVndInfo.isValidValue())  } 
public void testIsValidValue_returns_right_values_for_non_annotated_element(){   contentMimeTypeVndInfo=new ContentMimeTypeVndInfo(NonAnnotatedClassUnderTest.class)    assertEquals(NonAnnotatedClassUnderTest.class.getPackage().getName() + ContentMimeTypeVndInfo.PROVIDER_SUFFIX,contentMimeTypeVndInfo.getName())    assertEquals(NonAnnotatedClassUnderTest.class.getSimpleName().toLowerCase(Locale.ENGLISH),contentMimeTypeVndInfo.getType())    assertTrue(contentMimeTypeVndInfo.isValidValue())  } 
public void testIsValidValue_returns_false_for_null_or_empty_package_or_class(){   contentUriInfo=new ContentUriInfo(null,null)    assertFalse(contentUriInfo.isValidValue())    contentUriInfo=new ContentUriInfo(null,TEST_PATH)    assertFalse(contentUriInfo.isValidValue())    contentUriInfo=new ContentUriInfo(TEST_AUTHORITY,null)    assertFalse(contentUriInfo.isValidValue())    contentUriInfo=new ContentUriInfo(TEST_AUTHORITY,EMPTY)    assertFalse(contentUriInfo.isValidValue())    contentUriInfo=new ContentUriInfo(EMPTY,TEST_PATH)    assertFalse(contentUriInfo.isValidValue())  } 
public void testIsValidValue_returns_true(){   contentUriInfo=new ContentUriInfo(TEST_AUTHORITY,TEST_PATH)    assertTrue(contentUriInfo.isValidValue())  } 
public void testgetAuthority(){   contentUriInfo=new ContentUriInfo(TEST_AUTHORITY,TEST_PATH)    assertEquals(TEST_AUTHORITY,contentUriInfo.getAuthority())  } 
public void testgetPath(){   contentUriInfo=new ContentUriInfo(TEST_AUTHORITY,TEST_PATH)    assertEquals(TEST_PATH,contentUriInfo.getPath())  } 
public void testIsValidValue_returns_right_values_for_annotated_element_without_params(){   contentUriInfo=new ContentUriInfo(AnnotatedClassUnderTestNoParams.class)    assertEquals(AnnotatedClassUnderTestNoParams.class.getPackage().getName(),contentUriInfo.getAuthority())    assertEquals(AnnotatedClassUnderTestNoParams.class.getSimpleName().toLowerCase(Locale.ENGLISH),contentUriInfo.getPath())    assertTrue(contentUriInfo.isValidValue())  } 
public void testIsValidValue_returns_right_values_for_annotated_element_with_params(){   contentUriInfo=new ContentUriInfo(AnnotatedClassUnderTestWithParams.class)    assertEquals(TEST_AUTHORITY,contentUriInfo.getAuthority())    assertEquals(TEST_PATH,contentUriInfo.getPath())    assertTrue(contentUriInfo.isValidValue())  } 
public void testIsValidValue_returns_right_values_for_non_annotated_element(){   contentUriInfo=new ContentUriInfo(NonAnnotatedClassUnderTest.class)    assertEquals(NonAnnotatedClassUnderTest.class.getPackage().getName(),contentUriInfo.getAuthority())    assertEquals(NonAnnotatedClassUnderTest.class.getSimpleName().toLowerCase(Locale.ENGLISH),contentUriInfo.getPath())    assertTrue(contentUriInfo.isValidValue())  } 
public void testIsValid_returns_true_when_field_has_empty_column_name() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField("annotatedFieldWithEmptyColumnName")    columnInfo=new ColumnInfo(field)    assertTrue(columnInfo.isValid())  } 
public void testIsValid_returns_true_when_field_has_no_column_name() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField("annotatedField")    columnInfo=new ColumnInfo(field)    assertTrue(columnInfo.isValid())  } 
public void testIsValid_returns_true_when_field_has_column_name() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField("annotatedFieldWithParams")    columnInfo=new ColumnInfo(field)    assertTrue(columnInfo.isValid())  } 
public void testConstructor_throws_exception_when_field_is_not_annotated() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField("nonAnnotatedField")    try {     columnInfo=new ColumnInfo(field)      fail()    }  catch (  Exception e) {     assertTrue(true)    } } 
public void testGetProjectionColumnName_returns_field_name_when_has_no_column_name() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField(TEST_FIELD_NAME)    columnInfo=new ColumnInfo(field)    assertEquals(TEST_FIELD_NAME,columnInfo.getColumnName())  } 
public void testGetProjectionColumnName_returns_field_name_when_has_column_name() throws NoSuchFieldException {   Field field=ClassUnderTest.class.getDeclaredField(TEST_FIELD_NAME)    columnInfo=new ColumnInfo(field)    assertEquals(TEST_FIELD_NAME,columnInfo.getColumnName())  } 
public void testGetProjectionColumnName_returns_field_name_when_has_empty_column_name() throws NoSuchFieldException {   final String testFieldName="annotatedFieldWithEmptyColumnName"    Field field=ClassUnderTest.class.getDeclaredField(testFieldName)    columnInfo=new ColumnInfo(field)    assertEquals(testFieldName,columnInfo.getColumnName())  } 
public void testIsValid_should_return_false_if_subtype_is_null(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotations.class)    SubType subType=null    String pattern=TEST_PATTERN    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertFalse(matcherPattern.isValid(DEBUG))  } 
public void testIsValid_should_return_false_if_pattern_is_null(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotations.class)    SubType subType=SubType.ITEM    String pattern=null    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertFalse(matcherPattern.isValid(DEBUG))  } 
public void testIsValid_should_return_true_if_pattern_is_empty(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotations.class)    SubType subType=SubType.ITEM    String pattern=EMPTY    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertTrue(matcherPattern.isValid(DEBUG))  } 
public void testIsValid_should_return_false_if_pattern_code_is_0_or_negative(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotations.class)    SubType subType=SubType.ITEM    String pattern=TEST_PATTERN    int patternCode=0    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertFalse(matcherPattern.isValid(DEBUG))    patternCode=-1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertFalse(matcherPattern.isValid(DEBUG))  } 
public void testIsValid_should_return_true_for_properly_defined_matcher_pattern(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotations.class)    SubType subType=SubType.ITEM    String pattern=TEST_PATTERN    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertTrue(matcherPattern.isValid())  } 
public void testIsValid_should_return_true_for_non_annotated_class(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithoutAnnotations.class)    SubType subType=SubType.ITEM    String pattern=TEST_PATTERN    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertTrue(matcherPattern.isValid())  } 
public void testIsValid_should_return_true_for_class_annotated_with_params(){   TableInfo tableInfo=new TableInfo(ClassUnderTestWithAnnotationsWithParams.class)    SubType subType=SubType.ITEM    String pattern=TEST_PATTERN    int patternCode=1    matcherPattern=new MatcherPattern(tableInfo,subType,pattern,patternCode)    assertTrue(matcherPattern.isValid())  } 
public void testIsValid_returns_false_if_subtype_is_null(){   mimeTypeVnd=new MimeTypeVnd(null,new ContentMimeTypeVndInfo(CONTENT_MIME_TYPE_VND_NAME,CONTENT_MIME_TYPE_VND_TYPE))    assertFalse(mimeTypeVnd.isValid())  } 
public void testIsValid_returns_false_if_mime_type_has_null_or_empty_path(){   mimeTypeVnd=new MimeTypeVnd(SubType.ITEM,new ContentMimeTypeVndInfo(null,CONTENT_MIME_TYPE_VND_TYPE))    assertFalse(mimeTypeVnd.isValid())    mimeTypeVnd=new MimeTypeVnd(SubType.ITEM,new ContentMimeTypeVndInfo(EMPTY,CONTENT_MIME_TYPE_VND_TYPE))    assertFalse(mimeTypeVnd.isValid())  } 
public void testIsValid_returns_false_if_mime_type_has_null_or_empty_type(){   mimeTypeVnd=new MimeTypeVnd(SubType.ITEM,new ContentMimeTypeVndInfo(CONTENT_MIME_TYPE_VND_NAME,null))    assertFalse(mimeTypeVnd.isValid())    mimeTypeVnd=new MimeTypeVnd(SubType.ITEM,new ContentMimeTypeVndInfo(CONTENT_MIME_TYPE_VND_NAME,EMPTY))    assertFalse(mimeTypeVnd.isValid())  } 
public void testGetMimeTypeString(){   mimeTypeVnd=new MimeTypeVnd(SubType.ITEM,new ContentMimeTypeVndInfo(CONTENT_MIME_TYPE_VND_NAME,CONTENT_MIME_TYPE_VND_TYPE))    final String expectedTypeString=SubType.ITEM.toString() + File.separator + ContentMimeTypeVndInfo.VND+ ContentMimeTypeVndInfo.VND_SEPARATOR+ CONTENT_MIME_TYPE_VND_NAME+ ContentMimeTypeVndInfo.VND_SEPARATOR+ CONTENT_MIME_TYPE_VND_TYPE    assertEquals(expectedTypeString,mimeTypeVnd.getMimeTypeString())  } 
public Account(){ } 
public Account(String name){   this.id=0    this.name=name  } 
public int getId(){   return id  } 
public String getName(){   return name  } 
public Membership(){ } 
public Membership(int daysOfMembership){   this.id=0    this.daysOfMembership=daysOfMembership  } 
public int getId(){   return id  } 
public int getDaysOfMembership(){   return daysOfMembership  } 
private AccountContract(){ } 
private MembershipContract(){ } 
public SampleHelper(Context context){   super(context,"MyDatabase",null,1)  } 
@Override public void onCreate(SQLiteDatabase database,ConnectionSource connectionSource){   try {     resetAllTables()    }  catch (  SQLException e) {     e.printStackTrace()    } } 
@Override public void onUpgrade(SQLiteDatabase database,ConnectionSource connectionSource,int oldVersion,int newVersion){   try {     resetAllTables()    }  catch (  SQLException e) {     e.printStackTrace()    } } 
public void resetAllTables() throws SQLException {   for (  Class<?> clazz : CLASS_LIST) {     TableUtils.dropTable(connectionSource,clazz,true)      TableUtils.createTable(connectionSource,clazz)    } } 
@Override protected Class<SampleHelper> getHelperClass(){   return SampleHelper.class  } 
@Override public boolean onCreate(){   int patternCode=1    setMatcherController(new MatcherController().add(Account.class,SubType.DIRECTORY,"",patternCode++).add(Account.class,SubType.ITEM,"#",patternCode++).add(Membership.class,SubType.DIRECTORY,"",patternCode++).add(Membership.class,SubType.ITEM,"#",patternCode++))    return true  } 
@Override protected void setUp() throws Exception {   super.setUp()    getHelper().resetAllTables()    UnderTestSampleProvider provider=new UnderTestSampleProvider()    provider.attachInfo(getInstrumentation().getContext(),null)    this.resolver=new MockContentResolver()    this.resolver.addProvider(AccountContract.AUTHORITY,provider)  } 
public void testOnInsert(){   ContentValues values=new ContentValues()    values.clear()    values.put(AccountContract.NAME,TEST_NAME_1)    this.resolver.insert(AccountContract.CONTENT_URI,values)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(1,accountList.size())    assertEquals(TEST_NAME_1,accountList.get(0).getName())  } 
public void testOnDelete(){   Account account=new Account(TEST_NAME_2)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    simpleDao.create(account)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(1,accountList.size())    this.resolver.delete(AccountContract.CONTENT_URI,BaseColumns._ID + " = " + account.getId(),null)    accountList=simpleDao.queryForAll()    assertEquals(0,accountList.size())  } 
public void testOnUpdate(){   Account account=new Account(TEST_NAME_1)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    simpleDao.create(account)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(1,accountList.size())    ContentValues values=new ContentValues()    values.clear()    values.put(AccountContract.NAME,TEST_NAME_2)    this.resolver.update(AccountContract.CONTENT_URI,values,BaseColumns._ID + " = " + account.getId(),null)    accountList=simpleDao.queryForAll()    assertEquals(1,accountList.size())    assertEquals(TEST_NAME_2,accountList.get(0).getName())  } 
public void testOnQuery(){   Account account1=new Account(TEST_NAME_1)    Account account2=new Account(TEST_NAME_2)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    simpleDao.create(account1)    simpleDao.create(account2)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(2,accountList.size())    Cursor cursor=this.resolver.query(AccountContract.CONTENT_URI,new String[]{BaseColumns._ID,AccountContract.NAME},null,null,null)    accountList=new ArrayList<Account>()    while (cursor.moveToNext()) {     Account account=new Account(cursor.getString(1))      accountList.add(account)    }   cursor.close()    assertEquals(2,accountList.size())    assertEquals(TEST_NAME_1,accountList.get(0).getName())    assertEquals(TEST_NAME_2,accountList.get(1).getName())  } 
public void testOnQueryWithOrder(){   Account account1=new Account(TEST_NAME_1)    Account account2=new Account(TEST_NAME_2)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    simpleDao.create(account1)    simpleDao.create(account2)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(2,accountList.size())    String order=BaseColumns._ID + " DESC"    Cursor cursor=this.resolver.query(AccountContract.CONTENT_URI,new String[]{BaseColumns._ID,AccountContract.NAME},null,null,order)    accountList=new ArrayList<Account>()    while (cursor.moveToNext()) {     Account account=new Account(cursor.getString(1))      accountList.add(account)    }   cursor.close()    assertEquals(2,accountList.size())    assertEquals(TEST_NAME_2,accountList.get(0).getName())    assertEquals(TEST_NAME_1,accountList.get(1).getName())  } 
public void testContentProviderAcquisition() throws RemoteException {   Account account1=new Account(TEST_NAME_1)    Account account2=new Account(TEST_NAME_2)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    simpleDao.create(account1)    simpleDao.create(account2)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(2,accountList.size())    ContentProviderClient contentProviderClient=this.resolver.acquireContentProviderClient(AccountContract.CONTENT_URI)    Cursor cursor=contentProviderClient.query(AccountContract.CONTENT_URI,null,null,null,null)    accountList=new ArrayList<Account>()    while (cursor.moveToNext()) {     Account account=new Account(cursor.getString(1))      accountList.add(account)    }   cursor.close()    contentProviderClient.release()    assertEquals(2,accountList.size())    assertEquals(TEST_NAME_1,accountList.get(0).getName())    assertEquals(TEST_NAME_2,accountList.get(1).getName())  } 
public void testBulkInsert(){   final int testAccountCount=10    ContentValues[] contentValues=new ContentValues[testAccountCount]    for (int accountIndex=0  accountIndex < testAccountCount  accountIndex++) {     ContentValues values=new ContentValues()      values.clear()      values.put(AccountContract.NAME,TEST_NAME_1 + accountIndex)      contentValues[accountIndex]=values    }   this.resolver.bulkInsert(AccountContract.CONTENT_URI,contentValues)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(testAccountCount,accountList.size())    int accountIndex=0    for (  Account account : accountList) {     assertEquals(TEST_NAME_1 + accountIndex++,account.getName())    } } 
public void testApplyBatch() throws RemoteException, OperationApplicationException {   ArrayList<ContentProviderOperation> operations=new ArrayList<ContentProviderOperation>()    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,TEST_NAME_1).build())    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,TEST_NAME_2).build())    this.resolver.applyBatch(AccountContract.AUTHORITY,operations)    RuntimeExceptionDao<Account,Integer> simpleDao=getHelper().getRuntimeExceptionDao(Account.class)    List<Account> accountList=simpleDao.queryForAll()    assertEquals(2,accountList.size())    assertEquals(TEST_NAME_1,accountList.get(0).getName())    assertEquals(TEST_NAME_2,accountList.get(1).getName())  } 
private SampleHelper getHelper(){   return new SampleHelper(getInstrumentation().getTargetContext())  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    ContentValues values=new ContentValues()    values.clear()    values.put(AccountContract.NAME,"Yamada Tarou")    getContentResolver().insert(AccountContract.CONTENT_URI,values)    ContentValues[] contentValues=new ContentValues[TEST_ENTRY_COUNT]    for (int i=0  i < TEST_ENTRY_COUNT  i++) {     values=new ContentValues()      values.clear()      values.put(AccountContract.NAME,"Yamada Tarou: " + i)      contentValues[i]=values    }   getContentResolver().bulkInsert(AccountContract.CONTENT_URI,contentValues)    Cursor c=getContentResolver().query(AccountContract.CONTENT_URI,null,null,null,null)    c.moveToFirst()    do {     for (int i=0  i < c.getColumnCount()  i++) {       Log.d(getClass().getSimpleName(),c.getColumnName(i) + " : " + c.getString(i))      }   }  while (c.moveToNext())    c.close()    ArrayList<ContentProviderOperation> operations=new ArrayList<ContentProviderOperation>()    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,"Yamada Hanako 1").build())    operations.add(ContentProviderOperation.newInsert(AccountContract.CONTENT_URI).withValue(AccountContract.NAME,"Yamada Hanako 2").build())    try {     getContentResolver().applyBatch(AccountContract.AUTHORITY,operations)    }  catch (  Exception e) {     e.printStackTrace()    }   ContentProviderClient client=getContentResolver().acquireContentProviderClient(AccountContract.CONTENT_URI)    Cursor c2=null    try {     c2=client.query(AccountContract.CONTENT_URI,null,null,null,null)      c2.moveToFirst()      do {       for (int i=0  i < c2.getColumnCount()  i++) {         Log.d(getClass().getSimpleName(),c2.getColumnName(i) + " : " + c2.getString(i))        }     }  while (c2.moveToNext())    }  catch (  RemoteException e) {     e.printStackTrace()    }  finally {     if (c2 != null) {       c2.close()      }   }   client.release()  } 
@Override public boolean onCreateOptionsMenu(Menu menu){   getMenuInflater().inflate(R.menu.activity_main,menu)    return true  } 
public Account(){ } 
public Account(String name){   this.id=0    this.name=name  } 
public int getId(){   return id  } 
public String getName(){   return name  } 
private AccountContract(){ } 
public SampleHelper(Context context){   super(context,"MyDatabase",null,1)  } 
@Override public void onCreate(SQLiteDatabase database,ConnectionSource connectionSource){   try {     TableUtils.createTableIfNotExists(connectionSource,Account.class)    }  catch (  SQLException e) {     e.printStackTrace()    } } 
@Override public void onUpgrade(SQLiteDatabase database,ConnectionSource connectionSource,int oldVersion,int newVersion){   try {     TableUtils.dropTable(connectionSource,Account.class,true)      TableUtils.createTable(connectionSource,Account.class)    }  catch (  SQLException e) {     e.printStackTrace()    } } 
@Override protected Class<SampleHelper> getHelperClass(){   return SampleHelper.class  } 
@Override public boolean onCreate(){   setMatcherController(new MatcherController().add(Account.class,SubType.DIRECTORY,"",AccountContract.CONTENT_URI_PATTERN_MANY).add(Account.class,SubType.ITEM,"#",AccountContract.CONTENT_URI_PATTERN_ONE))    return true  } 
public GitActivityClone(){   super(GitActivity.class)  } 
protected void setUp() throws Exception {   super.setUp()    mInstrumentation=getInstrumentation()    Intent intent=new Intent()    intent.putExtra("Operation",GitActivity.REQUEST_CLONE)    setActivityIntent(intent)    gitActivity=getActivity()    assertNotNull(gitActivity)    settings=PreferenceManager.getDefaultSharedPreferences(gitActivity.getApplicationContext())    uri=(EditText)gitActivity.findViewById(R.id.clone_uri)    server_url=((EditText)gitActivity.findViewById(R.id.server_url))    server_port=((EditText)gitActivity.findViewById(R.id.server_port))    server_path=((EditText)gitActivity.findViewById(R.id.server_path))    server_user=((EditText)gitActivity.findViewById(R.id.server_user))    protocolSpinner=(Spinner)gitActivity.findViewById(R.id.clone_protocol)    connectionModeSpinner=(Spinner)gitActivity.findViewById(R.id.connection_mode)    assertNotNull(uri)    assertNotNull(server_url)    assertNotNull(server_port)    assertNotNull(server_path)    assertNotNull(server_user)    assertNotNull(protocolSpinner)    assertNotNull(connectionModeSpinner)    assertEquals(protocolSpinner.getSelectedItem(),settings.getString("git_remote_protocol","ssh://"))    assertEquals(connectionModeSpinner.getSelectedItem(),settings.getString("git_remote_auth","ssh-key"))  } 
public void testCloneSshUser() throws Exception {   final Solo solo=new Solo(getInstrumentation(),getActivity())    FileUtils.deleteDirectory(new File(gitActivity.getFilesDir() + gitActivity.getResources().getString(R.string.store_git)))    PasswordRepository.getRepository(new File(gitActivity.getFilesDir() + gitActivity.getResources().getString(R.string.store_git)))    gitActivity.runOnUiThread(new Runnable(){     public void run(){       protocolSpinner.setSelection(0)      }   } )  } 
public void run(){   protocolSpinner.setSelection(0)  } 
public GitActivityTest(){   super(GitActivity.class)  } 
protected void setUp() throws Exception {   super.setUp()    mInstrumentation=getInstrumentation()    Intent intent=new Intent()    intent.putExtra("Operation",GitActivity.EDIT_SERVER)    setActivityIntent(intent)    gitActivity=getActivity()    assertNotNull(gitActivity)    settings=PreferenceManager.getDefaultSharedPreferences(gitActivity.getApplicationContext())    uri=(EditText)gitActivity.findViewById(R.id.clone_uri)    server_url=((EditText)gitActivity.findViewById(R.id.server_url))    server_port=((EditText)gitActivity.findViewById(R.id.server_port))    server_path=((EditText)gitActivity.findViewById(R.id.server_path))    server_user=((EditText)gitActivity.findViewById(R.id.server_user))    protocolSpinner=(Spinner)gitActivity.findViewById(R.id.clone_protocol)    connectionModeSpinner=(Spinner)gitActivity.findViewById(R.id.connection_mode)    assertEquals(protocolSpinner.getSelectedItem(),settings.getString("git_remote_protocol","ssh://"))    assertEquals(connectionModeSpinner.getSelectedItem(),settings.getString("git_remote_auth","ssh-key"))  } 
/**   * If we change from ssh protocol to https we automatically switch to username/password auth  * @throws Exception  */ public void testSpinnerChange() throws Exception {   gitActivity.runOnUiThread(new Runnable(){     public void run(){       protocolSpinner.requestFocus()        protocolSpinner.setSelection(1)      }   } )    mInstrumentation.waitForIdleSync()    assertEquals(connectionModeSpinner.getSelectedItem(),"username/password")  } 
public void run(){   protocolSpinner.requestFocus()    protocolSpinner.setSelection(1)  } 
public RepositoryCreation(){   super(PasswordStore.class)  } 
protected void setUp() throws Exception {   super.setUp()    mInstrumentation=getInstrumentation()    Intent intent=new Intent()    setActivityIntent(intent)    passwordStore=getActivity()    assertNotNull(passwordStore)    settings=PreferenceManager.getDefaultSharedPreferences(passwordStore.getApplicationContext())    settings.edit().clear().apply()  } 
/**   * If we change from ssh protocol to https we automatically switch to username/password auth  * @throws Exception  */ public void testSpinnerChange() throws Exception { } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    Bundle extras=getIntent().getExtras()    if (extras != null && extras.containsKey("pending_intent")) {     try {       PendingIntent pi=extras.getParcelable("pending_intent")        if (pi == null) {         return        }       startIntentSenderForResult(pi.getIntentSender(),REQUEST_CODE_DECRYPT_AND_VERIFY,null,0,0,0)      }  catch (    IntentSender.SendIntentException e) {       Log.e(AutofillService.Constants.TAG,"SendIntentException",e)      }   }  else   if (extras != null && extras.containsKey("pick")) {     Intent intent=new Intent(getApplicationContext(),PasswordStore.class)      intent.putExtra("matchWith",true)      startActivityForResult(intent,REQUEST_CODE_PICK)    }  else   if (extras != null && extras.containsKey("pickMatchWith")) {     Intent intent=new Intent(getApplicationContext(),PasswordStore.class)      intent.putExtra("matchWith",true)      startActivityForResult(intent,REQUEST_CODE_PICK_MATCH_WITH)    } } 
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){   finish()  switch (requestCode) { case REQUEST_CODE_DECRYPT_AND_VERIFY:     if (resultCode == RESULT_OK) {       AutofillService.getInstance().setResultData(data)      }   break  case REQUEST_CODE_PICK: if (resultCode == RESULT_OK) {   AutofillService.getInstance().setPickedPassword(data.getStringExtra("path"))  } break  case REQUEST_CODE_PICK_MATCH_WITH: if (resultCode == RESULT_OK) { Bundle extras=getIntent().getExtras()  String packageName=extras.getString("packageName")  boolean isWeb=extras.getBoolean("isWeb")  String path=data.getStringExtra("path")  AutofillService.getInstance().setPickedPassword(data.getStringExtra("path"))  SharedPreferences prefs  if (!isWeb) { prefs=getApplicationContext().getSharedPreferences("autofill",Context.MODE_PRIVATE)  }  else { prefs=getApplicationContext().getSharedPreferences("autofill_web",Context.MODE_PRIVATE)  } SharedPreferences.Editor editor=prefs.edit()  String preference=prefs.getString(packageName,"")  switch (preference) { case "": case "/first": case "/never": editor.putString(packageName,path)  break  default : List<String> matches=new ArrayList<>(Arrays.asList(preference.trim().split("\n")))  matches.add(path)  String paths=StringUtils.join(matches,"\n")  editor.putString(packageName,paths)  } editor.apply()  } break  } } 
public AutofillFragment(){ } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   AlertDialog.Builder builder=new AlertDialog.Builder(getActivity())    final AutofillPreferenceActivity callingActivity=(AutofillPreferenceActivity)getActivity()    LayoutInflater inflater=callingActivity.getLayoutInflater()    final View view=inflater.inflate(R.layout.fragment_autofill,null)    builder.setView(view)    final String packageName=getArguments().getString("packageName")    final String appName=getArguments().getString("appName")    isWeb=getArguments().getBoolean("isWeb")    String iconPackageName    if (!isWeb) {     iconPackageName=packageName      builder.setTitle(appName)      view.findViewById(R.id.webURL).setVisibility(View.GONE)    }  else {     iconPackageName="com.android.browser"      builder.setTitle("Website")      ((EditText)view.findViewById(R.id.webURL)).setText(packageName)    }   try {     builder.setIcon(callingActivity.getPackageManager().getApplicationIcon(iconPackageName))    }  catch (  PackageManager.NameNotFoundException e) {     e.printStackTrace()    }   adapter=new ArrayAdapter<String>(getActivity().getApplicationContext(),android.R.layout.simple_list_item_1,android.R.id.text1){     @Override public View getView(    int position,    View convertView,    ViewGroup parent){       TextView textView=(TextView)super.getView(position,convertView,parent)        textView.setTextColor(ContextCompat.getColor(getContext(),R.color.grey_black_1000))        return textView      }   }     ((ListView)view.findViewById(R.id.matched)).setAdapter(adapter)    ((ListView)view.findViewById(R.id.matched)).setOnItemClickListener(new AdapterView.OnItemClickListener(){     @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){       adapter.remove(adapter.getItem(position))      }   } )    SharedPreferences prefs    if (!isWeb) {     prefs=getActivity().getApplicationContext().getSharedPreferences("autofill",Context.MODE_PRIVATE)    }  else {     prefs=getActivity().getApplicationContext().getSharedPreferences("autofill_web",Context.MODE_PRIVATE)    }   String preference=prefs.getString(packageName,"")  switch (preference) { case "":     ((RadioButton)view.findViewById(R.id.use_default)).toggle()    break  case "/first": ((RadioButton)view.findViewById(R.id.first)).toggle()  break  case "/never": ((RadioButton)view.findViewById(R.id.never)).toggle()  break  default : ((RadioButton)view.findViewById(R.id.match)).toggle()  adapter.addAll(preference.trim().split("\n"))  } View.OnClickListener matchPassword=new View.OnClickListener(){ @Override public void onClick(View v){ ((RadioButton)view.findViewById(R.id.match)).toggle()  Intent intent=new Intent(getActivity(),PasswordStore.class)  intent.putExtra("matchWith",true)  startActivityForResult(intent,MATCH_WITH)  } }   view.findViewById(R.id.matchButton).setOnClickListener(matchPassword)  builder.setPositiveButton(R.string.dialog_ok,new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog,int which){ } } )  builder.setNegativeButton(R.string.dialog_cancel,null)  final SharedPreferences.Editor editor=prefs.edit()  if (isWeb) { builder.setNeutralButton(R.string.autofill_apps_delete,new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog,int which){ if (callingActivity.recyclerAdapter != null && packageName != null && !packageName.equals("")) { editor.remove(packageName)  callingActivity.recyclerAdapter.removeWebsite(packageName)  editor.apply()  } } } )  } return builder.create()  } 
@Override public View getView(int position,View convertView,ViewGroup parent){   TextView textView=(TextView)super.getView(position,convertView,parent)    textView.setTextColor(ContextCompat.getColor(getContext(),R.color.grey_black_1000))    return textView  } 
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){   adapter.remove(adapter.getItem(position))  } 
@Override public void onClick(View v){   ((RadioButton)view.findViewById(R.id.match)).toggle()    Intent intent=new Intent(getActivity(),PasswordStore.class)    intent.putExtra("matchWith",true)    startActivityForResult(intent,MATCH_WITH)  } 
@Override public void onClick(DialogInterface dialog,int which){ } 
@Override public void onClick(DialogInterface dialog,int which){   if (callingActivity.recyclerAdapter != null && packageName != null && !packageName.equals("")) {     editor.remove(packageName)      callingActivity.recyclerAdapter.removeWebsite(packageName)      editor.apply()    } } 
@Override public void onStart(){   super.onStart()    AlertDialog ad=(AlertDialog)getDialog()    if (ad != null) {     Button positiveButton=ad.getButton(Dialog.BUTTON_POSITIVE)      positiveButton.setOnClickListener(new View.OnClickListener(){       @Override public void onClick(      View v){         AutofillPreferenceActivity callingActivity=(AutofillPreferenceActivity)getActivity()          Dialog dialog=getDialog()          SharedPreferences prefs          if (!isWeb) {           prefs=getActivity().getApplicationContext().getSharedPreferences("autofill",Context.MODE_PRIVATE)          }  else {           prefs=getActivity().getApplicationContext().getSharedPreferences("autofill_web",Context.MODE_PRIVATE)          }         SharedPreferences.Editor editor=prefs.edit()          String packageName=getArguments().getString("packageName","")          if (isWeb) {           packageName=((EditText)dialog.findViewById(R.id.webURL)).getText().toString()            EditText webURL=(EditText)dialog.findViewById(R.id.webURL)            if (packageName.equals("")) {             webURL.setError("URL cannot be blank")              return            }           String oldPackageName=getArguments().getString("packageName","")            if (!oldPackageName.equals(packageName) && prefs.getAll().containsKey(packageName)) {             webURL.setError("URL already exists")              return            }         }         RadioGroup radioGroup=(RadioGroup)dialog.findViewById(R.id.autofill_radiogroup)  switch (radioGroup.getCheckedRadioButtonId()) { case R.id.use_default:           if (!isWeb) {             editor.remove(packageName)            }  else {             editor.putString(packageName,"")            }         break  case R.id.first:       editor.putString(packageName,"/first")      break  case R.id.never:   editor.putString(packageName,"/never")  break  default : StringBuilder paths=new StringBuilder()  for (int i=0  i < adapter.getCount()  i++) { paths.append(adapter.getItem(i))  if (i != adapter.getCount()) { paths.append("\n")  } } editor.putString(packageName,paths.toString())  } editor.apply()  if (callingActivity.recyclerAdapter != null) { int position  if (!isWeb) { String appName=getArguments().getString("appName","")  position=callingActivity.recyclerAdapter.getPosition(appName)  callingActivity.recyclerAdapter.notifyItemChanged(position)  }  else { position=callingActivity.recyclerAdapter.getPosition(packageName)  String oldPackageName=getArguments().getString("packageName","")  if (oldPackageName.equals(packageName)) { callingActivity.recyclerAdapter.notifyItemChanged(position)  }  else if (oldPackageName.equals("")) { callingActivity.recyclerAdapter.addWebsite(packageName)  }  else { editor.remove(oldPackageName)  callingActivity.recyclerAdapter.updateWebsite(oldPackageName,packageName)  } } } dismiss()  } } )  } } 
@Override public void onClick(View v){   AutofillPreferenceActivity callingActivity=(AutofillPreferenceActivity)getActivity()    Dialog dialog=getDialog()    SharedPreferences prefs    if (!isWeb) {     prefs=getActivity().getApplicationContext().getSharedPreferences("autofill",Context.MODE_PRIVATE)    }  else {     prefs=getActivity().getApplicationContext().getSharedPreferences("autofill_web",Context.MODE_PRIVATE)    }   SharedPreferences.Editor editor=prefs.edit()    String packageName=getArguments().getString("packageName","")    if (isWeb) {     packageName=((EditText)dialog.findViewById(R.id.webURL)).getText().toString()      EditText webURL=(EditText)dialog.findViewById(R.id.webURL)      if (packageName.equals("")) {       webURL.setError("URL cannot be blank")        return      }     String oldPackageName=getArguments().getString("packageName","")      if (!oldPackageName.equals(packageName) && prefs.getAll().containsKey(packageName)) {       webURL.setError("URL already exists")        return      }   }   RadioGroup radioGroup=(RadioGroup)dialog.findViewById(R.id.autofill_radiogroup)  switch (radioGroup.getCheckedRadioButtonId()) { case R.id.use_default:     if (!isWeb) {       editor.remove(packageName)      }  else {       editor.putString(packageName,"")      }   break  case R.id.first: editor.putString(packageName,"/first")  break  case R.id.never: editor.putString(packageName,"/never")  break  default : StringBuilder paths=new StringBuilder()  for (int i=0  i < adapter.getCount()  i++) { paths.append(adapter.getItem(i))  if (i != adapter.getCount()) { paths.append("\n")  } } editor.putString(packageName,paths.toString())  } editor.apply()  if (callingActivity.recyclerAdapter != null) { int position  if (!isWeb) { String appName=getArguments().getString("appName","")  position=callingActivity.recyclerAdapter.getPosition(appName)  callingActivity.recyclerAdapter.notifyItemChanged(position)  }  else { position=callingActivity.recyclerAdapter.getPosition(packageName)  String oldPackageName=getArguments().getString("packageName","")  if (oldPackageName.equals(packageName)) { callingActivity.recyclerAdapter.notifyItemChanged(position)  }  else if (oldPackageName.equals("")) { callingActivity.recyclerAdapter.addWebsite(packageName)  }  else { editor.remove(oldPackageName)  callingActivity.recyclerAdapter.updateWebsite(oldPackageName,packageName)  } } } dismiss()  } 
@Override public void onActivityResult(int requestCode,int resultCode,Intent data){   if (resultCode == Activity.RESULT_OK) {     adapter.add(data.getStringExtra("path"))    } } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.autofill_recycler_view)    recyclerView=(RecyclerView)findViewById(R.id.autofill_recycler)    layoutManager=new LinearLayoutManager(this)    recyclerView.setLayoutManager(layoutManager)    recyclerView.addItemDecoration(new DividerItemDecoration(this,DividerItemDecoration.VERTICAL_LIST))    pm=getPackageManager()    new populateTask().execute()    recreate=false    Bundle extras=getIntent().getExtras()    if (extras != null) {     recreate=true      showDialog(extras.getString("packageName"),extras.getString("appName"),extras.getBoolean("isWeb"))    }   setTitle("Autofill Apps")    final FloatingActionButton fab=(FloatingActionButton)findViewById(R.id.fab)    fab.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       showDialog("","",true)      }   } )  } 
@Override public void onClick(View v){   showDialog("","",true)  } 
@Override protected void onPreExecute(){   runOnUiThread(new Runnable(){     public void run(){       findViewById(R.id.progress_bar).setVisibility(View.VISIBLE)      }   } )  } 
public void run(){   findViewById(R.id.progress_bar).setVisibility(View.VISIBLE)  } 
@Override protected Void doInBackground(Void... params){   Intent intent=new Intent(Intent.ACTION_MAIN)    intent.addCategory(Intent.CATEGORY_LAUNCHER)    List<ResolveInfo> allAppsResolveInfo=pm.queryIntentActivities(intent,0)    List<AutofillRecyclerAdapter.AppInfo> allApps=new ArrayList<>()    for (  ResolveInfo app : allAppsResolveInfo) {     allApps.add(new AutofillRecyclerAdapter.AppInfo(app.activityInfo.packageName,app.loadLabel(pm).toString(),false,app.loadIcon(pm)))    }   SharedPreferences prefs=getSharedPreferences("autofill_web",Context.MODE_PRIVATE)    Map<String,?> prefsMap=prefs.getAll()    for (  String key : prefsMap.keySet()) {     try {       allApps.add(new AutofillRecyclerAdapter.AppInfo(key,key,true,pm.getApplicationIcon("com.android.browser")))      }  catch (    PackageManager.NameNotFoundException e) {       allApps.add(new AutofillRecyclerAdapter.AppInfo(key,key,true,null))      }   }   recyclerAdapter=new AutofillRecyclerAdapter(allApps,pm,AutofillPreferenceActivity.this)    return null  } 
@Override protected void onPostExecute(Void aVoid){   runOnUiThread(new Runnable(){     public void run(){       findViewById(R.id.progress_bar).setVisibility(View.GONE)        recyclerView.setAdapter(recyclerAdapter)        Bundle extras=getIntent().getExtras()        if (extras != null) {         recyclerView.scrollToPosition(recyclerAdapter.getPosition(extras.getString("appName")))        }     }   } )  } 
public void run(){   findViewById(R.id.progress_bar).setVisibility(View.GONE)    recyclerView.setAdapter(recyclerAdapter)    Bundle extras=getIntent().getExtras()    if (extras != null) {     recyclerView.scrollToPosition(recyclerAdapter.getPosition(extras.getString("appName")))    } } 
@Override public boolean onCreateOptionsMenu(Menu menu){   getMenuInflater().inflate(R.menu.autofill_preference,menu)    MenuItem searchItem=menu.findItem(R.id.action_search)    SearchView searchView=(SearchView)MenuItemCompat.getActionView(searchItem)    searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener(){     @Override public boolean onQueryTextSubmit(    String s){       return false      }     @Override public boolean onQueryTextChange(    String s){       if (recyclerAdapter != null) {         recyclerAdapter.filter(s)        }       return true      }   } )    return super.onCreateOptionsMenu(menu)  } 
@Override public boolean onQueryTextSubmit(String s){   return false  } 
@Override public boolean onQueryTextChange(String s){   if (recyclerAdapter != null) {     recyclerAdapter.filter(s)    }   return true  } 
@Override public boolean onOptionsItemSelected(MenuItem item){ switch (item.getItemId()) { case android.R.id.home:     Intent upIntent=NavUtils.getParentActivityIntent(this)    if (recreate) {     TaskStackBuilder.create(this).addNextIntentWithParentStack(upIntent).startActivities()    }  else {     NavUtils.navigateUpTo(this,upIntent)    } return true  } return super.onOptionsItemSelected(item)  } 
public void showDialog(String packageName,String appName,boolean isWeb){   DialogFragment df=new AutofillFragment()    Bundle args=new Bundle()    args.putString("packageName",packageName)    args.putString("appName",appName)    args.putBoolean("isWeb",isWeb)    df.setArguments(args)    df.show(getFragmentManager(),"autofill_dialog")  } 
public ViewHolder(View view){   super(view)    this.view=view    name=(TextView)view.findViewById(R.id.app_name)    secondary=(TextView)view.findViewById(R.id.secondary_text)    icon=(ImageView)view.findViewById(R.id.app_icon)    view.setOnClickListener(this)  } 
@Override public void onClick(View v){   activity.showDialog(packageName,appName,isWeb)  } 
public AppInfo(String packageName,String appName,boolean isWeb,Drawable icon){   this.packageName=packageName    this.appName=appName    this.isWeb=isWeb    this.icon=icon  } 
@Override public boolean equals(Object o){   return o != null && o instanceof AppInfo && this.appName.equals(((AppInfo)o).appName)  } 
public AutofillRecyclerAdapter(List<AppInfo> allApps,final PackageManager pm,AutofillPreferenceActivity activity){   SortedList.Callback<AppInfo> callback=new SortedListAdapterCallback<AppInfo>(this){     @Override public int compare(    AppInfo o1,    AppInfo o2){       return o1.appName.toLowerCase().compareTo(o2.appName.toLowerCase())      }     @Override public boolean areContentsTheSame(    AppInfo oldItem,    AppInfo newItem){       return oldItem.appName.equals(newItem.appName)      }     @Override public boolean areItemsTheSame(    AppInfo item1,    AppInfo item2){       return item1.appName.equals(item2.appName)      }   }     this.apps=new SortedList<>(AppInfo.class,callback)    this.apps.addAll(allApps)    this.allApps=new ArrayList<>(allApps)    this.pm=pm    this.activity=activity    try {     browserIcon=activity.getPackageManager().getApplicationIcon("com.android.browser")    }  catch (  PackageManager.NameNotFoundException e) {     e.printStackTrace()    } } 
@Override public int compare(AppInfo o1,AppInfo o2){   return o1.appName.toLowerCase().compareTo(o2.appName.toLowerCase())  } 
@Override public boolean areContentsTheSame(AppInfo oldItem,AppInfo newItem){   return oldItem.appName.equals(newItem.appName)  } 
@Override public boolean areItemsTheSame(AppInfo item1,AppInfo item2){   return item1.appName.equals(item2.appName)  } 
@Override public AutofillRecyclerAdapter.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){   View v=LayoutInflater.from(parent.getContext()).inflate(R.layout.autofill_row_layout,parent,false)    return new ViewHolder(v)  } 
@Override public void onBindViewHolder(AutofillRecyclerAdapter.ViewHolder holder,int position){   AppInfo app=apps.get(position)    holder.packageName=app.packageName    holder.appName=app.appName    holder.isWeb=app.isWeb    holder.icon.setImageDrawable(app.icon)    holder.name.setText(app.appName)    holder.secondary.setVisibility(View.VISIBLE)    holder.view.setBackgroundResource(R.color.grey_white_1000)    SharedPreferences prefs    if (!app.appName.equals(app.packageName)) {     prefs=activity.getApplicationContext().getSharedPreferences("autofill",Context.MODE_PRIVATE)    }  else {     prefs=activity.getApplicationContext().getSharedPreferences("autofill_web",Context.MODE_PRIVATE)    }   String preference=prefs.getString(holder.packageName,"")  switch (preference) { case "":     holder.secondary.setVisibility(View.GONE)    holder.view.setBackgroundResource(0)  break  case "/first": holder.secondary.setText(R.string.autofill_apps_first)  break  case "/never": holder.secondary.setText(R.string.autofill_apps_never)  break  default : holder.secondary.setText(R.string.autofill_apps_match)  holder.secondary.append(" " + preference.split("\n")[0])  if ((preference.trim().split("\n").length - 1) > 0) { holder.secondary.append(" and " + (preference.trim().split("\n").length - 1) + " more")  } break  } } 
@Override public int getItemCount(){   return apps.size()  } 
public int getPosition(String appName){   return apps.indexOf(new AppInfo(null,appName,false,null))  } 
public void addWebsite(String packageName){   apps.add(new AppInfo(packageName,packageName,true,browserIcon))    allApps.add(new AppInfo(packageName,packageName,true,browserIcon))  } 
public void removeWebsite(String packageName){   apps.remove(new AppInfo(null,packageName,false,null))    allApps.remove(new AppInfo(null,packageName,false,null))  } 
public void updateWebsite(String oldPackageName,String packageName){   apps.updateItemAt(getPosition(oldPackageName),new AppInfo(packageName,packageName,true,browserIcon))    allApps.remove(new AppInfo(null,oldPackageName,false,null))    allApps.add(new AppInfo(null,packageName,false,null))  } 
public void filter(String s){   if (s.isEmpty()) {     apps.addAll(allApps)      return    }   apps.beginBatchedUpdates()    for (  AppInfo app : allApps) {     if (app.appName.toLowerCase().contains(s.toLowerCase())) {       apps.add(app)      }  else {       apps.remove(app)      }   }   apps.endBatchedUpdates()  } 
public static AutofillService getInstance(){   return instance  } 
public void setResultData(Intent data){   resultData=data  } 
public void setPickedPassword(String path){   items.add(new File(PasswordRepository.getRepositoryDirectory(getApplicationContext()) + "/" + path+ ".gpg"))    bindDecryptAndVerify()  } 
@Override public void onCreate(){   super.onCreate()    instance=this  } 
@Override protected void onServiceConnected(){   super.onServiceConnected()    serviceConnection=new OpenPgpServiceConnection(AutofillService.this,"org.sufficientlysecure.keychain")    serviceConnection.bindToService()    settings=PreferenceManager.getDefaultSharedPreferences(this)  } 
@Override public void onAccessibilityEvent(AccessibilityEvent event){   if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR2) {     return    }   if (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED && event.getPackageName() != null && event.getPackageName().equals(packageName) && resultData != null) {     bindDecryptAndVerify()    }   if (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED || (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED && event.getPackageName() != null && (event.getPackageName().equals("com.android.chrome") || event.getPackageName().equals("com.android.browser")))) {     AccessibilityNodeInfo root=getRootInActiveWindow()      webViewTitle=searchWebView(root)      webViewURL=null      if (webViewTitle != null) {       List<AccessibilityNodeInfo> nodes=root.findAccessibilityNodeInfosByViewId("com.android.chrome:id/url_bar")        if (nodes.isEmpty()) {         nodes=root.findAccessibilityNodeInfosByViewId("com.android.browser:id/url")        }       for (      AccessibilityNodeInfo node : nodes)       if (node.getText() != null) {         try {           webViewURL=new URL(node.getText().toString()).getHost()          }  catch (        MalformedURLException e) {           if (e.toString().contains("Protocol not found")) {             try {               webViewURL=new URL("http://" + node.getText().toString()).getHost()              }  catch (            MalformedURLException ignored) {             }           }         }       }     }   }   if (!event.isPassword() || event.getEventType() == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED || event.getPackageName() != null && event.getPackageName().equals("org.sufficientlysecure.keychain") || event.getPackageName() != null && event.getPackageName().equals("com.android.systemui")) {     dismissDialog(event)      return    }   if (dialog != null && dialog.isShowing()) {     if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_CLICKED) {       return      }     dialog.dismiss()      dialog=null    }   if (ignoreActionFocus) {     ignoreActionFocus=false      return    }   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(this)) {     Intent intent=new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,Uri.parse("package:" + getPackageName()))      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)      startActivity(intent)      return    }   info=event.getSource()    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {     window=info.getWindow()    }   String packageName    String appName    boolean isWeb    if (webViewTitle == null || (webViewTitle.equals("") && webViewURL == null)) {     packageName=info.getPackageName().toString()      PackageManager packageManager=getPackageManager()      ApplicationInfo applicationInfo      try {       applicationInfo=packageManager.getApplicationInfo(event.getPackageName().toString(),0)      }  catch (    PackageManager.NameNotFoundException e) {       applicationInfo=null      }     appName=(applicationInfo != null ? packageManager.getApplicationLabel(applicationInfo) : "").toString()      isWeb=false      setAppMatchingPasswords(appName,packageName)    }  else {     packageName=setWebMatchingPasswords(webViewTitle,webViewURL)      appName=packageName      isWeb=true    }   if (items.isEmpty() && !settings.getBoolean("autofill_always",false)) {     return    }   showDialog(packageName,appName,isWeb)  } 
private String searchWebView(AccessibilityNodeInfo source){   if (source == null) {     return null    }   for (int i=0  i < source.getChildCount()  i++) {     AccessibilityNodeInfo u=source.getChild(i)      if (u == null) {       continue      }     if (u.getClassName() != null && u.getClassName().equals("android.webkit.WebView")) {       if (u.getContentDescription() != null) {         return u.getContentDescription().toString()        }       return ""      }     if (searchWebView(u) != null) {       return searchWebView(u)      }     u.recycle()    }   return null  } 
private void dismissDialog(AccessibilityEvent event){   boolean dismiss    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {     dismiss=!getWindows().contains(window)    }  else {     dismiss=!(event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED && event.getPackageName() != null && event.getPackageName().toString().contains("inputmethod"))    }   if (dismiss && dialog != null && dialog.isShowing()) {     dialog.dismiss()      dialog=null    } } 
private String setWebMatchingPasswords(String webViewTitle,String webViewURL){   String settingsURL=webViewURL    String defValue=settings.getBoolean("autofill_default",true) ? "/first" : "/never"    SharedPreferences prefs    String preference    prefs=getSharedPreferences("autofill_web",Context.MODE_PRIVATE)    preference=defValue    if (webViewURL != null) {     Map<String,?> prefsMap=prefs.getAll()      for (    String key : prefsMap.keySet()) {       if ((webViewURL.toLowerCase().contains(key.toLowerCase()) || key.toLowerCase().contains(webViewURL.toLowerCase())) && !prefs.getString(key,null).equals("")) {         preference=prefs.getString(key,null)          settingsURL=key        }     }   } switch (preference) { case "/first":     if (!PasswordRepository.isInitialized()) {       PasswordRepository.initialize(this)      }   items=searchPasswords(PasswordRepository.getRepositoryDirectory(this),webViewTitle)  break  case "/never": items=new ArrayList<>()  break  default : getPreferredPasswords(preference)  } return settingsURL  } 
private void setAppMatchingPasswords(String appName,String packageName){   String defValue=settings.getBoolean("autofill_default",true) ? "/first" : "/never"    SharedPreferences prefs    String preference    prefs=getSharedPreferences("autofill",Context.MODE_PRIVATE)    preference=prefs.getString(packageName,defValue)  switch (preference) { case "/first":     if (!PasswordRepository.isInitialized()) {       PasswordRepository.initialize(this)      }   items=searchPasswords(PasswordRepository.getRepositoryDirectory(this),appName)  break  case "/never": items=new ArrayList<>()  break  default : getPreferredPasswords(preference)  } } 
private void getPreferredPasswords(String preference){   if (!PasswordRepository.isInitialized()) {     PasswordRepository.initialize(this)    }   String preferredPasswords[]=preference.split("\n")    items=new ArrayList<>()    for (  String password : preferredPasswords) {     String path=PasswordRepository.getRepositoryDirectory(getApplicationContext()) + "/" + password+ ".gpg"      if (new File(path).exists()) {       items.add(new File(path))      }   } } 
private ArrayList<File> searchPasswords(File path,String appName){   ArrayList<File> passList=PasswordRepository.getFilesList(path)    if (passList.size() == 0)   return new ArrayList<>()    ArrayList<File> items=new ArrayList<>()    for (  File file : passList) {     if (file.isFile()) {       if (appName.toLowerCase().contains(file.getName().toLowerCase().replace(".gpg",""))) {         items.add(file)        }     }  else {       if (file.getName().equals(".git"))       continue        items.addAll(searchPasswords(file,appName))      }   }   return items  } 
private void showDialog(final String packageName,final String appName,final boolean isWeb){   AlertDialog.Builder builder=new AlertDialog.Builder(this,R.style.Theme_AppCompat_Dialog)    builder.setNegativeButton(R.string.dialog_cancel,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface d,    int which){       dialog.dismiss()        dialog=null      }   } )    builder.setNeutralButton("Settings",new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       Intent intent=new Intent(AutofillService.this,AutofillPreferenceActivity.class)        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)        intent.putExtra("packageName",packageName)        intent.putExtra("appName",appName)        intent.putExtra("isWeb",isWeb)        startActivity(intent)      }   } )    CharSequence itemNames[]=new CharSequence[items.size() + 2]    for (int i=0  i < items.size()  i++) {     itemNames[i]=items.get(i).getName().replace(".gpg","")    }   itemNames[items.size()]="Pick..."    itemNames[items.size() + 1]="Pick and match..."    builder.setItems(itemNames,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       lastWhichItem=which        if (which < items.size()) {         bindDecryptAndVerify()        }  else       if (which == items.size()) {         Intent intent=new Intent(AutofillService.this,AutofillActivity.class)          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)          intent.putExtra("pick",true)          startActivity(intent)        }  else {         lastWhichItem--          Intent intent=new Intent(AutofillService.this,AutofillActivity.class)          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)          intent.putExtra("pickMatchWith",true)          intent.putExtra("packageName",packageName)          intent.putExtra("isWeb",isWeb)          startActivity(intent)        }     }   } )    dialog=builder.create()    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT)    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)    dialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND)    int height=154    if (itemNames.length > 1) {     height+=46    }   dialog.getWindow().setLayout((int)(240 * getApplicationContext().getResources().getDisplayMetrics().density),(int)(height * getApplicationContext().getResources().getDisplayMetrics().density))    dialog.show()  } 
@Override public void onClick(DialogInterface d,int which){   dialog.dismiss()    dialog=null  } 
@Override public void onClick(DialogInterface dialog,int which){   Intent intent=new Intent(AutofillService.this,AutofillPreferenceActivity.class)    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)    intent.putExtra("packageName",packageName)    intent.putExtra("appName",appName)    intent.putExtra("isWeb",isWeb)    startActivity(intent)  } 
@Override public void onClick(DialogInterface dialog,int which){   lastWhichItem=which    if (which < items.size()) {     bindDecryptAndVerify()    }  else   if (which == items.size()) {     Intent intent=new Intent(AutofillService.this,AutofillActivity.class)      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)      intent.putExtra("pick",true)      startActivity(intent)    }  else {     lastWhichItem--      Intent intent=new Intent(AutofillService.this,AutofillActivity.class)      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)      intent.putExtra("pickMatchWith",true)      intent.putExtra("packageName",packageName)      intent.putExtra("isWeb",isWeb)      startActivity(intent)    } } 
@Override public void onInterrupt(){ } 
@Override public void onBound(IOpenPgpService2 service){   decryptAndVerify()  } 
@Override public void onError(Exception e){   e.printStackTrace()  } 
private void bindDecryptAndVerify(){   if (serviceConnection.getService() == null) {     serviceConnection=new OpenPgpServiceConnection(AutofillService.this,"org.sufficientlysecure.keychain",new onBoundListener())      serviceConnection.bindToService()    }  else {     decryptAndVerify()    } } 
private void decryptAndVerify(){   packageName=info.getPackageName()    Intent data    if (resultData == null) {     data=new Intent()      data.setAction(OpenPgpApi.ACTION_DECRYPT_VERIFY)    }  else {     data=resultData      resultData=null    }   InputStream is=null    try {     is=FileUtils.openInputStream(items.get(lastWhichItem))    }  catch (  IOException e) {     e.printStackTrace()    }   ByteArrayOutputStream os=new ByteArrayOutputStream()    OpenPgpApi api=new OpenPgpApi(AutofillService.this,serviceConnection.getService())    Intent result=api.executeApi(data,is,os)  switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) { case OpenPgpApi.RESULT_CODE_SUCCESS: {       try {         String[] passContent=os.toString("UTF-8").split("\n")          ignoreActionFocus=info.performAction(AccessibilityNodeInfo.ACTION_FOCUS)          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {           Bundle args=new Bundle()            args.putCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE,passContent[0])            info.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT,args)          }  else {           ClipboardManager clipboard=(ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE)            ClipData clip=ClipData.newPlainText("autofill_pm",passContent[0])            clipboard.setPrimaryClip(clip)            info.performAction(AccessibilityNodeInfo.ACTION_PASTE)            clip=ClipData.newPlainText("autofill_pm","")            clipboard.setPrimaryClip(clip)            if (settings.getBoolean("clear_clipboard_20x",false)) {             for (int i=0  i < 19  i++) {               clip=ClipData.newPlainText(String.valueOf(i),String.valueOf(i))                clipboard.setPrimaryClip(clip)              }           }         }         info.recycle()        }  catch (      UnsupportedEncodingException e) {         Log.e(Constants.TAG,"UnsupportedEncodingException",e)        }       break      } case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED: {     Log.i("PgpHandler","RESULT_CODE_USER_INTERACTION_REQUIRED")      PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT)      Intent intent=new Intent(AutofillService.this,AutofillActivity.class)      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK)      intent.putExtra("pending_intent",pi)      startActivity(intent)      break    } case OpenPgpApi.RESULT_CODE_ERROR: {   OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR)    Toast.makeText(AutofillService.this,"Error from OpenKeyChain : " + error.getMessage(),Toast.LENGTH_LONG).show()    Log.e(Constants.TAG,"onError getErrorId:" + error.getErrorId())    Log.e(Constants.TAG,"onError getMessage:" + error.getMessage())    break  } } } 
public DividerItemDecoration(Context context,int orientation){   final TypedArray a=context.obtainStyledAttributes(ATTRS)    mDivider=a.getDrawable(0)    a.recycle()    setOrientation(orientation)  } 
public void setOrientation(int orientation){   if (orientation != HORIZONTAL_LIST && orientation != VERTICAL_LIST) {     throw new IllegalArgumentException("invalid orientation")    }   mOrientation=orientation  } 
@Override public void onDraw(Canvas c,RecyclerView parent,RecyclerView.State state){   if (mOrientation == VERTICAL_LIST) {     drawVertical(c,parent)    }  else {     drawHorizontal(c,parent)    } } 
public void drawVertical(Canvas c,RecyclerView parent){   final int left=parent.getPaddingLeft()    final int right=parent.getWidth() - parent.getPaddingRight()    final int childCount=parent.getChildCount()    for (int i=0  i < childCount  i++) {     final View child=parent.getChildAt(i)      final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams()      final int top=child.getBottom() + params.bottomMargin      final int bottom=top + mDivider.getIntrinsicHeight()      mDivider.setBounds(left,top,right,bottom)      mDivider.draw(c)    } } 
public void drawHorizontal(Canvas c,RecyclerView parent){   final int top=parent.getPaddingTop()    final int bottom=parent.getHeight() - parent.getPaddingBottom()    final int childCount=parent.getChildCount()    for (int i=0  i < childCount  i++) {     final View child=parent.getChildAt(i)      final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams()      final int left=child.getRight() + params.rightMargin      final int right=left + mDivider.getIntrinsicHeight()      mDivider.setBounds(left,top,right,bottom)      mDivider.draw(c)    } } 
@Override public void getItemOffsets(Rect outRect,View view,RecyclerView parent,RecyclerView.State state){   if (mOrientation == VERTICAL_LIST) {     outRect.set(0,0,0,mDivider.getIntrinsicHeight())    }  else {     outRect.set(0,0,mDivider.getIntrinsicWidth(),0)    } } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,WindowManager.LayoutParams.FLAG_SECURE)    this.activity=this    this.clipboard=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE)    if (getIntent().getStringExtra("Operation").equals("ENCRYPT")) {     setTitle("New password")    }   settings=PreferenceManager.getDefaultSharedPreferences(this)    String providerPackageName=settings.getString("openpgp_provider_list","")    keyIDs=settings.getStringSet("openpgp_key_ids_set",new HashSet<String>())    registered=false    if (TextUtils.isEmpty(providerPackageName)) {     Toast.makeText(this,this.getResources().getString(R.string.provider_toast_text),Toast.LENGTH_LONG).show()      Intent intent=new Intent(this,UserPreference.class)      startActivity(intent)      setResult(RESULT_CANCELED)      finish()    }  else {     mServiceConnection=new OpenPgpServiceConnection(PgpHandler.this,providerPackageName,this)      mServiceConnection.bindToService()      registered=true      getSupportActionBar().setDisplayHomeAsUpEnabled(true)    } } 
@Override public void onStop(){   super.onStop()    if (this.registered && this.mServiceConnection.isBound())   try {     this.mServiceConnection.unbindFromService()    }  catch (  Exception e) {   } } 
@Override public boolean onCreateOptionsMenu(Menu menu){ switch (getIntent().getStringExtra("Operation")) { case "ENCRYPT":     getMenuInflater().inflate(R.menu.pgp_handler_new_password,menu)    break  case "SELECTFOLDER": getMenuInflater().inflate(R.menu.pgp_handler_select_folder,menu)  break  default : getMenuInflater().inflate(R.menu.pgp_handler,menu)  } return true  } 
@Override public boolean onOptionsItemSelected(MenuItem item){   int id=item.getItemId()  switch (id) { case android.R.id.home:     setResult(RESULT_CANCELED)    finish()  return true  case R.id.copy_password: copyToClipBoard()  break  case R.id.share_password_as_plaintext: shareAsPlaintext()  break  case R.id.edit_password: editPassword()  break  case R.id.crypto_confirm_add: encrypt(new Intent())  break  case R.id.crypto_cancel_add: setResult(RESULT_CANCELED)  finish()  return true  case R.id.crypto_select: selectFolder()  break  } return super.onOptionsItemSelected(item)  } 
private void selectFolder(){   if (selectFolderData == null || passwordList == null) {     Log.wtf(Constants.TAG,"Folder selected while the app didn't ask for one to be selected?")    }   selectFolderData.putExtra("SELECTED_FOLDER_PATH",passwordList.getCurrentDir().getAbsolutePath())    setResult(RESULT_OK,selectFolderData)    finish()  } 
public void editPassword(){   if (findViewById(R.id.crypto_password_show) == null || findViewById(R.id.crypto_container).getVisibility() != View.VISIBLE)   return    CharSequence category=((TextView)findViewById(R.id.crypto_password_category)).getText()    CharSequence file=((TextView)findViewById(R.id.crypto_password_file)).getText()    CharSequence password=((TextView)findViewById(R.id.crypto_password_show)).getText()    CharSequence extra=((TextView)findViewById(R.id.crypto_extra_show)).getText()    setContentView(R.layout.encrypt_layout)    Typeface monoTypeface=Typeface.createFromAsset(getAssets(),"fonts/sourcecodepro.ttf")    ((EditText)findViewById(R.id.crypto_password_edit)).setTypeface(monoTypeface)    ((EditText)findViewById(R.id.crypto_extra_edit)).setTypeface(monoTypeface)    ((TextView)findViewById(R.id.crypto_password_category)).setText(category)    ((EditText)findViewById(R.id.crypto_password_file_edit)).setText(file)    ((EditText)findViewById(R.id.crypto_password_edit)).setText(password)    ((EditText)findViewById(R.id.crypto_extra_edit)).setText(extra)    findViewById(R.id.crypto_password_file_edit).setEnabled(false)    String filePath=getIntent().getExtras().getString("FILE_PATH")    String directoryPath=filePath.substring(0,filePath.lastIndexOf(File.separator))    Intent intent=new Intent(this,PgpHandler.class)    intent.putExtra("FILE_PATH",directoryPath)    intent.putExtra("Operation","ENCRYPT")    intent.putExtra("fromDecrypt",true)    setIntent(intent)    invalidateOptionsMenu()  } 
public void shareAsPlaintext(){   if (findViewById(R.id.share_password_as_plaintext) == null)   return    Intent sendIntent=new Intent()    sendIntent.setAction(Intent.ACTION_SEND)    sendIntent.putExtra(Intent.EXTRA_TEXT,decodedPassword)    sendIntent.setType("text/plain")    startActivity(Intent.createChooser(sendIntent,getResources().getText(R.string.send_plaintext_password_to)))  } 
public void copyToClipBoard(){   if (findViewById(R.id.crypto_password_show) == null)   return    setTimer()    ClipData clip=ClipData.newPlainText("pgp_handler_result_pm",decodedPassword)    clipboard.setPrimaryClip(clip)    try {     showToast(this.getResources().getString(R.string.clipboard_beginning_toast_text) + " " + Integer.parseInt(settings.getString("general_show_time","45"))+ " "+ this.getResources().getString(R.string.clipboard_ending_toast_text))    }  catch (  NumberFormatException e) {     showToast(this.getResources().getString(R.string.clipboard_beginning_toast_text) + " 45 " + this.getResources().getString(R.string.clipboard_ending_toast_text))    } } 
public void handleClick(View view){ switch (view.getId()) { case R.id.crypto_show_button:     decryptAndVerify(new Intent())    break  case R.id.crypto_delete_button: break  case R.id.crypto_get_key_ids: getKeyIds(new Intent())  break  case R.id.generate_password: DialogFragment df=new pwgenDialogFragment()  df.show(getFragmentManager(),"generator")  default : Log.wtf(Constants.TAG,"This should not happen.... PgpHandler.java#handleClick(View) default reached.")  } } 
private void handleError(final OpenPgpError error){   runOnUiThread(new Runnable(){     @Override public void run(){       Toast.makeText(PgpHandler.this,"Error from OpenKeyChain : " + error.getMessage(),Toast.LENGTH_LONG).show()        Log.e(Constants.TAG,"onError getErrorId:" + error.getErrorId())        Log.e(Constants.TAG,"onError getMessage:" + error.getMessage())      }   } )  } 
@Override public void run(){   Toast.makeText(PgpHandler.this,"Error from OpenKeyChain : " + error.getMessage(),Toast.LENGTH_LONG).show()    Log.e(Constants.TAG,"onError getErrorId:" + error.getErrorId())    Log.e(Constants.TAG,"onError getMessage:" + error.getMessage())  } 
private void showToast(final String message){   runOnUiThread(new Runnable(){     @Override public void run(){       Toast.makeText(PgpHandler.this,message,Toast.LENGTH_SHORT).show()      }   } )  } 
@Override public void run(){   Toast.makeText(PgpHandler.this,message,Toast.LENGTH_SHORT).show()  } 
@Override protected void onPreExecute(){   try {     showTime=Integer.parseInt(settings.getString("general_show_time","45"))    }  catch (  NumberFormatException e) {     showTime=45    }   current=0    LinearLayout container=(LinearLayout)findViewById(R.id.crypto_container)    container.setVisibility(View.VISIBLE)    TextView extraText=(TextView)findViewById(R.id.crypto_extra_show)    if (extraText.getText().length() != 0)   findViewById(R.id.crypto_extra_show_layout).setVisibility(View.VISIBLE)    if (showTime == 0) {     cancel(true)    }  else {     this.pb=(ProgressBar)findViewById(R.id.pbLoading)      this.pb.setMax(showTime)    } } 
@Override protected Boolean doInBackground(Void... params){   while (current < showTime) {     SystemClock.sleep(1000)      current++      publishProgress(current)    }   return true  } 
@Override protected void onPostExecute(Boolean b){   if (settings.getBoolean("copy_on_decrypt",true) && clearClipboard) {     Log.d("DELAY_SHOW","Clearing the clipboard")      ClipData clip=ClipData.newPlainText("pgp_handler_result_pm","")      clipboard.setPrimaryClip(clip)      if (settings.getBoolean("clear_clipboard_20x",false)) {       Handler handler=new Handler()        for (int i=0  i < 19  i++) {         final String count=String.valueOf(i)          handler.postDelayed(new Runnable(){           @Override public void run(){             clipboard.setPrimaryClip(ClipData.newPlainText(count,count))            }         } ,i * 500)        }     }   }   decodedPassword=""    if (findViewById(R.id.crypto_password_show) != null) {     ((TextView)findViewById(R.id.crypto_password_show)).setText("")      ((TextView)findViewById(R.id.crypto_extra_show)).setText("")      findViewById(R.id.crypto_extra_show_layout).setVisibility(View.INVISIBLE)      findViewById(R.id.crypto_container).setVisibility(View.INVISIBLE)      activity.setResult(RESULT_CANCELED)      activity.finish()    } } 
@Override public void run(){   clipboard.setPrimaryClip(ClipData.newPlainText(count,count))  } 
@Override protected void onProgressUpdate(Integer... values){   this.pb.setProgress(values[0])  } 
public void setClearClipboard(boolean value){   clearClipboard=value  } 
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){   super.onActivityResult(requestCode,resultCode,data)    Log.d(Constants.TAG,"onActivityResult resultCode: " + resultCode)    if (resultCode == RESULT_OK) { switch (requestCode) { case REQUEST_CODE_ENCRYPT: {         encrypt(data)          break        } case REQUEST_CODE_DECRYPT_AND_VERIFY: {       findViewById(R.id.progress_bar_label).setVisibility(View.GONE)        decryptAndVerify(data)        break      } case REQUEST_CODE_GET_KEY_IDS:   getKeyIds(data)  break  case REQUEST_CODE_EDIT: { edit(data)  break  } } }  else if (resultCode == RESULT_CANCELED) { setResult(RESULT_CANCELED,data)  finish()  } } 
private void selectFolder(Intent data){   if (data.getStringExtra("Operation") == null || !data.getStringExtra("Operation").equals("SELECTFOLDER")) {     Log.e(Constants.TAG,"PgpHandler#selectFolder(Intent) triggered with incorrect intent.")      if (BuildConfig.DEBUG) {       throw new UnsupportedOperationException("Triggered with incorrect intent.")      }     return    }   Log.d(Constants.TAG,"PgpHandler#selectFolder(Intent).")    FragmentManager fragmentManager=getSupportFragmentManager()    FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction()    passwordList=new SelectFolderFragment()    Bundle args=new Bundle()    args.putString("Path",PasswordRepository.getRepositoryDirectory(getApplicationContext()).getAbsolutePath())    passwordList.setArguments(args)    getSupportActionBar().show()    fragmentManager.popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE)    fragmentTransaction.replace(R.id.pgp_handler_linearlayout,passwordList,"PasswordsList")    fragmentTransaction.commit()    this.selectFolderData=data  } 
private PgpCallback(boolean returnToCiphertextField,ByteArrayOutputStream os,int requestCode){   this.returnToCiphertextField=returnToCiphertextField    this.os=os    this.requestCode=requestCode  } 
@Override public void onReturn(Intent result){ switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) { case OpenPgpApi.RESULT_CODE_SUCCESS: {       final TextView textViewPassword=(TextView)findViewById(R.id.crypto_password_show)        if (requestCode == REQUEST_CODE_DECRYPT_AND_VERIFY && os != null) {         try {           if (returnToCiphertextField) {             findViewById(R.id.progress_bar).setVisibility(View.GONE)              findViewById(R.id.progress_bar_label).setVisibility(View.GONE)              boolean showPassword=settings.getBoolean("show_password",true)              findViewById(R.id.crypto_container).setVisibility(View.VISIBLE)              Typeface monoTypeface=Typeface.createFromAsset(getAssets(),"fonts/sourcecodepro.ttf")              final String[] passContent=os.toString("UTF-8").split("\n")              textViewPassword.setTypeface(monoTypeface)              textViewPassword.setText(passContent[0])              Button toggleVisibilityButton=(Button)findViewById(R.id.crypto_password_toggle_show)              toggleVisibilityButton.setVisibility(showPassword ? View.GONE : View.VISIBLE)              textViewPassword.setTransformationMethod(showPassword ? null : new HoldToShowPasswordTransformation(toggleVisibilityButton,new Runnable(){               @Override public void run(){                 textViewPassword.setText(passContent[0])                }             } ))              decodedPassword=passContent[0]              String extraContent=os.toString("UTF-8").replaceFirst(".*\n","")              if (extraContent.length() != 0) {               ((TextView)findViewById(R.id.crypto_extra_show)).setTypeface(monoTypeface)                ((TextView)findViewById(R.id.crypto_extra_show)).setText(extraContent)              }             if (settings.getBoolean("copy_on_decrypt",true)) {               copyToClipBoard()              }           }  else {             Log.d("PGPHANDLER","Error message after decrypt : " + os.toString())            }         }  catch (        UnsupportedEncodingException e) {           Log.e(Constants.TAG,"UnsupportedEncodingException",e)          }       }       if (requestCode == REQUEST_CODE_ENCRYPT && os != null) {         try {           String path=getIntent().getExtras().getString("FILE_PATH") + "/" + ((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString()+ ".gpg"            OutputStream outputStream=FileUtils.openOutputStream(new File(path))            outputStream.write(os.toByteArray())            outputStream.close()            Intent data=new Intent()            data.putExtra("CREATED_FILE",path)            data.putExtra("NAME",((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString())            if (getIntent().getBooleanExtra("fromDecrypt",false)) {             data.putExtra("needCommit",true)            }           setResult(RESULT_OK,data)            finish()          }  catch (        Exception e) {           Log.e(Constants.TAG,"UnsupportedEncodingException",e)          }       }       if (result.hasExtra(OpenPgpApi.RESULT_KEY_IDS)) {         long[] ids=result.getLongArrayExtra(OpenPgpApi.RESULT_KEY_IDS)          Set<String> keys=new HashSet<String>()          for (        long id : ids)         keys.add(String.valueOf(id))          settings.edit().putStringSet("openpgp_key_ids_set",keys).apply()          showToast("PGP key selected")          setResult(RESULT_OK)          finish()        }       if (requestCode == REQUEST_CODE_EDIT && os != null) {         try {           if (returnToCiphertextField) {             findViewById(R.id.progress_bar).setVisibility(View.GONE)              findViewById(R.id.progress_bar_label).setVisibility(View.GONE)              findViewById(R.id.crypto_container).setVisibility(View.VISIBLE)              Typeface monoTypeface=Typeface.createFromAsset(getAssets(),"fonts/sourcecodepro.ttf")              String[] passContent=os.toString("UTF-8").split("\n")              textViewPassword.setTypeface(monoTypeface)              textViewPassword.setText(passContent[0])              decodedPassword=passContent[0]              String extraContent=os.toString("UTF-8").replaceFirst(".*\n","")              if (extraContent.length() != 0) {               ((TextView)findViewById(R.id.crypto_extra_show)).setTypeface(monoTypeface)                ((TextView)findViewById(R.id.crypto_extra_show)).setText(extraContent)              }             editPassword()            }  else {             Log.d("PGPHANDLER","Error message after decrypt : " + os.toString())            }         }  catch (        UnsupportedEncodingException e) {           Log.e(Constants.TAG,"UnsupportedEncodingException",e)          }       }       break      } case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED: {     Log.i("PgpHandler","RESULT_CODE_USER_INTERACTION_REQUIRED")      View progress_bar_label=findViewById(R.id.progress_bar_label)      if (progress_bar_label != null) {       progress_bar_label.setVisibility(View.VISIBLE)      }     PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT)      try {       PgpHandler.this.startIntentSenderForResult(pi.getIntentSender(),requestCode,null,0,0,0)      }  catch (    IntentSender.SendIntentException e) {       Log.e(Constants.TAG,"SendIntentException",e)      }     break    } case OpenPgpApi.RESULT_CODE_ERROR: {   OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR)    handleError(error)    break  } } } 
@Override public void run(){   textViewPassword.setText(passContent[0])  } 
public void getKeyIds(Intent data){   data.setAction(OpenPgpApi.ACTION_GET_KEY_IDS)    OpenPgpApi api=new OpenPgpApi(this,mServiceConnection.getService())    api.executeApiAsync(data,null,null,new PgpCallback(false,null,PgpHandler.REQUEST_CODE_GET_KEY_IDS))  } 
public void decryptAndVerify(Intent data){   data.setAction(OpenPgpApi.ACTION_DECRYPT_VERIFY)    findViewById(R.id.progress_bar).setVisibility(View.VISIBLE)    try {     InputStream is=FileUtils.openInputStream(new File(getIntent().getExtras().getString("FILE_PATH")))      ByteArrayOutputStream os=new ByteArrayOutputStream()      OpenPgpApi api=new OpenPgpApi(this,mServiceConnection.getService())      api.executeApiAsync(data,is,os,new PgpCallback(true,os,REQUEST_CODE_DECRYPT_AND_VERIFY))    }  catch (  Exception e) {     e.printStackTrace()    } } 
/**   * Encrypts a password file  * @param data  */ public void encrypt(Intent data){   data.setAction(OpenPgpApi.ACTION_ENCRYPT)    ArrayList<Long> longKeys=new ArrayList<>()    for (  String keyId : keyIDs)   longKeys.add(Long.valueOf(keyId))    data.putExtra(OpenPgpApi.EXTRA_KEY_IDS,Longs.toArray(longKeys))    data.putExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true)    String name=((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString()    String pass=((EditText)findViewById(R.id.crypto_password_edit)).getText().toString()    String extra=((EditText)findViewById(R.id.crypto_extra_edit)).getText().toString()    if (name.isEmpty()) {     showToast(this.getResources().getString(R.string.file_toast_text))      return    }   if (pass.isEmpty() && extra.isEmpty()) {     showToast(this.getResources().getString(R.string.empty_toast_text))      return    }   ByteArrayInputStream is    try {     is=new ByteArrayInputStream((pass + "\n" + extra).getBytes("UTF-8"))      ByteArrayOutputStream os=new ByteArrayOutputStream()      OpenPgpApi api=new OpenPgpApi(this,mServiceConnection.getService())      api.executeApiAsync(data,is,os,new PgpCallback(true,os,REQUEST_CODE_ENCRYPT))    }  catch (  Exception e) {     e.printStackTrace()    } } 
public void edit(Intent data){   data.setAction(OpenPgpApi.ACTION_DECRYPT_VERIFY)    findViewById(R.id.progress_bar).setVisibility(View.VISIBLE)    try {     InputStream is=FileUtils.openInputStream(new File(getIntent().getExtras().getString("FILE_PATH")))      ByteArrayOutputStream os=new ByteArrayOutputStream()      OpenPgpApi api=new OpenPgpApi(this,mServiceConnection.getService())      api.executeApiAsync(data,is,os,new PgpCallback(true,os,REQUEST_CODE_EDIT))    }  catch (  Exception e) {     e.printStackTrace()    } } 
@Override public void onBound(IOpenPgpService2 service){   Log.i("PGP","ISBOUND!!")    Bundle extra=getIntent().getExtras()    final String operation=extra.getString("Operation")    if (operation == null) {     return    }   if (operation.equals("DECRYPT")) {     setContentView(R.layout.decrypt_layout)      ((TextView)findViewById(R.id.crypto_password_file)).setText(extra.getString("NAME"))      String path=extra.getString("FILE_PATH").replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()).getAbsolutePath(),"")      String cat=new File(path).getParentFile().getName()      ((TextView)findViewById(R.id.crypto_password_category)).setText(cat + "/")      decryptAndVerify(new Intent())    }  else   if (operation.equals("ENCRYPT")) {     setContentView(R.layout.encrypt_layout)      Typeface monoTypeface=Typeface.createFromAsset(getAssets(),"fonts/sourcecodepro.ttf")      ((EditText)findViewById(R.id.crypto_password_edit)).setTypeface(monoTypeface)      ((EditText)findViewById(R.id.crypto_extra_edit)).setTypeface(monoTypeface)      String cat=extra.getString("FILE_PATH")      cat=cat.replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()).getAbsolutePath(),"")      cat=cat + "/"      ((TextView)findViewById(R.id.crypto_password_category)).setText(cat)    }  else   if (operation.equals("GET_KEY_ID")) {     getKeyIds(new Intent())    }  else   if (operation.equals("EDIT")) {     setContentView(R.layout.decrypt_layout)      ((TextView)findViewById(R.id.crypto_password_file)).setText(extra.getString("NAME"))      String cat=new File(extra.getString("FILE_PATH").replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()).getAbsolutePath(),"")).getParentFile().getName()      ((TextView)findViewById(R.id.crypto_password_category)).setText(cat + "/")      edit(new Intent())    }  else   if (operation.equals("SELECTFOLDER")) {     setContentView(R.layout.select_folder_layout)      selectFolder(getIntent())    } } 
@Override public void onError(Exception e){ } 
private HoldToShowPasswordTransformation(Button button,Runnable onToggle){   this.onToggle=onToggle    button.setOnTouchListener(this)  } 
@Override public CharSequence getTransformation(CharSequence charSequence,View view){   return shown ? charSequence : super.getTransformation("12345",view)  } 
@Override public boolean onTouch(View view,MotionEvent motionEvent){ switch (motionEvent.getAction()) { case MotionEvent.ACTION_DOWN:     shown=true    onToggle.run()  break  case MotionEvent.ACTION_UP: shown=false  onToggle.run()  break  } return false  } 
private void setTimer(){   if (delayTask != null) {     delayTask.setClearClipboard(false)    }   delayTask=new DelayShow()    delayTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)  } 
/**   * Default divider will be used  */ public DividerItemDecoration(Context context){   final TypedArray styledAttributes=context.obtainStyledAttributes(ATTRS)    mDivider=styledAttributes.getDrawable(0)    styledAttributes.recycle()  } 
/**   * Custom divider will be used  */ public DividerItemDecoration(Context context,int resId){   mDivider=ContextCompat.getDrawable(context,resId)  } 
@Override public void onDraw(Canvas c,RecyclerView parent,RecyclerView.State state){   int left=parent.getPaddingLeft()    int right=parent.getWidth() - parent.getPaddingRight()    int childCount=parent.getChildCount()    for (int i=0  i < childCount  i++) {     View child=parent.getChildAt(i)      RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams()      int top=child.getBottom() + params.bottomMargin      int bottom=top + mDivider.getIntrinsicHeight()      mDivider.setBounds(left,top,right,bottom)      mDivider.draw(c)    } } 
/**   * Creates a new clone operation  * @param fileDir         the git working tree directory  * @param callingActivity the calling activity  */ public CloneOperation(File fileDir,Activity callingActivity){   super(fileDir,callingActivity)  } 
/**   * Sets the command using the repository uri  * @param uri the uri of the repository  * @return the current object  */ public CloneOperation setCommand(String uri){   this.command=Git.cloneRepository().setCloneAllBranches(true).setDirectory(repository.getWorkTree()).setURI(uri)    return this  } 
/**   * sets the authentication for user/pwd scheme  * @param username the username  * @param password the password  * @return the current object  */ @Override public CloneOperation setAuthentication(String username,String password){   super.setAuthentication(username,password)    return this  } 
/**   * sets the authentication for the ssh-key scheme  * @param sshKey     the ssh-key file  * @param username   the username  * @param passphrase the passphrase  * @return the current object  */ @Override public CloneOperation setAuthentication(File sshKey,String username,String passphrase){   super.setAuthentication(sshKey,username,passphrase)    return this  } 
@Override public void execute(){   if (this.provider != null) {     ((CloneCommand)this.command).setCredentialsProvider(this.provider)    }   new GitAsyncTask(callingActivity,true,false,this).execute(this.command)  } 
@Override public void onTaskEnded(String result){   new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.jgit_error_dialog_title)).setMessage("Error occured during the clone operation, " + callingActivity.getResources().getString(R.string.jgit_error_dialog_text) + result+ "\nPlease check the FAQ for possible reasons why this error might occur.").setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){     }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
protected void configure(OpenSshConfig.Host hc,Session session){   session.setConfig("StrictHostKeyChecking","no")  } 
@Override protected JSch getJSch(final OpenSshConfig.Host hc,FS fs) throws JSchException {   JSch jsch=super.getJSch(hc,fs)    jsch.removeAllIdentity()    return jsch  } 
public SshConfigSessionFactory(String sshKey,String username,String passphrase){   this.sshKey=sshKey    this.passphrase=passphrase    this.username=username  } 
@Override protected JSch getJSch(final OpenSshConfig.Host hc,FS fs) throws JSchException {   JSch jsch=super.getJSch(hc,fs)    jsch.removeAllIdentity()    jsch.addIdentity(sshKey)    return jsch  } 
@Override protected void configure(OpenSshConfig.Host hc,Session session){   session.setConfig("StrictHostKeyChecking","no")    session.setConfig("PreferredAuthentications","publickey,password")    CredentialsProvider provider=new CredentialsProvider(){     @Override public boolean isInteractive(){       return false      }     @Override public boolean supports(    CredentialItem... items){       return true      }     @Override public boolean get(    URIish uri,    CredentialItem... items) throws UnsupportedCredentialItem {       for (      CredentialItem item : items) {         if (item instanceof CredentialItem.Username) {           ((CredentialItem.Username)item).setValue(username)            continue          }         if (item instanceof CredentialItem.StringType) {           ((CredentialItem.StringType)item).setValue(passphrase)          }       }       return true      }   }     UserInfo userInfo=new CredentialsProviderUserInfo(session,provider)    session.setUserInfo(userInfo)  } 
@Override public boolean isInteractive(){   return false  } 
@Override public boolean supports(CredentialItem... items){   return true  } 
@Override public boolean get(URIish uri,CredentialItem... items) throws UnsupportedCredentialItem {   for (  CredentialItem item : items) {     if (item instanceof CredentialItem.Username) {       ((CredentialItem.Username)item).setValue(username)        continue      }     if (item instanceof CredentialItem.StringType) {       ((CredentialItem.StringType)item).setValue(passphrase)      }   }   return true  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    context=getApplicationContext()    activity=this    settings=PreferenceManager.getDefaultSharedPreferences(this.context)    protocol=settings.getString("git_remote_protocol","ssh://")    connectionMode=settings.getString("git_remote_auth","ssh-key")    int operationCode=getIntent().getExtras().getInt("Operation")    getSupportActionBar().setDisplayHomeAsUpEnabled(true)  switch (operationCode) { case REQUEST_CLONE: case EDIT_SERVER:     setContentView(R.layout.activity_git_clone)    setTitle(R.string.title_activity_git_clone)  final Spinner protcol_spinner=(Spinner)findViewById(R.id.clone_protocol)  final Spinner connection_mode_spinner=(Spinner)findViewById(R.id.connection_mode)  final ArrayAdapter<CharSequence> connection_mode_adapter=ArrayAdapter.createFromResource(this,R.array.connection_modes,android.R.layout.simple_spinner_item)  connection_mode_adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)  connection_mode_spinner.setAdapter(connection_mode_adapter)  connection_mode_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){ @Override public void onItemSelected(AdapterView<?> adapterView,View view,int i,long l){ String selection=((Spinner)findViewById(R.id.connection_mode)).getSelectedItem().toString()  connectionMode=selection  settings.edit().putString("git_remote_auth",selection).apply()  } @Override public void onNothingSelected(AdapterView<?> adapterView){ } } )  ArrayAdapter<CharSequence> protocol_adapter=ArrayAdapter.createFromResource(this,R.array.clone_protocols,android.R.layout.simple_spinner_item)  protocol_adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)  protcol_spinner.setAdapter(protocol_adapter)  protcol_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){ @Override public void onItemSelected(AdapterView<?> adapterView,View view,int i,long l){ protocol=((Spinner)findViewById(R.id.clone_protocol)).getSelectedItem().toString()  if (protocol.equals("ssh://")) { ((EditText)findViewById(R.id.clone_uri)).setHint("user@hostname:path")  ((EditText)findViewById(R.id.server_port)).setHint(R.string.default_ssh_port)  connection_mode_spinner.setSelection(0)  connection_mode_spinner.setEnabled(true)  if (connectionMode.equals("ssh-key")) { connection_mode_spinner.setSelection(0)  }  else { connection_mode_spinner.setSelection(1)  } }  else { ((EditText)findViewById(R.id.clone_uri)).setHint("hostname/path")  ((EditText)findViewById(R.id.server_port)).setHint(R.string.default_https_port)  connection_mode_spinner.setSelection(1)  connection_mode_spinner.setEnabled(false)  } } @Override public void onNothingSelected(AdapterView<?> adapterView){ } } )  if (protocol.equals("ssh://")) { protcol_spinner.setSelection(0)  }  else { protcol_spinner.setSelection(1)  } final EditText server_url=((EditText)findViewById(R.id.server_url))  final EditText server_port=((EditText)findViewById(R.id.server_port))  final EditText server_path=((EditText)findViewById(R.id.server_path))  final EditText server_user=((EditText)findViewById(R.id.server_user))  final EditText server_uri=((EditText)findViewById(R.id.clone_uri))  View.OnFocusChangeListener updateListener=new View.OnFocusChangeListener(){ @Override public void onFocusChange(View view,boolean b){ updateURI()  } }   server_url.setText(settings.getString("git_remote_server",""))  server_port.setText(settings.getString("git_remote_port",""))  server_user.setText(settings.getString("git_remote_username",""))  server_path.setText(settings.getString("git_remote_location",""))  server_url.addTextChangedListener(new TextWatcher(){ @Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } @Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){ if (server_url.isFocused()) updateURI()  } @Override public void afterTextChanged(Editable editable){ } } )  server_port.addTextChangedListener(new TextWatcher(){ @Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } @Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){ if (server_port.isFocused()) updateURI()  } @Override public void afterTextChanged(Editable editable){ } } )  server_user.addTextChangedListener(new TextWatcher(){ @Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } @Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){ if (server_user.isFocused()) updateURI()  } @Override public void afterTextChanged(Editable editable){ } } )  server_path.addTextChangedListener(new TextWatcher(){ @Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } @Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){ if (server_path.isFocused()) updateURI()  } @Override public void afterTextChanged(Editable editable){ } } )  server_uri.addTextChangedListener(new TextWatcher(){ @Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } @Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){ if (server_uri.isFocused()) splitURI()  } @Override public void afterTextChanged(Editable editable){ } } )  if (operationCode == EDIT_SERVER) { findViewById(R.id.clone_button).setVisibility(View.INVISIBLE)  findViewById(R.id.save_button).setVisibility(View.VISIBLE)  }  else { findViewById(R.id.clone_button).setVisibility(View.VISIBLE)  findViewById(R.id.save_button).setVisibility(View.INVISIBLE)  } updateURI()  break  case REQUEST_PULL: syncRepository(REQUEST_PULL)  break  case REQUEST_PUSH: syncRepository(REQUEST_PUSH)  break  case REQUEST_SYNC: syncRepository(REQUEST_SYNC)  break  } } 
@Override public void onItemSelected(AdapterView<?> adapterView,View view,int i,long l){   String selection=((Spinner)findViewById(R.id.connection_mode)).getSelectedItem().toString()    connectionMode=selection    settings.edit().putString("git_remote_auth",selection).apply()  } 
@Override public void onNothingSelected(AdapterView<?> adapterView){ } 
@Override public void onItemSelected(AdapterView<?> adapterView,View view,int i,long l){   protocol=((Spinner)findViewById(R.id.clone_protocol)).getSelectedItem().toString()    if (protocol.equals("ssh://")) {     ((EditText)findViewById(R.id.clone_uri)).setHint("user@hostname:path")      ((EditText)findViewById(R.id.server_port)).setHint(R.string.default_ssh_port)      connection_mode_spinner.setSelection(0)      connection_mode_spinner.setEnabled(true)      if (connectionMode.equals("ssh-key")) {       connection_mode_spinner.setSelection(0)      }  else {       connection_mode_spinner.setSelection(1)      }   }  else {     ((EditText)findViewById(R.id.clone_uri)).setHint("hostname/path")      ((EditText)findViewById(R.id.server_port)).setHint(R.string.default_https_port)      connection_mode_spinner.setSelection(1)      connection_mode_spinner.setEnabled(false)    } } 
@Override public void onNothingSelected(AdapterView<?> adapterView){ } 
@Override public void onFocusChange(View view,boolean b){   updateURI()  } 
@Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } 
@Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){   if (server_url.isFocused())   updateURI()  } 
@Override public void afterTextChanged(Editable editable){ } 
@Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } 
@Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){   if (server_port.isFocused())   updateURI()  } 
@Override public void afterTextChanged(Editable editable){ } 
@Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } 
@Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){   if (server_user.isFocused())   updateURI()  } 
@Override public void afterTextChanged(Editable editable){ } 
@Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } 
@Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){   if (server_path.isFocused())   updateURI()  } 
@Override public void afterTextChanged(Editable editable){ } 
@Override public void beforeTextChanged(CharSequence charSequence,int i,int i2,int i3){ } 
@Override public void onTextChanged(CharSequence charSequence,int i,int i2,int i3){   if (server_uri.isFocused())   splitURI()  } 
@Override public void afterTextChanged(Editable editable){ } 
/**   * Fills in the server_uri field with the information coming from other fields  */ private void updateURI(){   EditText uri=(EditText)findViewById(R.id.clone_uri)    EditText server_url=((EditText)findViewById(R.id.server_url))    EditText server_port=((EditText)findViewById(R.id.server_port))    EditText server_path=((EditText)findViewById(R.id.server_path))    EditText server_user=((EditText)findViewById(R.id.server_user))    if (uri != null) { switch (protocol) { case "ssh://": {         String hostname=server_user.getText() + "@" + server_url.getText().toString().trim()+ ":"          if (server_port.getText().toString().equals("22")) {           hostname+=server_path.getText().toString()            ((TextView)findViewById(R.id.warn_url)).setVisibility(View.GONE)          }  else {           TextView warn_url=(TextView)findViewById(R.id.warn_url)            if (!server_path.getText().toString().matches("/.*") && !server_port.getText().toString().isEmpty()) {             warn_url.setText(R.string.warn_malformed_url_port)              warn_url.setVisibility(View.VISIBLE)            }  else {             warn_url.setVisibility(View.GONE)            }           hostname+=server_port.getText().toString() + server_path.getText().toString()          }         if (!hostname.equals("@:"))         uri.setText(hostname)        }     break  case "https://": {     StringBuilder hostname=new StringBuilder()      hostname.append(server_url.getText().toString().trim())      if (server_port.getText().toString().equals("443")) {       hostname.append(server_path.getText().toString())        ((TextView)findViewById(R.id.warn_url)).setVisibility(View.GONE)      }  else {       hostname.append("/")        hostname.append(server_port.getText().toString()).append(server_path.getText().toString())      }     if (!hostname.toString().equals("@/"))     uri.setText(hostname)    } break  default : break  } } } 
/**   * Splits the information in server_uri into the other fields  */ private void splitURI(){   EditText server_uri=(EditText)findViewById(R.id.clone_uri)    EditText server_url=((EditText)findViewById(R.id.server_url))    EditText server_port=((EditText)findViewById(R.id.server_port))    EditText server_path=((EditText)findViewById(R.id.server_path))    EditText server_user=((EditText)findViewById(R.id.server_user))    String uri=server_uri.getText().toString()    Pattern pattern=Pattern.compile("(.+)@([\\w\\d\\.]+):([\\d]+)*(.*)")    Matcher matcher=pattern.matcher(uri)    if (matcher.find()) {     int count=matcher.groupCount()      if (count > 1) {       server_user.setText(matcher.group(1))        server_url.setText(matcher.group(2))      }     if (count == 4) {       server_port.setText(matcher.group(3))        server_path.setText(matcher.group(4))        TextView warn_url=(TextView)findViewById(R.id.warn_url)        if (!server_path.getText().toString().matches("/.*") && !server_port.getText().toString().isEmpty()) {         warn_url.setText(R.string.warn_malformed_url_port)          warn_url.setVisibility(View.VISIBLE)        }  else {         warn_url.setVisibility(View.GONE)        }     }   } } 
@Override public void onResume(){   super.onResume()    updateURI()  } 
@Override public boolean onCreateOptionsMenu(Menu menu){   getMenuInflater().inflate(R.menu.git_clone,menu)    return true  } 
@Override public boolean onOptionsItemSelected(MenuItem item){   int id=item.getItemId()  switch (id) { case R.id.user_pref:     try {       Intent intent=new Intent(this,UserPreference.class)        startActivity(intent)      }  catch (    Exception e) {       System.out.println("Exception caught :(")        e.printStackTrace()      }   return true  } return super.onOptionsItemSelected(item)  } 
/**   * Saves the configuration found in the form  */ private boolean saveConfiguration(){   SharedPreferences.Editor editor=settings.edit()    editor.putString("git_remote_server",((EditText)findViewById(R.id.server_url)).getText().toString())    editor.putString("git_remote_location",((EditText)findViewById(R.id.server_path)).getText().toString())    editor.putString("git_remote_username",((EditText)findViewById(R.id.server_user)).getText().toString())    editor.putString("git_remote_protocol",protocol)    editor.putString("git_remote_auth",connectionMode)    editor.putString("git_remote_port",((EditText)findViewById(R.id.server_port)).getText().toString())    editor.putString("git_remote_uri",((EditText)findViewById(R.id.clone_uri)).getText().toString())    hostname=((EditText)findViewById(R.id.clone_uri)).getText().toString()    port=((EditText)findViewById(R.id.server_port)).getText().toString()    hostname=hostname.replaceFirst("^.+://","")    ((TextView)findViewById(R.id.clone_uri)).setText(hostname)    if (!protocol.equals("ssh://")) {     hostname=protocol + hostname    }  else {     if (!port.isEmpty() && !port.equals("22"))     hostname=protocol + hostname      if (!hostname.matches("^.+@.+")) {       new AlertDialog.Builder(this).setMessage(activity.getResources().getString(R.string.forget_username_dialog_text)).setPositiveButton(activity.getResources().getString(R.string.dialog_oops),null).show()        return false      }   }   if (PasswordRepository.isInitialized()) {     PasswordRepository.addRemote("origin",hostname,true)    }   editor.apply()    return true  } 
/**   * Save the repository information to the shared preferences settings  * @param view  */ public void saveConfiguration(View view){   if (!saveConfiguration())   return    finish()  } 
/**   * Clones the repository, the directory exists, deletes it  * @param view  */ public void cloneRepository(View view){   if (PasswordRepository.getRepository(null) == null) {     PasswordRepository.initialize(this)    }   localDir=PasswordRepository.getRepositoryDirectory(context)    if (!saveConfiguration())   return    if (localDir.exists() && localDir.listFiles().length != 0 && !(localDir.listFiles().length == 1 && localDir.listFiles()[0].getName().equals(".git"))) {     new AlertDialog.Builder(this).setTitle(R.string.dialog_delete_title).setMessage(getResources().getString(R.string.dialog_delete_msg) + " " + localDir.toString()).setCancelable(false).setPositiveButton(R.string.dialog_delete,new DialogInterface.OnClickListener(){       public void onClick(      DialogInterface dialog,      int id){         try {           FileUtils.deleteDirectory(localDir)            try {             new CloneOperation(localDir,activity).setCommand(hostname).executeAfterAuthentication(connectionMode,settings.getString("git_remote_username","git"),new File(getFilesDir() + "/.ssh_key"))            }  catch (          Exception e) {             e.printStackTrace()              new AlertDialog.Builder(GitActivity.this).setMessage(e.getMessage()).show()            }         }  catch (        IOException e) {           e.printStackTrace()            new AlertDialog.Builder(GitActivity.this).setMessage(e.getMessage()).show()          }         dialog.cancel()        }     } ).setNegativeButton(R.string.dialog_do_not_delete,new DialogInterface.OnClickListener(){       public void onClick(      DialogInterface dialog,      int id){         dialog.cancel()        }     } ).show()    }  else {     try {       if (localDir.listFiles().length == 1 && localDir.listFiles()[0].getName().equals(".git")) {         try {           FileUtils.deleteDirectory(localDir)          }  catch (        IOException e) {           e.printStackTrace()            new AlertDialog.Builder(GitActivity.this).setMessage(e.getMessage()).show()          }       }       new CloneOperation(localDir,activity).setCommand(hostname).executeAfterAuthentication(connectionMode,settings.getString("git_remote_username","git"),new File(getFilesDir() + "/.ssh_key"))      }  catch (    Exception e) {       e.printStackTrace()        new AlertDialog.Builder(this).setMessage(e.getMessage()).show()      }   } } 
public void onClick(DialogInterface dialog,int id){   try {     FileUtils.deleteDirectory(localDir)      try {       new CloneOperation(localDir,activity).setCommand(hostname).executeAfterAuthentication(connectionMode,settings.getString("git_remote_username","git"),new File(getFilesDir() + "/.ssh_key"))      }  catch (    Exception e) {       e.printStackTrace()        new AlertDialog.Builder(GitActivity.this).setMessage(e.getMessage()).show()      }   }  catch (  IOException e) {     e.printStackTrace()      new AlertDialog.Builder(GitActivity.this).setMessage(e.getMessage()).show()    }   dialog.cancel()  } 
public void onClick(DialogInterface dialog,int id){   dialog.cancel()  } 
/**   * Syncs the local repository with the remote one (either pull or push)  * @param operation the operation to execute can be REQUEST_PULL or REQUEST_PUSH  */ private void syncRepository(int operation){   if (settings.getString("git_remote_username","").isEmpty() || settings.getString("git_remote_server","").isEmpty() || settings.getString("git_remote_location","").isEmpty())   new AlertDialog.Builder(this).setMessage(activity.getResources().getString(R.string.set_information_dialog_text)).setPositiveButton(activity.getResources().getString(R.string.dialog_positive),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       Intent intent=new Intent(activity,UserPreference.class)        startActivityForResult(intent,REQUEST_PULL)      }   } ).setNegativeButton(activity.getResources().getString(R.string.dialog_negative),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       setResult(RESULT_OK)        finish()      }   } ).show()   else {     PasswordRepository.addRemote("origin",hostname,false)      GitOperation op  switch (operation) { case REQUEST_PULL:       op=new PullOperation(localDir,activity).setCommand()      break  case REQUEST_PUSH:   op=new PushOperation(localDir,activity).setCommand()  break  case REQUEST_SYNC: op=new SyncOperation(localDir,activity).setCommands()  break  default : Log.e(TAG,"Sync operation not recognized : " + operation)  return  } try { op.executeAfterAuthentication(connectionMode,settings.getString("git_remote_username","git"),new File(getFilesDir() + "/.ssh_key"))  }  catch (Exception e) { e.printStackTrace()  } } } 
@Override public void onClick(DialogInterface dialogInterface,int i){   Intent intent=new Intent(activity,UserPreference.class)    startActivityForResult(intent,REQUEST_PULL)  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   setResult(RESULT_OK)    finish()  } 
protected void onActivityResult(int requestCode,int resultCode,Intent data){   if (resultCode == RESULT_CANCELED) {     setResult(RESULT_CANCELED)      finish()      return    }   if (resultCode == RESULT_OK) {     GitOperation op  switch (requestCode) { case REQUEST_CLONE:       setResult(RESULT_OK)      finish()    return  case REQUEST_PULL: op=new PullOperation(localDir,activity).setCommand()  break  case REQUEST_PUSH: op=new PushOperation(localDir,activity).setCommand()  break  case GitOperation.GET_SSH_KEY_FROM_CLONE: op=new CloneOperation(localDir,activity).setCommand(hostname)  break  default : Log.e(TAG,"Operation not recognized : " + resultCode)  setResult(RESULT_CANCELED)  finish()  return  } try { op.executeAfterAuthentication(connectionMode,settings.getString("git_remote_username","git"),new File(getFilesDir() + "/.ssh_key"))  }  catch (Exception e) { e.printStackTrace()  } } } 
public GitAsyncTask(Activity activity,boolean finishOnEnd,boolean refreshListOnEnd,GitOperation operation){   this.activity=activity    this.finishOnEnd=finishOnEnd    this.refreshListOnEnd=refreshListOnEnd    this.operation=operation    dialog=new ProgressDialog(this.activity)  } 
protected void onPreExecute(){   this.dialog.setMessage(activity.getResources().getString(R.string.running_dialog_text))    this.dialog.setCancelable(false)    this.dialog.show()  } 
@Override protected String doInBackground(GitCommand... commands){   Integer nbChanges=null    for (  GitCommand command : commands) {     try {       if (command instanceof StatusCommand) {         nbChanges=((StatusCommand)command).call().getChanged().size()        }  else       if (command instanceof CommitCommand) {         if (nbChanges == null || nbChanges > 0)         command.call()        }  else {         command.call()        }     }  catch (    Exception e) {       e.printStackTrace()        return e.getMessage() + "\nCaused by:\n" + e.getCause()      }   }   return ""  } 
protected void onPostExecute(String result){   if (this.dialog != null)   try {     this.dialog.dismiss()    }  catch (  Exception e) {   }   if (result == null)   result="Unexpected error"    if (!result.isEmpty()) {     this.operation.onTaskEnded(result)    }  else {     if (finishOnEnd) {       this.activity.setResult(Activity.RESULT_OK)        this.activity.finish()      }     if (refreshListOnEnd) {       try {         ((PasswordStore)this.activity).updateListAdapter()        }  catch (      ClassCastException e) {       }     }   } } 
/**   * Creates a new git operation  * @param fileDir         the git working tree directory  * @param callingActivity the calling activity  */ public GitOperation(File fileDir,Activity callingActivity){   this.repository=PasswordRepository.getRepository(fileDir)    this.callingActivity=callingActivity  } 
/**   * Sets the authentication using user/pwd scheme  * @param username the username  * @param password the password  * @return the current object  */ public GitOperation setAuthentication(String username,String password){   SshSessionFactory.setInstance(new GitConfigSessionFactory())    this.provider=new UsernamePasswordCredentialsProvider(username,password)    return this  } 
/**   * Sets the authentication using ssh-key scheme  * @param sshKey     the ssh-key file  * @param username   the username  * @param passphrase the passphrase  * @return the current object  */ public GitOperation setAuthentication(File sshKey,String username,String passphrase){   JschConfigSessionFactory sessionFactory=new SshConfigSessionFactory(sshKey.getAbsolutePath(),username,passphrase)    SshSessionFactory.setInstance(sessionFactory)    this.provider=null    return this  } 
/**   * Executes the GitCommand in an async task  */ public abstract void execute()  
/**   * Executes the GitCommand in an async task after creating the authentication  * @param connectionMode the server-connection mode  * @param username       the username  * @param sshKey         the ssh-key file  */ public void executeAfterAuthentication(final String connectionMode,final String username,@Nullable final File sshKey){   executeAfterAuthentication(connectionMode,username,sshKey,false)  } 
/**   * Executes the GitCommand in an async task after creating the authentication  * @param connectionMode the server-connection mode  * @param username       the username  * @param sshKey         the ssh-key file  * @param showError      show the passphrase edit text in red  */ private void executeAfterAuthentication(final String connectionMode,final String username,@Nullable final File sshKey,final boolean showError){   if (connectionMode.equalsIgnoreCase("ssh-key")) {     if (sshKey == null || !sshKey.exists()) {       new AlertDialog.Builder(callingActivity).setMessage(callingActivity.getResources().getString(R.string.ssh_preferences_dialog_text)).setTitle(callingActivity.getResources().getString(R.string.ssh_preferences_dialog_title)).setPositiveButton(callingActivity.getResources().getString(R.string.ssh_preferences_dialog_import),new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialog,        int id){           try {             Intent intent=new Intent(callingActivity.getApplicationContext(),UserPreference.class)              intent.putExtra("operation","get_ssh_key")              callingActivity.startActivityForResult(intent,GET_SSH_KEY_FROM_CLONE)            }  catch (          Exception e) {             System.out.println("Exception caught :(")              e.printStackTrace()            }         }       } ).setNegativeButton(callingActivity.getResources().getString(R.string.ssh_preferences_dialog_generate),new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialog,        int which){           try {             Intent intent=new Intent(callingActivity.getApplicationContext(),UserPreference.class)              intent.putExtra("operation","make_ssh_key")              callingActivity.startActivityForResult(intent,GET_SSH_KEY_FROM_CLONE)            }  catch (          Exception e) {             System.out.println("Exception caught :(")              e.printStackTrace()            }         }       } ).setNeutralButton(callingActivity.getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialog,        int id){           callingActivity.finish()          }       } ).show()      }  else {       final EditText passphrase=new EditText(callingActivity)        passphrase.setHint("Passphrase")        passphrase.setWidth(LinearLayout.LayoutParams.MATCH_PARENT)        passphrase.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)        if (showError) {         passphrase.setError("Wrong passphrase")        }       JSch jsch=new JSch()        try {         final KeyPair keyPair=KeyPair.load(jsch,callingActivity.getFilesDir() + "/.ssh_key")          if (keyPair.isEncrypted()) {           new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.passphrase_dialog_title)).setMessage(callingActivity.getResources().getString(R.string.passphrase_dialog_text)).setView(passphrase).setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){             public void onClick(            DialogInterface dialog,            int whichButton){               if (keyPair.decrypt(passphrase.getText().toString())) {                 setAuthentication(sshKey,username,passphrase.getText().toString()).execute()                }  else {                 executeAfterAuthentication(connectionMode,username,sshKey,true)                }             }           } ).setNegativeButton(callingActivity.getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){             public void onClick(            DialogInterface dialog,            int whichButton){             }           } ).show()          }  else {           setAuthentication(sshKey,username,"").execute()          }       }  catch (      JSchException e) {         new AlertDialog.Builder(callingActivity).setTitle("Unable to open the ssh-key").setMessage("Please check that it was imported.").setPositiveButton("Ok",new DialogInterface.OnClickListener(){           @Override public void onClick(          DialogInterface dialogInterface,          int i){           }         } ).show()        }     }   }  else {     final EditText password=new EditText(callingActivity)      password.setHint("Password")      password.setWidth(LinearLayout.LayoutParams.MATCH_PARENT)      password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)      new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.passphrase_dialog_title)).setMessage(callingActivity.getResources().getString(R.string.password_dialog_text)).setView(password).setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){       public void onClick(      DialogInterface dialog,      int whichButton){         setAuthentication(username,password.getText().toString()).execute()        }     } ).setNegativeButton(callingActivity.getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){       public void onClick(      DialogInterface dialog,      int whichButton){       }     } ).show()    } } 
@Override public void onClick(DialogInterface dialog,int id){   try {     Intent intent=new Intent(callingActivity.getApplicationContext(),UserPreference.class)      intent.putExtra("operation","get_ssh_key")      callingActivity.startActivityForResult(intent,GET_SSH_KEY_FROM_CLONE)    }  catch (  Exception e) {     System.out.println("Exception caught :(")      e.printStackTrace()    } } 
@Override public void onClick(DialogInterface dialog,int which){   try {     Intent intent=new Intent(callingActivity.getApplicationContext(),UserPreference.class)      intent.putExtra("operation","make_ssh_key")      callingActivity.startActivityForResult(intent,GET_SSH_KEY_FROM_CLONE)    }  catch (  Exception e) {     System.out.println("Exception caught :(")      e.printStackTrace()    } } 
@Override public void onClick(DialogInterface dialog,int id){   callingActivity.finish()  } 
public void onClick(DialogInterface dialog,int whichButton){   if (keyPair.decrypt(passphrase.getText().toString())) {     setAuthentication(sshKey,username,passphrase.getText().toString()).execute()    }  else {     executeAfterAuthentication(connectionMode,username,sshKey,true)    } } 
public void onClick(DialogInterface dialog,int whichButton){ } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
public void onClick(DialogInterface dialog,int whichButton){   setAuthentication(username,password.getText().toString()).execute()  } 
public void onClick(DialogInterface dialog,int whichButton){ } 
public void onTaskEnded(String result){   new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.jgit_error_dialog_title)).setMessage("Error occurred during a Git operation, " + callingActivity.getResources().getString(R.string.jgit_error_dialog_text) + result+ "\nPlease check the FAQ for possible reasons why this error might occur.").setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       callingActivity.setResult(Activity.RESULT_CANCELED)        callingActivity.finish()      }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   callingActivity.setResult(Activity.RESULT_CANCELED)    callingActivity.finish()  } 
/**   * Creates a new git operation  * @param fileDir         the git working tree directory  * @param callingActivity the calling activity  */ public PullOperation(File fileDir,Activity callingActivity){   super(fileDir,callingActivity)  } 
/**   * Sets the command  * @return the current object  */ public PullOperation setCommand(){   this.command=new Git(repository).pull().setRebase(true).setRemote("origin")    return this  } 
@Override public void execute(){   if (this.provider != null) {     ((PullCommand)this.command).setCredentialsProvider(this.provider)    }   new GitAsyncTask(callingActivity,true,false,this).execute(this.command)  } 
@Override public void onTaskEnded(String result){   new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.jgit_error_dialog_title)).setMessage("Error occured during the pull operation, " + callingActivity.getResources().getString(R.string.jgit_error_dialog_text) + result+ "\nPlease check the FAQ for possible reasons why this error might occur.").setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       callingActivity.finish()      }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   callingActivity.finish()  } 
/**   * Creates a new git operation  * @param fileDir         the git working tree directory  * @param callingActivity the calling activity  */ public PushOperation(File fileDir,Activity callingActivity){   super(fileDir,callingActivity)  } 
/**   * Sets the command  * @return the current object  */ public PushOperation setCommand(){   this.command=new Git(repository).push().setPushAll().setRemote("origin")    return this  } 
@Override public void execute(){   if (this.provider != null) {     ((PushCommand)this.command).setCredentialsProvider(this.provider)    }   new GitAsyncTask(callingActivity,true,false,this).execute(this.command)  } 
@Override public void onTaskEnded(String result){   new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.jgit_error_dialog_title)).setMessage("Error occured during the push operation, " + callingActivity.getResources().getString(R.string.jgit_error_dialog_text) + result+ "\nPlease check the FAQ for possible reasons why this error might occur.").setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       callingActivity.finish()      }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   callingActivity.finish()  } 
/**   * Creates a new git operation  * @param fileDir         the git working tree directory  * @param callingActivity the calling activity  */ public SyncOperation(File fileDir,Activity callingActivity){   super(fileDir,callingActivity)  } 
/**   * Sets the command  * @return the current object  */ public SyncOperation setCommands(){   Git git=new Git(repository)    this.addCommand=git.add().setUpdate(true).addFilepattern(".")    this.statusCommand=git.status()    this.commitCommand=git.commit().setMessage("[Android Password Store] Sync")    this.pullCommand=git.pull().setRebase(true).setRemote("origin")    this.pushCommand=git.push().setPushAll().setRemote("origin")    return this  } 
@Override public void execute(){   if (this.provider != null) {     this.pullCommand.setCredentialsProvider(this.provider)      this.pushCommand.setCredentialsProvider(this.provider)    }   new GitAsyncTask(callingActivity,true,false,this).execute(this.addCommand,this.statusCommand,this.commitCommand,this.pullCommand,this.pushCommand)  } 
@Override public void onTaskEnded(String result){   new AlertDialog.Builder(callingActivity).setTitle(callingActivity.getResources().getString(R.string.jgit_error_dialog_title)).setMessage("Error occured during the sync operation, " + callingActivity.getResources().getString(R.string.jgit_error_dialog_text) + result+ "\nPlease check the FAQ for possible reasons why this error might occur.").setPositiveButton(callingActivity.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       callingActivity.finish()      }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   callingActivity.finish()  } 
public void onFragmentInteraction(PasswordItem item)  
/**   * Mandatory empty constructor for the fragment manager to instantiate the fragment (e.g. upon screen orientation changes).  */ public PasswordFragment(){ } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    String path=getArguments().getString("Path")    settings=PreferenceManager.getDefaultSharedPreferences(getActivity())    passListStack=new Stack<ArrayList<PasswordItem>>()    scrollPosition=new Stack<Integer>()    pathStack=new Stack<File>()    recyclerAdapter=new PasswordRecyclerAdapter((PasswordStore)getActivity(),mListener,PasswordRepository.getPasswords(new File(path),PasswordRepository.getRepositoryDirectory(getActivity())))  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   View view=inflater.inflate(R.layout.password_recycler_view,container,false)    mLayoutManager=new LinearLayoutManager(getActivity())    recyclerView=(RecyclerView)view.findViewById(R.id.pass_recycler)    recyclerView.setLayoutManager(mLayoutManager)    recyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),R.drawable.divider))    recyclerView.setAdapter(recyclerAdapter)    final FloatingActionButton fab=(FloatingActionButton)view.findViewById(R.id.fab)    fab.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       ((PasswordStore)getActivity()).createPassword()      }   } )    registerForContextMenu(recyclerView)    return view  } 
@Override public void onClick(View v){   ((PasswordStore)getActivity()).createPassword()  } 
@Override public void onAttach(final Context context){   super.onAttach(context)    try {     mListener=new OnFragmentInteractionListener(){       public void onFragmentInteraction(      PasswordItem item){         if (item.getType() == PasswordItem.TYPE_CATEGORY) {           passListStack.push(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(context)) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(context)))            pathStack.push(item.getFile())            scrollPosition.push(recyclerView.getVerticalScrollbarPosition())            recyclerView.scrollToPosition(0)            recyclerAdapter.clear()            recyclerAdapter.addAll(PasswordRepository.getPasswords(item.getFile(),PasswordRepository.getRepositoryDirectory(context)))            ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(true)          }  else {           if (getArguments().getBoolean("matchWith",false)) {             ((PasswordStore)getActivity()).matchPasswordWithApp(item)            }  else {             ((PasswordStore)getActivity()).decryptPassword(item)            }         }       }       public void savePosition(      Integer position){       }     }     }  catch (  ClassCastException e) {     throw new ClassCastException(context.toString() + " must implement OnFragmentInteractionListener")    } } 
public void onFragmentInteraction(PasswordItem item){   if (item.getType() == PasswordItem.TYPE_CATEGORY) {     passListStack.push(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(context)) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(context)))      pathStack.push(item.getFile())      scrollPosition.push(recyclerView.getVerticalScrollbarPosition())      recyclerView.scrollToPosition(0)      recyclerAdapter.clear()      recyclerAdapter.addAll(PasswordRepository.getPasswords(item.getFile(),PasswordRepository.getRepositoryDirectory(context)))      ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(true)    }  else {     if (getArguments().getBoolean("matchWith",false)) {       ((PasswordStore)getActivity()).matchPasswordWithApp(item)      }  else {       ((PasswordStore)getActivity()).decryptPassword(item)      }   } } 
public void savePosition(Integer position){ } 
@Override public void onPause(){   super.onPause()  } 
/**   * clears the adapter content and sets it back to the root view  */ public void updateAdapter(){   passListStack.clear()    pathStack.clear()    scrollPosition.clear()    recyclerAdapter.clear()    recyclerAdapter.addAll(PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())))    ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(false)  } 
/**   * refreshes the adapter with the latest opened category  */ public void refreshAdapter(){   recyclerAdapter.clear()    recyclerAdapter.addAll(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(getActivity())))  } 
/**   * filters the list adapter  * @param filter the filter to apply  */ public void filterAdapter(String filter){   Log.d("FRAG","filter: " + filter)    if (filter.isEmpty()) {     refreshAdapter()    }  else {     recursiveFilter(filter,pathStack.isEmpty() ? null : pathStack.peek())    } } 
/**   * recursively filters a directory and extract all the matching items  * @param filter the filter to apply  * @param dir the directory to filter  */ private void recursiveFilter(String filter,File dir){   ArrayList<PasswordItem> passwordItems=dir == null ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())) : PasswordRepository.getPasswords(dir,PasswordRepository.getRepositoryDirectory(getActivity()))    boolean rec=settings.getBoolean("filter_recursively",true)    for (  PasswordItem item : passwordItems) {     if (item.getType() == PasswordItem.TYPE_CATEGORY && rec) {       recursiveFilter(filter,item.getFile())      }     boolean matches=item.toString().toLowerCase().contains(filter.toLowerCase())      boolean inAdapter=recyclerAdapter.getValues().contains(item)      if (matches && !inAdapter) {       recyclerAdapter.add(item)      }  else     if (!matches && inAdapter) {       recyclerAdapter.remove(recyclerAdapter.getValues().indexOf(item))      }   } } 
/**   * Goes back one level back in the path  */ public void popBack(){   if (passListStack.isEmpty())   return    recyclerView.scrollToPosition(scrollPosition.pop())    recyclerAdapter.clear()    recyclerAdapter.addAll(passListStack.pop())    pathStack.pop()  } 
/**   * gets the current directory  * @return the current directory  */ public File getCurrentDir(){   if (pathStack.isEmpty())   return PasswordRepository.getRepositoryDirectory(getActivity().getApplicationContext())   else   return pathStack.peek()  } 
public boolean isNotEmpty(){   return !passListStack.isEmpty()  } 
@Override protected void onCreate(Bundle savedInstanceState){   settings=PreferenceManager.getDefaultSharedPreferences(this.getApplicationContext())    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1)   shortcutManager=getSystemService(ShortcutManager.class)    activity=this    PRNGFixes.apply()    if (savedInstanceState != null && (!settings.getBoolean("git_external",false) || ContextCompat.checkSelfPermission(activity,Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)) {     savedInstanceState=null    }   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_pwdstore)  } 
@Override public void onResume(){   super.onResume()    if (settings.getBoolean("git_external",false)) {     if (ContextCompat.checkSelfPermission(activity,Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {       if (ActivityCompat.shouldShowRequestPermissionRationale(activity,Manifest.permission.READ_EXTERNAL_STORAGE)) {         Snackbar snack=Snackbar.make(findViewById(R.id.main_layout),"The store is on the sdcard but the app does not have permission to access it. Please give permission.",Snackbar.LENGTH_INDEFINITE).setAction(R.string.dialog_ok,new View.OnClickListener(){           @Override public void onClick(          View view){             ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)            }         } )          snack.show()          View view=snack.getView()          TextView tv=(TextView)view.findViewById(android.support.design.R.id.snackbar_text)          tv.setTextColor(Color.WHITE)          tv.setMaxLines(10)        }  else {         ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)        }     }  else {       checkLocalRepository()      }   }  else {     checkLocalRepository()    } } 
@Override public void onClick(View view){   ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)  } 
@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){ switch (requestCode) { case REQUEST_EXTERNAL_STORAGE: {       if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {         checkLocalRepository()        }     } } } 
@Override public void onPause(){   super.onPause()  } 
@Override public boolean onCreateOptionsMenu(Menu menu){   getMenuInflater().inflate(R.menu.main_menu,menu)    MenuItem searchItem=menu.findItem(R.id.action_search)    SearchView searchView=(SearchView)MenuItemCompat.getActionView(searchItem)    searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener(){     @Override public boolean onQueryTextSubmit(    String s){       return true      }     @Override public boolean onQueryTextChange(    String s){       filterListAdapter(s)        return true      }   } )    MenuItemCompat.setOnActionExpandListener(searchItem,new MenuItemCompat.OnActionExpandListener(){     @Override public boolean onMenuItemActionCollapse(    MenuItem item){       refreshListAdapter()        return true      }     @Override public boolean onMenuItemActionExpand(    MenuItem item){       return true      }   } )    return super.onCreateOptionsMenu(menu)  } 
@Override public boolean onQueryTextSubmit(String s){   return true  } 
@Override public boolean onQueryTextChange(String s){   filterListAdapter(s)    return true  } 
@Override public boolean onMenuItemActionCollapse(MenuItem item){   refreshListAdapter()    return true  } 
@Override public boolean onMenuItemActionExpand(MenuItem item){   return true  } 
@Override public boolean onOptionsItemSelected(MenuItem item){   int id=item.getItemId()    Intent intent    Log.d("PASS","Menu item " + id + " pressed")    AlertDialog.Builder initBefore=new AlertDialog.Builder(this).setMessage(this.getResources().getString(R.string.creation_dialog_text)).setPositiveButton(this.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){     }   } )  switch (id) { case R.id.user_pref:     try {       intent=new Intent(this,UserPreference.class)        startActivity(intent)      }  catch (    Exception e) {       System.out.println("Exception caught :(")        e.printStackTrace()      }   return true  case R.id.git_push: if (!PasswordRepository.isInitialized()) {   initBefore.show()    break  } intent=new Intent(this,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_PUSH)  startActivityForResult(intent,GitActivity.REQUEST_PUSH)  return true  case R.id.git_pull: if (!PasswordRepository.isInitialized()) { initBefore.show()  break  } intent=new Intent(this,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_PULL)  startActivityForResult(intent,GitActivity.REQUEST_PULL)  return true  case R.id.git_sync: if (!PasswordRepository.isInitialized()) { initBefore.show()  break  } intent=new Intent(this,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_SYNC)  startActivityForResult(intent,GitActivity.REQUEST_SYNC)  return true  case R.id.refresh: updateListAdapter()  return true  case android.R.id.home: Log.d("PASS","Home pressed")  this.onBackPressed()  break  default : break  } return super.onOptionsItemSelected(item)  } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
public void openSettings(View view){   Intent intent    try {     intent=new Intent(this,UserPreference.class)      startActivity(intent)    }  catch (  Exception e) {     System.out.println("Exception caught :(")      e.printStackTrace()    } } 
public void cloneExistingRepository(View view){   initRepository(CLONE_REPO_BUTTON)  } 
public void createNewRepository(View view){   initRepository(NEW_REPO_BUTTON)  } 
private void createRepository(){   if (!PasswordRepository.isInitialized()) {     PasswordRepository.initialize(this)    }   File localDir=PasswordRepository.getRepositoryDirectory(getApplicationContext())    localDir.mkdir()    try {     PasswordRepository.createRepository(localDir)      new File(localDir.getAbsolutePath() + "/.gpg-id").createNewFile()      settings.edit().putBoolean("repository_initialized",true).apply()    }  catch (  Exception e) {     e.printStackTrace()      localDir.delete()      return    }   checkLocalRepository()  } 
public void initializeRepositoryInfo(){   if (settings.getBoolean("git_external",false) && settings.getString("git_external_repo",null) != null) {     File dir=new File(settings.getString("git_external_repo",null))      if (dir.exists() && dir.isDirectory() && !FileUtils.listFiles(dir,null,true).isEmpty()&& !PasswordRepository.getPasswords(dir,PasswordRepository.getRepositoryDirectory(this)).isEmpty()) {       PasswordRepository.closeRepository()        checkLocalRepository()        return      }   }   final Set<String> keyIds=settings.getStringSet("openpgp_key_ids_set",new HashSet<String>())    if (keyIds.isEmpty())   new AlertDialog.Builder(this).setMessage(this.getResources().getString(R.string.key_dialog_text)).setPositiveButton(this.getResources().getString(R.string.dialog_positive),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       Intent intent=new Intent(activity,UserPreference.class)        startActivityForResult(intent,GitActivity.REQUEST_INIT)      }   } ).setNegativeButton(this.getResources().getString(R.string.dialog_negative),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){     }   } ).show()    createRepository()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   Intent intent=new Intent(activity,UserPreference.class)    startActivityForResult(intent,GitActivity.REQUEST_INIT)  } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
private void checkLocalRepository(){   Repository repo=PasswordRepository.initialize(this)    if (repo == null) {     Intent intent=new Intent(activity,UserPreference.class)      intent.putExtra("operation","git_external")      startActivityForResult(intent,HOME)    }  else {     checkLocalRepository(PasswordRepository.getRepositoryDirectory(getApplicationContext()))    } } 
private void checkLocalRepository(File localDir){   FragmentManager fragmentManager=getSupportFragmentManager()    FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction()    if (localDir != null && settings.getBoolean("repository_initialized",false)) {     Log.d("PASS","Check, dir: " + localDir.getAbsolutePath())      if (fragmentManager.findFragmentByTag("PasswordsList") == null || settings.getBoolean("repo_changed",false)) {       settings.edit().putBoolean("repo_changed",false).apply()        plist=new PasswordFragment()        Bundle args=new Bundle()        args.putString("Path",PasswordRepository.getRepositoryDirectory(getApplicationContext()).getAbsolutePath())        if (getIntent().getBooleanExtra("matchWith",false)) {         args.putBoolean("matchWith",true)        }       plist.setArguments(args)        getSupportActionBar().show()        getSupportActionBar().setDisplayHomeAsUpEnabled(false)        fragmentManager.popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE)        fragmentTransaction.replace(R.id.main_layout,plist,"PasswordsList")        fragmentTransaction.commit()      }   }  else {     getSupportActionBar().hide()      fragmentManager.popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE)      ToCloneOrNot cloneFrag=new ToCloneOrNot()      fragmentTransaction.replace(R.id.main_layout,cloneFrag,"ToCloneOrNot")      fragmentTransaction.commit()    } } 
@Override public void onBackPressed(){   if ((null != plist) && plist.isNotEmpty()) {     plist.popBack()    }  else {     super.onBackPressed()    }   if (null != plist && !plist.isNotEmpty()) {     getSupportActionBar().setDisplayHomeAsUpEnabled(false)    } } 
public void decryptPassword(PasswordItem item){   Intent intent=new Intent(this,PgpHandler.class)    intent.putExtra("NAME",item.toString())    intent.putExtra("FILE_PATH",item.getFile().getAbsolutePath())    intent.putExtra("Operation","DECRYPT")    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {     ShortcutInfo shortcut=new ShortcutInfo.Builder(this,item.getFullPathToParent()).setShortLabel(item.toString()).setLongLabel(item.getFullPathToParent() + item.toString()).setIcon(Icon.createWithResource(this,R.drawable.ic_launcher)).setIntent(intent.setAction("DECRYPT_PASS")).build()      shortcutManager.addDynamicShortcuts(Arrays.asList(shortcut))    }   startActivityForResult(intent,PgpHandler.REQUEST_CODE_DECRYPT_AND_VERIFY)  } 
public void editPassword(PasswordItem item){   Intent intent=new Intent(this,PgpHandler.class)    intent.putExtra("NAME",item.toString())    intent.putExtra("FILE_PATH",item.getFile().getAbsolutePath())    intent.putExtra("Operation","EDIT")    startActivityForResult(intent,PgpHandler.REQUEST_CODE_EDIT)  } 
public void createPassword(){   if (!PasswordRepository.isInitialized()) {     new AlertDialog.Builder(this).setMessage(this.getResources().getString(R.string.creation_dialog_text)).setPositiveButton(this.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialogInterface,      int i){       }     } ).show()      return    }   if (settings.getStringSet("openpgp_key_ids_set",new HashSet<String>()).isEmpty()) {     new AlertDialog.Builder(this).setTitle("OpenPGP key not selected").setMessage("We will redirect you to settings. Please select your OpenPGP Key.").setPositiveButton(this.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialogInterface,      int i){         Intent intent=new Intent(activity,UserPreference.class)          startActivity(intent)        }     } ).show()      return    }   this.currentDir=getCurrentDir()    Log.i("PWDSTR","Adding file to : " + this.currentDir.getAbsolutePath())    Intent intent=new Intent(this,PgpHandler.class)    intent.putExtra("FILE_PATH",getCurrentDir().getAbsolutePath())    intent.putExtra("Operation","ENCRYPT")    startActivityForResult(intent,PgpHandler.REQUEST_CODE_ENCRYPT)  } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
@Override public void onClick(DialogInterface dialogInterface,int i){   Intent intent=new Intent(activity,UserPreference.class)    startActivity(intent)  } 
public void deletePasswords(final PasswordRecyclerAdapter adapter,final Set<Integer> selectedItems){   final Iterator it=selectedItems.iterator()    if (!it.hasNext()) {     return    }   final int position=(int)it.next()    final PasswordItem item=adapter.getValues().get(position)    new AlertDialog.Builder(this).setMessage(this.getResources().getString(R.string.delete_dialog_text) + item + "\"").setPositiveButton(this.getResources().getString(R.string.dialog_yes),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       item.getFile().delete()        adapter.remove(position)        it.remove()        adapter.updateSelectedItems(position,selectedItems)        commitAdd("[ANDROID PwdStore] Remove " + item + " from store.")        deletePasswords(adapter,selectedItems)      }   } ).setNegativeButton(this.getResources().getString(R.string.dialog_no),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       it.remove()        deletePasswords(adapter,selectedItems)      }   } ).show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   item.getFile().delete()    adapter.remove(position)    it.remove()    adapter.updateSelectedItems(position,selectedItems)    commitAdd("[ANDROID PwdStore] Remove " + item + " from store.")    deletePasswords(adapter,selectedItems)  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   it.remove()    deletePasswords(adapter,selectedItems)  } 
public void movePasswords(ArrayList<PasswordItem> values){   Intent intent=new Intent(this,PgpHandler.class)    ArrayList<String> fileLocations=new ArrayList<>()    for (  PasswordItem passwordItem : values) {     fileLocations.add(passwordItem.getFile().getAbsolutePath())    }   intent.putExtra("Files",fileLocations)    intent.putExtra("Operation","SELECTFOLDER")    startActivityForResult(intent,PgpHandler.REQUEST_CODE_SELECT_FOLDER)  } 
/**   * clears adapter's content and updates it with a fresh list of passwords from the root  */ public void updateListAdapter(){   if ((null != plist)) {     plist.updateAdapter()    } } 
/**   * Updates the adapter with the current view of passwords  */ public void refreshListAdapter(){   if ((null != plist)) {     plist.refreshAdapter()    } } 
public void filterListAdapter(String filter){   if ((null != plist)) {     plist.filterAdapter(filter)    } } 
private File getCurrentDir(){   if ((null != plist)) {     return plist.getCurrentDir()    }   return PasswordRepository.getRepositoryDirectory(getApplicationContext())  } 
private void commitAdd(final String message){   new GitOperation(PasswordRepository.getRepositoryDirectory(activity),activity){     @Override public void execute(){       Log.d(TAG,"Commiting with message " + message)        Git git=new Git(this.repository)        GitAsyncTask tasks=new GitAsyncTask(activity,false,true,this)        tasks.execute(git.add().setUpdate(true).addFilepattern("."),git.commit().setMessage(message))      }   } .execute()  } 
@Override public void execute(){   Log.d(TAG,"Commiting with message " + message)    Git git=new Git(this.repository)    GitAsyncTask tasks=new GitAsyncTask(activity,false,true,this)    tasks.execute(git.add().setUpdate(true).addFilepattern("."),git.commit().setMessage(message))  } 
protected void onActivityResult(int requestCode,int resultCode,Intent data){   if (resultCode == RESULT_OK) { switch (requestCode) { case GitActivity.REQUEST_CLONE:       settings.edit().putBoolean("repository_initialized",true).apply()      break  case PgpHandler.REQUEST_CODE_DECRYPT_AND_VERIFY:   if (data.getBooleanExtra("needCommit",false)) {     commitAdd(this.getResources().getString(R.string.edit_commit_text) + data.getExtras().getString("NAME"))      refreshListAdapter()    } break  case PgpHandler.REQUEST_CODE_ENCRYPT: commitAdd(this.getResources().getString(R.string.add_commit_text) + data.getExtras().getString("NAME") + this.getResources().getString(R.string.from_store))  refreshListAdapter()  break  case PgpHandler.REQUEST_CODE_EDIT: commitAdd(this.getResources().getString(R.string.edit_commit_text) + data.getExtras().getString("NAME"))  refreshListAdapter()  break  case GitActivity.REQUEST_INIT: initializeRepositoryInfo()  break  case GitActivity.REQUEST_SYNC: case GitActivity.REQUEST_PULL: updateListAdapter()  break  case HOME: checkLocalRepository()  break  case NEW_REPO_BUTTON: initializeRepositoryInfo()  break  case CLONE_REPO_BUTTON: if (settings.getBoolean("git_external",false) && settings.getString("git_external_repo",null) != null) { String externalRepoPath=settings.getString("git_external_repo",null)  File dir=externalRepoPath != null ? new File(externalRepoPath) : null  if (dir != null && dir.exists() && dir.isDirectory() && !FileUtils.listFiles(dir,null,true).isEmpty() && !PasswordRepository.getPasswords(dir,PasswordRepository.getRepositoryDirectory(this)).isEmpty()) { PasswordRepository.closeRepository()  checkLocalRepository()  return  } } Intent intent=new Intent(activity,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  case PgpHandler.REQUEST_CODE_SELECT_FOLDER: Log.d("Moving","Moving passwords to " + data.getStringExtra("SELECTED_FOLDER_PATH"))  Log.d("Moving",TextUtils.join(", ",data.getStringArrayListExtra("Files")))  File target=new File(data.getStringExtra("SELECTED_FOLDER_PATH"))  if (!target.isDirectory()) { Log.e("Moving","Tried moving passwords to a non-existing folder.")  break  } for (String string : data.getStringArrayListExtra("Files")) { File source=new File(string)  if (!source.exists()) { Log.e("Moving","Tried moving something that appears non-existent.")  continue  } if (!source.renameTo(new File(target.getAbsolutePath() + "/" + source.getName()))) { Log.e("Moving","Something went wrong while moving.")  }  else { commitAdd("[ANDROID PwdStore] Moved " + string.replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()) + "/","") + " to "+ target.getAbsolutePath().replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()) + "/","")+ target.getAbsolutePath()+ "/"+ source.getName()+ ".")  } } updateListAdapter()  break  } } } 
protected void initRepository(final int operation){   PasswordRepository.closeRepository()    new AlertDialog.Builder(this).setTitle("Repository location").setMessage("Select where to create or clone your password repository.").setPositiveButton("Hidden (preferred)",new DialogInterface.OnClickListener(){     public void onClick(    DialogInterface dialog,    int whichButton){       settings.edit().putBoolean("git_external",false).apply()  switch (operation) { case NEW_REPO_BUTTON:         initializeRepositoryInfo()        break  case CLONE_REPO_BUTTON:     PasswordRepository.initialize(PasswordStore.this)    Intent intent=new Intent(activity,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  } } } ).setNegativeButton("SD-Card",new DialogInterface.OnClickListener(){ public void onClick(DialogInterface dialog,int whichButton){ settings.edit().putBoolean("git_external",true).apply()  if (settings.getString("git_external_repo",null) == null) { Intent intent=new Intent(activity,UserPreference.class)  intent.putExtra("operation","git_external")  startActivityForResult(intent,operation)  }  else { new AlertDialog.Builder(activity).setTitle("Directory already selected").setMessage("Do you want to use \"" + settings.getString("git_external_repo",null) + "\"?").setPositiveButton("Use",new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog,int which){ switch (operation) { case NEW_REPO_BUTTON: initializeRepositoryInfo()  break  case CLONE_REPO_BUTTON: PasswordRepository.initialize(PasswordStore.this)  Intent intent=new Intent(activity,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  } } } ).setNegativeButton("Change",new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog,int which){ Intent intent=new Intent(activity,UserPreference.class)  intent.putExtra("operation","git_external")  startActivityForResult(intent,operation)  } } ).show()  } } } ).show()  } 
public void onClick(DialogInterface dialog,int whichButton){   settings.edit().putBoolean("git_external",false).apply()  switch (operation) { case NEW_REPO_BUTTON:     initializeRepositoryInfo()    break  case CLONE_REPO_BUTTON: PasswordRepository.initialize(PasswordStore.this)  Intent intent=new Intent(activity,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  } } 
public void onClick(DialogInterface dialog,int whichButton){   settings.edit().putBoolean("git_external",true).apply()    if (settings.getString("git_external_repo",null) == null) {     Intent intent=new Intent(activity,UserPreference.class)      intent.putExtra("operation","git_external")      startActivityForResult(intent,operation)    }  else {     new AlertDialog.Builder(activity).setTitle("Directory already selected").setMessage("Do you want to use \"" + settings.getString("git_external_repo",null) + "\"?").setPositiveButton("Use",new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialog,      int which){ switch (operation) { case NEW_REPO_BUTTON:           initializeRepositoryInfo()          break  case CLONE_REPO_BUTTON:       PasswordRepository.initialize(PasswordStore.this)      Intent intent=new Intent(activity,GitActivity.class)    intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  } } } ).setNegativeButton("Change",new DialogInterface.OnClickListener(){ @Override public void onClick(DialogInterface dialog,int which){ Intent intent=new Intent(activity,UserPreference.class)  intent.putExtra("operation","git_external")  startActivityForResult(intent,operation)  } } ).show()  } } 
@Override public void onClick(DialogInterface dialog,int which){ switch (operation) { case NEW_REPO_BUTTON:     initializeRepositoryInfo()    break  case CLONE_REPO_BUTTON: PasswordRepository.initialize(PasswordStore.this)  Intent intent=new Intent(activity,GitActivity.class)  intent.putExtra("Operation",GitActivity.REQUEST_CLONE)  startActivityForResult(intent,GitActivity.REQUEST_CLONE)  break  } } 
@Override public void onClick(DialogInterface dialog,int which){   Intent intent=new Intent(activity,UserPreference.class)    intent.putExtra("operation","git_external")    startActivityForResult(intent,operation)  } 
public void matchPasswordWithApp(PasswordItem item){   String path=item.getFile().getAbsolutePath()    path=path.replace(PasswordRepository.getRepositoryDirectory(getApplicationContext()) + "/","").replace(".gpg","")    Intent data=new Intent()    data.putExtra("path",path)    setResult(RESULT_OK,data)    finish()  } 
/**   * Hidden constructor to prevent instantiation.   */ private PRNGFixes(){ } 
/**   * Applies all fixes.  * @throws SecurityException if a fix is needed but could not be applied.  */ public static void apply(){   applyOpenSSLFix()    installLinuxPRNGSecureRandom()  } 
/**   * Applies the fix for OpenSSL PRNG having low entropy. Does nothing if the fix is not needed.  * @throws SecurityException if the fix is needed but could not be applied.  */ private static void applyOpenSSLFix() throws SecurityException {   if ((Build.VERSION.SDK_INT < VERSION_CODE_JELLY_BEAN) || (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2)) {     return    }   try {     Class.forName("org.apache.harmony.xnet.provider.jsse.NativeCrypto").getMethod("RAND_seed",byte[].class).invoke(null,generateSeed())      int bytesRead=(Integer)Class.forName("org.apache.harmony.xnet.provider.jsse.NativeCrypto").getMethod("RAND_load_file",String.class,long.class).invoke(null,"/dev/urandom",1024)      if (bytesRead != 1024) {       throw new IOException("Unexpected number of bytes read from Linux PRNG: " + bytesRead)      }   }  catch (  Exception e) {     throw new SecurityException("Failed to seed OpenSSL PRNG",e)    } } 
/**   * Installs a Linux PRNG-backed  {@code SecureRandom} implementation as thedefault. Does nothing if the implementation is already the default or if there is not need to install the implementation.  * @throws SecurityException if the fix is needed but could not be applied.  */ private static void installLinuxPRNGSecureRandom() throws SecurityException {   if (Build.VERSION.SDK_INT > VERSION_CODE_JELLY_BEAN_MR2) {     return    }   Provider[] secureRandomProviders=Security.getProviders("SecureRandom.SHA1PRNG")    if ((secureRandomProviders == null) || (secureRandomProviders.length < 1) || (!LinuxPRNGSecureRandomProvider.class.equals(secureRandomProviders[0].getClass()))) {     Security.insertProviderAt(new LinuxPRNGSecureRandomProvider(),1)    }   SecureRandom rng1=new SecureRandom()    if (!LinuxPRNGSecureRandomProvider.class.equals(rng1.getProvider().getClass())) {     throw new SecurityException("new SecureRandom() backed by wrong Provider: " + rng1.getProvider().getClass())    }   SecureRandom rng2    try {     rng2=SecureRandom.getInstance("SHA1PRNG")    }  catch (  NoSuchAlgorithmException e) {     throw new SecurityException("SHA1PRNG not available",e)    }   if (!LinuxPRNGSecureRandomProvider.class.equals(rng2.getProvider().getClass())) {     throw new SecurityException("SecureRandom.getInstance(\"SHA1PRNG\") backed by wrong" + " Provider: " + rng2.getProvider().getClass())    } } 
public LinuxPRNGSecureRandomProvider(){   super("LinuxPRNG",1.0,"A Linux-specific random number provider that uses" + " /dev/urandom")    put("SecureRandom.SHA1PRNG",LinuxPRNGSecureRandom.class.getName())    put("SecureRandom.SHA1PRNG ImplementedIn","Software")  } 
@Override protected void engineSetSeed(byte[] bytes){   try {     OutputStream out  synchronized (sLock) {       out=getUrandomOutputStream()      }     out.write(bytes)      out.flush()    }  catch (  IOException e) {     Log.w(PRNGFixes.class.getSimpleName(),"Failed to mix seed into " + URANDOM_FILE)    }  finally {     mSeeded=true    } } 
@Override protected void engineNextBytes(byte[] bytes){   if (!mSeeded) {     engineSetSeed(generateSeed())    }   try {     DataInputStream in  synchronized (sLock) {       in=getUrandomInputStream()      } synchronized (in) {       in.readFully(bytes)      }   }  catch (  IOException e) {     throw new SecurityException("Failed to read from " + URANDOM_FILE,e)    } } 
@Override protected byte[] engineGenerateSeed(int size){   byte[] seed=new byte[size]    engineNextBytes(seed)    return seed  } 
private DataInputStream getUrandomInputStream(){ synchronized (sLock) {     if (sUrandomIn == null) {       try {         sUrandomIn=new DataInputStream(new FileInputStream(URANDOM_FILE))        }  catch (      IOException e) {         throw new SecurityException("Failed to open " + URANDOM_FILE + " for reading",e)        }     }     return sUrandomIn    } } 
private OutputStream getUrandomOutputStream() throws IOException { synchronized (sLock) {     if (sUrandomOut == null) {       sUrandomOut=new FileOutputStream(URANDOM_FILE)      }     return sUrandomOut    } } 
/**   * Generates a device- and invocation-specific seed to be mixed into the Linux PRNG.  */ private static byte[] generateSeed(){   try {     ByteArrayOutputStream seedBuffer=new ByteArrayOutputStream()      DataOutputStream seedBufferOut=new DataOutputStream(seedBuffer)      seedBufferOut.writeLong(System.currentTimeMillis())      seedBufferOut.writeLong(System.nanoTime())      seedBufferOut.writeInt(Process.myPid())      seedBufferOut.writeInt(Process.myUid())      seedBufferOut.write(BUILD_FINGERPRINT_AND_DEVICE_SERIAL)      seedBufferOut.close()      return seedBuffer.toByteArray()    }  catch (  IOException e) {     throw new SecurityException("Failed to generate seed",e)    } } 
/**   * Gets the hardware serial number of this device.  * @return serial number or {@code null} if not available.  */ private static String getDeviceSerialNumber(){   try {     return (String)Build.class.getField("SERIAL").get(null)    }  catch (  Exception ignored) {     return null    } } 
private static byte[] getBuildFingerprintAndDeviceSerial(){   StringBuilder result=new StringBuilder()    String fingerprint=Build.FINGERPRINT    if (fingerprint != null) {     result.append(fingerprint)    }   String serial=getDeviceSerialNumber()    if (serial != null) {     result.append(serial)    }   try {     return result.toString().getBytes("UTF-8")    }  catch (  UnsupportedEncodingException e) {     throw new RuntimeException("UTF-8 encoding not supported")    } } 
/**   * Sets password generation preferences.  * @param ctx     context from which to retrieve SharedPreferences frompreferences file 'pwgen'  * @param argv    options for password generation<table summary="options for password generation"> <tr><td>Option</td><td>Description</td></tr> <tr><td>0</td><td>don't include numbers</td></tr> <tr><td>A</td><td>don't include uppercase letters</td></tr> <tr><td>B</td><td>don't include ambiguous charactersl</td></tr> <tr><td>s</td><td>generate completely random passwords</td></tr> <tr><td>v</td><td>don't include vowels</td></tr> <tr><td>y</td><td>include at least one symbol</td></tr> </table>  * @param numArgv numerical options for password generation: length ofgenerated passwords followed by number of passwords to generate  * @return <code>false</code> if a numerical options is invalid,<code>true</code> otherwise  */ public static boolean setPrefs(Context ctx,ArrayList<String> argv,int... numArgv){   SharedPreferences prefs=ctx.getSharedPreferences("pwgen",Context.MODE_PRIVATE)    SharedPreferences.Editor editor=prefs.edit()    for (  char option : pwOptions.toCharArray()) {     if (argv.contains(String.valueOf(option))) {       editor.putBoolean(String.valueOf(option),true)        argv.remove(String.valueOf(option))      }  else {       editor.putBoolean(String.valueOf(option),false)      }   }   for (int i=0  i < numArgv.length && i < 2  i++) {     if (numArgv[i] <= 0) {       return false      }     String name=i == 0 ? "length" : "num"      editor.putInt(name,numArgv[i])    }   editor.apply()    return true  } 
/**   * Generates passwords using the preferences set by {@link #setPrefs(Context,ArrayList,int)}.  * @param ctx context from which to retrieve SharedPreferences frompreferences file 'pwgen'  * @return list of generated passwords  */ public static ArrayList<String> generate(Context ctx){   SharedPreferences prefs=ctx.getSharedPreferences("pwgen",Context.MODE_PRIVATE)    boolean phonemes=true    int pwgenFlags=DIGITS | UPPERS    for (  char option : pwOptions.toCharArray()) {     if (prefs.getBoolean(String.valueOf(option),false)) { switch (option) { case '0':         pwgenFlags&=~DIGITS        break  case 'A':     pwgenFlags&=~UPPERS    break  case 'B': pwgenFlags|=AMBIGUOUS  break  case 's': phonemes=false  break  case 'y': pwgenFlags|=SYMBOLS  break  case 'v': phonemes=false  pwgenFlags|=NO_VOWELS  break  } } } int length=prefs.getInt("length",8)  if (length < 5) { phonemes=false  } if (length <= 2) { pwgenFlags&=~UPPERS  } if (length <= 1) { pwgenFlags&=~DIGITS  } ArrayList<String> passwords=new ArrayList<>()  int num=prefs.getInt("num",1)  for (int i=0  i < num  i++) { if (phonemes) { passwords.add(pw_phonemes.phonemes(length,pwgenFlags))  }  else { passwords.add(pw_rand.rand(length,pwgenFlags))  } } return passwords  } 
element(String str,int flags){   this.str=str    this.flags=flags  } 
/**   * Generates a human-readable password.  * @param size    length of password to generate  * @param pwFlags flag field where set bits indicate conditions thegenerated password must meet <table summary="bits of flag field"> <tr><td>Bit</td><td>Condition</td></tr> <tr><td>0</td><td>include at least one number</td></tr> <tr><td>1</td><td>include at least one uppercase letter</td></tr> <tr><td>2</td><td>include at least one symbol</td></tr> <tr><td>3</td><td>don't include ambiguous characters</td></tr> </table>  * @return the generated password  */ public static String phonemes(int size,int pwFlags){   String password    int curSize, i, length, flags, featureFlags, prev, shouldBe    boolean first    String str    char cha    do {     password=""      featureFlags=pwFlags      curSize=0      prev=0      first=true      shouldBe=randnum.number(2) == 1 ? VOWEL : CONSONANT      while (curSize < size) {       i=randnum.number(NUM_ELEMENTS)        str=elements[i].str        length=str.length()        flags=elements[i].flags        if ((flags & shouldBe) == 0) {         continue        }       if (first && (flags & NOT_FIRST) > 0) {         continue        }       if ((prev & VOWEL) > 0 && (flags & VOWEL) > 0 && (flags & DIPTHONG) > 0) {         continue        }       if (length > size - curSize) {         continue        }       password+=str        if ((pwFlags & pwgen.UPPERS) > 0) {         if ((first || (flags & CONSONANT) > 0) && (randnum.number(10) < 2)) {           int index=password.length() - length            password=password.substring(0,index) + str.toUpperCase()            featureFlags&=~pwgen.UPPERS          }       }       if ((pwFlags & pwgen.AMBIGUOUS) > 0) {         for (        char ambiguous : pwgen.AMBIGUOUS_STR.toCharArray()) {           if (password.contains(String.valueOf(ambiguous))) {             password=password.substring(0,curSize)              break            }         }         if (password.length() == curSize)         continue        }       curSize+=length        if (curSize >= size)       break        if ((pwFlags & pwgen.DIGITS) > 0) {         if (!first && (randnum.number(10) < 3)) {           String val            do {             cha=Character.forDigit(randnum.number(10),10)              val=String.valueOf(cha)            }  while ((pwFlags & pwgen.AMBIGUOUS) > 0 && pwgen.AMBIGUOUS_STR.contains(val))            password+=val            curSize++            featureFlags&=~pwgen.DIGITS            first=true            prev=0            shouldBe=randnum.number(2) == 1 ? VOWEL : CONSONANT            continue          }       }       if ((pwFlags & pwgen.SYMBOLS) > 0) {         if (!first && (randnum.number(10) < 2)) {           String val            int num            do {             num=randnum.number(pwgen.SYMBOLS_STR.length())              cha=pwgen.SYMBOLS_STR.toCharArray()[num]              val=String.valueOf(cha)            }  while ((pwFlags & pwgen.AMBIGUOUS) > 0 && pwgen.AMBIGUOUS_STR.contains(val))            password+=val            curSize++            featureFlags&=~pwgen.SYMBOLS          }       }       if (shouldBe == CONSONANT) {         shouldBe=VOWEL        }  else {         if ((prev & VOWEL) > 0 || (flags & DIPTHONG) > 0 || (randnum.number(10) > 3)) {           shouldBe=CONSONANT          }  else {           shouldBe=VOWEL          }       }       prev=flags        first=false      }   }  while ((featureFlags & (pwgen.UPPERS | pwgen.DIGITS | pwgen.SYMBOLS)) > 0)    return password  } 
/**   * Generates a completely random password.  * @param size    length of password to generate  * @param pwFlags flag field where set bits indicate conditions thegenerated password must meet <table summary ="bits of flag field"> <tr><td>Bit</td><td>Condition</td></tr> <tr><td>0</td><td>include at least one number</td></tr> <tr><td>1</td><td>include at least one uppercase letter</td></tr> <tr><td>2</td><td>include at least one symbol</td></tr> <tr><td>3</td><td>don't include ambiguous characters</td></tr> <tr><td>4</td><td>don't include vowels</td></tr> </table>  * @return the generated password  */ public static String rand(int size,int pwFlags){   String password    char cha    int i, featureFlags, num    String val    String bank=""    if ((pwFlags & pwgen.DIGITS) > 0) {     bank+=pwgen.DIGITS_STR    }   if ((pwFlags & pwgen.UPPERS) > 0) {     bank+=pwgen.UPPERS_STR    }   bank+=pwgen.LOWERS_STR    if ((pwFlags & pwgen.SYMBOLS) > 0) {     bank+=pwgen.SYMBOLS_STR    }   do {     password=""      featureFlags=pwFlags      i=0      while (i < size) {       num=randnum.number(bank.length())        cha=bank.toCharArray()[num]        val=String.valueOf(cha)        if ((pwFlags & pwgen.AMBIGUOUS) > 0 && pwgen.AMBIGUOUS_STR.contains(val)) {         continue        }       if ((pwFlags & pwgen.NO_VOWELS) > 0 && pwgen.VOWELS_STR.contains(val)) {         continue        }       password+=val        i++        if (pwgen.DIGITS_STR.contains(val)) {         featureFlags&=~pwgen.DIGITS        }       if (pwgen.UPPERS_STR.contains(val)) {         featureFlags&=~pwgen.UPPERS        }       if (pwgen.SYMBOLS_STR.contains(val)) {         featureFlags&=~pwgen.SYMBOLS        }     }   }  while ((featureFlags & (pwgen.UPPERS | pwgen.DIGITS | pwgen.SYMBOLS)) > 0)    return password  } 
/**   * Generate a random number n, where 0 &lt = n &lt  maxNum.  * @param maxNum the bound on the random number to be returned  * @return the generated random number  */ public static int number(int maxNum){   return random.nextInt(maxNum)  } 
public pwgenDialogFragment(){ } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   AlertDialog.Builder builder=new AlertDialog.Builder(getActivity())    final Activity callingActivity=getActivity()    LayoutInflater inflater=callingActivity.getLayoutInflater()    final View view=inflater.inflate(R.layout.fragment_pwgen,null)    Typeface monoTypeface=Typeface.createFromAsset(callingActivity.getAssets(),"fonts/sourcecodepro.ttf")    builder.setView(view)    SharedPreferences prefs=getActivity().getApplicationContext().getSharedPreferences("pwgen",Context.MODE_PRIVATE)    CheckBox checkBox=(CheckBox)view.findViewById(R.id.numerals)    checkBox.setChecked(!prefs.getBoolean("0",false))    checkBox=(CheckBox)view.findViewById(R.id.symbols)    checkBox.setChecked(prefs.getBoolean("y",false))    checkBox=(CheckBox)view.findViewById(R.id.uppercase)    checkBox.setChecked(!prefs.getBoolean("A",false))    checkBox=(CheckBox)view.findViewById(R.id.ambiguous)    checkBox.setChecked(!prefs.getBoolean("B",false))    checkBox=(CheckBox)view.findViewById(R.id.pronounceable)    checkBox.setChecked(!prefs.getBoolean("s",true))    TextView textView=(TextView)view.findViewById(R.id.lengthNumber)    textView.setText(Integer.toString(prefs.getInt("length",20)))    ((TextView)view.findViewById(R.id.passwordText)).setTypeface(monoTypeface)    builder.setPositiveButton(getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       EditText edit=(EditText)callingActivity.findViewById(R.id.crypto_password_edit)        TextView generate=(TextView)view.findViewById(R.id.passwordText)        edit.append(generate.getText())      }   } )    builder.setNegativeButton(getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){     }   } )    builder.setNeutralButton(getResources().getString(R.string.pwgen_generate),null)    final AlertDialog ad=builder.setTitle("Generate Password").create()    ad.setOnShowListener(new DialogInterface.OnShowListener(){     @Override public void onShow(    DialogInterface dialog){       setPreferences()        TextView textView=(TextView)view.findViewById(R.id.passwordText)        textView.setText(pwgen.generate(getActivity().getApplicationContext()).get(0))        Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL)        b.setOnClickListener(new View.OnClickListener(){         @Override public void onClick(        View v){           setPreferences()            TextView textView=(TextView)view.findViewById(R.id.passwordText)            textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0))          }       } )      }   } )    return ad  } 
@Override public void onClick(DialogInterface dialog,int which){   EditText edit=(EditText)callingActivity.findViewById(R.id.crypto_password_edit)    TextView generate=(TextView)view.findViewById(R.id.passwordText)    edit.append(generate.getText())  } 
@Override public void onClick(DialogInterface dialog,int which){ } 
@Override public void onShow(DialogInterface dialog){   setPreferences()    TextView textView=(TextView)view.findViewById(R.id.passwordText)    textView.setText(pwgen.generate(getActivity().getApplicationContext()).get(0))    Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL)    b.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       setPreferences()        TextView textView=(TextView)view.findViewById(R.id.passwordText)        textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0))      }   } )  } 
@Override public void onClick(View v){   setPreferences()    TextView textView=(TextView)view.findViewById(R.id.passwordText)    textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0))  } 
private boolean setPreferences(){   ArrayList<String> preferences=new ArrayList<>()    if (!((CheckBox)getDialog().findViewById(R.id.numerals)).isChecked()) {     preferences.add("0")    }   if (((CheckBox)getDialog().findViewById(R.id.symbols)).isChecked()) {     preferences.add("y")    }   if (!((CheckBox)getDialog().findViewById(R.id.uppercase)).isChecked()) {     preferences.add("A")    }   if (!((CheckBox)getDialog().findViewById(R.id.ambiguous)).isChecked()) {     preferences.add("B")    }   if (!((CheckBox)getDialog().findViewById(R.id.pronounceable)).isChecked()) {     preferences.add("s")    }   EditText editText=(EditText)getDialog().findViewById(R.id.lengthNumber)    try {     int length=Integer.valueOf(editText.getText().toString())      return pwgen.setPrefs(getActivity().getApplicationContext(),preferences,length)    }  catch (  NumberFormatException e) {     return pwgen.setPrefs(getActivity().getApplicationContext(),preferences)    } } 
public void onFragmentInteraction(PasswordItem item)  
/**   * Mandatory empty constructor for the fragment manager to instantiate the fragment (e.g. upon screen orientation changes).  */ public SelectFolderFragment(){ } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    String path=getArguments().getString("Path")    settings=PreferenceManager.getDefaultSharedPreferences(getActivity())    passListStack=new Stack<ArrayList<PasswordItem>>()    scrollPosition=new Stack<Integer>()    pathStack=new Stack<File>()    recyclerAdapter=new FolderRecyclerAdapter((PgpHandler)getActivity(),mListener,PasswordRepository.getPasswords(new File(path),PasswordRepository.getRepositoryDirectory(getActivity())))  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   View view=inflater.inflate(R.layout.password_recycler_view,container,false)    mLayoutManager=new LinearLayoutManager(getActivity())    recyclerView=(RecyclerView)view.findViewById(R.id.pass_recycler)    recyclerView.setLayoutManager(mLayoutManager)    recyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),R.drawable.divider))    recyclerView.setAdapter(recyclerAdapter)    final FloatingActionButton fab=(FloatingActionButton)view.findViewById(R.id.fab)    fab.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       ((PasswordStore)getActivity()).createPassword()      }   } )    registerForContextMenu(recyclerView)    return view  } 
@Override public void onClick(View v){   ((PasswordStore)getActivity()).createPassword()  } 
@Override public void onAttach(final Context context){   super.onAttach(context)    try {     mListener=new OnFragmentInteractionListener(){       public void onFragmentInteraction(      PasswordItem item){         if (item.getType() == PasswordItem.TYPE_CATEGORY) {           passListStack.push(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(context)) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(context)))            pathStack.push(item.getFile())            scrollPosition.push(recyclerView.getVerticalScrollbarPosition())            recyclerView.scrollToPosition(0)            recyclerAdapter.clear()            recyclerAdapter.addAll(PasswordRepository.getPasswords(item.getFile(),PasswordRepository.getRepositoryDirectory(context)))            ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(true)          }       }       public void savePosition(      Integer position){       }     }     }  catch (  ClassCastException e) {     throw new ClassCastException(context.toString() + " must implement OnFragmentInteractionListener")    } } 
public void onFragmentInteraction(PasswordItem item){   if (item.getType() == PasswordItem.TYPE_CATEGORY) {     passListStack.push(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(context)) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(context)))      pathStack.push(item.getFile())      scrollPosition.push(recyclerView.getVerticalScrollbarPosition())      recyclerView.scrollToPosition(0)      recyclerAdapter.clear()      recyclerAdapter.addAll(PasswordRepository.getPasswords(item.getFile(),PasswordRepository.getRepositoryDirectory(context)))      ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(true)    } } 
public void savePosition(Integer position){ } 
@Override public void onPause(){   super.onPause()  } 
/**   * clears the adapter content and sets it back to the root view  */ public void updateAdapter(){   passListStack.clear()    pathStack.clear()    scrollPosition.clear()    recyclerAdapter.clear()    recyclerAdapter.addAll(PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())))    ((AppCompatActivity)getActivity()).getSupportActionBar().setDisplayHomeAsUpEnabled(false)  } 
/**   * refreshes the adapter with the latest opened category  */ public void refreshAdapter(){   recyclerAdapter.clear()    recyclerAdapter.addAll(pathStack.isEmpty() ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())) : PasswordRepository.getPasswords(pathStack.peek(),PasswordRepository.getRepositoryDirectory(getActivity())))  } 
/**   * filters the list adapter  * @param filter the filter to apply  */ public void filterAdapter(String filter){   Log.d("FRAG","filter: " + filter)    if (filter.isEmpty()) {     refreshAdapter()    }  else {     recursiveFilter(filter,pathStack.isEmpty() ? null : pathStack.peek())    } } 
/**   * recursively filters a directory and extract all the matching items  * @param filter the filter to apply  * @param dir the directory to filter  */ private void recursiveFilter(String filter,File dir){   ArrayList<PasswordItem> passwordItems=dir == null ? PasswordRepository.getPasswords(PasswordRepository.getRepositoryDirectory(getActivity())) : PasswordRepository.getPasswords(dir,PasswordRepository.getRepositoryDirectory(getActivity()))    boolean rec=settings.getBoolean("filter_recursively",true)    for (  PasswordItem item : passwordItems) {     if (item.getType() == PasswordItem.TYPE_CATEGORY && rec) {       recursiveFilter(filter,item.getFile())      }     boolean matches=item.toString().toLowerCase().contains(filter.toLowerCase())      boolean inAdapter=recyclerAdapter.getValues().contains(item)      if (matches && !inAdapter) {       recyclerAdapter.add(item)      }  else     if (!matches && inAdapter) {       recyclerAdapter.remove(recyclerAdapter.getValues().indexOf(item))      }   } } 
/**   * Goes back one level back in the path  */ public void popBack(){   if (passListStack.isEmpty())   return    recyclerView.scrollToPosition(scrollPosition.pop())    recyclerAdapter.clear()    recyclerAdapter.addAll(passListStack.pop())    pathStack.pop()  } 
/**   * gets the current directory  * @return the current directory  */ public File getCurrentDir(){   if (pathStack.isEmpty())   return PasswordRepository.getRepositoryDirectory(getActivity().getApplicationContext())   else   return pathStack.peek()  } 
public boolean isNotEmpty(){   return !passListStack.isEmpty()  } 
public SshKeyGenFragment(){ } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   final View v=inflater.inflate(R.layout.fragment_ssh_keygen,container,false)    Typeface monoTypeface=Typeface.createFromAsset(getActivity().getAssets(),"fonts/sourcecodepro.ttf")    Spinner spinner=(Spinner)v.findViewById(R.id.length)    Integer[] lengths=new Integer[]{2048,4096}    ArrayAdapter<Integer> adapter=new ArrayAdapter<>(getActivity(),android.R.layout.simple_spinner_dropdown_item,lengths)    spinner.setAdapter(adapter)    ((EditText)v.findViewById(R.id.passphrase)).setTypeface(monoTypeface)    CheckBox checkbox=(CheckBox)v.findViewById(R.id.show_passphrase)    checkbox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){     @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){       EditText editText=(EditText)v.findViewById(R.id.passphrase)        int selection=editText.getSelectionEnd()        if (isChecked) {         editText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD)        }  else {         editText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)        }       editText.setSelection(selection)      }   } )    return v  } 
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){   EditText editText=(EditText)v.findViewById(R.id.passphrase)    int selection=editText.getSelectionEnd()    if (isChecked) {     editText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD)    }  else {     editText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD)    }   editText.setSelection(selection)  } 
public ShowSshKeyFragment(){ } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   AlertDialog.Builder builder=new AlertDialog.Builder(getActivity())    LayoutInflater inflater=getActivity().getLayoutInflater()    final View v=inflater.inflate(R.layout.fragment_show_ssh_key,null)    builder.setView(v)    TextView textView=(TextView)v.findViewById(R.id.public_key)    File file=new File(getActivity().getFilesDir() + "/.ssh_key.pub")    try {     textView.setText(FileUtils.readFileToString(file))    }  catch (  Exception e) {     System.out.println("Exception caught :(")      e.printStackTrace()    }   builder.setPositiveButton(getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       if (getActivity() instanceof SshKeyGen)       getActivity().finish()      }   } )    builder.setNegativeButton(getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){     }   } )    builder.setNeutralButton(getResources().getString(R.string.ssh_keygen_copy),null)    final AlertDialog ad=builder.setTitle("Your public key").create()    ad.setOnShowListener(new DialogInterface.OnShowListener(){     @Override public void onShow(    DialogInterface dialog){       Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL)        b.setOnClickListener(new View.OnClickListener(){         @Override public void onClick(        View v){           TextView textView=(TextView)getDialog().findViewById(R.id.public_key)            ClipboardManager clipboard=(ClipboardManager)getActivity().getSystemService(Context.CLIPBOARD_SERVICE)            ClipData clip=ClipData.newPlainText("public key",textView.getText().toString())            clipboard.setPrimaryClip(clip)          }       } )      }   } )    return ad  } 
@Override public void onClick(DialogInterface dialog,int which){   if (getActivity() instanceof SshKeyGen)   getActivity().finish()  } 
@Override public void onClick(DialogInterface dialog,int which){ } 
@Override public void onShow(DialogInterface dialog){   Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL)    b.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       TextView textView=(TextView)getDialog().findViewById(R.id.public_key)        ClipboardManager clipboard=(ClipboardManager)getActivity().getSystemService(Context.CLIPBOARD_SERVICE)        ClipData clip=ClipData.newPlainText("public key",textView.getText().toString())        clipboard.setPrimaryClip(clip)      }   } )  } 
@Override public void onClick(View v){   TextView textView=(TextView)getDialog().findViewById(R.id.public_key)    ClipboardManager clipboard=(ClipboardManager)getActivity().getSystemService(Context.CLIPBOARD_SERVICE)    ClipData clip=ClipData.newPlainText("public key",textView.getText().toString())    clipboard.setPrimaryClip(clip)  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    if (getSupportActionBar() != null)   getSupportActionBar().setDisplayHomeAsUpEnabled(true)    setTitle("Generate SSH Key")    if (savedInstanceState == null) {     getFragmentManager().beginTransaction().replace(android.R.id.content,new SshKeyGenFragment()).commit()    } } 
@Override protected void onPreExecute(){   super.onPreExecute()    pd=ProgressDialog.show(SshKeyGen.this,"","Generating keys")  } 
protected Exception doInBackground(String... strings){   int length=Integer.parseInt(strings[0])    String passphrase=strings[1]    String comment=strings[2]    JSch jsch=new JSch()    try {     KeyPair kp=KeyPair.genKeyPair(jsch,KeyPair.RSA,length)      File file=new File(getFilesDir() + "/.ssh_key")      FileOutputStream out=new FileOutputStream(file,false)      if (passphrase.length() > 0) {       kp.writePrivateKey(out,passphrase.getBytes())      }  else {       kp.writePrivateKey(out)      }     file=new File(getFilesDir() + "/.ssh_key.pub")      out=new FileOutputStream(file,false)      kp.writePublicKey(out,comment)      return null    }  catch (  Exception e) {     System.out.println("Exception caught :(")      e.printStackTrace()      return e    } } 
@Override protected void onPostExecute(Exception e){   super.onPostExecute(e)    pd.dismiss()    if (e == null) {     Toast.makeText(SshKeyGen.this,"SSH-key generated",Toast.LENGTH_LONG).show()      DialogFragment df=new ShowSshKeyFragment()      df.show(getFragmentManager(),"public_key")      SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(getApplicationContext())      SharedPreferences.Editor editor=prefs.edit()      editor.putBoolean("use_generated_key",true)      editor.apply()    }  else {     new AlertDialog.Builder(SshKeyGen.this).setTitle("Error while trying to generate the ssh-key").setMessage(getResources().getString(R.string.ssh_key_error_dialog_text) + e.getMessage()).setPositiveButton(getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialogInterface,      int i){       }     } ).show()    } } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
public void generate(View view){   String length=Integer.toString((Integer)((Spinner)findViewById(R.id.length)).getSelectedItem())    String passphrase=((EditText)findViewById(R.id.passphrase)).getText().toString()    String comment=((EditText)findViewById(R.id.comment)).getText().toString()    new generateTask().execute(length,passphrase,comment)    InputMethodManager imm=(InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE)    imm.hideSoftInputFromWindow(view.getWindowToken(),0)  } 
public ToCloneOrNot(){ } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_to_clone_or_not,container,false)  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    final UserPreference callingActivity=(UserPreference)getActivity()    final SharedPreferences sharedPreferences=getPreferenceManager().getSharedPreferences()    addPreferencesFromResource(R.xml.preference)    findPreference("openpgp_key_id_pref").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       Intent intent=new Intent(callingActivity,PgpHandler.class)        intent.putExtra("Operation","GET_KEY_ID")        startActivityForResult(intent,IMPORT_PGP_KEY)        return true      }   } )    findPreference("ssh_key").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       callingActivity.getSshKeyWithPermissions()        return true      }   } )    findPreference("ssh_keygen").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       callingActivity.makeSshKey(true)        return true      }   } )    findPreference("ssh_see_key").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       DialogFragment df=new SshKeyGen.ShowSshKeyFragment()        df.show(getFragmentManager(),"public_key")        return true      }   } )    findPreference("git_server_info").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       Intent intent=new Intent(callingActivity,GitActivity.class)        intent.putExtra("Operation",GitActivity.EDIT_SERVER)        startActivityForResult(intent,EDIT_GIT_INFO)        return true      }   } )    findPreference("git_delete_repo").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       new AlertDialog.Builder(callingActivity).setTitle(R.string.pref_dialog_delete_title).setMessage(getResources().getString(R.string.dialog_delete_msg) + " \n" + PasswordRepository.getRepositoryDirectory(callingActivity.getApplicationContext()).toString()).setCancelable(false).setPositiveButton(R.string.dialog_delete,new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialogInterface,        int i){           try {             FileUtils.cleanDirectory(PasswordRepository.getRepositoryDirectory(callingActivity.getApplicationContext()))              PasswordRepository.closeRepository()            }  catch (          Exception e) {           }           sharedPreferences.edit().putBoolean("repository_initialized",false).apply()            dialogInterface.cancel()            callingActivity.finish()          }       } ).setNegativeButton(R.string.dialog_do_not_delete,new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialogInterface,        int i){ {             dialogInterface.cancel()            }         }       } ).show()        return true      }   } )    final Preference externalRepo=findPreference("pref_select_external")    externalRepo.setSummary(getPreferenceManager().getSharedPreferences().getString("git_external_repo",callingActivity.getString(R.string.no_repo_selected)))    externalRepo.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       callingActivity.selectExternalGitRepository()        return true      }   } )    Preference.OnPreferenceChangeListener resetRepo=new Preference.OnPreferenceChangeListener(){     @Override public boolean onPreferenceChange(    Preference preference,    Object o){       findPreference("git_delete_repo").setEnabled(!(Boolean)o)        PasswordRepository.closeRepository()        getPreferenceManager().getSharedPreferences().edit().putBoolean("repo_changed",true).apply()        return true      }   }     findPreference("pref_select_external").setOnPreferenceChangeListener(resetRepo)    findPreference("git_external").setOnPreferenceChangeListener(resetRepo)    findPreference("autofill_apps").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       Intent intent=new Intent(callingActivity,AutofillPreferenceActivity.class)        startActivity(intent)        return true      }   } )    findPreference("autofill_enable").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       new AlertDialog.Builder(callingActivity).setTitle(R.string.pref_autofill_enable_title).setView(R.layout.autofill_instructions).setPositiveButton(R.string.dialog_ok,new DialogInterface.OnClickListener(){         @Override public void onClick(        DialogInterface dialog,        int which){           Intent intent=new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)            startActivity(intent)          }       } ).setNegativeButton(R.string.dialog_cancel,null).setOnDismissListener(new DialogInterface.OnDismissListener(){         @Override public void onDismiss(        DialogInterface dialog){           ((CheckBoxPreference)findPreference("autofill_enable")).setChecked(((UserPreference)getActivity()).isServiceEnabled())          }       } ).show()        return true      }   } )    findPreference("export_passwords").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){     @Override public boolean onPreferenceClick(    Preference preference){       callingActivity.exportPasswordsWithPermissions()        return true      }   } )  } 
@Override public boolean onPreferenceClick(Preference preference){   Intent intent=new Intent(callingActivity,PgpHandler.class)    intent.putExtra("Operation","GET_KEY_ID")    startActivityForResult(intent,IMPORT_PGP_KEY)    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   callingActivity.getSshKeyWithPermissions()    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   callingActivity.makeSshKey(true)    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   DialogFragment df=new SshKeyGen.ShowSshKeyFragment()    df.show(getFragmentManager(),"public_key")    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   Intent intent=new Intent(callingActivity,GitActivity.class)    intent.putExtra("Operation",GitActivity.EDIT_SERVER)    startActivityForResult(intent,EDIT_GIT_INFO)    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   new AlertDialog.Builder(callingActivity).setTitle(R.string.pref_dialog_delete_title).setMessage(getResources().getString(R.string.dialog_delete_msg) + " \n" + PasswordRepository.getRepositoryDirectory(callingActivity.getApplicationContext()).toString()).setCancelable(false).setPositiveButton(R.string.dialog_delete,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       try {         FileUtils.cleanDirectory(PasswordRepository.getRepositoryDirectory(callingActivity.getApplicationContext()))          PasswordRepository.closeRepository()        }  catch (      Exception e) {       }       sharedPreferences.edit().putBoolean("repository_initialized",false).apply()        dialogInterface.cancel()        callingActivity.finish()      }   } ).setNegativeButton(R.string.dialog_do_not_delete,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){ {         dialogInterface.cancel()        }     }   } ).show()    return true  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   try {     FileUtils.cleanDirectory(PasswordRepository.getRepositoryDirectory(callingActivity.getApplicationContext()))      PasswordRepository.closeRepository()    }  catch (  Exception e) {   }   sharedPreferences.edit().putBoolean("repository_initialized",false).apply()    dialogInterface.cancel()    callingActivity.finish()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){ {     dialogInterface.cancel()    } } 
@Override public boolean onPreferenceClick(Preference preference){   callingActivity.selectExternalGitRepository()    return true  } 
@Override public boolean onPreferenceChange(Preference preference,Object o){   findPreference("git_delete_repo").setEnabled(!(Boolean)o)    PasswordRepository.closeRepository()    getPreferenceManager().getSharedPreferences().edit().putBoolean("repo_changed",true).apply()    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   Intent intent=new Intent(callingActivity,AutofillPreferenceActivity.class)    startActivity(intent)    return true  } 
@Override public boolean onPreferenceClick(Preference preference){   new AlertDialog.Builder(callingActivity).setTitle(R.string.pref_autofill_enable_title).setView(R.layout.autofill_instructions).setPositiveButton(R.string.dialog_ok,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       Intent intent=new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)        startActivity(intent)      }   } ).setNegativeButton(R.string.dialog_cancel,null).setOnDismissListener(new DialogInterface.OnDismissListener(){     @Override public void onDismiss(    DialogInterface dialog){       ((CheckBoxPreference)findPreference("autofill_enable")).setChecked(((UserPreference)getActivity()).isServiceEnabled())      }   } ).show()    return true  } 
@Override public void onClick(DialogInterface dialog,int which){   Intent intent=new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)    startActivity(intent)  } 
@Override public void onDismiss(DialogInterface dialog){   ((CheckBoxPreference)findPreference("autofill_enable")).setChecked(((UserPreference)getActivity()).isServiceEnabled())  } 
@Override public boolean onPreferenceClick(Preference preference){   callingActivity.exportPasswordsWithPermissions()    return true  } 
@Override public void onStart(){   super.onStart()    final SharedPreferences sharedPreferences=getPreferenceManager().getSharedPreferences()    findPreference("pref_select_external").setSummary(getPreferenceManager().getSharedPreferences().getString("git_external_repo",getString(R.string.no_repo_selected)))    findPreference("ssh_see_key").setEnabled(sharedPreferences.getBoolean("use_generated_key",false))    findPreference("git_delete_repo").setEnabled(!sharedPreferences.getBoolean("git_external",false))    Preference keyPref=findPreference("openpgp_key_id_pref")    Set<String> selectedKeys=sharedPreferences.getStringSet("openpgp_key_ids_set",new HashSet<String>())    if (selectedKeys.isEmpty()) {     keyPref.setSummary("No key selected")    }  else {     keyPref.setSummary(Joiner.on(',').join(Iterables.transform(selectedKeys,new Function<String,Object>(){       @Override public Object apply(      String input){         return OpenPgpUtils.convertKeyIdToHex(Long.valueOf(input))        }     } )))    }   ((CheckBoxPreference)findPreference("autofill_enable")).setChecked(((UserPreference)getActivity()).isServiceEnabled())  } 
@Override public Object apply(String input){   return OpenPgpUtils.convertKeyIdToHex(Long.valueOf(input))  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    if (getIntent() != null) {     if (getIntent().getStringExtra("operation") != null) { switch (getIntent().getStringExtra("operation")) { case "get_ssh_key":         getSshKeyWithPermissions()        break  case "make_ssh_key":     makeSshKey(false)    break  case "git_external": selectExternalGitRepository()  break  } } } prefsFragment=new PrefsFragment()  getFragmentManager().beginTransaction().replace(android.R.id.content,prefsFragment).commit()  getSupportActionBar().setDisplayHomeAsUpEnabled(true)  } 
public void selectExternalGitRepository(){   final Activity activity=this    new AlertDialog.Builder(this).setTitle("Choose where to store the passwords").setMessage("You must select a directory where to store your passwords. If you want " + "to store your passwords within the hidden storage of the application, " + "cancel this dialog and disable the \"External Repository\" option.").setPositiveButton(R.string.dialog_ok,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       Intent i=new Intent(activity.getApplicationContext(),FilePickerActivity.class)        i.putExtra(FilePickerActivity.EXTRA_ALLOW_MULTIPLE,false)        i.putExtra(FilePickerActivity.EXTRA_ALLOW_CREATE_DIR,true)        i.putExtra(FilePickerActivity.EXTRA_MODE,FilePickerActivity.MODE_DIR)        i.putExtra(FilePickerActivity.EXTRA_START_PATH,Environment.getExternalStorageDirectory().getPath())        startActivityForResult(i,SELECT_GIT_DIRECTORY)      }   } ).setNegativeButton(R.string.dialog_cancel,null).show()  } 
@Override public void onClick(DialogInterface dialog,int which){   Intent i=new Intent(activity.getApplicationContext(),FilePickerActivity.class)    i.putExtra(FilePickerActivity.EXTRA_ALLOW_MULTIPLE,false)    i.putExtra(FilePickerActivity.EXTRA_ALLOW_CREATE_DIR,true)    i.putExtra(FilePickerActivity.EXTRA_MODE,FilePickerActivity.MODE_DIR)    i.putExtra(FilePickerActivity.EXTRA_START_PATH,Environment.getExternalStorageDirectory().getPath())    startActivityForResult(i,SELECT_GIT_DIRECTORY)  } 
@Override public boolean onOptionsItemSelected(MenuItem item){   int id=item.getItemId()  switch (id) { case android.R.id.home:     setResult(RESULT_OK)    finish()  return true  } return super.onOptionsItemSelected(item)  } 
/**   * Opens a file explorer to import the private key  */ public void getSshKeyWithPermissions(){   final Activity activity=this    if (ContextCompat.checkSelfPermission(activity,Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {     if (ActivityCompat.shouldShowRequestPermissionRationale(activity,Manifest.permission.READ_EXTERNAL_STORAGE)) {       Snackbar snack=Snackbar.make(prefsFragment.getView(),"We need access to the sd-card to import the ssh-key",Snackbar.LENGTH_INDEFINITE).setAction(R.string.dialog_ok,new View.OnClickListener(){         @Override public void onClick(        View view){           ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)          }       } )        snack.show()        View view=snack.getView()        TextView tv=(TextView)view.findViewById(android.support.design.R.id.snackbar_text)        tv.setTextColor(Color.WHITE)        tv.setMaxLines(10)      }  else {       ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)      }   }  else {     getSshKey()    } } 
@Override public void onClick(View view){   ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)  } 
/**   * Opens a file explorer to import the private key  */ public void getSshKey(){   Intent i=new Intent(getApplicationContext(),FilePickerActivity.class)    i.putExtra(FilePickerActivity.EXTRA_ALLOW_MULTIPLE,false)    i.putExtra(FilePickerActivity.EXTRA_ALLOW_CREATE_DIR,false)    i.putExtra(FilePickerActivity.EXTRA_MODE,FilePickerActivity.MODE_FILE)    i.putExtra(FilePickerActivity.EXTRA_START_PATH,Environment.getExternalStorageDirectory().getPath())    startActivityForResult(i,IMPORT_SSH_KEY)  } 
public void exportPasswordsWithPermissions(){   final Activity activity=this    if (ContextCompat.checkSelfPermission(activity,Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {     if (ActivityCompat.shouldShowRequestPermissionRationale(activity,Manifest.permission.WRITE_EXTERNAL_STORAGE)) {       Snackbar snack=Snackbar.make(prefsFragment.getView(),"We need access to the sd-card to export the passwords",Snackbar.LENGTH_INDEFINITE).setAction(R.string.dialog_ok,new View.OnClickListener(){         @Override public void onClick(        View view){           ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)          }       } )        snack.show()        View view=snack.getView()        TextView tv=(TextView)view.findViewById(android.support.design.R.id.snackbar_text)        tv.setTextColor(Color.WHITE)        tv.setMaxLines(10)      }  else {       ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)      }   }  else {     Intent i=new Intent(getApplicationContext(),FilePickerActivity.class)      i.putExtra(FilePickerActivity.EXTRA_ALLOW_MULTIPLE,false)      i.putExtra(FilePickerActivity.EXTRA_ALLOW_CREATE_DIR,true)      i.putExtra(FilePickerActivity.EXTRA_MODE,FilePickerActivity.MODE_DIR)      i.putExtra(FilePickerActivity.EXTRA_START_PATH,Environment.getExternalStorageDirectory().getPath())      startActivityForResult(i,EXPORT_PASSWORDS)    } } 
@Override public void onClick(View view){   ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_EXTERNAL_STORAGE)  } 
/**   * Opens a key generator to generate a public/private key pair  */ public void makeSshKey(boolean fromPreferences){   Intent intent=new Intent(getApplicationContext(),SshKeyGen.class)    startActivity(intent)    if (!fromPreferences) {     setResult(RESULT_OK)      finish()    } } 
private void copySshKey(Uri uri) throws IOException {   InputStream sshKey=this.getContentResolver().openInputStream(uri)    byte[] privateKey=IOUtils.toByteArray(sshKey)    FileUtils.writeByteArrayToFile(new File(getFilesDir() + "/.ssh_key"),privateKey)    sshKey.close()  } 
private boolean isServiceEnabled(){   AccessibilityManager am=(AccessibilityManager)this.getSystemService(Context.ACCESSIBILITY_SERVICE)    List<AccessibilityServiceInfo> runningServices=am.getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_GENERIC)    for (  AccessibilityServiceInfo service : runningServices) {     if ("com.zeapo.pwdstore/.autofill.AutofillService".equals(service.getId())) {       return true      }   }   return false  } 
protected void onActivityResult(int requestCode,int resultCode,Intent data){   if (resultCode == RESULT_OK) { switch (requestCode) { case IMPORT_SSH_KEY: {         try {           final Uri uri=data.getData()            if (uri == null) {             throw new IOException("Unable to open file")            }           copySshKey(uri)            Toast.makeText(this,this.getResources().getString(R.string.ssh_key_success_dialog_title),Toast.LENGTH_LONG).show()            SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(getApplicationContext())            SharedPreferences.Editor editor=prefs.edit()            editor.putBoolean("use_generated_key",false)            editor.apply()            File file=new File(getFilesDir() + "/.ssh_key.pub")            file.delete()            setResult(RESULT_OK)            finish()          }  catch (        IOException e) {           new AlertDialog.Builder(this).setTitle(this.getResources().getString(R.string.ssh_key_error_dialog_title)).setMessage(this.getResources().getString(R.string.ssh_key_error_dialog_text) + e.getMessage()).setPositiveButton(this.getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){             @Override public void onClick(            DialogInterface dialogInterface,            int i){             }           } ).show()          }       }     break  case EDIT_GIT_INFO: {   } break  case SELECT_GIT_DIRECTORY: { final Uri uri=data.getData()  if (uri.getPath().equals(Environment.getExternalStorageDirectory().getPath())) {   new AlertDialog.Builder(this).setTitle("SD-Card root selected").setMessage("You have selected the root of your sdcard for the store. " + "This is extremely dangerous and you will lose your data " + "as its content will, eventually, be deleted").setPositiveButton("Remove everything",new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit().putString("git_external_repo",uri.getPath()).apply()      }   } ).setNegativeButton(R.string.dialog_cancel,null).show()  }  else {   PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit().putString("git_external_repo",uri.getPath()).apply()  } } break  case EXPORT_PASSWORDS: { final Uri uri=data.getData()  final File repositoryDirectory=PasswordRepository.getRepositoryDirectory(getApplicationContext())  SimpleDateFormat fmtOut=new SimpleDateFormat("yyyy_MM_dd_HH_mm_ss",Locale.US)  Date date=new Date()  String password_now="/password_store_" + fmtOut.format(date)  final File targetDirectory=new File(uri.getPath() + password_now)  if (repositoryDirectory != null) { try { FileUtils.copyDirectory(repositoryDirectory,targetDirectory,true)  }  catch (IOException e) { Log.d("PWD_EXPORT","Exception happened : " + e.getMessage())  } } } break  default : break  } } } 
@Override public void onClick(DialogInterface dialogInterface,int i){ } 
@Override public void onClick(DialogInterface dialog,int which){   PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit().putString("git_external_repo",uri.getPath()).apply()  } 
@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){ switch (requestCode) { case REQUEST_EXTERNAL_STORAGE: {       if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {         getSshKey()        }     } } } 
public EntryRecyclerAdapter(Activity activity,ArrayList<PasswordItem> values){   this.activity=activity    this.values=values  } 
@Override public int getItemCount(){   return values.size()  } 
public ArrayList<PasswordItem> getValues(){   return this.values  } 
public void clear(){   this.values.clear()    this.notifyDataSetChanged()  } 
public void addAll(ArrayList<PasswordItem> list){   this.values.addAll(list)    this.notifyDataSetChanged()  } 
public void add(PasswordItem item){   this.values.add(item)    this.notifyItemInserted(getItemCount())  } 
public void toggleSelection(int position){   if (!selectedItems.remove(position)) {     selectedItems.add(position)    } } 
public void updateSelectedItems(int position,Set<Integer> selectedItems){   Set<Integer> temp=new TreeSet<>()    for (  int selected : selectedItems) {     if (selected > position) {       temp.add(selected - 1)      }  else {       temp.add(selected)      }   }   selectedItems.clear()    selectedItems.addAll(temp)  } 
public void remove(int position){   this.values.remove(position)    this.notifyItemRemoved(position)    updateSelectedItems(position,selectedItems)  } 
@NonNull protected View.OnLongClickListener getOnLongClickListener(ViewHolder holder,PasswordItem pass){   return new View.OnLongClickListener(){     @Override public boolean onLongClick(    View v){       return false      }   }   } 
@Override public boolean onLongClick(View v){   return false  } 
@Override public void onBindViewHolder(final ViewHolder holder,int position){   final PasswordItem pass=getValues().get(position)    holder.name.setText(pass.toString())    if (pass.getType() == PasswordItem.TYPE_CATEGORY) {     holder.typeImage.setImageResource(R.drawable.ic_folder_grey600_24dp)      holder.name.setText(pass.toString() + "/")    }  else {     holder.typeImage.setImageResource(R.drawable.ic_action_secure)      holder.name.setText(pass.toString())    }   holder.type.setText(pass.getFullPathToParent())    if (pass.getType() == PasswordItem.TYPE_CATEGORY) {   }  else {   }   holder.view.setOnClickListener(getOnClickListener(holder,pass))    holder.view.setOnLongClickListener(getOnLongClickListener(holder,pass))    boolean selected=selectedItems.contains(position)    holder.view.setSelected(selected)    if (selected) {     holder.itemView.setBackgroundResource(R.color.deep_orange_200)      holder.type.setTextColor(Color.BLACK)    }  else {     holder.itemView.setBackgroundResource(Color.alpha(1))      holder.type.setTextColor(ContextCompat.getColor(activity,R.color.grey_500))    } } 
@NonNull protected abstract View.OnClickListener getOnClickListener(ViewHolder holder,PasswordItem pass)  
public ViewHolder(View v){   super(v)    view=v    name=(TextView)view.findViewById(R.id.label)    type=(TextView)view.findViewById(R.id.type)    typeImage=(ImageView)view.findViewById(R.id.type_image)  } 
@Override public PasswordRecyclerAdapter.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){   View v=LayoutInflater.from(parent.getContext()).inflate(R.layout.password_row_layout,parent,false)    return new ViewHolder(v)  } 
public FolderRecyclerAdapter(PgpHandler activity,SelectFolderFragment.OnFragmentInteractionListener listener,ArrayList<PasswordItem> values){   super(activity,values)    this.listener=listener  } 
@NonNull protected View.OnClickListener getOnClickListener(final ViewHolder holder,final PasswordItem pass){   return new View.OnClickListener(){     @Override public void onClick(    View v){       listener.onFragmentInteraction(pass)        notifyItemChanged(holder.getAdapterPosition())      }   }   } 
@Override public void onClick(View v){   listener.onFragmentInteraction(pass)    notifyItemChanged(holder.getAdapterPosition())  } 
/**   * Create a password item Make it protected so that we use a builder  * @param name  * @param parent  * @param type  */ protected PasswordItem(String name,PasswordItem parent,char type,File file,File rootDir){   this.name=name    this.parent=parent    this.type=type    this.file=file    this.fullPathToParent=file.getAbsolutePath().replace(rootDir.getAbsolutePath(),"").replace(file.getName(),"")  } 
/**   * Create a new Category item  * @param name  * @param parent  * @return  */ public static PasswordItem newCategory(String name,File file,PasswordItem parent,File rootDir){   return new PasswordItem(name,parent,TYPE_CATEGORY,file,rootDir)  } 
/**   * Create a new parentless category item  * @param name  * @return  */ public static PasswordItem newCategory(String name,File file,File rootDir){   return new PasswordItem(name,null,TYPE_CATEGORY,file,rootDir)  } 
/**   * Create a new password item  * @param name  * @param parent  * @return  */ public static PasswordItem newPassword(String name,File file,PasswordItem parent,File rootDir){   return new PasswordItem(name,parent,TYPE_PASSWORD,file,rootDir)  } 
/**   * Create a new parentless password item  * @param name  * @return  */ public static PasswordItem newPassword(String name,File file,File rootDir){   return new PasswordItem(name,null,TYPE_PASSWORD,file,rootDir)  } 
public char getType(){   return this.type  } 
public String getName(){   return this.name  } 
public PasswordItem getParent(){   return this.parent  } 
public File getFile(){   return this.file  } 
public String getFullPathToParent(){   return this.fullPathToParent  } 
@Override public String toString(){   return this.getName().replace(".gpg","")  } 
@Override public boolean equals(Object o){   PasswordItem other=(PasswordItem)o    return (other.getFile().equals(this.getFile()))  } 
@Override public int compareTo(Object o){   PasswordItem other=(PasswordItem)o    return (this.getType() + this.getName()).compareTo(other.getType() + other.getName())  } 
public PasswordRecyclerAdapter(PasswordStore activity,PasswordFragment.OnFragmentInteractionListener listener,ArrayList<PasswordItem> values){   super(activity,values)    this.activity=activity    this.listener=listener  } 
@Override @NonNull protected View.OnLongClickListener getOnLongClickListener(final ViewHolder holder,final PasswordItem pass){   return new View.OnLongClickListener(){     @Override public boolean onLongClick(    View v){       if (mActionMode != null) {         return false        }       toggleSelection(holder.getAdapterPosition())        canEdit=pass.getType() == PasswordItem.TYPE_PASSWORD        mActionMode=activity.startSupportActionMode(mActionModeCallback)        mActionMode.setTitle("" + selectedItems.size())        mActionMode.invalidate()        notifyItemChanged(holder.getAdapterPosition())        return true      }   }   } 
@Override public boolean onLongClick(View v){   if (mActionMode != null) {     return false    }   toggleSelection(holder.getAdapterPosition())    canEdit=pass.getType() == PasswordItem.TYPE_PASSWORD    mActionMode=activity.startSupportActionMode(mActionModeCallback)    mActionMode.setTitle("" + selectedItems.size())    mActionMode.invalidate()    notifyItemChanged(holder.getAdapterPosition())    return true  } 
@Override @NonNull protected View.OnClickListener getOnClickListener(final ViewHolder holder,final PasswordItem pass){   return new View.OnClickListener(){     @Override public void onClick(    View v){       if (mActionMode != null) {         toggleSelection(holder.getAdapterPosition())          mActionMode.setTitle("" + selectedItems.size())          if (selectedItems.isEmpty()) {           mActionMode.finish()          }  else         if (selectedItems.size() == 1 && !canEdit) {           if (getValues().get(selectedItems.iterator().next()).getType() == PasswordItem.TYPE_PASSWORD) {             canEdit=true              mActionMode.invalidate()            }         }  else         if (selectedItems.size() >= 1 && canEdit) {           canEdit=false            mActionMode.invalidate()          }       }  else {         listener.onFragmentInteraction(pass)        }       notifyItemChanged(holder.getAdapterPosition())      }   }   } 
@Override public void onClick(View v){   if (mActionMode != null) {     toggleSelection(holder.getAdapterPosition())      mActionMode.setTitle("" + selectedItems.size())      if (selectedItems.isEmpty()) {       mActionMode.finish()      }  else     if (selectedItems.size() == 1 && !canEdit) {       if (getValues().get(selectedItems.iterator().next()).getType() == PasswordItem.TYPE_PASSWORD) {         canEdit=true          mActionMode.invalidate()        }     }  else     if (selectedItems.size() >= 1 && canEdit) {       canEdit=false        mActionMode.invalidate()      }   }  else {     listener.onFragmentInteraction(pass)    }   notifyItemChanged(holder.getAdapterPosition())  } 
@Override public boolean onCreateActionMode(ActionMode mode,Menu menu){   mode.getMenuInflater().inflate(R.menu.context_pass,menu)    return true  } 
@Override public boolean onPrepareActionMode(ActionMode mode,Menu menu){   if (canEdit) {     menu.findItem(R.id.menu_edit_password).setVisible(true)    }  else {     menu.findItem(R.id.menu_edit_password).setVisible(false)    }   return true  } 
@Override public boolean onActionItemClicked(ActionMode mode,MenuItem item){ switch (item.getItemId()) { case R.id.menu_delete_password:     activity.deletePasswords(PasswordRecyclerAdapter.this,new TreeSet<>(selectedItems))    mode.finish()  return true  case R.id.menu_edit_password: activity.editPassword(getValues().get(selectedItems.iterator().next()))  mode.finish()  return true  case R.id.menu_move_password: ArrayList<PasswordItem> selectedPasswords=new ArrayList<>()  for (Integer id : selectedItems) { selectedPasswords.add(getValues().get(id))  } activity.movePasswords(selectedPasswords)  default : return false  } } 
@Override public void onDestroyActionMode(ActionMode mode){   for (Iterator<Integer> it=selectedItems.iterator()  it.hasNext()  ) {     notifyItemChanged(it.next())      it.remove()    }   mActionMode=null  } 
protected PasswordRepository(){ } 
/**   * Returns the git repository  * @param localDir needed only on the creation  * @return the git repository  */ public static Repository getRepository(File localDir){   if (repository == null && localDir != null) {     FileRepositoryBuilder builder=new FileRepositoryBuilder()      try {       repository=builder.setGitDir(localDir).readEnvironment().build()      }  catch (    Exception e) {       e.printStackTrace()        return null      }   }   return repository  } 
public static boolean isInitialized(){   return repository != null  } 
public static void createRepository(File localDir) throws Exception {   localDir.delete()    Git.init().setDirectory(localDir).call()    getRepository(localDir)  } 
public static void addRemote(String name,String url,Boolean replace){   StoredConfig storedConfig=repository.getConfig()    Set<String> remotes=storedConfig.getSubsections("remote")    if (!remotes.contains(name)) {     try {       URIish uri=new URIish(url)        RefSpec refSpec=new RefSpec("+refs/head/*:refs/remotes/" + name + "/*")        RemoteConfig remoteConfig=new RemoteConfig(storedConfig,name)        remoteConfig.addFetchRefSpec(refSpec)        remoteConfig.addPushRefSpec(refSpec)        remoteConfig.addURI(uri)        remoteConfig.addPushURI(uri)        remoteConfig.update(storedConfig)        storedConfig.save()      }  catch (    Exception e) {       e.printStackTrace()      }   }  else   if (replace) {     try {       URIish uri=new URIish(url)        RemoteConfig remoteConfig=new RemoteConfig(storedConfig,name)        if (remoteConfig.getURIs().size() > 0) {         remoteConfig.removeURI(remoteConfig.getURIs().get(0))        }       if (remoteConfig.getPushURIs().size() > 0) {         remoteConfig.removePushURI(remoteConfig.getPushURIs().get(0))        }       remoteConfig.addURI(uri)        remoteConfig.addPushURI(uri)        remoteConfig.update(storedConfig)        storedConfig.save()      }  catch (    Exception e) {       e.printStackTrace()      }   } } 
public static void closeRepository(){   if (repository != null)   repository.close()    repository=null  } 
public static File getRepositoryDirectory(Context context){   File dir=null    SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(context.getApplicationContext())    if (settings.getBoolean("git_external",false)) {     String external_repo=settings.getString("git_external_repo",null)      if (external_repo != null) {       dir=new File(external_repo)      }   }  else {     dir=new File(context.getFilesDir() + "/store")    }   return dir  } 
public static Repository initialize(Context context){   File dir=getRepositoryDirectory(context)    SharedPreferences settings=PreferenceManager.getDefaultSharedPreferences(context.getApplicationContext())    if (dir == null) {     return null    }   if (!dir.exists() || !dir.isDirectory() || FileUtils.listFiles(dir,null,false).isEmpty()) {     settings.edit().putBoolean("repository_initialized",false).apply()    }   if (!PasswordRepository.getPasswords(dir).isEmpty()) {     settings.edit().putBoolean("repository_initialized",true).apply()    }   return PasswordRepository.getRepository(new File(dir.getAbsolutePath() + "/.git"))  } 
/**   * Gets the password items in the root directory  * @return a list of passwords in the root direcotyr  */ public static ArrayList<PasswordItem> getPasswords(File rootDir){   return getPasswords(rootDir,rootDir)  } 
/**   * Gets the .gpg files in a directory  * @param path the directory path  * @return the list of gpg files in that directory  */ public static ArrayList<File> getFilesList(File path){   if (!path.exists())   return new ArrayList<File>()    Log.d("REPO","current path: " + path.getPath())    ArrayList<File> files=new ArrayList<File>(Arrays.asList(path.listFiles((FileFilter)FileFilterUtils.directoryFileFilter())))    files.addAll(new ArrayList<File>((List<File>)FileUtils.listFiles(path,new String[]{"gpg"},false)))    return new ArrayList<File>(files)  } 
/**   * Gets the passwords (PasswordItem) in a directory  * @param path the directory path  * @return a list of password items  */ public static ArrayList<PasswordItem> getPasswords(File path,File rootDir){   ArrayList<File> passList=getFilesList(path)    if (passList.size() == 0)   return new ArrayList<PasswordItem>()    ArrayList<PasswordItem> passwordList=new ArrayList<PasswordItem>()    for (  File file : passList) {     if (file.isFile()) {       passwordList.add(PasswordItem.newPassword(file.getName(),file,rootDir))      }  else {       if (file.getName().equals(".git"))       continue        passwordList.add(PasswordItem.newCategory(file.getName(),file,rootDir))      }   }   sort(passwordList)    return passwordList  } 
public void testCalculateMD5() throws NoSuchAlgorithmException {   assertEquals("acbd18db4cc2f85cedef654fccc4a4d8",MD5Hash.calculateMD5("foo"))    assertEquals("37b51d194a7513e45b56f6524f2d51f2",MD5Hash.calculateMD5("bar"))    assertEquals("0cc175b9c0f1b6a831c399e269772661",MD5Hash.calculateMD5("a"))  } 
@Override protected void setUp() throws Exception {   super.setUp()    clearAllWAILData(getContext())  } 
@Override protected void tearDown() throws Exception {   clearAllWAILData(getContext())    super.tearDown()  } 
protected Random getRandom(){   return random  } 
public static void clearAllWAILData(Context context){   WAILSettings.clearAllSettings(context)    AppDBManager.getInstance(context).clearAll()    assertEquals(0,TracksDBHelper.getInstance(context).getAllDesc().getCount())  } 
public static Track newTrackWithRandomData(){   Track track=new Track()    track.setTrack("Song name " + random.nextInt(1000))    track.setArtist("Artist " + random.nextInt(1005))    track.setAlbum("Album " + random.nextInt(100000))    track.setDuration(random.nextInt(102455))    track.setTimestamp(System.currentTimeMillis())    track.setState(random.nextInt(4))    track.setStateTimestamp(System.currentTimeMillis())    track.setPlayerPackageName("playerPackageName" + random.nextInt(1251561))    return track  } 
public void testParseFromIntentExtras(){   Track track=TestTrackFactory.newTrackWithRandomData()    Intent intent=new Intent()    intent.putExtra(CommonMusicAppReceiver.EXTRA_PLAYER_PACKAGE_NAME,track.getPlayerPackageName())    intent.putExtra(CommonMusicAppReceiver.EXTRA_TRACK,track.getTrack())    intent.putExtra(CommonMusicAppReceiver.EXTRA_ARTIST,track.getArtist())    intent.putExtra(CommonMusicAppReceiver.EXTRA_ALBUM,track.getAlbum())    intent.putExtra(CommonMusicAppReceiver.EXTRA_DURATION,track.getDuration())    intent.putExtra(CommonMusicAppReceiver.EXTRA_TIMESTAMP,track.getTimestamp())    Track parsedTrack=CommonMusicAppReceiver.parseFromIntentExtras(intent)    assertEquals(track.getPlayerPackageName(),parsedTrack.getPlayerPackageName())    assertEquals(track.getTrack(),parsedTrack.getTrack())    assertEquals(track.getArtist(),parsedTrack.getArtist())    assertEquals(track.getAlbum(),parsedTrack.getAlbum())    assertEquals(track.getDuration(),parsedTrack.getDuration())    assertEquals(track.getTimestamp(),parsedTrack.getTimestamp())  } 
public void testGetInstanceIsSingleton(){   assertSame(AppDBManager.getInstance(getContext()),AppDBManager.getInstance(getContext()))  } 
public void testConvertIntegerToBoolean1(){   assertTrue(AppDBManager.convertIntegerToBoolean(1))  } 
public void testConvertIntegerToBoolean2(){   assertTrue(AppDBManager.convertIntegerToBoolean(2))  } 
public void testConvertIntegerToBooleanRandomPositive(){   assertTrue(AppDBManager.convertIntegerToBoolean(getRandom().nextInt(10000) + 1))  } 
public void testConvertIntegerToBooleanMinus1(){   assertFalse(AppDBManager.convertIntegerToBoolean(-1))  } 
public void testConvertIntegerToBooleanMinus2(){   assertFalse(AppDBManager.convertIntegerToBoolean(-2))  } 
public void testConvertIntegerToBooleanBigNegative(){   assertFalse(AppDBManager.convertIntegerToBoolean((-1) * (getRandom().nextInt(10000) + 1)))  } 
public void testConvertIntegerToBooleanZero(){   assertNull(AppDBManager.convertIntegerToBoolean(0))  } 
public void testConvertBooleanToIntegerNull(){   assertEquals(0,AppDBManager.convertBooleanToInteger(null))  } 
public void testConvertBooleanToIntegerTrue(){   assertEquals(1,AppDBManager.convertBooleanToInteger(true))  } 
public void testConvertBooleanToIntegerFalse(){   assertEquals(-1,AppDBManager.convertBooleanToInteger(false))  } 
public void testGetInstanceIsSingleton(){   assertSame(TracksDBHelper.getInstance(getContext()),TracksDBHelper.getInstance(getContext()))  } 
public void testAdd(){   Track track=TestTrackFactory.newTrackWithRandomData()    assertTrue(TracksDBHelper.getInstance(getContext()).add(track) != -1)    assertTrue(track.specialEquals(TracksDBHelper.getInstance(getContext()).getLastAddedTrack()))  } 
public void testUpdate(){   Track track=TestTrackFactory.newTrackWithRandomData()    final long trackDBId=TracksDBHelper.getInstance(getContext()).add(track)    assertTrue(trackDBId != -1)    track.setInternalDBId(trackDBId)    track.setDuration(getRandom().nextLong())    track.setArtist(track.getArtist() + getRandom().nextFloat())    track.setAlbum(track.getAlbum() + getRandom().nextDouble())    track.setPlayerPackageName(track.getPlayerPackageName() + getRandom().nextGaussian())    assertTrue(TracksDBHelper.getInstance(getContext()).update(track))    assertTrue(track.specialEquals(TracksDBHelper.getInstance(getContext()).getLastAddedTrack()))  } 
public void testDelete(){   Track track=TestTrackFactory.newTrackWithRandomData()    final long trackDBId=TracksDBHelper.getInstance(getContext()).add(track)    assertTrue(trackDBId != -1)    track.setInternalDBId(trackDBId)    assertTrue(track.specialEquals(TracksDBHelper.getInstance(getContext()).getLastAddedTrack()))    assertEquals(1,TracksDBHelper.getInstance(getContext()).delete(track))    assertNull(TracksDBHelper.getInstance(getContext()).getLastAddedTrack())  } 
public void testUpdateAll(){ } 
public void testDeleteAll(){   assertEquals(0,TracksDBHelper.getInstance(getContext()).getAllDesc().getCount())    final int count=getRandom().nextInt(1000) + 200    for (int i=0  i < count  i++) {     TracksDBHelper.getInstance(getContext()).add(TestTrackFactory.newTrackWithRandomData())    }   assertEquals(count,TracksDBHelper.getInstance(getContext()).getAllDesc().getCount())    assertEquals(count,TracksDBHelper.getInstance(getContext()).deleteAll())    assertEquals(0,TracksDBHelper.getInstance(getContext()).getAllDesc().getCount())  } 
@Override protected void setUp() throws Exception {   super.setUp()    clearAllWAILData(getContext())  } 
public void testIsAuthorizedDefault(){   assertFalse(WAILSettings.isAuthorized(getContext()))  } 
public void testIsAuthorizedWithSessionKey(){   WAILSettings.setLastfmSessionKey(getContext(),"asasdff")    assertTrue(WAILSettings.isAuthorized(getContext()))  } 
public void testGetLastfmApiKeyNotNull(){   assertNotNull(WAILSettings.getLastfmApiKey())  } 
public void testGetLastfmSecret(){   assertNotNull(WAILSettings.getLastfmSecret())  } 
public void testIsEnabledDefault(){   assertFalse(WAILSettings.isEnabled(getContext()))  } 
public void testSetAndGetIsEnabled(){   assertFalse(WAILSettings.isEnabled(getContext()))    WAILSettings.setEnabled(getContext(),true)    assertTrue(WAILSettings.isEnabled(getContext()))  } 
public void testIsStartOnBootDefault(){   assertTrue(WAILSettings.isStartOnBoot(getContext()))  } 
public void testSetAndGetIsStartOnBoot(){   assertTrue(WAILSettings.isStartOnBoot(getContext()))    WAILSettings.setStartOnBoot(getContext(),false)    assertFalse(WAILSettings.isStartOnBoot(getContext()))  } 
public void testGetLastfmSessionKeyDefault(){   assertNull(WAILSettings.getLastfmSessionKey(getContext()))  } 
public void testSetAndGetLastfmSessionKey(){   assertNull(WAILSettings.getLastfmSessionKey(getContext()))    String value="fakjasfolasddaf"    WAILSettings.setLastfmSessionKey(getContext(),value)    assertEquals(value,WAILSettings.getLastfmSessionKey(getContext()))  } 
public void testGetMinTrackDurationInPercentsDefault(){   assertEquals(WAILSettings.DEFAULT_MIN_TRACK_DURATION_IN_PERCENT,WAILSettings.getMinTrackDurationInPercents(getContext()))  } 
public void testSetAndGetMinTrackDurationInPercents(){   final int value=21    assertTrue(value != WAILSettings.getMinTrackDurationInPercents(getContext()))    WAILSettings.setMinTrackDurationInPercents(getContext(),value)    assertEquals(value,WAILSettings.getMinTrackDurationInPercents(getContext()))  } 
public void testGetMinTrackDurationInSecondsDefault(){   assertEquals(WAILSettings.DEFAULT_MIN_TRACK_DURATION_IN_SECONDS,WAILSettings.getMinTrackDurationInSeconds(getContext()))  } 
public void testSetAndGetMinTrackDurationInSeconds(){   final int value=124512    assertTrue(value != WAILSettings.getMinTrackDurationInSeconds(getContext()))    WAILSettings.setMinTrackDurationInSeconds(getContext(),value)    assertEquals(value,WAILSettings.getMinTrackDurationInSeconds(getContext()))  } 
public void testGetTotalHandledTracksCountDefault(){   assertEquals(0,WAILSettings.getTotalHandledTracksCount(getContext()))  } 
public void testSetAndGetTotalHandledTracksCount(){   final long value=215    assertTrue(value != WAILSettings.getTotalHandledTracksCount(getContext()))    WAILSettings.setTotalHandledTracksCount(getContext(),value)    assertEquals(value,WAILSettings.getTotalHandledTracksCount(getContext()))  } 
public void testIsLastfmNowplayingUpdateEnabledDefault(){   assertTrue(WAILSettings.isLastfmNowplayingUpdateEnabled(getContext()))  } 
public void testSetAndGetIsLastfmNowplayingUpdateEnabled(){   final boolean value=false    assertTrue(value != WAILSettings.isLastfmNowplayingUpdateEnabled(getContext()))    WAILSettings.setLastfmNowplayingUpdateEnabled(getContext(),value)    assertEquals(value,WAILSettings.isLastfmNowplayingUpdateEnabled(getContext()))  } 
public void testGetLastfmUserNameDefault(){   assertEquals("",WAILSettings.getLastfmUserName(getContext()))  } 
public void testSetAndGetLastfmUserName(){   final String value="adkjhafklio3"    assertFalse(value.equals(WAILSettings.getLastfmUserName(getContext())))    WAILSettings.setLastfmUserName(getContext(),value)    assertEquals(value,WAILSettings.getLastfmUserName(getContext()))  } 
public void testIsFirstLaunchDefault(){   assertTrue(WAILSettings.isFirstLaunch(getContext()))  } 
public void testSetAndGetIsFirstLaunch(){   assertTrue(WAILSettings.isFirstLaunch(getContext()))    WAILSettings.setIsFirstLaunch(getContext(),false)    assertFalse(WAILSettings.isFirstLaunch(getContext()))  } 
public void testGetLastCapturedTrackInfoDefault(){   assertNull(WAILSettings.getLastCapturedTrackInfo(getContext()))  } 
public void testSetAndGetLastCapturedTrackInfo(){   assertNull(WAILSettings.getLastCapturedTrackInfo(getContext()))    Track track=TestTrackFactory.newTrackWithRandomData()    WAILService.LastCapturedTrackInfo trackInfo=new WAILService.LastCapturedTrackInfo(track,true)    WAILSettings.setLastCapturedTrackInfo(getContext(),trackInfo)    WAILService.LastCapturedTrackInfo actualTrackInfo=WAILSettings.getLastCapturedTrackInfo(getContext())    assertNotNull(actualTrackInfo)    assertTrue(actualTrackInfo.isPlaying())    assertEquals(track,actualTrackInfo.getTrack())  } 
public void testGetLastfmUserInfoDefault(){   assertNull(WAILSettings.getLastfmUserInfo(getContext()))  } 
public void testSetAndGetLastfmUserInfo() throws Exception {   final String userInfoJSON="\n" + "{\"user\":{\"name\":\"RJ\",\"realname\":\"Richard Jones \",\"image\":[{\"#text\":\"http:\\/\\/userserve-ak.last.fm\\/serve\\/34\\/84504153.jpg\",\"size\":\"small\"},{\"#text\":\"http:\\/\\/userserve-ak.last.fm\\/serve\\/64\\/84504153.jpg\",\"size\":\"medium\"},{\"#text\":\"http:\\/\\/userserve-ak.last.fm\\/serve\\/126\\/84504153.jpg\",\"size\":\"large\"},{\"#text\":\"http:\\/\\/userserve-ak.last.fm\\/serve\\/252\\/84504153.jpg\",\"size\":\"extralarge\"}],\"url\":\"http:\\/\\/www.last.fm\\/user\\/RJ\",\"id\":\"1000002\",\"country\":\"UK\",\"age\":\"31\",\"gender\":\"m\",\"subscriber\":\"1\",\"playcount\":\"89564\",\"playlists\":\"4\",\"bootstrap\":\"0\",\"registered\":{\"#text\":\"2002-11-20 11:50\",\"unixtime\":\"1037793040\"},\"type\":\"alumni\"}}"    assertNull(WAILSettings.getLastfmUserInfo(getContext()))    WAILSettings.setLastfmUserInfo(getContext(),userInfoJSON)    assertEquals(LFUserResponseModel.parseFromJSON(userInfoJSON),WAILSettings.getLastfmUserInfo(getContext()))  } 
public void testGetLastfmUserInfoUpdateTimestampDefault(){   assertEquals(-1,WAILSettings.getLastfmUserInfoUpdateTimestamp(getContext()))  } 
public void testSetAndGetLastfmUserInfoUpdateTimestamp(){   final long timestamp=System.currentTimeMillis()    WAILSettings.setLastfmUserInfoUpdateTimestamp(getContext(),timestamp)    assertEquals(timestamp,WAILSettings.getLastfmUserInfoUpdateTimestamp(getContext()))  } 
public void testIsSoundNotificationTrackMarkedAsScrobbledEnabledDefault(){   assertFalse(WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(getContext()))  } 
public void testSetAndGetIsSoundNotificationTrackMarkedAsScrobbledEnabled(){   WAILSettings.setSoundNotificationTrackMarkedAsScrobbledEnabled(getContext(),true)    assertTrue(WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(getContext()))    WAILSettings.setSoundNotificationTrackMarkedAsScrobbledEnabled(getContext(),false)    assertFalse(WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(getContext()))  } 
public void testIsSoundNotificationTrackSkippedEnabledDefault(){   assertFalse(WAILSettings.isSoundNotificationTrackSkippedEnabled(getContext()))  } 
public void testSetAndGetIsSoundNotificationTrackSkippedEnabled(){   WAILSettings.setSoundNotificationTrackSkippedEnabled(getContext(),true)    assertTrue(WAILSettings.isSoundNotificationTrackSkippedEnabled(getContext()))    WAILSettings.setSoundNotificationTrackSkippedEnabled(getContext(),false)    assertFalse(WAILSettings.isSoundNotificationTrackSkippedEnabled(getContext()))  } 
public void testIsShowFeedbackRequestDefault(){   assertTrue(WAILSettings.isShowFeedbackRequest(getContext()))  } 
public void testSetAndGetIsShowFeedbackRequest(){   WAILSettings.setShowFeedbackRequest(getContext(),false)    assertFalse(WAILSettings.isShowFeedbackRequest(getContext()))    WAILSettings.setShowFeedbackRequest(getContext(),true)    assertTrue(WAILSettings.isShowFeedbackRequest(getContext()))  } 
public void testGetLongOrIntExtraNullIntent(){   assertEquals(-1,IntentUtil.getLongOrIntExtra(null,-1,"WOW"))  } 
public void testGetLongOrIntExtraNullExtraName(){   assertEquals(-1,IntentUtil.getLongOrIntExtra(new Intent(),-1,(String[])null))  } 
public void testGetLongOrIntNoExtra(){   Intent intent=new Intent()    assertEquals(-1,IntentUtil.getLongOrIntExtra(intent,-1,"NO_SUCH_EXTRA"))  } 
public void testGetLongOrIntExtraShortExtra(){   Intent intent=new Intent()    short value=143    intent.putExtra("SHORT_EXTRA",value)    assertEquals(value,IntentUtil.getLongOrIntExtra(intent,-1,"SHORT_EXTRA"))  } 
public void testGetLongOrIntExtraIntExtra(){   Intent intent=new Intent()    intent.putExtra("INT_EXTRA",3)    assertEquals(3,IntentUtil.getLongOrIntExtra(intent,-1,"INT_EXTRA"))  } 
public void testGetLongOrIntExtraLongExtra(){   Intent intent=new Intent()    intent.putExtra("LONG_EXTRA",1424125151214L)    assertEquals(1424125151214L,IntentUtil.getLongOrIntExtra(intent,-1,"LONG_EXTRA"))  } 
public void testGetLongOrIntExtraStringExtra(){   Intent intent=new Intent()    intent.putExtra("STRING_EXTRA","someValue")    assertEquals(-1,IntentUtil.getLongOrIntExtra(intent,-1,"STRING_EXTRA"))  } 
public void testGetLongOrIntExtraPossibilities(){   Intent intent=new Intent()    intent.putExtra("REAL_LONG_EXTRA",2145125L)    assertEquals(2145125L,IntentUtil.getLongOrIntExtra(intent,-1,"INCORRECT_EXTRA","ANOTHER_EXTRA","REAL_LONG_EXTRA","OTHER_EXTRA"))  } 
public void testGetBoolOrNumberAsBoolNullIntent(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(null,false,""))  } 
public void testGetBoolOrNumberAsBoolNoExtras(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent(),false,"asd"))  } 
public void testGetBoolOrNumberAsBoolFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("BOOL_VALUE",false),true,"BOOL_VALUE"))  } 
public void testGetBoolOrNumberAsBoolTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("BOOL_VALUE",true),false,"BOOL_VALUE"))  } 
public void testGetBoolOrNumberAsBoolIntFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("INT_VALUE",-1),true,"INT_VALUE"))  } 
public void testGetBoolOrNumberAsBoolIntTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("INT_VALUE",1),false,"INT_VALUE"))  } 
public void testGetBoolOrNumberAsBoolLongFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("LONG_VALUE",-1L),true,"LONG_VALUE"))  } 
public void testGetBoolOrNumberAsBoolLongTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("LONG_VALUE",1L),false,"LONG_VALUE"))  } 
public void testGetBoolOrNumberAsBoolShortFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("SHORT_VALUE",new Short("-1")),true,"SHORT_VALUE"))  } 
public void testGetBoolOrNumberAsBoolShortTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("SHORT_VALUE",new Short("1")),false,"SHORT_VALUE"))  } 
public void testGetBoolOrNumberAsBoolByteFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("BYTE_VALUE",new Byte("0")),true,"BYTE_VALUE"))  } 
public void testGetBoolOrNumberAsBoolByteTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("BYTE_VALUE",new Byte("1")),false,"BYTE_VALUE"))  } 
public void testGetBoolOrNumberAsBoolPossibleNamesFalse(){   assertEquals(Boolean.FALSE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("ASD",-1).putExtra("ANOTHER",145).putExtra("ASDadfaf","adfa"),false,"dkgds","dgsgs","dsgsfg"))  } 
public void testGetBoolOrNumberAsBoolPossibleNamesTrue(){   assertEquals(Boolean.TRUE,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("ASD",-1).putExtra("ANOTHER",145).putExtra("ASDadfaf","adfa"),false,"dkgds","ANOTHER","dsgsfg"))  } 
public void testGetBoolOrNumberAsBoolPossibleNamesNull(){   assertEquals(null,IntentUtil.getBoolOrNumberAsBoolExtra(new Intent().putExtra("ASD",-1).putExtra("ANOTHER",145).putExtra("ASDadfaf","adfa"),null,"dkgds","ANOTHERasf","dsgsfg"))  } 
public void testGetIntentAsStringNullIntent(){   assertEquals("null intent",IntentUtil.getIntentAsString(null))  } 
public void testGetIntentAsStringNoExtras(){   assertEquals("Intent action: null, no extras",IntentUtil.getIntentAsString(new Intent()))  } 
public void testGetIntentAsString(){   String intentAsString=IntentUtil.getIntentAsString(new Intent().putExtra("1","value1").putExtra("3",4))    assertTrue(intentAsString.contains("Intent action: null, extras: "))    assertTrue(intentAsString.contains("(1, value1)"))    assertTrue(intentAsString.contains("(3, 4)"))  } 
/**   * Returning required word form  * @param count of objects  * @param wordForms array with 1, 2 or 3 word forms to return  * @return required word form<p>Example for English: wordForms = { "track", "tracks" } count = 1 -> return "track" count > 1 -> return "tracks" </p> <p> Example for Russian and some other languages with 3 word forms: <br> wordForms = {"", "", ""}<br/> count = 1    -> return "" <br/> count = 2..4 -> return "" <br/> count = 5... -> return "" <br/> </p>  */ public static String wordFormForCount(final long count,String[] wordForms){   final long countAbs=Math.abs(count)    if (wordForms.length == 1) {     return wordForms[0]    }  else   if (wordForms.length == 2) {     return getWordFormFor2WordForms(countAbs,wordForms)    }  else   if (wordForms.length >= 3) {     return getWordFormFor3WordForms(countAbs,wordForms)    }  else {     return null    } } 
private static String getWordFormFor2WordForms(final long countAbs,String[] wordForms){   if (countAbs == 1) {     return wordForms[0]    }  else {     return wordForms[1]    } } 
private static String getWordFormFor3WordForms(final long countAbs,String[] wordForms){   if (countAbs == 1) {     return wordForms[0]    }  else   if (countAbs > 1 & countAbs < 5) {     return wordForms[1]    }  else   if (countAbs > 20) {     if (countAbs > 100) {       long tempCount=countAbs % 100        if (tempCount < 20) {         return getWordFormFor3WordForms(tempCount,wordForms)        }  else {         return getWordFormFor3WordForms(countAbs % 10,wordForms)        }     }  else {       return getWordFormFor3WordForms(countAbs % 10,wordForms)      }   }  else {     return wordForms[2]    } } 
private DisplayUnitsConverter(){ } 
/**   * Converts dp unit to equivalent pixels, depending on device density.  * @param context Context to get resources and device specific display metrics  * @param dp A value in dp (density independent pixels) unit. Which we need to convert into pixels  * @return A float value to represent px equivalent to dp depending on device density  */ public static float dpToPx(Context context,final float dp){   return dp * (context.getResources().getDisplayMetrics().densityDpi / 160f)  } 
/**   * Converts device specific pixels to density independent pixels.  * @param context Context to get resources and device specific display metrics  * @param px A value in px (pixels) unit. Which we need to convert into db  * @return A float value to represent dp equivalent to px value  */ public static float pxToDp(Context context,final float px){   return px / (context.getResources().getDisplayMetrics().densityDpi / 160f)  } 
/**   * Converts sp unit to equivalent pixels, depending on device density and user scale options  * @param context Context to get resources and device and user specific display metrics  * @param sp A value in sp to convert to px  * @return A float value to represent px equivalent to sp depending on device density and user's text scale options  */ public static float spToPx(Context context,final float sp){   return sp * (context.getResources().getDisplayMetrics().scaledDensity)  } 
/**   * Converts device specific pixels to density independent pixels * user's value of text scale  * @param context Context to get resources and device and user specific display metrics  * @param px A value in px to convert to sp  * @return A float value to represent sp equivalent to px depending on device density and user's text scale options  */ public static float pxToSp(Context context,final float px){   return px / (context.getResources().getDisplayMetrics().scaledDensity)  } 
/**   * Converts dp unit to equivalent pixels, depending on device density. Works without Context object  * @param dp A value in dp (density independent pixels) unit. Which we need to convert into pixels  * @return A float value to represent px equivalent to dp depending on device density  */ public static float dpToPx(final float dp){   return dp * (Resources.getSystem().getDisplayMetrics().densityDpi / 160f)  } 
/**   * Converts device specific pixels to density independent pixels. Works without Context object  * @param px A value in px (pixels) unit. Which we need to convert into db  * @return A float value to represent dp equivalent to px value  */ public static float pxToDp(final float px){   return px / (Resources.getSystem().getDisplayMetrics().densityDpi / 160f)  } 
/**   * Converts sp unit to equivalent pixels, depending on device density and user scale options Works without Context object  * @param sp A value in sp to convert to px  * @return A float value to represent px equivalent to sp depending on device density and user's text scale options  */ public static float spToPx(final float sp){   return sp * (Resources.getSystem().getDisplayMetrics().scaledDensity)  } 
/**   * Converts device specific pixels to density independent pixels * user's value of text scale Works without Context object  * @param px A value in px to convert to sp  * @return A float value to represent sp equivalent to px depending on device density and user's text scale options  */ public static float pxToSp(final float px){   return px / (Resources.getSystem().getDisplayMetrics().scaledDensity)  } 
private ViewUtil(){ } 
/**   * Sets View.GONE or View.VISIBLE to the view visibility, this method is LAZY. If current View's flag is equals to flag you want to set, it would not set it and View would not be invalidated  * @param view object to show/hide, can be null  * @param isVisible true to set View.VISIBLE flag, false to set View.GONE flag  */ public static void setVisibility(final View view,final boolean isVisible){   if (view == null)   return    final int visibilityFlag=isVisible ? View.VISIBLE : View.GONE    if (view.getVisibility() != visibilityFlag) {     view.setVisibility(visibilityFlag)    } } 
/**   * Recursively sets enabled flag for all views contained in viewGroup. Very useful for something like settings screens, when you need to enable/disable all controls inside a layout via Switch, RadioButton or CheckBox  * @param viewGroup which children will be enabled/disabled  * @param isEnabled true or false to set  */ public static void setEnabledForAllChildrenRecursively(final ViewGroup viewGroup,final boolean isEnabled){   for (int i=0  i < viewGroup.getChildCount()  i++) {     final View child=viewGroup.getChildAt(i)      if (child == null)     continue      child.setEnabled(isEnabled)      if (child instanceof ViewGroup) {       setEnabledForAllChildrenRecursively((ViewGroup)child,isEnabled)      }   } } 
/**   * Recursively sets selected flag for all views contained in viewGroup. Very useful for something like settings screens, when you need to select/unselect all controls inside a layout via Switch, RadioButton or CheckBox  * @param viewGroup which children will be selected/unselected  * @param selected true or false to set  */ public static void setSelectedForAllChildrenRecursively(final ViewGroup viewGroup,final boolean selected){   for (int i=0  i < viewGroup.getChildCount()  i++) {     final View child=viewGroup.getChildAt(i)      if (child == null)     continue      child.setSelected(selected)      if (child instanceof ViewGroup) {       setSelectedForAllChildrenRecursively((ViewGroup)child,selected)      }   } } 
private LFApiCommon(){ } 
protected LFApiException(){ } 
public static LFApiException newIntance(String error,String message){   final LFApiException exception=new LFApiException()    exception.error=error    exception.message=message    return exception  } 
public static LFApiException newDataFormatErrorInstance(String error,String message){   final LFApiException exception=new LFApiException()    exception.error=error    exception.message=message    return exception  } 
public String getError(){   return error  } 
public String getMessage(){   return message  } 
private LFAuthApi(){ } 
public static LFTokenResponseModel getToken(String apiKey,String secret) throws LFApiException, NetworkException {   final String requestParams=new LFRequestParamContainer("auth.getToken",secret).addParam(LFApiCommon.PARAM_API_KEY,apiKey).generateRequestParamsAsStringWithSign()    return LFTokenResponseModel.parseFromJson(NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams).getResponse())  } 
public static LFSessionResponseModel getSession(String apiKey,String secret,String token) throws LFApiException, NetworkException {   final String requestParams=new LFRequestParamContainer("auth.getSession",secret).addParam("token",token).addParam(LFApiCommon.PARAM_API_KEY,apiKey).generateRequestParamsAsStringWithSign()    return LFSessionResponseModel.parseFromJson(NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams).getResponse())  } 
private LFLibraryApi(){ } 
public static String addAlbum(String sessionKey,String apiKey,String secret,List<LFArtistAndAlbumRequestModel> artistAndAlbums) throws NetworkException, LFApiException {   final LFRequestParamContainer requestParams=new LFRequestParamContainer("library.addAlbum",secret)    for (int i=0  i < artistAndAlbums.size()  i++) {     final LFArtistAndAlbumRequestModel artistAndAlbum=artistAndAlbums.get(i)      requestParams.addParam("artist[" + i + "]",artistAndAlbum.getArtist())      requestParams.addParam("album[" + i + "]",artistAndAlbum.getAlbum())    }   requestParams.addParam(LFApiCommon.PARAM_API_KEY,apiKey)    requestParams.addParam(LFApiCommon.PARAM_SK,sessionKey)    return NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams.generateRequestParamsAsStringWithSign()).getResponse()  } 
public LFRequestParamContainer(String methodName,String secret){   this.secret=secret    addParam("method",methodName)  } 
public LFRequestParamContainer addParam(String name,String value){   paramsMap.put(name.trim(),value)    return this  } 
private String getParamsAsGETParamsString() throws Exception {   final StringBuilder stringBuilder=new StringBuilder()    final Set<Map.Entry<String,String>> entrySet=paramsMap.entrySet()    int i=0    final int paramsCount=entrySet.size()    for (  Map.Entry<String,String> param : entrySet) {     i++      stringBuilder.append(param.getKey()).append("=").append(URLEncoder.encode(param.getValue(),"UTF-8"))      if (i != paramsCount) {       stringBuilder.append("&")      }   }   return stringBuilder.toString()  } 
private String calculateRequestSign() throws Exception {   final StringBuilder stringBuilder=new StringBuilder()    for (  Map.Entry<String,String> param : paramsMap.entrySet()) {     stringBuilder.append(param.getKey()).append(param.getValue())    }   stringBuilder.append(secret)    return MD5Hash.calculateMD5(stringBuilder.toString())  } 
private String getParamsAsGETParamsStringWithSign() throws Exception {   final String sig=calculateRequestSign()    addParam("format","json")    final StringBuilder stringBuilder=new StringBuilder(getParamsAsGETParamsString())    stringBuilder.append("&").append(LFApiCommon.PARAM_API_SIG).append("=").append(sig)    return stringBuilder.toString()  } 
public String generateRequestParamsAsStringWithSign(){   try {     return getParamsAsGETParamsStringWithSign()    }  catch (  Exception e) {     return null    } } 
private LFTrackApi(){ } 
public static LFScrobbleResponseModel scrobble(String sessionKey,String apiKey,String secret,List<LFTrackRequestModel> tracks) throws LFApiException, NetworkException {   LFRequestParamContainer requestParams=new LFRequestParamContainer("track.scrobble",secret)    for (int i=0  i < tracks.size()  i++) {     final LFTrackRequestModel track=tracks.get(i)      requestParams.addParam("artist[" + i + "]",track.getArtist())      requestParams.addParam("track[" + i + "]",track.getTrack())      requestParams.addParam("timestamp[" + i + "]",track.getTimeStamp().toString())      if (!TextUtils.isEmpty(track.getAlbum())) {       requestParams.addParam("album[" + i + "]",track.getAlbum())      }     requestParams.addParam("chosenByUser[" + i + "]",track.getChosenByUser().toString())      if (track.getTrackNumber() != null) {       requestParams.addParam("trackNumber[" + i + "]",track.getTrackNumber().toString())      }     if (track.getDuration() != null) {       requestParams.addParam("duration[" + i + "]",track.getDuration().toString())      }   }   requestParams.addParam(LFApiCommon.PARAM_API_KEY,apiKey)    requestParams.addParam(LFApiCommon.PARAM_SK,sessionKey)    String response=NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams.generateRequestParamsAsStringWithSign()).getResponse()    return LFScrobbleResponseModel.parseFromJSON(response)  } 
public static LFUpdateNowPlayingResponseModel updateNowPlaying(String sessionKey,String apiKey,String secret,LFTrackRequestModel track) throws LFApiException, NetworkException {   LFRequestParamContainer requestParams=new LFRequestParamContainer("track.updateNowPlaying",secret)    requestParams.addParam("artist",track.getArtist())    requestParams.addParam("track",track.getTrack())    if (!TextUtils.isEmpty(track.getAlbum())) {     requestParams.addParam("album",track.getAlbum())    }   if (track.getTrackNumber() != null) {     requestParams.addParam("trackNumber",track.getTrackNumber().toString())    }   if (track.getDuration() != null) {     requestParams.addParam("duration",track.getDuration().toString())    }   requestParams.addParam(LFApiCommon.PARAM_API_KEY,apiKey)    requestParams.addParam(LFApiCommon.PARAM_SK,sessionKey)    String response=NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams.generateRequestParamsAsStringWithSign()).getResponse()    return LFUpdateNowPlayingResponseModel.parseFromJSON(response)  } 
public static LFLoveTrackResponseModel love(String sessionKey,String apiKey,String secret,LFTrackRequestModel track) throws NetworkException, LFApiException {   LFRequestParamContainer requestParams=new LFRequestParamContainer("track.love",secret)    requestParams.addParam("artist",track.getArtist())    requestParams.addParam("track",track.getTrack())    requestParams.addParam(LFApiCommon.PARAM_API_KEY,apiKey)    requestParams.addParam(LFApiCommon.PARAM_SK,sessionKey)    String response=NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams.generateRequestParamsAsStringWithSign()).getResponse()    return LFLoveTrackResponseModel.parseFromJSON(response)  } 
private LFUserApi(){ } 
/**   * @param user optional user name  * @see <a href="http://www.lastfm.ru/api/show/user.getInfo">user.getInfo()</a>  */ public static String getInfo(String sessionKey,String apiKey,String secret,String user) throws LFApiException, NetworkException {   final LFRequestParamContainer requestParams=new LFRequestParamContainer("user.getInfo",secret)    if (!TextUtils.isEmpty(user)) {     requestParams.addParam("user",user)    }   requestParams.addParam(LFApiCommon.PARAM_API_KEY,apiKey)    requestParams.addParam(LFApiCommon.PARAM_SK,sessionKey)    return NetworkRequest.newPostRequestInstance(LFApiCommon.API_ROOT_URL,requestParams.generateRequestParamsAsStringWithSign()).getResponse()  } 
public LFArtistAndAlbumRequestModel(String artist,String album){   this.artist=artist    this.album=album  } 
public String getArtist(){   return artist  } 
public void setArtist(String artist){   this.artist=artist  } 
public String getAlbum(){   return album  } 
public void setAlbum(String album){   this.album=album  } 
public LFTrackRequestModel(){ } 
public LFTrackRequestModel(com.artemzin.android.wail.storage.model.Track trackModel){   artist=trackModel.getArtist()    track=trackModel.getTrack()    timeStamp=trackModel.getTimestamp() / 1000    album=trackModel.getAlbum()    duration=(int)(trackModel.getDuration() / 1000)  } 
public String getArtist(){   return artist  } 
public void setArtist(String artist){   this.artist=artist  } 
public String getTrack(){   return track  } 
public void setTrack(String track){   this.track=track  } 
public Long getTimeStamp(){   return timeStamp  } 
public void setTimeStamp(Long timeStamp){   this.timeStamp=timeStamp  } 
public String getAlbum(){   return album  } 
public void setAlbum(String album){   this.album=album  } 
public Integer getChosenByUser(){   return chosenByUser  } 
public void setChosenByUser(Integer chosenByUser){   this.chosenByUser=chosenByUser  } 
public Integer getTrackNumber(){   return trackNumber  } 
public void setTrackNumber(Integer trackNumber){   this.trackNumber=trackNumber  } 
public String getAlbumArtist(){   return albumArtist  } 
public void setAlbumArtist(String albumArtist){   this.albumArtist=albumArtist  } 
public Integer getDuration(){   return duration  } 
public void setDuration(Integer duration){   this.duration=duration  } 
public String getPlayerPackageName(){   return playerPackageName  } 
public void setPlayerPackageName(String playerPackageName){   this.playerPackageName=playerPackageName  } 
public JSONObject getJsonObject(){   return jsonObject  } 
protected LFBaseResponseModel(String json) throws LFApiException {   try {     jsonObject=new JSONObject(json)    }  catch (  Exception e) {     throw LFApiException.newDataFormatErrorInstance(null,e.getMessage())    }   error=Error.optFromJSONObject(jsonObject)    if (error != null) {     throw LFApiException.newIntance(error.error,error.message)    } } 
public String getError(){   return error  } 
public String getMessage(){   return message  } 
public static Error optFromJSONObject(JSONObject jsonObject){   final String errorValue=jsonObject.optString("error")    if (!TextUtils.isEmpty(errorValue)) {     final Error error=new Error()      error.error=errorValue      error.message=jsonObject.optString("message")      return error    }   return null  } 
protected LFLoveTrackResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFLoveTrackResponseModel parseFromJSON(String json) throws LFApiException {   final LFLoveTrackResponseModel responseModel=new LFLoveTrackResponseModel(json)    responseModel.json=json    return responseModel  } 
@Override public String toString(){   return json  } 
protected LFScrobbleResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFScrobbleResponseModel parseFromJSON(String json) throws LFApiException {   final LFScrobbleResponseModel responseModel=new LFScrobbleResponseModel(json)    responseModel.json=json    return responseModel  } 
@Override public String toString(){   return json  } 
protected LFSessionResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFSessionResponseModel parseFromJson(String json) throws LFApiException {   try {     final LFSessionResponseModel sessionModel=new LFSessionResponseModel(json)      final JSONObject sessionJson=sessionModel.getJsonObject().getJSONObject("session")      sessionModel.name=sessionJson.optString("name")      sessionModel.key=sessionJson.optString("key")      sessionModel.subscriber=sessionJson.optString("subscriber")      return sessionModel    }  catch (  JSONException e) {     throw LFApiException.newDataFormatErrorInstance(null,e.getMessage())    } } 
public String getName(){   return name  } 
public String getKey(){   return key  } 
public String getSubscriber(){   return subscriber  } 
protected LFTokenResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFTokenResponseModel parseFromJson(String json) throws LFApiException {   try {     final LFTokenResponseModel tokenModel=new LFTokenResponseModel(json)      final JSONObject tokenJson=tokenModel.getJsonObject()      tokenModel.token=tokenJson.getString("token")      return tokenModel    }  catch (  JSONException e) {     throw LFApiException.newDataFormatErrorInstance(null,e.getMessage())    } } 
public String getToken(){   return token  } 
protected LFUpdateNowPlayingResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFUpdateNowPlayingResponseModel parseFromJSON(String json) throws LFApiException {   final LFUpdateNowPlayingResponseModel responseModel=new LFUpdateNowPlayingResponseModel(json)    responseModel.json=json    return responseModel  } 
@Override public String toString(){   return json  } 
private Registered(){ } 
public String getText(){   return text  } 
public void setText(String text){   this.text=text  } 
public long getUnixtime(){   return unixtime  } 
public void setUnixtime(long unixtime){   this.unixtime=unixtime  } 
public static Registered fromJSON(JSONObject json){   try {     Registered registered=new Registered()      registered.text=json.optString("#text")      registered.unixtime=json.optLong("unixtime")      return registered    }  catch (  Exception e) {     return null    } } 
@Override public boolean equals(Object other){   if (other instanceof Registered) {     Registered o=(Registered)other      return TextUtils.equals(text,o.text) && unixtime == o.unixtime    }   return false  } 
@Override public int hashCode(){   int result=text != null ? text.hashCode() : 0    result=31 * result + (int)(unixtime ^ (unixtime >>> 32))    return result  } 
protected LFUserResponseModel(String json) throws LFApiException {   super(json)  } 
public static LFUserResponseModel parseFromJSON(String json) throws LFApiException {   try {     final LFUserResponseModel userModel=new LFUserResponseModel(json)      final JSONObject userJson=new JSONObject(json).getJSONObject("user")      userModel.id=userJson.optString("id")      userModel.name=userJson.optString("name")      userModel.realName=userJson.optString("realname")      userModel.url=userJson.optString("url")      userModel.country=userJson.optString("country")      userModel.age=userJson.optString("age")      userModel.gender=userJson.optString("gender")      userModel.subscriber=userJson.optInt("subscriber")      userModel.playCount=userJson.optInt("playcount")      userModel.playlists=userJson.optInt("playlists")      userModel.registered=Registered.fromJSON(userJson.optJSONObject("registered"))      return userModel    }  catch (  JSONException e) {     throw LFApiException.newDataFormatErrorInstance(null,e.getMessage())    } } 
public String getId(){   return id  } 
public void setId(String id){   this.id=id  } 
public String getName(){   return name  } 
public void setName(String name){   this.name=name  } 
public String getRealName(){   return realName  } 
public void setRealName(String realName){   this.realName=realName  } 
public String getUrl(){   return url  } 
public void setUrl(String url){   this.url=url  } 
public String getCountry(){   return country  } 
public void setCountry(String country){   this.country=country  } 
public String getAge(){   return age  } 
public void setAge(String age){   this.age=age  } 
public String getGender(){   return gender  } 
public void setGender(String gender){   this.gender=gender  } 
public int getSubscriber(){   return subscriber  } 
public void setSubscriber(int subscriber){   this.subscriber=subscriber  } 
public int getPlayCount(){   return playCount  } 
public void setPlayCount(int playCount){   this.playCount=playCount  } 
public int getPlaylists(){   return playlists  } 
public void setPlaylists(int playlists){   this.playlists=playlists  } 
public Registered getRegistered(){   return registered  } 
public void setRegistered(Registered registered){   this.registered=registered  } 
@Override public boolean equals(Object other){   if (other instanceof LFUserResponseModel) {     LFUserResponseModel o=(LFUserResponseModel)other      return TextUtils.equals(id,o.id) && TextUtils.equals(name,o.name) && TextUtils.equals(realName,o.realName)&& TextUtils.equals(url,o.url)&& TextUtils.equals(country,o.country)&& TextUtils.equals(age,o.age)&& TextUtils.equals(gender,o.gender)&& subscriber == o.subscriber && playCount == o.playCount && playlists == o.playlists && registered.equals(o.registered)    }   return false  } 
@Override public int hashCode(){   int result=id != null ? id.hashCode() : 0    result=31 * result + (name != null ? name.hashCode() : 0)    result=31 * result + (realName != null ? realName.hashCode() : 0)    result=31 * result + (url != null ? url.hashCode() : 0)    result=31 * result + (country != null ? country.hashCode() : 0)    result=31 * result + (age != null ? age.hashCode() : 0)    result=31 * result + (gender != null ? gender.hashCode() : 0)    result=31 * result + subscriber    result=31 * result + playCount    result=31 * result + playlists    result=31 * result + (registered != null ? registered.hashCode() : 0)    return result  } 
/**   * Calculates MD5 hash from input string <br/> Result should be equals to PHP md5() function  * @param input string md5 from which should be calculated  * @return calculated md5 hash from input string  * @throws NoSuchAlgorithmException if md5 could not be calculated, because algorithm not founded  */ public static String calculateMD5(String input) throws NoSuchAlgorithmException {   try {     final byte[] digest=MessageDigest.getInstance("MD5").digest(input.getBytes("UTF-8"))      return String.format("%032x",new BigInteger(1,digest))    }  catch (  UnsupportedEncodingException e) {     throw new RuntimeException(e)    } } 
public NetworkException(String message){   super(message)  } 
/**   * Creating network request object and checks entered url  * @param url where you want to send request  * @param method request method  * @throws java.net.MalformedURLException if url format is incorrect  */ private NetworkRequest(String url,Method method,String postBody) throws NetworkException {   try {     this.url=new URL(url)    }  catch (  MalformedURLException e) {     throw new NetworkException("MalformedURLException: " + e.getMessage())    }   this.method=method    this.postBody=postBody  } 
public static NetworkRequest newGetRequestInstance(String url) throws NetworkException {   return new NetworkRequest(url,Method.GET,null)  } 
public static NetworkRequest newPostRequestInstance(String url,String postBody) throws NetworkException {   return new NetworkRequest(url,Method.POST,postBody)  } 
public int getConnectionTimeoutInMillis(){   return connectionTimeoutInMillis  } 
public void setConnectionTimeoutInMillis(int connectionTimeoutInMillis){   this.connectionTimeoutInMillis=connectionTimeoutInMillis  } 
public boolean isGzipCompressionEnabled(){   return isGzipCompressionEnabled  } 
public void setGzipCompressionEnabled(boolean gzipCompressionEnabled){   isGzipCompressionEnabled=gzipCompressionEnabled  } 
public int getQueryRetryLimit(){   return queryRetryLimit  } 
public void setQueryRetryLimit(int queryRetryLimit){   this.queryRetryLimit=queryRetryLimit  } 
public String getUrl(){   return url.toExternalForm()  } 
/**   * Sends request to needed url and returns response as string  * @return server response as string  * @throws NetworkException if some of network problems caused  */ public String getResponse() throws NetworkException {   String response=null    for (int i=0  i < queryRetryLimit  i++) {     try {       response=getInternalResponse()        break      }  catch (    SSLException e) {       if (i < queryRetryLimit - 1)       continue        throw new NetworkException("SSL exception: " + e.getMessage())      } catch (    SocketException e) {       if (i < queryRetryLimit - 1)       continue        throw new NetworkException("Socket exception: " + e.getMessage())      } catch (    Exception e) {       if (i < queryRetryLimit - 1)       continue        throw new NetworkException("Network exception: " + e.getMessage())      }   }   return response  } 
/**   * Sends http request to needed url and returns result as string  * @return response as string  * @throws Exception if something going wrong  */ private String getInternalResponse() throws Exception {   HttpURLConnection connection=null    try {     connection=(HttpURLConnection)new URL(url.toExternalForm()).openConnection()      connection.setConnectTimeout(connectionTimeoutInMillis)      connection.setReadTimeout(connectionTimeoutInMillis)      connection.setUseCaches(false)      connection.setDoInput(true)      if (isGzipCompressionEnabled)     connection.setRequestProperty("Accept-Encoding","gzip")      if (method.equals(Method.GET)) {       connection.setRequestMethod("GET")        connection.setDoOutput(false)      }  else     if (method.equals(Method.POST)) {       connection.setRequestMethod("POST")        if (postBody != null) {         connection.setDoOutput(true)          final OutputStream outputStream=connection.getOutputStream()          final BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(outputStream))          bufferedWriter.write(postBody)          bufferedWriter.close()        }     }     final int responseCode=connection.getResponseCode()      if (responseCode == -1)     throw new Exception("Got response code -1, may be http keep-alive problem")      InputStream inputStream=new BufferedInputStream(connection.getInputStream(),8192)      final String contentEncoding=connection.getContentEncoding()      if (contentEncoding != null && contentEncoding.equalsIgnoreCase("gzip"))     inputStream=new GZIPInputStream(inputStream)      return Util.convertStreamToString(inputStream)    }   finally {     if (connection != null)     connection.disconnect()    } } 
private Util(){ } 
/**   * Converting input stream content to string  * @param is input stream to convert  * @return String with stream content  * @throws java.io.IOException if problems with reading input stream  */ public static String convertStreamToString(InputStream is) throws IOException {   InputStreamReader r=new InputStreamReader(is)    StringWriter sw=new StringWriter()    char[] buffer=new char[1024]    try {     for (int n  (n=r.read(buffer)) != -1  )     sw.write(buffer,0,n)    }   finally {     try {       is.close()      }  catch (    IOException e1) {       e1.printStackTrace()      }   }   return sw.toString()  } 
private SoundNotificationsManager(Context context){   this.context=context.getApplicationContext()  } 
public static SoundNotificationsManager getInstance(Context context){   if (instance == null) { synchronized (SoundNotificationsManager.class) {       if (instance == null) {         instance=new SoundNotificationsManager(context)        }     }   }   return instance  } 
public void playTrackSkippedSound(){   playTrackSkippedSound(false)  } 
public void playTrackSkippedSound(boolean force){   if (!force && !WAILSettings.isSoundNotificationTrackSkippedEnabled(context)) {     Loggi.w("SoundNotificationsManager.playTrackSkippedSound() disabled")      return    }   if (SystemClock.elapsedRealtime() - lastTrackSkippedPlayTime < 300) {     return    }   lastTrackSkippedPlayTime=SystemClock.elapsedRealtime()    AsyncTaskExecutor.executeConcurrently(new AsyncTask<Object,Object,Object>(){     volatile MediaPlayer mediaPlayer      @Override protected Object doInBackground(    Object... params){       final long startTime=SystemClock.elapsedRealtime()        try {         mediaPlayer=MediaPlayer.create(context,R.raw.track_skipped)        }  catch (      Exception e) {         Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() exception: " + e)        }       ThreadUtil.sleepIfRequired(startTime,250)        return null      }     @Override protected void onPostExecute(    Object o){       super.onPostExecute(o)        if (mediaPlayer == null)       return        try {         mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){           @Override public void onCompletion(          MediaPlayer mp){             tryToReleaseMediaPlayer(mediaPlayer)            }         } )          mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener(){           @Override public boolean onError(          MediaPlayer mp,          int what,          int extra){             tryToReleaseMediaPlayer(mediaPlayer)              return false            }         } )          mediaPlayer.setVolume(0.07f,0.07f)          mediaPlayer.start()        }  catch (      Exception e) {         Loggi.e("SoundNotificationsManager.playTrackSkippedSound() can not play sound: " + e)        }     }   } )  } 
@Override protected Object doInBackground(Object... params){   final long startTime=SystemClock.elapsedRealtime()    try {     mediaPlayer=MediaPlayer.create(context,R.raw.track_skipped)    }  catch (  Exception e) {     Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() exception: " + e)    }   ThreadUtil.sleepIfRequired(startTime,250)    return null  } 
@Override protected void onPostExecute(Object o){   super.onPostExecute(o)    if (mediaPlayer == null)   return    try {     mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){       @Override public void onCompletion(      MediaPlayer mp){         tryToReleaseMediaPlayer(mediaPlayer)        }     } )      mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener(){       @Override public boolean onError(      MediaPlayer mp,      int what,      int extra){         tryToReleaseMediaPlayer(mediaPlayer)          return false        }     } )      mediaPlayer.setVolume(0.07f,0.07f)      mediaPlayer.start()    }  catch (  Exception e) {     Loggi.e("SoundNotificationsManager.playTrackSkippedSound() can not play sound: " + e)    } } 
@Override public void onCompletion(MediaPlayer mp){   tryToReleaseMediaPlayer(mediaPlayer)  } 
@Override public boolean onError(MediaPlayer mp,int what,int extra){   tryToReleaseMediaPlayer(mediaPlayer)    return false  } 
public void playTrackMarkedAsScrobbledSound(){   playTrackMarkedAsScrobbledSound(false)  } 
public void playTrackMarkedAsScrobbledSound(boolean force){   if (!force && !WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(context)) {     Loggi.w("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() disabled")      return    }   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){     volatile MediaPlayer mediaPlayer      @Override protected Void doInBackground(    Void... params){       final long startTime=SystemClock.elapsedRealtime()        try {         mediaPlayer=MediaPlayer.create(context,R.raw.track_marked_as_scrobbled)        }  catch (      Exception e) {         Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() exception: " + e)        }       ThreadUtil.sleepIfRequired(startTime,350)        return null      }     @Override protected void onPostExecute(    Void aVoid){       super.onPostExecute(aVoid)        if (mediaPlayer == null)       return        try {         mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){           @Override public void onCompletion(          MediaPlayer mp){             tryToReleaseMediaPlayer(mediaPlayer)            }         } )          mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener(){           @Override public boolean onError(          MediaPlayer mp,          int what,          int extra){             tryToReleaseMediaPlayer(mediaPlayer)              return false            }         } )          mediaPlayer.setVolume(0.18f,0.18f)          mediaPlayer.start()        }  catch (      Exception e) {         Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() can not play sound: " + e)        }     }   } )  } 
@Override protected Void doInBackground(Void... params){   final long startTime=SystemClock.elapsedRealtime()    try {     mediaPlayer=MediaPlayer.create(context,R.raw.track_marked_as_scrobbled)    }  catch (  Exception e) {     Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() exception: " + e)    }   ThreadUtil.sleepIfRequired(startTime,350)    return null  } 
@Override protected void onPostExecute(Void aVoid){   super.onPostExecute(aVoid)    if (mediaPlayer == null)   return    try {     mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){       @Override public void onCompletion(      MediaPlayer mp){         tryToReleaseMediaPlayer(mediaPlayer)        }     } )      mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener(){       @Override public boolean onError(      MediaPlayer mp,      int what,      int extra){         tryToReleaseMediaPlayer(mediaPlayer)          return false        }     } )      mediaPlayer.setVolume(0.18f,0.18f)      mediaPlayer.start()    }  catch (  Exception e) {     Loggi.e("SoundNotificationsManager.playTrackMarkedAsScrobbledSound() can not play sound: " + e)    } } 
@Override public void onCompletion(MediaPlayer mp){   tryToReleaseMediaPlayer(mediaPlayer)  } 
@Override public boolean onError(MediaPlayer mp,int what,int extra){   tryToReleaseMediaPlayer(mediaPlayer)    return false  } 
private static void tryToReleaseMediaPlayer(MediaPlayer mediaPlayer){   try {     mediaPlayer.reset()      mediaPlayer.release()    }  catch (  Exception e) {     Loggi.w("SoundNotificationsManager can not release media player")    } } 
private StatusBarNotificationsManager(Context context){   this.context=context  } 
public static StatusBarNotificationsManager getInstance(Context context){   if (instance == null) { synchronized (StatusBarNotificationsManager.class) {       if (instance == null) {         instance=new StatusBarNotificationsManager(context)        }     }   }   return instance  } 
private NotificationManager getNotificationManager(){   return (NotificationManager)context.getSystemService(Activity.NOTIFICATION_SERVICE)  } 
public void showTrackScrobblingStatusBarNotification(Track track){   if (!WAILSettings.isStatusBarNotificationTrackScrobblingEnabled(context)) {     Loggi.i("StatusBarNotificationsManager: Status bar notifications are disabled, skipping")      return    }   Intent resultIntent=new Intent(context,MainActivity.class)    TaskStackBuilder taskStackBuilder=TaskStackBuilder.create(context)    taskStackBuilder.addParentStack(MainActivity.class)    taskStackBuilder.addNextIntent(resultIntent)    PendingIntent intent=taskStackBuilder.getPendingIntent(0,PendingIntent.FLAG_UPDATE_CURRENT)    Intent loveIntent=new Intent(context,NotificationActionsReceiver.class)    PendingIntent lovePendingIntent=PendingIntent.getBroadcast(context,0,loveIntent,PendingIntent.FLAG_UPDATE_CURRENT)    boolean minPriority=WAILSettings.isStatusBarNotificationMinPriority(context)    Notification notification=new NotificationCompat.Builder(context).setPriority(minPriority ? -2 : 0).setContentTitle(context.getString(R.string.notifications_now_scrobbling)).setContentText(track.getArtist() + " - " + track.getTrack()).setSmallIcon(R.drawable.ic_status_wail_notifications).setContentIntent(intent).addAction(R.drawable.ic_status_wail_love_track,context.getString(R.string.notifications_love_current_track),lovePendingIntent).build()    notification.flags=Notification.FLAG_ONGOING_EVENT    getNotificationManager().notify(TRACK_SCROBBLING_NOTIFICATION_ID,notification)  } 
public void hideTrackScrobblingStatusBarNotification(){   if (!WAILSettings.isStatusBarNotificationTrackScrobblingEnabled(context)) {     Loggi.i("StatusBarNotificationsManager: Status bar notifications are disabled, skipping")      return    }   getNotificationManager().cancel(TRACK_SCROBBLING_NOTIFICATION_ID)  } 
public void showTrackLovedStatusBarNotification(Track track){   Notification notification=new NotificationCompat.Builder(context).setContentTitle(context.getString(R.string.notifications_track_loved)).setContentText(track.getArtist() + " - " + track.getTrack()).setSmallIcon(R.drawable.ic_status_wail_notifications).build()    getNotificationManager().notify(TRACK_LOVED_NOTIFICATION_ID,notification)  } 
public void hideTrackLovedStatusBarNotification(){   getNotificationManager().cancel(TRACK_LOVED_NOTIFICATION_ID)  } 
public void cancelAllNotifications(){   getNotificationManager().cancelAll()  } 
@Override public void onReceive(Context context,Intent intent){   if (NetworkUtil.isAvailable(context)) {     if (!WAILSettings.isEnableScrobblingOverMobileNetwork(context) && NetworkUtil.isMobileNetwork(context)) {       return      }     context.startService(new Intent(context,WAILService.class).setAction(WAILService.INTENT_ACTION_SCROBBLE_PENDING_TRACKS))    } } 
@Override public void onReceive(Context context,Intent intent){   Loggi.i("BOOT COMPLETED received")    if (WAILSettings.isStartOnBoot(context)) {     Loggi.w("Starting WAILService after boot")      context.startService(new Intent(context,WAILService.class))    }  else {     Loggi.w("Skipping WAILService start after boot")    } } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.amazon.mp3")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   final Intent handleTrackIntent=super.handleIntent(context,originalIntent)    if (handleTrackIntent != null && originalIntent.hasExtra("com.maxmpz.audioplayer.source")) {     handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.maxmpz.audioplayer")    }   return handleTrackIntent  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.andrew.appolo")  } 
@Override public final void onReceive(Context context,Intent intent){   asyncProcessTheIntent(context,intent)  } 
protected final Intent newIntentForWAILService(Context context){   return new Intent(context,WAILService.class)  } 
private void asyncProcessTheIntent(final Context context,final Intent intent){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Intent>(){     @Override protected Intent doInBackground(    Void... params){       try {         try {           Loggi.d("CommonMusicAppReceiver.onReceive() intent: " + IntentUtil.getIntentAsString(intent))          }  catch (        Exception e) {           Loggi.e("CommonMusicAppReceiver.onReceive() can not display intent info")          }         if (intent == null) {           Loggi.e("CommonMusicAppReceiver.onReceive() intent is null")            return null          }         if (TextUtils.isEmpty(intent.getAction()) || intent.getAction().indexOf('.') == -1) {           Loggi.e("CommonMusicAppReceiver.onReceive() intent action is corrupted: " + intent.getAction())            return null          }         if (intent.getExtras() == null || intent.getExtras().size() == 0) {           Loggi.e("CommonMusicAppReceiver.onReceive() intent extras are null or empty, skipping intent")            return null          }         if (isInitialStickyBroadcast()) {           Loggi.w("CommonMusicAppReceiver.onReceive() received cached sticky broadcast, WAIL won't process it")            return null          }         final Intent intentForWAILService=handleIntent(context,intent)          if (intentForWAILService != null) {           intentForWAILService.setAction(WAILService.INTENT_ACTION_HANDLE_TRACK)            intentForWAILService.putExtra(EXTRA_ACTION,intent.getAction())            intentForWAILService.putExtra(EXTRA_TIMESTAMP,System.currentTimeMillis())            return intentForWAILService          }  else {           Loggi.w("CommonMusicAppReceiver.onReceive() did not send intent for service, handleIntent() returns null, skipping intent")            return null          }       }  catch (      Exception e) {         final String log="CommonMusicAppReceiver.onReceive() exception while handleIntent(): " + StackTraceUtil.getStackTrace(e)          Loggi.e(log)          EasyTracker.getInstance(context).send(MapBuilder.createException(log,false).build())          return null        }     }     @Override protected void onPostExecute(    Intent intentForWAILService){       if (intentForWAILService != null) {         context.startService(intentForWAILService)        }     }   } )  } 
@Override protected Intent doInBackground(Void... params){   try {     try {       Loggi.d("CommonMusicAppReceiver.onReceive() intent: " + IntentUtil.getIntentAsString(intent))      }  catch (    Exception e) {       Loggi.e("CommonMusicAppReceiver.onReceive() can not display intent info")      }     if (intent == null) {       Loggi.e("CommonMusicAppReceiver.onReceive() intent is null")        return null      }     if (TextUtils.isEmpty(intent.getAction()) || intent.getAction().indexOf('.') == -1) {       Loggi.e("CommonMusicAppReceiver.onReceive() intent action is corrupted: " + intent.getAction())        return null      }     if (intent.getExtras() == null || intent.getExtras().size() == 0) {       Loggi.e("CommonMusicAppReceiver.onReceive() intent extras are null or empty, skipping intent")        return null      }     if (isInitialStickyBroadcast()) {       Loggi.w("CommonMusicAppReceiver.onReceive() received cached sticky broadcast, WAIL won't process it")        return null      }     final Intent intentForWAILService=handleIntent(context,intent)      if (intentForWAILService != null) {       intentForWAILService.setAction(WAILService.INTENT_ACTION_HANDLE_TRACK)        intentForWAILService.putExtra(EXTRA_ACTION,intent.getAction())        intentForWAILService.putExtra(EXTRA_TIMESTAMP,System.currentTimeMillis())        return intentForWAILService      }  else {       Loggi.w("CommonMusicAppReceiver.onReceive() did not send intent for service, handleIntent() returns null, skipping intent")        return null      }   }  catch (  Exception e) {     final String log="CommonMusicAppReceiver.onReceive() exception while handleIntent(): " + StackTraceUtil.getStackTrace(e)      Loggi.e(log)      EasyTracker.getInstance(context).send(MapBuilder.createException(log,false).build())      return null    } } 
@Override protected void onPostExecute(Intent intentForWAILService){   if (intentForWAILService != null) {     context.startService(intentForWAILService)    } } 
protected Intent handleIntent(Context context,Intent originalIntent){   final Intent handleTrackIntent=newIntentForWAILService(context)    handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,originalIntent.getAction().substring(0,originalIntent.getAction().lastIndexOf('.')))    handleTrackIntent.putExtra(EXTRA_ID,IntentUtil.getLongOrIntExtra(originalIntent,-1,"id","trackid","trackId"))    final Boolean isPlaying=IntentUtil.getBoolOrNumberAsBoolExtra(originalIntent,null,"playing","playstate","isPlaying","isplaying","is_playing")    if (isPlaying == null) {     Loggi.w("CommonMusicAppReceiver track info does not contains playing state, ignoring")      return null    }  else {     handleTrackIntent.putExtra(EXTRA_PLAYING,isPlaying)    }   handleTrackIntent.putExtra(EXTRA_ALBUM_ID,IntentUtil.getLongOrIntExtra(originalIntent,-1,"albumid","albumId"))    handleTrackIntent.putExtra(EXTRA_TRACK,originalIntent.getStringExtra("track"))    handleTrackIntent.putExtra(EXTRA_ARTIST,originalIntent.getStringExtra("artist"))    handleTrackIntent.putExtra(EXTRA_ALBUM,originalIntent.getStringExtra("album"))    long duration=IntentUtil.getLongOrIntExtra(originalIntent,-1,"duration")    if (duration != -1) {     if (duration < 30000) {       duration*=1000      }   }   handleTrackIntent.putExtra(EXTRA_DURATION,duration)    return handleTrackIntent  } 
public static Track parseFromIntentExtras(final Intent intent){   final Track track=new Track()    track.setPlayerPackageName(intent.getStringExtra(EXTRA_PLAYER_PACKAGE_NAME))    track.setTrack(intent.getStringExtra(EXTRA_TRACK))    track.setArtist(intent.getStringExtra(EXTRA_ARTIST))    track.setAlbum(intent.getStringExtra(EXTRA_ALBUM))    track.setDuration(intent.getLongExtra(EXTRA_DURATION,-1L))    track.setTimestamp(intent.getLongExtra(EXTRA_TIMESTAMP,-1L))    return track  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.htc.music")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.jetappfactory.jetaudio")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.lge.music")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.miui.player")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.tbig.playerpro")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.tbig.playerprotrial")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.rdio.android")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.rhapsody")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.jrtstudio.AnotherMusicPlayer")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.samsung.MusicPlayer")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.samsung.music")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.samsung.sec.android.MusicPlayer")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.samsung.sec.android")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.samsung.sec")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   final Intent handleTrackIntent=newIntentForWAILService(context)    handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.sonyericsson.music")    final String actionSuffix    try {     actionSuffix=originalIntent.getAction().substring(originalIntent.getAction().lastIndexOf('.') + 1)    }  catch (  Exception e) {     Loggi.e("Can not parse action suffix for intent action: " + originalIntent.getAction())      return null    }   if (actionSuffix.equals("ACTION_TRACK_STARTED")) {     handleTrackIntent.putExtra(EXTRA_PLAYING,true)    }  else   if (actionSuffix.equals("TRACK_COMPLETED") || actionSuffix.equals("ACTION_PAUSED")) {     handleTrackIntent.putExtra(EXTRA_PLAYING,false)    }  else {     Loggi.w("SonyEricssonMusicAppReceiver track info does not contains playing state, ignoring")      return null    }   handleTrackIntent.putExtra(EXTRA_ID,(long)originalIntent.getIntExtra("TRACK_ID",-1))    handleTrackIntent.putExtra(EXTRA_ALBUM_ID,(long)originalIntent.getIntExtra("ALBUM_ID",-1))    handleTrackIntent.putExtra(EXTRA_TRACK,originalIntent.getStringExtra("TRACK_NAME"))    handleTrackIntent.putExtra(EXTRA_ARTIST,originalIntent.getStringExtra("ARTIST_NAME"))    handleTrackIntent.putExtra(EXTRA_ALBUM,originalIntent.getStringExtra("ALBUM_NAME"))    handleTrackIntent.putExtra(EXTRA_DURATION,(long)originalIntent.getIntExtra("TRACK_DURATION",-1))    return handleTrackIntent  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   EasyTracker.getInstance(context).send(MapBuilder.createEvent("SpotifyReceiver","handleIntent",IntentUtil.getIntentAsString(originalIntent),0L).build())    return null  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   final Intent handleTrackIntent=super.handleIntent(context,originalIntent)    if (originalIntent.hasExtra(EXTRA_WAIL_PLAYER_PACKAGE_NAME)) {     try {       handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,originalIntent.getStringExtra(EXTRA_WAIL_PLAYER_PACKAGE_NAME))      }  catch (    Exception e) {       handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,"unknown")      }   }  else {     handleTrackIntent.putExtra(EXTRA_PLAYER_PACKAGE_NAME,"unknown")    }   return handleTrackIntent  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.nullsoft.winamp")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.vblast.xiialive.BETA")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.vblast.xiialive.FREE")  } 
@Override protected Intent handleIntent(Context context,Intent originalIntent){   return super.handleIntent(context,originalIntent).putExtra(EXTRA_PLAYER_PACKAGE_NAME,"com.vblast.xiialive.PRO")  } 
@Override public void onReceive(final Context context,Intent intent){   final Track track=WAILSettings.getNowScrobblingTrack(context)    if (track != null) {     AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){       @Override protected Void doInBackground(      Void... objects){         LovedTracksDBHelper.getInstance(context).add(track)          Intent intent=new Intent(context,WAILService.class)          intent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)          context.startService(intent)          return null        }       @Override protected void onPostExecute(      Void o){         StatusBarNotificationsManager.getInstance(context).showTrackLovedStatusBarNotification(track)        }     } )    } } 
@Override protected Void doInBackground(Void... objects){   LovedTracksDBHelper.getInstance(context).add(track)    Intent intent=new Intent(context,WAILService.class)    intent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)    context.startService(intent)    return null  } 
@Override protected void onPostExecute(Void o){   StatusBarNotificationsManager.getInstance(context).showTrackLovedStatusBarNotification(track)  } 
@Override public IBinder onBind(Intent intent){   return null  } 
@Override public void onCreate(){   super.onCreate()    Loggi.i("WAILService onCreate()")  } 
@Override public int onStartCommand(Intent intent,int flags,int startId){   Loggi.i("WAILService.onStartCommand() " + IntentUtil.getIntentAsString(intent))    ignoredPlayersDBHelper=IgnoredPlayersDBHelper.getInstance(getApplicationContext())    if (intent == null) {     return START_STICKY    }   final String action=intent.getAction()    if (action == null) {     return START_STICKY    }   if (!action.equals(INTENT_ACTION_HANDLE_PREVIOUSLY_IGNORED_TRACK)) {     lastIntent=intent    }   if (action.equals(INTENT_ACTION_HANDLE_TRACK)) {     handleTrack(intent)    }  else   if (action.equals(INTENT_ACTION_SCROBBLE_PENDING_TRACKS)) {     scrobblePendingTracks(false)      pushLovedTracks()    }  else   if (action.equals(INTENT_ACTION_HANDLE_PREVIOUSLY_IGNORED_TRACK)) {     handleTrack(lastIntent)    }  else   if (action.equals(INTENT_ACTION_HANDLE_LOVED_TRACKS)) {     pushLovedTracks()    }  else {   }   return START_STICKY  } 
private void updateWidget(@Nullable Track track){   RemoteViews remoteViews=new RemoteViews(getPackageName(),R.layout.waillove_widget)    AppWidgetManager appWidgetManager=AppWidgetManager.getInstance(getApplicationContext())    String trackText    String artistText    if (track == null) {     trackText=getString(R.string.main_now_scrobbling_label,"")      artistText=getString(R.string.main_now_scrobbling_nothing)      remoteViews.setBoolean(R.id.widget_love_current_track_button,"setEnabled",false)    }  else {     trackText=track.getTrack()      artistText=track.getArtist()      remoteViews.setBoolean(R.id.widget_love_current_track_button,"setEnabled",true)    }   remoteViews.setTextViewText(R.id.widget_infobox_track_text,trackText)    remoteViews.setTextViewText(R.id.widget_infobox_artist_text,artistText)    int[] widgetIds=appWidgetManager.getAppWidgetIds(new ComponentName(getApplicationContext(),WAILLoveWidget.class))    appWidgetManager.updateAppWidget(widgetIds,remoteViews)  } 
private void handleTrack(final Intent intent){   if (intent == null || !WAILSettings.isEnabled(this)) {     Loggi.w("WAILService track is not handled because WAIL is disabled")      return    }   final String player=intent.getStringExtra(CommonMusicAppReceiver.EXTRA_PLAYER_PACKAGE_NAME)    if (ignoredPlayersDBHelper.contains(player)) {     Loggi.w(String.format("WAILService track is not handled because the player %s is ignored",player))      return    }   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){     @Override protected Void doInBackground(    Void... params){       Loggi.i("\n\n----------\nWAILService track handling: " + intent)        mayBeCleanDB()        final String extraAction=intent.getStringExtra(CommonMusicAppReceiver.EXTRA_ACTION)        if (extraAction == null || extraAction.lastIndexOf('.') == -1) {         Loggi.e("Can not handle track without player package name")          return null        }       final boolean isCurrentTrackPlaying=intent.getBooleanExtra(CommonMusicAppReceiver.EXTRA_PLAYING,false)        final Track currentTrack=CommonMusicAppReceiver.parseFromIntentExtras(intent)        if (isCurrentTrackPlaying) {         WAILSettings.setNowScrobblingTrack(getApplicationContext(),currentTrack)          String applicationLabel=null          try {           PackageManager packageManager=getApplication().getPackageManager()            ApplicationInfo applicationInfo=packageManager.getApplicationInfo(player,0)            applicationLabel=packageManager.getApplicationLabel(applicationInfo).toString()          }  catch (        PackageManager.NameNotFoundException e) {           Loggi.w("Couldn't get player name from package name: " + player)          }         WAILSettings.setNowScrobblingPlayerLabel(getApplicationContext(),applicationLabel)          WAILSettings.setNowScrobblingPlayerPackageName(getApplicationContext(),player)          StatusBarNotificationsManager.getInstance(getApplicationContext()).showTrackScrobblingStatusBarNotification(currentTrack)          updateNowPlaying(currentTrack)          updateWidget(currentTrack)        }  else {         StatusBarNotificationsManager.getInstance(getApplicationContext()).hideTrackScrobblingStatusBarNotification()          WAILSettings.setNowScrobblingTrack(getApplicationContext(),null)          WAILSettings.setNowScrobblingPlayerPackageName(getApplicationContext(),null)          updateWidget(null)        }       LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(new Intent(TracksDBHelper.INTENT_TRACKS_CHANGED))        final LastCapturedTrackInfo mLastCapturedTrackInfo=WAILSettings.getLastCapturedTrackInfo(getApplicationContext())        if (mLastCapturedTrackInfo != null) {         final long trackPlayingDurationInMillis=currentTrack.getTimestamp() - mLastCapturedTrackInfo.getTrack().getTimestamp()          final long minTrackDurationInMillis=WAILSettings.getMinTrackDurationInSeconds(getApplicationContext()) * 1000          final int minTrackDurationInPercents=WAILSettings.getMinTrackDurationInPercents(getApplicationContext())          if ((!isCurrentTrackPlaying && mLastCapturedTrackInfo.isPlaying()) || mLastCapturedTrackInfo.isPlaying()) {           long duration=mLastCapturedTrackInfo.getTrack().getDuration()            if (duration != -1) {             final int trackDurationInPercents=(int)(100 * trackPlayingDurationInMillis / (duration + 2500))              if (trackDurationInPercents >= minTrackDurationInPercents && trackPlayingDurationInMillis >= minTrackDurationInMillis) {               scrobble(mLastCapturedTrackInfo,trackPlayingDurationInMillis,minTrackDurationInMillis,duration,minTrackDurationInPercents)              }  else {               skip(trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents,duration)              }           }  else           if (trackPlayingDurationInMillis >= minTrackDurationInMillis) {             Loggi.d("Duration of track not set, skipping checking mitTrackDurationInPercents")              scrobble(mLastCapturedTrackInfo,trackPlayingDurationInMillis,minTrackDurationInMillis,duration,minTrackDurationInPercents)            }  else {             skip(trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents,duration)            }         }  else {           Loggi.w("Skipping track")          }       }       WAILSettings.setLastCapturedTrackInfo(getApplicationContext(),new LastCapturedTrackInfo(currentTrack,isCurrentTrackPlaying))        return null      }     @Override protected void onPostExecute(    Void aVoid){       scrobblePendingTracks(false)      }     private void scrobble(    LastCapturedTrackInfo mLastCapturedTrackInfo,    long trackPlayingDurationInMillis,    long minTrackDurationInMillis,    long duration,    int minTrackDurationInPercents){       Loggi.i(String.format("Adding track to DB. Duration: %s ms, playing for: %s ms, minTrackDurationInMillis: %s," + " minTrackDurationInPercents: %s",duration,trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents))        addTrackToDB(mLastCapturedTrackInfo.getTrack())        SoundNotificationsManager.getInstance(getApplicationContext()).playTrackMarkedAsScrobbledSound()      }     private void skip(    long trackPlayingDurationInMillis,    long minTrackDurationInMillis,    int minTrackDurationInPercents,    long duration){       Loggi.i(String.format("Skipping track. Duration: %s ms, playing for: %s ms, minTrackDurationInMillis: %s," + " minTrackDurationInPercents: %s",duration,trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents))        SoundNotificationsManager.getInstance(getApplicationContext()).playTrackSkippedSound()      }   } )  } 
@Override protected Void doInBackground(Void... params){   Loggi.i("\n\n----------\nWAILService track handling: " + intent)    mayBeCleanDB()    final String extraAction=intent.getStringExtra(CommonMusicAppReceiver.EXTRA_ACTION)    if (extraAction == null || extraAction.lastIndexOf('.') == -1) {     Loggi.e("Can not handle track without player package name")      return null    }   final boolean isCurrentTrackPlaying=intent.getBooleanExtra(CommonMusicAppReceiver.EXTRA_PLAYING,false)    final Track currentTrack=CommonMusicAppReceiver.parseFromIntentExtras(intent)    if (isCurrentTrackPlaying) {     WAILSettings.setNowScrobblingTrack(getApplicationContext(),currentTrack)      String applicationLabel=null      try {       PackageManager packageManager=getApplication().getPackageManager()        ApplicationInfo applicationInfo=packageManager.getApplicationInfo(player,0)        applicationLabel=packageManager.getApplicationLabel(applicationInfo).toString()      }  catch (    PackageManager.NameNotFoundException e) {       Loggi.w("Couldn't get player name from package name: " + player)      }     WAILSettings.setNowScrobblingPlayerLabel(getApplicationContext(),applicationLabel)      WAILSettings.setNowScrobblingPlayerPackageName(getApplicationContext(),player)      StatusBarNotificationsManager.getInstance(getApplicationContext()).showTrackScrobblingStatusBarNotification(currentTrack)      updateNowPlaying(currentTrack)      updateWidget(currentTrack)    }  else {     StatusBarNotificationsManager.getInstance(getApplicationContext()).hideTrackScrobblingStatusBarNotification()      WAILSettings.setNowScrobblingTrack(getApplicationContext(),null)      WAILSettings.setNowScrobblingPlayerPackageName(getApplicationContext(),null)      updateWidget(null)    }   LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(new Intent(TracksDBHelper.INTENT_TRACKS_CHANGED))    final LastCapturedTrackInfo mLastCapturedTrackInfo=WAILSettings.getLastCapturedTrackInfo(getApplicationContext())    if (mLastCapturedTrackInfo != null) {     final long trackPlayingDurationInMillis=currentTrack.getTimestamp() - mLastCapturedTrackInfo.getTrack().getTimestamp()      final long minTrackDurationInMillis=WAILSettings.getMinTrackDurationInSeconds(getApplicationContext()) * 1000      final int minTrackDurationInPercents=WAILSettings.getMinTrackDurationInPercents(getApplicationContext())      if ((!isCurrentTrackPlaying && mLastCapturedTrackInfo.isPlaying()) || mLastCapturedTrackInfo.isPlaying()) {       long duration=mLastCapturedTrackInfo.getTrack().getDuration()        if (duration != -1) {         final int trackDurationInPercents=(int)(100 * trackPlayingDurationInMillis / (duration + 2500))          if (trackDurationInPercents >= minTrackDurationInPercents && trackPlayingDurationInMillis >= minTrackDurationInMillis) {           scrobble(mLastCapturedTrackInfo,trackPlayingDurationInMillis,minTrackDurationInMillis,duration,minTrackDurationInPercents)          }  else {           skip(trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents,duration)          }       }  else       if (trackPlayingDurationInMillis >= minTrackDurationInMillis) {         Loggi.d("Duration of track not set, skipping checking mitTrackDurationInPercents")          scrobble(mLastCapturedTrackInfo,trackPlayingDurationInMillis,minTrackDurationInMillis,duration,minTrackDurationInPercents)        }  else {         skip(trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents,duration)        }     }  else {       Loggi.w("Skipping track")      }   }   WAILSettings.setLastCapturedTrackInfo(getApplicationContext(),new LastCapturedTrackInfo(currentTrack,isCurrentTrackPlaying))    return null  } 
@Override protected void onPostExecute(Void aVoid){   scrobblePendingTracks(false)  } 
private void scrobble(LastCapturedTrackInfo mLastCapturedTrackInfo,long trackPlayingDurationInMillis,long minTrackDurationInMillis,long duration,int minTrackDurationInPercents){   Loggi.i(String.format("Adding track to DB. Duration: %s ms, playing for: %s ms, minTrackDurationInMillis: %s," + " minTrackDurationInPercents: %s",duration,trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents))    addTrackToDB(mLastCapturedTrackInfo.getTrack())    SoundNotificationsManager.getInstance(getApplicationContext()).playTrackMarkedAsScrobbledSound()  } 
private void skip(long trackPlayingDurationInMillis,long minTrackDurationInMillis,int minTrackDurationInPercents,long duration){   Loggi.i(String.format("Skipping track. Duration: %s ms, playing for: %s ms, minTrackDurationInMillis: %s," + " minTrackDurationInPercents: %s",duration,trackPlayingDurationInMillis,minTrackDurationInMillis,minTrackDurationInPercents))    SoundNotificationsManager.getInstance(getApplicationContext()).playTrackSkippedSound()  } 
private synchronized void addTrackToDB(com.artemzin.android.wail.storage.model.Track track){   com.artemzin.android.wail.storage.model.Track lastAddedTrack=TracksDBHelper.getInstance(getApplicationContext()).getLastAddedTrack()    if (lastAddedTrack != null) {     final long pauseBetweenTracksInSeconds=(track.getTimestamp() - lastAddedTrack.getTimestamp()) / 1000      if (pauseBetweenTracksInSeconds < 10) {       Loggi.w("Too small pause between tracks " + pauseBetweenTracksInSeconds + " seconds, skipping track: "+ track)        return      }  else {       Loggi.w("Pause between tracks is ok " + pauseBetweenTracksInSeconds + " seconds")      }   }   if (TextUtils.isEmpty(track.getArtist()) || TextUtils.isEmpty(track.getTrack())) {     Loggi.w("Skipping track without name or artist")      return    }   if (TracksDBHelper.getInstance(WAILService.this).add(track) != -1) {     WAILSettings.setTotalHandledTracksCount(WAILService.this,WAILSettings.getTotalHandledTracksCount(WAILService.this) + 1)      Loggi.w("Track has been written to db: " + track)      SoundNotificationsManager.getInstance(getApplicationContext()).playTrackMarkedAsScrobbledSound()    }  else {     Loggi.e("Track was not written to db: " + track)    } } 
private void scrobblePendingTracks(boolean forceScrobble){   if (!forceScrobble && (lastScrobbleTime != 0 && SystemClock.elapsedRealtime() - lastScrobbleTime < 30000)) {     Loggi.w("WAILService lastScrobble request was less than 30 seconds from current, skipping scrobble")      return    }   if (!NetworkUtil.isAvailable(this)) {     Loggi.e("WAILService scrobblePendingTracks() stopped, network is not available")      return    }  else   if (!WAILSettings.isEnableScrobblingOverMobileNetwork(getApplicationContext()) && NetworkUtil.isMobileNetwork(this)) {     Loggi.e("WAILService scrobblePendingTracks() stopped, scrobbling over mobile network disabled")      return    }   lastScrobbleTime=SystemClock.elapsedRealtime()    AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){     @Override protected void onPreExecute(){       Loggi.w("WAILService going to scrobble pending tracks to Last.fm")      }     @Override protected Void doInBackground(    Void... params){       TracksDBHelper tracksDBHelper=TracksDBHelper.getInstance(getApplicationContext())        Cursor tracksCursor=tracksDBHelper.getAllDesc()        final List<com.artemzin.android.wail.storage.model.Track> tracksToScrobbleListForDB=new ArrayList<>()        final List<LFTrackRequestModel> tracksToScrobbleForApiRequest=new ArrayList<>()        boolean isTracksToScrobbleCountMoreThanMaxForRequest=false        if (tracksCursor.getCount() == 0) {         Loggi.w("Nothing to scrobble")          tracksCursor.close()          return null        }       if (tracksCursor.moveToFirst()) {         do {           com.artemzin.android.wail.storage.model.Track track=TracksDBHelper.parseFromCursor(tracksCursor)            if (TextUtils.isEmpty(track.getArtist()) || TextUtils.isEmpty(track.getTrack())) {             Loggi.w("Removing track without name or artist from database")              tracksDBHelper.delete(track)              continue            }           if (tracksToScrobbleForApiRequest.size() >= 48) {             isTracksToScrobbleCountMoreThanMaxForRequest=true              break            }           if (track.getState() == com.artemzin.android.wail.storage.model.Track.STATE_WAITING_FOR_SCROBBLE || track.getState() == com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR) {             track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLING)              track.setStateTimestamp(System.currentTimeMillis())              tracksToScrobbleListForDB.add(track)              tracksToScrobbleForApiRequest.add(new LFTrackRequestModel(track))            }         }  while (tracksCursor.moveToNext())        }       tracksCursor.close()        if (tracksToScrobbleListForDB.size() != 0) {         TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)        }       if (tracksToScrobbleForApiRequest.size() == 0) {         Loggi.w("WAILService all tracks marked as scrobbled, skipping scrobble")          return null        }       try {         final LFScrobbleResponseModel result=LFTrackApi.scrobble(WAILSettings.getLastfmSessionKey(WAILService.this),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),tracksToScrobbleForApiRequest)          Loggi.w("WAILService tracks scrobbling succeed! Response: " + result)          for (        com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {           track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_SUCCESS)            track.setStateTimestamp(System.currentTimeMillis())          }         TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)          EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"success",null,(long)tracksToScrobbleListForDB.size()).build())          if (isTracksToScrobbleCountMoreThanMaxForRequest) {           Loggi.w("scrobble started again with force flag, because tracks count > max tracks per request")            EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"started again because counts of track was too big",null,0L).build())            scrobblePendingTracks(true)          }       }  catch (      NetworkException e) {         Loggi.e("WAILService tracks scrobbling to Last.fm failed with network error: " + e.getMessage())          for (        com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {           track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR)            track.setStateTimestamp(System.currentTimeMillis())          }         TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)          EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"failed with NetworkException: " + e.getMessage(),null,0L).build())        } catch (      LFApiException e) {         handleSessionKeyInvalidError(e)          Loggi.e("WAILService tracks scrobbling to Last.fm failed with api error: " + e.getMessage())          for (        com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {           track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR)            track.setStateTimestamp(System.currentTimeMillis())          }         TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)          EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"failed with LFApiException: " + e.getMessage(),null,0L).build())        }       return null      }   } )  } 
@Override protected void onPreExecute(){   Loggi.w("WAILService going to scrobble pending tracks to Last.fm")  } 
@Override protected Void doInBackground(Void... params){   TracksDBHelper tracksDBHelper=TracksDBHelper.getInstance(getApplicationContext())    Cursor tracksCursor=tracksDBHelper.getAllDesc()    final List<com.artemzin.android.wail.storage.model.Track> tracksToScrobbleListForDB=new ArrayList<>()    final List<LFTrackRequestModel> tracksToScrobbleForApiRequest=new ArrayList<>()    boolean isTracksToScrobbleCountMoreThanMaxForRequest=false    if (tracksCursor.getCount() == 0) {     Loggi.w("Nothing to scrobble")      tracksCursor.close()      return null    }   if (tracksCursor.moveToFirst()) {     do {       com.artemzin.android.wail.storage.model.Track track=TracksDBHelper.parseFromCursor(tracksCursor)        if (TextUtils.isEmpty(track.getArtist()) || TextUtils.isEmpty(track.getTrack())) {         Loggi.w("Removing track without name or artist from database")          tracksDBHelper.delete(track)          continue        }       if (tracksToScrobbleForApiRequest.size() >= 48) {         isTracksToScrobbleCountMoreThanMaxForRequest=true          break        }       if (track.getState() == com.artemzin.android.wail.storage.model.Track.STATE_WAITING_FOR_SCROBBLE || track.getState() == com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR) {         track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLING)          track.setStateTimestamp(System.currentTimeMillis())          tracksToScrobbleListForDB.add(track)          tracksToScrobbleForApiRequest.add(new LFTrackRequestModel(track))        }     }  while (tracksCursor.moveToNext())    }   tracksCursor.close()    if (tracksToScrobbleListForDB.size() != 0) {     TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)    }   if (tracksToScrobbleForApiRequest.size() == 0) {     Loggi.w("WAILService all tracks marked as scrobbled, skipping scrobble")      return null    }   try {     final LFScrobbleResponseModel result=LFTrackApi.scrobble(WAILSettings.getLastfmSessionKey(WAILService.this),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),tracksToScrobbleForApiRequest)      Loggi.w("WAILService tracks scrobbling succeed! Response: " + result)      for (    com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {       track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_SUCCESS)        track.setStateTimestamp(System.currentTimeMillis())      }     TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)      EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"success",null,(long)tracksToScrobbleListForDB.size()).build())      if (isTracksToScrobbleCountMoreThanMaxForRequest) {       Loggi.w("scrobble started again with force flag, because tracks count > max tracks per request")        EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"started again because counts of track was too big",null,0L).build())        scrobblePendingTracks(true)      }   }  catch (  NetworkException e) {     Loggi.e("WAILService tracks scrobbling to Last.fm failed with network error: " + e.getMessage())      for (    com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {       track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR)        track.setStateTimestamp(System.currentTimeMillis())      }     TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)      EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"failed with NetworkException: " + e.getMessage(),null,0L).build())    } catch (  LFApiException e) {     handleSessionKeyInvalidError(e)      Loggi.e("WAILService tracks scrobbling to Last.fm failed with api error: " + e.getMessage())      for (    com.artemzin.android.wail.storage.model.Track track : tracksToScrobbleListForDB) {       track.setState(com.artemzin.android.wail.storage.model.Track.STATE_SCROBBLE_ERROR)        track.setStateTimestamp(System.currentTimeMillis())      }     TracksDBHelper.getInstance(WAILService.this).updateAll(tracksToScrobbleListForDB)      EasyTracker.getInstance(WAILService.this).send(MapBuilder.createEvent(GA_EVENT_SCROBBLE_TO_THE_LASTFM,"failed with LFApiException: " + e.getMessage(),null,0L).build())    }   return null  } 
private synchronized void updateNowPlaying(Track track){   if (track == null) {     Loggi.w("WAILService.updateNowPlaying() track is null, skipping")      return    }   if (!NetworkUtil.isAvailable(getApplicationContext())) {     Loggi.w("WAILService.updateNowPlaying() network is not available, update skipped: " + track)      return    }  else   if (!WAILSettings.isEnableScrobblingOverMobileNetwork(getApplicationContext()) && NetworkUtil.isMobileNetwork(getApplicationContext())) {     Loggi.w("WAILService.updateNowPlaying() scrobbling over mobile network is disabled, update skipped: " + track)      return    }   final Track mLastUpdatedNowPlayingTrackInfo=lastUpdatedNowPlayingTrackInfo    if (mLastUpdatedNowPlayingTrackInfo != null) {     if (System.currentTimeMillis() - mLastUpdatedNowPlayingTrackInfo.getStateTimestamp() < 10000 && mLastUpdatedNowPlayingTrackInfo.specialEquals(track)) {       Loggi.w("WAILService.updateNowPlaying() skipping nowplaying update, too small pause for track: " + track)        return      }   }   lastUpdatedNowPlayingTrackInfo=track.copy()    lastUpdatedNowPlayingTrackInfo.setStateTimestamp(System.currentTimeMillis())    if (WAILSettings.isLastfmNowplayingUpdateEnabled(getApplicationContext())) {     updateLastfmNowplaying(track)    }  else {     Loggi.w("WAILService.updateNowPlaying() last.fm nowplaying updates disabled, skipping track: " + track)    } } 
private synchronized void updateLastfmNowplaying(final com.artemzin.android.wail.storage.model.Track track){   Loggi.i("WAILService going to update last.fm nowplaying with track: " + track)    AsyncTaskExecutor.executeConcurrently(new AsyncTask<Object,Object,Object>(){     @Override protected Object doInBackground(    Object... params){       try {         final LFTrackRequestModel trackForRequest=new LFTrackRequestModel(track)          if (trackForRequest.getDuration() == null || trackForRequest.getDuration() <= 0) {           trackForRequest.setDuration(DEFAULT_TRACK_DURATION_IF_UNKNOWN_SECONDS)          }         Loggi.w("Result: " + LFTrackApi.updateNowPlaying(WAILSettings.getLastfmSessionKey(getApplicationContext()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),trackForRequest))          EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"success",null,1L).build())        }  catch (      NetworkException e) {         Loggi.e("Can not update last.fm nowplaying with track: " + track + ", exception: "+ e.getMessage())          EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with NetworkException: " + e.getMessage(),null,0L).build())        } catch (      LFApiException e) {         handleSessionKeyInvalidError(e)          Loggi.e("Can not update last.fm nowplaying with track: " + track + ", exception: "+ e.getMessage())          EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with LFApiException: " + e.getMessage(),null,0L).build())        }       return null      }   } )  } 
@Override protected Object doInBackground(Object... params){   try {     final LFTrackRequestModel trackForRequest=new LFTrackRequestModel(track)      if (trackForRequest.getDuration() == null || trackForRequest.getDuration() <= 0) {       trackForRequest.setDuration(DEFAULT_TRACK_DURATION_IF_UNKNOWN_SECONDS)      }     Loggi.w("Result: " + LFTrackApi.updateNowPlaying(WAILSettings.getLastfmSessionKey(getApplicationContext()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),trackForRequest))      EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"success",null,1L).build())    }  catch (  NetworkException e) {     Loggi.e("Can not update last.fm nowplaying with track: " + track + ", exception: "+ e.getMessage())      EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with NetworkException: " + e.getMessage(),null,0L).build())    } catch (  LFApiException e) {     handleSessionKeyInvalidError(e)      Loggi.e("Can not update last.fm nowplaying with track: " + track + ", exception: "+ e.getMessage())      EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with LFApiException: " + e.getMessage(),null,0L).build())    }   return null  } 
private void mayBeCleanDB(){   if (new Random(System.currentTimeMillis()).nextInt(100) > 70) {     try {       final int removedTracksCount=TracksDBHelper.getInstance(getApplicationContext()).removeOldOrInconsistentTracks(200)        Loggi.w("Removed old tracks, count: " + removedTracksCount)      }  catch (    Exception e) {       Loggi.e("Could not remove old tracks: " + e.getMessage())        EasyTracker.getInstance(getApplication()).send(MapBuilder.createException("removeOldOrInconsistentTracks failed: " + e.getMessage(),false).build())      }   } } 
private void pushLovedTracks(){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){     private void loveTrack(    Track track){       if (track != null) {         Loggi.i("Wail is going to love track: " + track)          LFTrackRequestModel trackForRequest=new LFTrackRequestModel(track)          try {           Loggi.w("Result: " + LFTrackApi.love(WAILSettings.getLastfmSessionKey(getApplicationContext()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),trackForRequest))            LovedTracksDBHelper.getInstance(getApplicationContext()).delete(track)            EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_LOVE_TRACK,"success",null,1L).build())          }  catch (        NetworkException e) {           Loggi.e("Can not love track: " + track + ", exception: "+ e.getMessage())            EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_LOVE_TRACK,"failed with NetworkException: " + e.getMessage(),null,0L).build())          } catch (        LFApiException e) {           handleSessionKeyInvalidError(e)            Loggi.e("Can not love track: " + track + ", exception: "+ e.getMessage())            EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with LFApiException: " + e.getMessage(),null,0L).build())          }       }     }     @Override protected Void doInBackground(    Void... params){       LovedTracksDBHelper lovedTracksDBHelper=LovedTracksDBHelper.getInstance(getApplicationContext())        Cursor tracksCursor=lovedTracksDBHelper.getAllDesc()        if (tracksCursor.moveToFirst()) {         do {           Track track=LovedTracksDBHelper.parseFromCursor(tracksCursor)            if (TextUtils.isEmpty(track.getArtist()) || TextUtils.isEmpty(track.getTrack())) {             Loggi.w("Removing track without name or artist from loved tracks database")              lovedTracksDBHelper.delete(track)              continue            }           loveTrack(track)          }  while (tracksCursor.moveToNext())        }       SystemClock.sleep(1500)        return null      }     @Override protected void onPostExecute(    Void aVoid){       StatusBarNotificationsManager.getInstance(getApplicationContext()).hideTrackLovedStatusBarNotification()      }   } )  } 
private void loveTrack(Track track){   if (track != null) {     Loggi.i("Wail is going to love track: " + track)      LFTrackRequestModel trackForRequest=new LFTrackRequestModel(track)      try {       Loggi.w("Result: " + LFTrackApi.love(WAILSettings.getLastfmSessionKey(getApplicationContext()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),trackForRequest))        LovedTracksDBHelper.getInstance(getApplicationContext()).delete(track)        EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_LOVE_TRACK,"success",null,1L).build())      }  catch (    NetworkException e) {       Loggi.e("Can not love track: " + track + ", exception: "+ e.getMessage())        EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_LOVE_TRACK,"failed with NetworkException: " + e.getMessage(),null,0L).build())      } catch (    LFApiException e) {       handleSessionKeyInvalidError(e)        Loggi.e("Can not love track: " + track + ", exception: "+ e.getMessage())        EasyTracker.getInstance(getApplicationContext()).send(MapBuilder.createEvent(GA_EVENT_UPDATE_LASTFM_NOW_PLAYING,"failed with LFApiException: " + e.getMessage(),null,0L).build())      }   } } 
@Override protected Void doInBackground(Void... params){   LovedTracksDBHelper lovedTracksDBHelper=LovedTracksDBHelper.getInstance(getApplicationContext())    Cursor tracksCursor=lovedTracksDBHelper.getAllDesc()    if (tracksCursor.moveToFirst()) {     do {       Track track=LovedTracksDBHelper.parseFromCursor(tracksCursor)        if (TextUtils.isEmpty(track.getArtist()) || TextUtils.isEmpty(track.getTrack())) {         Loggi.w("Removing track without name or artist from loved tracks database")          lovedTracksDBHelper.delete(track)          continue        }       loveTrack(track)      }  while (tracksCursor.moveToNext())    }   SystemClock.sleep(1500)    return null  } 
@Override protected void onPostExecute(Void aVoid){   StatusBarNotificationsManager.getInstance(getApplicationContext()).hideTrackLovedStatusBarNotification()  } 
private void handleSessionKeyInvalidError(LFApiException exception){   if (LFApiException.ERROR_INVALID_SESSION_KEY.equals(exception.getError())) {     sendBroadcast(new Intent(BaseActivity.ACTION_INVALID_SESSION_KEY))    } } 
public LastCapturedTrackInfo(com.artemzin.android.wail.storage.model.Track track,boolean isPlaying){   this.track=track    this.isPlaying=isPlaying  } 
public com.artemzin.android.wail.storage.model.Track getTrack(){   return track  } 
public boolean isPlaying(){   return isPlaying  } 
public String toJSON(){   final JSONObject json=new JSONObject()    try {     json.put("playerPackageName",track.getPlayerPackageName())      json.put("track",track.getTrack())      json.put("artist",track.getArtist())      json.put("album",track.getAlbum())      json.put("duration",track.getDuration())      json.put("timestamp",track.getTimestamp())      json.put("state",track.getState())      json.put("stateTimestamp",track.getStateTimestamp())      json.put("isPlaying",isPlaying)    }  catch (  Exception e) {     return null    }   return json.toString()  } 
public static LastCapturedTrackInfo fromJSON(String jsonString){   try {     final JSONObject json=new JSONObject(jsonString)      final com.artemzin.android.wail.storage.model.Track track=new com.artemzin.android.wail.storage.model.Track()      track.setPlayerPackageName(json.optString("playerPackageName"))      track.setTrack(json.optString("track"))      track.setArtist(json.optString("artist"))      track.setAlbum(json.optString("album"))      track.setDuration(json.optLong("duration"))      track.setTimestamp(json.optLong("timestamp"))      track.setState(json.optInt("state"))      track.setStateTimestamp(json.optLong("stateTimestamp"))      return new LastCapturedTrackInfo(track,json.optBoolean("isPlaying"))    }  catch (  Exception e) {     return null    } } 
private AppDBManager(Context context){   super(context,DB_NAME,null,DB_VERSION)    this.context=context  } 
public static AppDBManager getInstance(Context context){   if (instance == null) { synchronized (AppDBManager.class) {       if (instance == null) {         instance=new AppDBManager(context.getApplicationContext())        }     }   }   return instance  } 
@Override public void onCreate(SQLiteDatabase db){   db.execSQL(TracksDBHelper.TableInfo.CREATE_TABLE_QUERY)    db.execSQL(PlayersDBHelper.TableInfo.CREATE_TABLE_QUERY)    db.execSQL(LovedTracksDBHelper.TableInfo.CREATE_TABLE_QUERY)    db.execSQL(IgnoredPlayersDBHelper.TableInfo.CREATE_TABLE_QUERY)  } 
@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){ switch (oldVersion) { case 1:     db.execSQL(LovedTracksDBHelper.TableInfo.CREATE_TABLE_QUERY)  case 2:   db.execSQL(IgnoredPlayersDBHelper.TableInfo.CREATE_TABLE_QUERY)  } } 
@Override public synchronized void close(){   super.close()    instance=null  } 
public static Boolean convertIntegerToBoolean(int value){   if (value < 0)   return false    if (value > 0)   return true   else   return null  } 
public static int convertBooleanToInteger(Boolean value){   if (value == null)   return 0    return value ? 1 : -1  } 
public void clearAll(){   PlayersDBHelper.getInstance(context).removeAll()    TracksDBHelper.getInstance(context).deleteAll()    LovedTracksDBHelper.getInstance(context).deleteAll()    IgnoredPlayersDBHelper.getInstance(context).deleteAll()  } 
private IgnoredPlayersDBHelper(Context context){   this.context=context  } 
public static IgnoredPlayersDBHelper getInstance(Context context){   if (instance == null) { synchronized (IgnoredPlayersDBHelper.class) {       if (instance == null) {         instance=new IgnoredPlayersDBHelper(context)        }     }   }   return instance  } 
public synchronized long add(String packageName){   ContentValues contentValues=new ContentValues()    contentValues.put(TableInfo.COLUMN_PACKAGE_NAME,packageName)    final long rowId=AppDBManager.getInstance(context).getWritableDatabase().insert(TableInfo.TABLE_NAME,null,contentValues)    if (rowId == -1) {     Loggi.e("IgnoredPlayersDBHelper can not add ignored player: " + packageName)    }   return rowId  } 
public synchronized List<ApplicationInfo> getAll(){   List<ApplicationInfo> result=new ArrayList<>()    Cursor cursor=AppDBManager.getInstance(context).getReadableDatabase().query(false,TableInfo.TABLE_NAME,new String[]{TableInfo.COLUMN_PACKAGE_NAME},null,null,null,null,null,null)    if (cursor.moveToFirst()) {     while (!cursor.isAfterLast()) {       String packageName=cursor.getString(TableInfo.NUM_COLUMN_PACKAGE_NAME)        ApplicationInfo applicationInfo        try {         applicationInfo=context.getPackageManager().getApplicationInfo(packageName,0)        }  catch (      PackageManager.NameNotFoundException e) {         Loggi.w("IgnoredPlayersDBHelper could not get application info: " + packageName)          applicationInfo=new ApplicationInfo()          applicationInfo.packageName=packageName        }       result.add(applicationInfo)        cursor.moveToNext()      }   }   cursor.close()    return result  } 
public synchronized boolean contains(String packageName){   return AppDBManager.getInstance(context).getReadableDatabase().query(TableInfo.TABLE_NAME,new String[]{TableInfo.COLUMN_PACKAGE_NAME},TableInfo.COLUMN_PACKAGE_NAME + "=?",new String[]{String.valueOf(packageName)},null,null,null).getCount() >= 1  } 
public synchronized int deleteAll(){   return AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,null,null)  } 
public synchronized int delete(String packageName){   return AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,TableInfo.COLUMN_PACKAGE_NAME + "=?",new String[]{String.valueOf(packageName)})  } 
private LovedTracksDBHelper(Context context){   this.context=context  } 
public static LovedTracksDBHelper getInstance(Context context){   if (instance == null) { synchronized (LovedTracksDBHelper.class) {       if (instance == null) {         instance=new LovedTracksDBHelper(context)        }     }   }   return instance  } 
public synchronized long add(Track track){   ContentValues contentValues=asContentValues(track)    final long rowId=AppDBManager.getInstance(context).getWritableDatabase().insert(TableInfo.TABLE_NAME,null,contentValues)    if (rowId == -1) {     Loggi.e("LovedTracksDBHelper can not add track info, track: " + track)    }   return rowId  } 
public synchronized Cursor getAllDesc(){   return AppDBManager.getInstance(context).getReadableDatabase().query(TableInfo.TABLE_NAME,null,null,null,null,null,TableInfo.COLUMN_INTERNAL_ID + " DESC")  } 
public synchronized int deleteAll(){   final int count=AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,null,null)    return count  } 
public synchronized int delete(Track track){   return AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,TableInfo.COLUMN_INTERNAL_ID + "=?",new String[]{String.valueOf(track.getInternalDBId())})  } 
public static Track parseFromCursor(Cursor cursor){   final Track track=new Track()    track.setInternalDBId(cursor.getLong(TableInfo.NUM_COLUMN_INTERNAL_ID))    track.setTrack(cursor.getString(TableInfo.NUM_COLUMN_TRACK))    track.setArtist(cursor.getString(TableInfo.NUM_COLUMN_ARTIST))    return track  } 
private static ContentValues asContentValues(Track track){   final ContentValues contentValues=new ContentValues()    contentValues.put(TableInfo.COLUMN_TRACK,track.getTrack())    contentValues.put(TableInfo.COLUMN_ARTIST,track.getArtist())    return contentValues  } 
public Player(){ } 
public Player(String packageName,String displayName,String link){   this.packageName=packageName    this.displayName=displayName    this.link=link    this.isEnabled=true  } 
public String getPackageName(){   return packageName  } 
public Player setPackageName(String packageName){   this.packageName=packageName    return this  } 
public boolean isEnabled(){   return isEnabled  } 
public Player setEnabled(boolean isEnabled){   this.isEnabled=isEnabled    return this  } 
public String getDisplayName(){   return displayName  } 
public Player setDisplayName(String displayName){   this.displayName=displayName    return this  } 
public int getScrobbledTracksCount(){   return scrobbledTracksCount  } 
public Player setScrobbledTracksCount(int scrobbledTracksCount){   this.scrobbledTracksCount=scrobbledTracksCount    return this  } 
public String getLink(){   return link  } 
public Player setLink(String link){   this.link=link    return this  } 
private PlayersDBHelper(Context context){   this.context=context.getApplicationContext()  } 
public static PlayersDBHelper getInstance(Context context){   if (instance == null) { synchronized (PlayersDBHelper.class) {       if (instance == null) {         instance=new PlayersDBHelper(context)        }     }   }   return instance  } 
public synchronized boolean add(Player player){   final ContentValues contentValues=new ContentValues()    contentValues.put(TableInfo.COLUMN_PACKAGE_NAME,player.getPackageName())    contentValues.put(TableInfo.COLUMN_IS_ENABLED,player.isEnabled())    contentValues.put(TableInfo.COLUMN_DISPLAY_NAME,player.getDisplayName())    contentValues.put(TableInfo.COLUMN_SCROBBLED_TRACKS_COUNT,player.getScrobbledTracksCount())    contentValues.put(TableInfo.COLUMN_LINK,player.getLink())    return AppDBManager.getInstance(context).getWritableDatabase().insert(TableInfo.TABLE_NAME,null,contentValues) != -1  } 
public synchronized Player findPlayerByPackageName(String packageName){   final Cursor cursor=AppDBManager.getInstance(context).getReadableDatabase().query(TableInfo.TABLE_NAME,null,TableInfo.COLUMN_PACKAGE_NAME + " = ?",new String[]{packageName},null,null,TableInfo.COLUMN_ID)    Player player=null    if (cursor.moveToFirst()) {     player=parseFromCursor(cursor)    }   cursor.close()    return player  } 
public synchronized List<Player> getAll(){   final Cursor cursor=AppDBManager.getInstance(context).getReadableDatabase().query(TableInfo.TABLE_NAME,null,null,null,null,null,TableInfo.COLUMN_ID)    final List<Player> players=new ArrayList<Player>(cursor.getCount())    if (cursor.moveToFirst()) {     do {       players.add(parseFromCursor(cursor))      }  while (cursor.moveToNext())    }   cursor.close()    return players  } 
public synchronized int removeAll(){   return AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,null,null)  } 
private static Player parseFromCursor(Cursor cursor){   final Player player=new Player()    player.setPackageName(cursor.getString(TableInfo.NUM_COLUMN_PACKAGE_NAME))    player.setEnabled(cursor.getInt(TableInfo.NUM_COLUMN_IS_ENABLED) == TableInfo.DEFAULT_COLUMN_IS_ENABLED)    player.setDisplayName(cursor.getString(TableInfo.NUM_COLUMN_DISPLAY_NAME))    player.setScrobbledTracksCount(cursor.getInt(TableInfo.NUM_COLUMN_SCROBBLED_TRACKS_COUNT))    player.setLink(cursor.getString(TableInfo.NUM_COLUMN_LINK))    return player  } 
public synchronized void updateSupportedPlayers(){   final Player[] defaultSupportedPlayers={new Player("com.maxmpz.audioplayer","Poweramp","https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer"),new Player("com.jrtstudio.music","Android music player (not standard!)","https://play.google.com/store/apps/details?id=com.jrtstudio.music"),new Player("com.htc.music","HTC Music player",null),new Player("com.miui.player","MIU player","http://en.miui.com/"),new Player("com.sonyericsson.music","Sony music player",null),new Player("com.rdio.android","Rdio","https://play.google.com/store/apps/details?id=com.rdio.android.ui"),new Player("com.samsung.sec.android.MusicPlayer","Samsung music player",null),new Player("com.sec.android.app.music","Samsung music player (another one)",null),new Player("com.nullsoft.winamp","Winamp","https://play.google.com/store/apps/details?id=com.nullsoft.winamp"),new Player("com.amazon.mp3","Amazon MP3  play and download","https://play.google.com/store/apps/details?id=com.amazon.mp3"),new Player("com.rhapsody","Rhapsody","https://play.google.com/store/apps/details?id=com.rhapsody"),new Player("com.andrew.appolo","Appolo music player (CyanogenMod)","https://f-droid.org/wiki/page/com.andrew.apollo"),new Player("com.android.music","Android default music player",null),new Player("com.jetappfactory.jetaudio","jetAudio music player","https://play.google.com/store/apps/details?id=com.jetappfactory.jetaudio"),new Player("com.tbig.playerprotrial","PlayerPro Trial Music Player","https://play.google.com/store/apps/details?id=com.tbig.playerprotrial"),new Player("com.tbig.playerpro","PlayerPro Music Player","https://play.google.com/store/apps/details?id=com.tbig.playerpro"),new Player("com.lge.music","LG music player",null)}    AppDBManager.getInstance(context).getWritableDatabase().beginTransaction()    try {     for (    Player defaultSupportedPlayer : defaultSupportedPlayers) {       if (findPlayerByPackageName(defaultSupportedPlayer.getPackageName()) == null) {         add(defaultSupportedPlayer)        }     }     AppDBManager.getInstance(context).getWritableDatabase().setTransactionSuccessful()    }  catch (  Exception e) {     EasyTracker.getInstance(context).send(MapBuilder.createException("Can not update supported players: " + e.getMessage(),false).build())      Loggi.e("Can not update supported players: " + e.getMessage())    }  finally {     AppDBManager.getInstance(context).getWritableDatabase().endTransaction()    } } 
private TracksDBHelper(Context context){   this.context=context.getApplicationContext()  } 
public static TracksDBHelper getInstance(Context context){   if (instance == null) { synchronized (TracksDBHelper.class) {       if (instance == null) {         instance=new TracksDBHelper(context)        }     }   }   return instance  } 
public synchronized long add(Track track){   ContentValues contentValues=asContentValues(track)    final long rowId=AppDBManager.getInstance(context).getWritableDatabase().insert(TableInfo.TABLE_NAME,null,contentValues)    if (rowId == -1) {     Loggi.e("TracksDBHelper can not add track info, track: " + track)    }   sendBroadcastTracksChanged()    return rowId  } 
public synchronized boolean update(Track track){   ContentValues contentValues=asContentValues(track)    final boolean result=AppDBManager.getInstance(context).getWritableDatabase().update(TableInfo.TABLE_NAME,contentValues,TableInfo.COLUMN_INTERNAL_ID + " = ?",new String[]{String.valueOf(track.getInternalDBId())}) >= 1    if (!result) {     Loggi.e("TracksDBHelper can not update track info, track: " + track)    }   sendBroadcastTracksChanged()    return result  } 
public synchronized int delete(Track track){   return AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,TableInfo.COLUMN_INTERNAL_ID + "=?",new String[]{String.valueOf(track.getInternalDBId())})  } 
public synchronized void updateAll(List<Track> tracks){   AppDBManager.getInstance(context).getWritableDatabase().beginTransaction()    try {     for (    Track track : tracks) {       final ContentValues contentValues=asContentValues(track)        AppDBManager.getInstance(context).getWritableDatabase().update(TableInfo.TABLE_NAME,contentValues,TableInfo.COLUMN_INTERNAL_ID + " = ?",new String[]{String.valueOf(track.getInternalDBId())})      }     AppDBManager.getInstance(context).getWritableDatabase().setTransactionSuccessful()    }  catch (  Exception e) {     Loggi.e("TracksDBHelper.updateAll() can not perform action: " + e)    }  finally {     AppDBManager.getInstance(context).getWritableDatabase().endTransaction()    }   sendBroadcastTracksChanged()  } 
public synchronized Cursor getAllDesc(){   return AppDBManager.getInstance(context).getReadableDatabase().query(TableInfo.TABLE_NAME,null,null,null,null,null,TableInfo.COLUMN_INTERNAL_ID + " DESC")  } 
public synchronized Track getLastAddedTrack(){   Cursor cursor=AppDBManager.getInstance(context).getReadableDatabase().rawQuery("SELECT * FROM " + TableInfo.TABLE_NAME + " ORDER BY "+ TableInfo.COLUMN_INTERNAL_ID+ " DESC LIMIT 1",null)    Track lastAddedTrack=null    if (cursor.moveToFirst()) {     lastAddedTrack=parseFromCursor(cursor)    }   cursor.close()    return lastAddedTrack  } 
public synchronized int deleteAll(){   final int count=AppDBManager.getInstance(context).getWritableDatabase().delete(TableInfo.TABLE_NAME,null,null)    sendBroadcastTracksChanged()    return count  } 
public synchronized int removeOldOrInconsistentTracks(int maxLocalTracksCount){   AppDBManager.getInstance(context).getWritableDatabase().beginTransaction()    int removedTracksCount=0    try {     Cursor cursor=getAllDesc()      if (cursor.moveToFirst()) {       do {         Track track=parseFromCursor(cursor)          if (track.getState() == Track.STATE_SCROBBLING && System.currentTimeMillis() - track.getStateTimestamp() > 86400000) {           removedTracksCount+=delete(track)          }       }  while (cursor.moveToNext())      }     final int count=cursor.getCount()      if (count > maxLocalTracksCount) {       for (int i=maxLocalTracksCount  i < count  i++) {         cursor.moveToPosition(i)          final Track track=parseFromCursor(cursor)          if (System.currentTimeMillis() - track.getStateTimestamp() > 86400000 && (track.getState() == Track.STATE_SCROBBLE_SUCCESS || track.getState() == Track.STATE_SCROBBLE_ERROR || track.getState() == Track.STATE_SCROBBLING)) {           removedTracksCount+=delete(track)          }       }     }     AppDBManager.getInstance(context).getWritableDatabase().setTransactionSuccessful()      cursor.close()    }  catch (  Exception e) {     String errorMessage="TracksDBHelper.removeOldOrInconsistentTracks() exception: " + e      Loggi.e(errorMessage)      EasyTracker.getInstance(context).send(MapBuilder.createException(errorMessage,false).build())    }  finally {     AppDBManager.getInstance(context).getWritableDatabase().endTransaction()    }   if (removedTracksCount > 0) {     try {       AppDBManager.getInstance(context).getWritableDatabase().execSQL("VACUUM")      }  catch (    Exception e) {       Loggi.e("Can not perform VACUUM on database: " + e.getMessage())      }   }   sendBroadcastTracksChanged()    return removedTracksCount  } 
private void sendBroadcastTracksChanged(){   LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(INTENT_TRACKS_CHANGED))  } 
public static ContentValues asContentValues(Track track){   final ContentValues contentValues=new ContentValues()    contentValues.put(TableInfo.COLUMN_PLAYER_PACKAGE_NAME,track.getPlayerPackageName())    contentValues.put(TableInfo.COLUMN_TRACK,track.getTrack())    contentValues.put(TableInfo.COLUMN_ARTIST,track.getArtist())    contentValues.put(TableInfo.COLUMN_ALBUM,track.getAlbum())    contentValues.put(TableInfo.COLUMN_DURATION,track.getDuration())    contentValues.put(TableInfo.COLUMN_TIMESTAMP,track.getTimestamp())    contentValues.put(TableInfo.COLUMN_STATE,track.getState())    contentValues.put(TableInfo.COLUMN_STATE_TIMESTAMP,track.getStateTimestamp())    return contentValues  } 
public static Track parseFromCursor(Cursor cursor){   final Track track=new Track()    track.setInternalDBId(cursor.getLong(TableInfo.NUM_COLUMN_INTERNAL_ID))    track.setPlayerPackageName(cursor.getString(TableInfo.NUM_COLUMN_PLAYER_PACKAGE_NAME))    track.setTrack(cursor.getString(TableInfo.NUM_COLUMN_TRACK))    track.setArtist(cursor.getString(TableInfo.NUM_COLUMN_ARTIST))    track.setAlbum(cursor.getString(TableInfo.NUM_COLUMN_ALBUM))    track.setDuration(cursor.getLong(TableInfo.NUM_COLUMN_DURATION))    track.setTimestamp(cursor.getLong(TableInfo.NUM_COLUMN_TIMESTAMP))    track.setState(cursor.getInt(TableInfo.NUM_COLUMN_STATE))    track.setStateTimestamp(cursor.getLong(TableInfo.NUM_COLUMN_STATE_TIMESTAMP))    return track  } 
public long getInternalDBId(){   return internalDBId  } 
public void setInternalDBId(long internalDBId){   this.internalDBId=internalDBId  } 
public String getPlayerPackageName(){   return playerPackageName  } 
public void setPlayerPackageName(String playerPackageName){   this.playerPackageName=playerPackageName  } 
public String getTrack(){   return track  } 
public void setTrack(String track){   this.track=track  } 
public String getArtist(){   return artist  } 
public void setArtist(String artist){   this.artist=artist  } 
public String getAlbum(){   return album  } 
public void setAlbum(String album){   this.album=album  } 
public long getDuration(){   return duration  } 
public void setDuration(long duration){   this.duration=duration  } 
public long getTimestamp(){   return timestamp  } 
public void setTimestamp(long timestamp){   this.timestamp=timestamp  } 
public int getState(){   return state  } 
public void setState(int state){   this.state=state  } 
public long getStateTimestamp(){   return stateTimestamp  } 
public void setStateTimestamp(long stateTimestamp){   this.stateTimestamp=stateTimestamp  } 
@Override public String toString(){   return "Track: playerPackageName - " + playerPackageName + ", track name: "+ track+ ", artist: "+ artist+ ", album: "+ album+ ", duration: "+ duration  } 
public Track copy(){   final Track trackCopy=new Track()    trackCopy.playerPackageName=playerPackageName    trackCopy.track=track    trackCopy.artist=artist    trackCopy.album=album    trackCopy.duration=duration    trackCopy.timestamp=timestamp    trackCopy.state=state    return trackCopy  } 
/**   * Checks equality only of some Track's fields  * @param track to compare  * @return true if special fields are equal, false otherwise  */ public boolean specialEquals(Track track){   if (track == null)   return false    if (!TextUtils.equals(getPlayerPackageName(),track.getPlayerPackageName())) {     return false    }   if (!TextUtils.equals(getTrack(),track.getTrack())) {     return false    }   if (!TextUtils.equals(getAlbum(),track.getAlbum())) {     return false    }   if (duration != track.getDuration()) {     return false    }   return true  } 
@Override public boolean equals(Object o){   if (o instanceof Track) {     Track track=(Track)o      return internalDBId == track.internalDBId && TextUtils.equals(playerPackageName,track.playerPackageName) && TextUtils.equals(this.track,track.track) && TextUtils.equals(artist,track.artist) && TextUtils.equals(album,track.album) && duration == track.duration && timestamp == track.timestamp && state == track.state && stateTimestamp == track.stateTimestamp    }   return false  } 
private WAILSettings(){ } 
private static SharedPreferences getSharedPreferences(Context context){   return context.getSharedPreferences(APP_SETTINGS,Context.MODE_PRIVATE)  } 
public static synchronized void clearAllSettings(Context context){   lastfmSessionKey=null    lastfmToken=null    isEnabled=null    minTrackDurationInPercents=null    minTrackDurationInSeconds=null    totalHandledTracksCount=null    isLastfmNowplayingUpdateEnabled=null    lastfmUserName=null    lastfmUserRegistered=null    isShowFeedbackRequest=null    isShowFeedbackRequest=null    soundNotificationTrackScrobbledEnabled=null    soundNotificationTrackSkippedEnabled=null    getSharedPreferences(context).edit().clear().apply()  } 
public static synchronized String getLanguage(Context context){   return getSharedPreferences(context).getString(KEY_LOCALE,null)  } 
public static synchronized void setLanguage(Context context,String value){   getSharedPreferences(context).edit().putString(KEY_LOCALE,value).apply()  } 
public static synchronized Theme getTheme(Context context){   return Theme.valueOf(getSharedPreferences(context).getString(KEY_THEME,Theme.LIGHT.name()))  } 
public static synchronized void setTheme(Context context,Theme theme){   getSharedPreferences(context).edit().putString(KEY_THEME,theme.name()).apply()  } 
public static synchronized boolean isAuthorized(Context context){   return !TextUtils.isEmpty(getLastfmSessionKey(context))  } 
public static String getLastfmApiKey(){   return "8974fa2aeab3c058d87767a60e38cbc6"  } 
public static String getLastfmSecret(){   return "588695f95da39dd308e1b275a4c47ece"  } 
public static synchronized boolean isEnabled(Context context){   return isEnabled != null ? isEnabled : (isEnabled=getSharedPreferences(context).getBoolean(KEY_IS_ENABLED,false))  } 
public static synchronized void setEnabled(Context context,boolean value){   isEnabled=value    getSharedPreferences(context).edit().putBoolean(KEY_IS_ENABLED,value).apply()  } 
public static synchronized boolean isStartOnBoot(Context context){   return getSharedPreferences(context).getBoolean(KEY_START_ON_BOOT,true)  } 
public static synchronized void setStartOnBoot(Context context,boolean value){   getSharedPreferences(context).edit().putBoolean(KEY_START_ON_BOOT,value).apply()  } 
public static synchronized String getLastfmSessionKey(Context context){   return lastfmSessionKey != null ? lastfmSessionKey : (lastfmSessionKey=getSharedPreferences(context).getString(KEY_LASTFM_SESSION_KEY,null))  } 
public static synchronized void setLastfmSessionKey(Context context,String value){   lastfmSessionKey=value    getSharedPreferences(context).edit().putString(KEY_LASTFM_SESSION_KEY,value).apply()  } 
public static synchronized String getKeyLastfmToken(Context context){   return lastfmToken != null ? lastfmToken : (lastfmToken=getSharedPreferences(context).getString(KEY_LASTFM_TOKEN,null))  } 
public static synchronized void setKeyLastfmToken(Context context,String value){   lastfmToken=value    getSharedPreferences(context).edit().putString(KEY_LASTFM_TOKEN,value).apply()  } 
public static synchronized int getMinTrackDurationInPercents(Context context){   return minTrackDurationInPercents != null ? minTrackDurationInPercents : (minTrackDurationInPercents=getSharedPreferences(context).getInt(KEY_MIN_TRACK_DURATION_IN_PERCENTS,DEFAULT_MIN_TRACK_DURATION_IN_PERCENT))  } 
public static synchronized void setMinTrackDurationInPercents(Context context,int value){   minTrackDurationInPercents=value    getSharedPreferences(context).edit().putInt(KEY_MIN_TRACK_DURATION_IN_PERCENTS,value).apply()  } 
public static synchronized int getMinTrackDurationInSeconds(Context context){   return minTrackDurationInSeconds != null ? minTrackDurationInSeconds : (minTrackDurationInSeconds=getSharedPreferences(context).getInt(KEY_MIN_TRACK_DURATION_IN_SECONDS,DEFAULT_MIN_TRACK_DURATION_IN_SECONDS))  } 
public static synchronized void setMinTrackDurationInSeconds(Context context,int value){   minTrackDurationInSeconds=value    getSharedPreferences(context).edit().putInt(KEY_MIN_TRACK_DURATION_IN_SECONDS,value).apply()  } 
public static synchronized long getTotalHandledTracksCount(Context context){   return totalHandledTracksCount != null ? totalHandledTracksCount : (totalHandledTracksCount=getSharedPreferences(context).getLong(KEY_TOTAL_HANDLED_TRACKS_COUNT,0))  } 
public static synchronized void setTotalHandledTracksCount(Context context,long value){   totalHandledTracksCount=value    getSharedPreferences(context).edit().putLong(KEY_TOTAL_HANDLED_TRACKS_COUNT,value).apply()  } 
public static synchronized boolean isLastfmNowplayingUpdateEnabled(Context context){   return isLastfmNowplayingUpdateEnabled != null ? isLastfmNowplayingUpdateEnabled : (isLastfmNowplayingUpdateEnabled=getSharedPreferences(context).getBoolean(KEY_IS_LASTFM_NOWPLAYING_UPDATE_ENABLED,true))  } 
public static synchronized void setLastfmNowplayingUpdateEnabled(Context context,boolean value){   isLastfmNowplayingUpdateEnabled=value    getSharedPreferences(context).edit().putBoolean(KEY_IS_LASTFM_NOWPLAYING_UPDATE_ENABLED,value).apply()  } 
public static synchronized String getLastfmUserName(Context context){   final String lastfmUserNameRefCopy=lastfmUserName    if (!TextUtils.isEmpty(lastfmUserNameRefCopy)) {     return lastfmUserNameRefCopy    }   return lastfmUserName=getSharedPreferences(context).getString(KEY_LASTFM_USER_NAME,"")  } 
public static synchronized void setLastfmUserName(Context context,String userName){   lastfmUserName=userName    final SharedPreferences.Editor editor=getSharedPreferences(context).edit()    editor.putString(KEY_LASTFM_USER_NAME,userName)    editor.apply()  } 
public static synchronized String getLastfmUserRegistered(Context context){   final String lastfmUserRegisteredRefCopy=lastfmUserRegistered    if (!TextUtils.isEmpty(lastfmUserRegisteredRefCopy)) {     return lastfmUserRegisteredRefCopy    }   return lastfmUserRegistered=getSharedPreferences(context).getString(KEY_LASTFM_USER_REGISTERED,"")  } 
public static synchronized void setLastfmUserRegistered(Context context,String userRegistered){   lastfmUserRegistered=userRegistered    final SharedPreferences.Editor editor=getSharedPreferences(context).edit()    editor.putString(KEY_LASTFM_USER_REGISTERED,userRegistered)    editor.apply()  } 
public static synchronized boolean isFirstLaunch(Context context){   return getSharedPreferences(context).getBoolean(KEY_IS_FIRST_LAUNCH,true)  } 
public static synchronized void setIsFirstLaunch(Context context,boolean isFirstLaunch){   getSharedPreferences(context).edit().putBoolean(KEY_IS_FIRST_LAUNCH,isFirstLaunch).apply()  } 
public static synchronized WAILService.LastCapturedTrackInfo getLastCapturedTrackInfo(Context context){   return WAILService.LastCapturedTrackInfo.fromJSON(getSharedPreferences(context).getString(KEY_LAST_CAPTURED_TRACK_INFO,""))  } 
public static synchronized void setLastCapturedTrackInfo(Context context,WAILService.LastCapturedTrackInfo lastCapturedTrackInfo){   String value=null    if (lastCapturedTrackInfo != null) {     value=lastCapturedTrackInfo.toJSON()    }   getSharedPreferences(context).edit().putString(KEY_LAST_CAPTURED_TRACK_INFO,value).apply()  } 
public static synchronized LFUserResponseModel getLastfmUserInfo(Context context){   try {     return LFUserResponseModel.parseFromJSON(getSharedPreferences(context).getString(KEY_LASTFM_USER_INFO,""))    }  catch (  Exception e) {     return null    } } 
public static synchronized void setLastfmUserInfo(Context context,String json){   getSharedPreferences(context).edit().putString(KEY_LASTFM_USER_INFO,json).apply()  } 
public static synchronized long getLastfmUserInfoUpdateTimestamp(Context context){   return getSharedPreferences(context).getLong(KEY_LASTFM_USER_INFO_UPDATE_TIMESTAMP,-1)  } 
public static synchronized void setLastfmUserInfoUpdateTimestamp(Context context,long timestamp){   getSharedPreferences(context).edit().putLong(KEY_LASTFM_USER_INFO_UPDATE_TIMESTAMP,timestamp).apply()  } 
public static synchronized boolean isSoundNotificationTrackMarkedAsScrobbledEnabled(Context context){   return soundNotificationTrackScrobbledEnabled != null ? soundNotificationTrackScrobbledEnabled : (soundNotificationTrackScrobbledEnabled=getSharedPreferences(context).getBoolean(KEY_SOUND_NOTIFICATION_TRACK_MARKED_AS_SCROBBLED_ENABLED,false))  } 
public static synchronized void setSoundNotificationTrackMarkedAsScrobbledEnabled(Context context,boolean value){   soundNotificationTrackScrobbledEnabled=value    getSharedPreferences(context).edit().putBoolean(KEY_SOUND_NOTIFICATION_TRACK_MARKED_AS_SCROBBLED_ENABLED,value).apply()  } 
public static synchronized boolean isSoundNotificationTrackSkippedEnabled(Context context){   return soundNotificationTrackSkippedEnabled != null ? soundNotificationTrackSkippedEnabled : (soundNotificationTrackSkippedEnabled=getSharedPreferences(context).getBoolean(KEY_SOUND_NOTIFICATION_TRACK_SKIPPED_ENABLED,false))  } 
public static synchronized void setSoundNotificationTrackSkippedEnabled(Context context,boolean value){   soundNotificationTrackSkippedEnabled=value    getSharedPreferences(context).edit().putBoolean(KEY_SOUND_NOTIFICATION_TRACK_SKIPPED_ENABLED,value).apply()  } 
public static synchronized boolean isShowFeedbackRequest(Context context){   return isShowFeedbackRequest != null ? isShowFeedbackRequest : (isShowFeedbackRequest=getSharedPreferences(context).getBoolean(KEY_IS_SHOW_FEEDBACK_REQUEST,true))  } 
public static synchronized void setShowFeedbackRequest(Context context,boolean value){   isShowFeedbackRequest=value    getSharedPreferences(context).edit().putBoolean(KEY_IS_SHOW_FEEDBACK_REQUEST,value).apply()  } 
public static synchronized Track getNowScrobblingTrack(Context context){   String artist=getSharedPreferences(context).getString(KEY_NOW_SCROBBLING_TRACK_ARTIST,null)    String title=getSharedPreferences(context).getString(KEY_NOW_SCROBBLING_TRACK_TITLE,null)    if (artist == null && title == null) {     return null    }   Track track=new Track()    track.setArtist(artist)    track.setTrack(title)    return track  } 
public static synchronized void setNowScrobblingTrack(Context context,Track track){   getSharedPreferences(context).edit().putString(KEY_NOW_SCROBBLING_TRACK_ARTIST,track == null ? null : track.getArtist()).apply()    getSharedPreferences(context).edit().putString(KEY_NOW_SCROBBLING_TRACK_TITLE,track == null ? null : track.getTrack()).apply()  } 
public static synchronized String getNowScrobblingPlayerPackageName(Context context){   return getSharedPreferences(context).getString(KEY_NOW_SCROBBLING_PLAYER_PACKAGE_NAME,null)  } 
public static synchronized void setNowScrobblingPlayerPackageName(Context context,String player){   getSharedPreferences(context).edit().putString(KEY_NOW_SCROBBLING_PLAYER_PACKAGE_NAME,player).apply()  } 
public static synchronized String getNowScrobblingPlayerLabel(Context context){   return getSharedPreferences(context).getString(KEY_NOW_SCROBBLING_PLAYER_LABEL,null)  } 
public static synchronized void setNowScrobblingPlayerLabel(Context context,String player){   getSharedPreferences(context).edit().putString(KEY_NOW_SCROBBLING_PLAYER_LABEL,player).apply()  } 
public static boolean isEnableScrobblingOverMobileNetwork(Context context){   return enableScrobblingOverMobileNetwork != null ? enableScrobblingOverMobileNetwork : getSharedPreferences(context).getBoolean(KEY_DISABLE_SCROBBLING_OVER_MOBILE_NETWORK,true)  } 
public static void setDisableScrobblingOverMobileNetwork(Context context,boolean value){   enableScrobblingOverMobileNetwork=value    getSharedPreferences(context).edit().putBoolean(KEY_DISABLE_SCROBBLING_OVER_MOBILE_NETWORK,value).apply()  } 
public static boolean isStatusBarNotificationTrackScrobblingEnabled(Context context){   return statusBarNotificationTrackScrobblingEnabled != null ? statusBarNotificationTrackScrobblingEnabled : getSharedPreferences(context).getBoolean(KEY_STATUS_BAR_NOTIFICATION_TRACK_SCROBBLING,false)  } 
public static void setStatusBarNotificationTrackScrobblingEnabled(Context context,boolean value){   WAILSettings.statusBarNotificationTrackScrobblingEnabled=value    getSharedPreferences(context).edit().putBoolean(KEY_STATUS_BAR_NOTIFICATION_TRACK_SCROBBLING,value).apply()  } 
public static boolean isStatusBarNotificationMinPriority(Context context){   return statusBarNotificationMinPriority != null ? statusBarNotificationMinPriority : getSharedPreferences(context).getBoolean(KEY_STATUS_BAR_NOTIFICATION_MIN_PRIORITY,false)  } 
public static void setStatusBarNotificationMinPriority(Context context,boolean value){   WAILSettings.statusBarNotificationMinPriority=value    getSharedPreferences(context).edit().putBoolean(KEY_STATUS_BAR_NOTIFICATION_MIN_PRIORITY,value).apply()  } 
@Override public void onReceive(Context context,Intent intent){   WAILSettings.clearAllSettings(BaseActivity.this)    AppDBManager.getInstance(BaseActivity.this).clearAll()    LocaleUtil.updateLanguage(BaseActivity.this,null)    startActivity(new Intent(BaseActivity.this,MainActivity.class))    BaseActivity.this.finish()  } 
protected boolean doFinishOnHomeAsUpButton(){   return true  } 
@Override protected void onCreate(Bundle savedInstanceState){   setTheme()    super.onCreate(savedInstanceState)    if (savedInstanceState == null) {     onCreteWithNullState()    }   setupUI(savedInstanceState)  } 
@Override protected void onPause(){   super.onPause()    unregisterReceiver(invalidSessionKeyReceiver)    WAILApp.activityPaused()  } 
@Override protected void onResume(){   super.onResume()    registerReceiver(invalidSessionKeyReceiver,new IntentFilter(ACTION_INVALID_SESSION_KEY))    WAILApp.activityResumed()  } 
/**   * Will be called only once through the activity lifecycle When savedInstanceState bundle in onCreate is null, that method will be called  */ protected void onCreteWithNullState(){ } 
protected void setupUI(Bundle savedInstanceState){ } 
@Override public void onStart(){   super.onStart()    EasyTracker.getInstance(this).activityStart(this)  } 
@Override public boolean onOptionsItemSelected(MenuItem item){   if (item.getItemId() == android.R.id.home) {     if (doFinishOnHomeAsUpButton()) {       finish()        return true      }   }   return super.onOptionsItemSelected(item)  } 
@Override protected void onStop(){   super.onStop()    EasyTracker.getInstance(this).activityStop(this)  } 
public void setTheme(){   if (WAILSettings.getTheme(getBaseContext()) == WAILSettings.Theme.DARK) {     if (this instanceof MainActivity) {       setTheme(R.style.AppTheme_Dark_NoActionBar)      }  else {       setTheme(R.style.AppTheme_Dark)      }   }  else {     if (this instanceof MainActivity) {       setTheme(R.style.AppTheme_Light_NoActionBar)      }  else {       setTheme(R.style.AppTheme_Light)      }   } } 
public void restart(){   finish()    startActivity(getIntent())  } 
@OnItemClick(R.id.main_left_drawer_list) public void onItemsSelected(int position){   selectNavDrawerItem(position)    if (drawerLayout != null) {     SleepIfRequiredAsyncTask.newInstance(SystemClock.elapsedRealtime(),150,new Runnable(){       @Override public void run(){         try {           drawerLayout.closeDrawers()          }  catch (        Exception e) {           Loggi.e("MainActivity closeNavigationDrawer() exception: " + e.getMessage())          }       }     } ).execute()    }   setSelectedItem(position)  } 
@Override public void run(){   try {     drawerLayout.closeDrawers()    }  catch (  Exception e) {     Loggi.e("MainActivity closeNavigationDrawer() exception: " + e.getMessage())    } } 
@Override protected void onCreate(final Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    ButterKnife.inject(this)    setSupportActionBar(toolbar)    if (!WAILSettings.isAuthorized(this)) {     startActivityForResult(new Intent(this,NonAuthorizedActivity.class),REQUEST_CODE_NON_AUTHORIZED_ACTIVITY_INTENT)    }   setDrawerHeaderText()    if (drawerLayout != null) {     drawerLayout.setStatusBarBackgroundColor(getResources().getColor(R.color.primary_dark))      actionBarDrawerToggle=new ActionBarDrawerToggle(this,drawerLayout,R.string.app_name,R.string.app_name){       @Override public void onDrawerOpened(      View drawerView){         super.onDrawerOpened(drawerView)          if (TextUtils.isEmpty(drawerTitleMain.getText().toString()) || TextUtils.isEmpty(drawerTitleSecondary.getText().toString())) {           setDrawerHeaderText()          }       }     }       drawerLayout.setDrawerListener(actionBarDrawerToggle)      getSupportActionBar().setDisplayHomeAsUpEnabled(true)      getSupportActionBar().setHomeButtonEnabled(true)    }  else   if (drawerLayoutLand != null) {     drawerLayoutLand.setStatusBarBackgroundColor(getResources().getColor(R.color.primary_dark))    }   ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,R.layout.activity_main_drawer_item_layout,getResources().getStringArray(R.array.drawer_items)){     @Override public View getView(    int position,    View view,    ViewGroup parent){       ViewHolder holder        View rowView=view        if (rowView == null) {         LayoutInflater inflater=getLayoutInflater()          rowView=inflater.inflate(R.layout.activity_main_drawer_item_layout,parent,false)          holder=new ViewHolder()          holder.background=rowView          holder.textView=(TypefaceTextView)rowView.findViewById(R.id.activity_main_drawer_item_text)          holder.imageView=(ImageView)rowView.findViewById(R.id.activity_main_drawer_item_image)          rowView.setTag(holder)        }  else {         holder=(ViewHolder)rowView.getTag()        }       holder.textView.setText(getItem(position))  switch (position) { case 0:         holder.imageView.setImageResource(R.drawable.ic_home_grey600_24dp)        break  case 1:     holder.imageView.setImageResource(R.drawable.ic_list_grey600_24dp)    break  case 2: holder.imageView.setImageResource(R.drawable.ic_settings_grey600_24dp)  break  } if (position == 0 && lastItemSelected == -1) { holder.background.setBackgroundColor(getResources().getColor(R.color.drawer_item_selected_background))  lastItemSelected=0  } return rowView  } class ViewHolder { View background  TypefaceTextView textView  ImageView imageView  } }   drawerList.setAdapter(adapter)  setDrawerWidth()  } 
@Override public void onDrawerOpened(View drawerView){   super.onDrawerOpened(drawerView)    if (TextUtils.isEmpty(drawerTitleMain.getText().toString()) || TextUtils.isEmpty(drawerTitleSecondary.getText().toString())) {     setDrawerHeaderText()    } } 
@Override public View getView(int position,View view,ViewGroup parent){   ViewHolder holder    View rowView=view    if (rowView == null) {     LayoutInflater inflater=getLayoutInflater()      rowView=inflater.inflate(R.layout.activity_main_drawer_item_layout,parent,false)      holder=new ViewHolder()      holder.background=rowView      holder.textView=(TypefaceTextView)rowView.findViewById(R.id.activity_main_drawer_item_text)      holder.imageView=(ImageView)rowView.findViewById(R.id.activity_main_drawer_item_image)      rowView.setTag(holder)    }  else {     holder=(ViewHolder)rowView.getTag()    }   holder.textView.setText(getItem(position))  switch (position) { case 0:     holder.imageView.setImageResource(R.drawable.ic_home_grey600_24dp)    break  case 1: holder.imageView.setImageResource(R.drawable.ic_list_grey600_24dp)  break  case 2: holder.imageView.setImageResource(R.drawable.ic_settings_grey600_24dp)  break  } if (position == 0 && lastItemSelected == -1) { holder.background.setBackgroundColor(getResources().getColor(R.color.drawer_item_selected_background))  lastItemSelected=0  } return rowView  } 
private void setDrawerWidth(){   TypedValue typedValue=new TypedValue()    getTheme().resolveAttribute(R.attr.actionBarSize,typedValue,true)    DisplayMetrics displayMetrics=getResources().getDisplayMetrics()    float px=typedValue.getDimension(displayMetrics)    ViewGroup.LayoutParams params=drawer.getLayoutParams()    if (getResources().getBoolean(R.bool.isTablet)) {     params.width=(int)Math.min(displayMetrics.widthPixels - px,getResources().getDimension(R.dimen.main_drawer_standard_increment) * 5)    }  else {     if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {       params.width=(int)(displayMetrics.widthPixels - px)      }  else {       params.width=(int)(displayMetrics.heightPixels - px)      }   }   drawer.setLayoutParams(params)  } 
private void setDrawerHeaderText(){   drawerTitleMain.setText(WAILSettings.getLastfmUserName(this))    drawerTitleSecondary.setText(getString(R.string.drawer_registered_at) + WAILSettings.getLastfmUserRegistered(this).split(" ")[0])  } 
@Override protected void onPostCreate(Bundle savedInstanceState){   super.onPostCreate(savedInstanceState)    if (drawerLayout != null && actionBarDrawerToggle != null) {     actionBarDrawerToggle.syncState()    }   navigationFragments[0]=new MainFragment()    navigationFragments[1]=new TracksListFragment()    navigationFragments[2]=new SettingsFragment()    selectNavDrawerItem(0)    if (WAILSettings.isFirstLaunch(this)) {     WAILSettings.setIsFirstLaunch(this,false)    } } 
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){   super.onActivityResult(requestCode,resultCode,data)    if (requestCode == REQUEST_CODE_NON_AUTHORIZED_ACTIVITY_INTENT) {     if (resultCode == RESULT_CANCELED) {       finish()      }   } } 
@Override public boolean onOptionsItemSelected(MenuItem item){   if (actionBarDrawerToggle != null && actionBarDrawerToggle.onOptionsItemSelected(item)) {     return true    }   return super.onOptionsItemSelected(item)  } 
@Override protected void onSaveInstanceState(Bundle outState){   super.onSaveInstanceState(outState)  } 
private void selectNavDrawerItem(final int position){   final FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction()    fragmentTransaction.setCustomAnimations(R.anim.fragment_transaction_alpha_up,R.anim.fragment_transaction_alpha_down)    fragmentTransaction.replace(R.id.main_content,navigationFragments[position])    fragmentTransaction.commit()  } 
private void setSelectedItem(int position){   if (lastItemSelected != -1) {     drawerList.getChildAt(lastItemSelected).setBackgroundColor(getResources().getColor(R.color.drawer_item_background))    }   drawerList.getChildAt(position).setBackgroundColor(getResources().getColor(R.color.drawer_item_selected_background))    lastItemSelected=position  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_non_authorized)    if (savedInstanceState == null) {     getFragmentManager().beginTransaction().add(R.id.non_authorized_frame,new NonAuthorizedMainFragment()).commit()    }   setResult(RESULT_CANCELED)  } 
@Override protected void setupUI(Bundle savedInstanceState){   super.setupUI(savedInstanceState)    overridePendingTransition(R.anim.activity_pull_from_right_to_left,R.anim.activity_pull_from_current_to_left)    getSupportActionBar().setDisplayHomeAsUpEnabled(true)  } 
@Override protected void onPause(){   super.onPause()    overridePendingTransition(R.anim.activity_pull_from_left_out_to_screen,R.anim.activity_pull_from_center_to_out_right)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_settings_ignored_players)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_settings_select_language)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_settings_sound_notifications)  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_settings_status_bar_notifications)  } 
@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){   super.onUpdate(context,appWidgetManager,appWidgetIds)    for (  int appWidgetId : appWidgetIds) {     Bundle options=appWidgetManager.getAppWidgetOptions(appWidgetId)      onAppWidgetOptionsChanged(context,appWidgetManager,appWidgetId,options)    } } 
@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onAppWidgetOptionsChanged(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle newOptions){   RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.waillove_widget)    int newMinWidth=newOptions.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH)    if (newMinWidth > MIN_WIDTH_TO_SHOW_INFO_BOX) {     views.setViewVisibility(R.id.widget_infobox_layout,View.VISIBLE)    }  else {     views.setViewVisibility(R.id.widget_infobox_layout,View.GONE)    }   Intent loveTrackIntent=new Intent(context,getClass())    loveTrackIntent.setAction(LOVE_TRACK_BUTTON_CLICKED)    PendingIntent pendingLoveTrackIntent=PendingIntent.getBroadcast(context,0,loveTrackIntent,0)    views.setOnClickPendingIntent(R.id.widget_love_current_track_button,pendingLoveTrackIntent)    Intent appMainIntent=new Intent(context,MainActivity.class)    PendingIntent pendingAppMainIntent=PendingIntent.getActivity(context,0,appMainIntent,0)    views.setOnClickPendingIntent(R.id.widget_infobox_layout,pendingAppMainIntent)    appWidgetManager.updateAppWidget(appWidgetId,views)  } 
@Override public void onReceive(@NonNull final Context context,@NonNull final Intent intent){   super.onReceive(context,intent)    if (LOVE_TRACK_BUTTON_CLICKED.equals(intent.getAction())) {     final Track track=WAILSettings.getNowScrobblingTrack(context)      if (track == null) {       Toast.makeText(context,context.getString(R.string.widget_nothing_to_love),Toast.LENGTH_SHORT).show()        return      }     AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){       @Override protected Void doInBackground(      Void... objects){         LovedTracksDBHelper.getInstance(context).add(track)          Intent handleLovedTracksIntent=new Intent(context,WAILService.class)          handleLovedTracksIntent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)          context.startService(handleLovedTracksIntent)          return null        }       @Override protected void onPostExecute(      Void o){         Toast.makeText(context,context.getString(R.string.main_track_loved),Toast.LENGTH_SHORT).show()        }     } )    } } 
@Override protected Void doInBackground(Void... objects){   LovedTracksDBHelper.getInstance(context).add(track)    Intent handleLovedTracksIntent=new Intent(context,WAILService.class)    handleLovedTracksIntent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)    context.startService(handleLovedTracksIntent)    return null  } 
@Override protected void onPostExecute(Void o){   Toast.makeText(context,context.getString(R.string.main_track_loved),Toast.LENGTH_SHORT).show()  } 
protected boolean isRetainInstance(){   return true  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    this.savedInstanceState=savedInstanceState    if (isRetainInstance()) {     setRetainInstance(true)    } } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)  } 
@Override public void onStart(){   super.onStart()    if (!wasStarted) {     wasStarted=true      onFirstStart(savedInstanceState)    } } 
protected void onFirstStart(Bundle savedInstanceState){ } 
public void setListener(Callback listener){   this.listener=listener  } 
@Override public void onAttach(Activity activity){   super.onAttach(activity)    this.activity=activity  } 
@Override public void onDismiss(DialogInterface dialog){   super.onDismiss(dialog)    if (listener != null) {     listener.onDismiss()    } } 
void onDismiss()  
public static DialogFragmentWithNumberPicker newInstance(String title,int minValue,int maxValue,int initValue){   final DialogFragmentWithNumberPicker dialog=new DialogFragmentWithNumberPicker()    dialog.title=title    dialog.minValue=minValue    dialog.maxValue=maxValue    dialog.initValue=initValue    return dialog  } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   MaterialDialog dialog=new MaterialDialog.Builder(getActivity()).customView(R.layout.dialog_with_number_picker_fragment,false).theme(Theme.DARK).title(title).positiveText(R.string.dialog_save).negativeText(R.string.dialog_cancel).callback(new MaterialDialog.ButtonCallback(){     @Override public void onPositive(    MaterialDialog dialog){       WAILSettings.setMinTrackDurationInSeconds(getActivity(),numberPicker.getValue())        EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(SettingsFragment.GA_EVENT_SETTINGS_FRAGMENT,"changed min track duration in seconds to: " + WAILSettings.getMinTrackDurationInSeconds(getActivity()) + " seconds",null,1L).build())      }     @Override public void onNegative(    MaterialDialog dialog){       dialog.dismiss()      }   } ).build()    numberPicker=(NumberPicker)dialog.getCustomView().findViewById(R.id.dialog_with_number_picker_picker)    numberPicker.setMinValue(minValue)    numberPicker.setMaxValue(maxValue)    numberPicker.setValue(initValue)    numberPicker.setDescendantFocusability(NumberPicker.FOCUS_BLOCK_DESCENDANTS)    return dialog  } 
@Override public void onPositive(MaterialDialog dialog){   WAILSettings.setMinTrackDurationInSeconds(getActivity(),numberPicker.getValue())    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(SettingsFragment.GA_EVENT_SETTINGS_FRAGMENT,"changed min track duration in seconds to: " + WAILSettings.getMinTrackDurationInSeconds(getActivity()) + " seconds",null,1L).build())  } 
@Override public void onNegative(MaterialDialog dialog){   dialog.dismiss()  } 
public static DialogFragmentWithSeekBar newInstance(String title,int startProgressValue){   final DialogFragmentWithSeekBar dialog=new DialogFragmentWithSeekBar()    dialog.startProgressValue=startProgressValue    dialog.title=title    return dialog  } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   MaterialDialog dialog=new MaterialDialog.Builder(getActivity()).customView(R.layout.dialog_with_seek_bar_fragment,false).theme(Theme.DARK).title(title).positiveText(R.string.dialog_save).negativeText(R.string.dialog_cancel).callback(new MaterialDialog.ButtonCallback(){     @Override public void onPositive(    MaterialDialog dialog){       WAILSettings.setMinTrackDurationInPercents(getActivity(),seekBar.getProgress())        EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(SettingsFragment.GA_EVENT_SETTINGS_FRAGMENT,"changed min track duration in seconds to: " + WAILSettings.getMinTrackDurationInSeconds(getActivity()) + " seconds",null,1L).build())      }     @Override public void onNegative(    MaterialDialog dialog){       dialog.dismiss()      }   } ).build()    seekBar=(SeekBar)dialog.getCustomView().findViewById(R.id.dialog_with_seek_bar_seek_bar)    seekBar.setProgress(startProgressValue)    final TextView label=(TextView)dialog.getCustomView().findViewById(R.id.dialog_with_seek_bar_bottom_text)    label.setText(getString(R.string.settings_min_track_elapsed_time_in_percent_dialog_bottom_text,seekBar.getProgress()))    seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){     @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){       if (progress < 50) {         seekBar.setProgress(50)        }       label.setText(getString(R.string.settings_min_track_elapsed_time_in_percent_dialog_bottom_text,seekBar.getProgress()))      }     @Override public void onStartTrackingTouch(    SeekBar seekBar){     }     @Override public void onStopTrackingTouch(    SeekBar seekBar){     }   } )    return dialog  } 
@Override public void onPositive(MaterialDialog dialog){   WAILSettings.setMinTrackDurationInPercents(getActivity(),seekBar.getProgress())    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(SettingsFragment.GA_EVENT_SETTINGS_FRAGMENT,"changed min track duration in seconds to: " + WAILSettings.getMinTrackDurationInSeconds(getActivity()) + " seconds",null,1L).build())  } 
@Override public void onNegative(MaterialDialog dialog){   dialog.dismiss()  } 
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){   if (progress < 50) {     seekBar.setProgress(50)    }   label.setText(getString(R.string.settings_min_track_elapsed_time_in_percent_dialog_bottom_text,seekBar.getProgress()))  } 
@Override public void onStartTrackingTouch(SeekBar seekBar){ } 
@Override public void onStopTrackingTouch(SeekBar seekBar){ } 
public static TrackActionsDialog newInstance(Track track){   TrackActionsDialog dialog=new TrackActionsDialog()    dialog.track=track    return dialog  } 
@Override public Dialog onCreateDialog(Bundle savedInstanceState){   return new MaterialDialog.Builder(activity).items(R.array.track_actions).itemsCallback(new MaterialDialog.ListCallback(){     @Override public void onSelection(    MaterialDialog materialDialog,    View view,    int i,    CharSequence charSequence){ switch (i) { case 0:         loveTrack()        break    } } } ).theme(Theme.DARK).build()  } 
@Override public void onSelection(MaterialDialog materialDialog,View view,int i,CharSequence charSequence){ switch (i) { case 0:     loveTrack()    break  } } 
private void loveTrack(){   if (track != null) {     LovedTracksDBHelper.getInstance(activity).add(track)      Intent intent=new Intent(activity,WAILService.class)      intent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)      activity.startService(intent)      Toast.makeText(activity,getString(R.string.main_track_loved),Toast.LENGTH_SHORT).show()      dismiss()    } } 
@Override public void onReceive(Context context,Intent intent){   updateLocalInfo()  } 
@OnClick(R.id.main_tracks_today_view) public void onTracksTodayViewClick(){   Toast.makeText(getActivity(),getString(R.string.main_pull_down_to_refresh_toast),Toast.LENGTH_SHORT).show()  } 
@OnClick(R.id.main_feedback_please) public void onFeedbackPleaseClick(){   final Activity activity=getActivity()    WAILSettings.setShowFeedbackRequest(activity,false)    ViewUtil.setVisibility(feedbackPleaseView,false)    Toast.makeText(activity,getString(R.string.main_feedback_please_happy_toast),Toast.LENGTH_LONG).show()    final String appPackageName=activity.getPackageName()    try {     startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse("market://details?id=" + appPackageName)))      EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"feedback_please_click","Google Play opened",1L).build())    }  catch (  Exception e) {     startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse("http://play.google.com/store/apps/details?id=" + appPackageName)))      EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"feedback_please_click","Browser opened",1L).build())    } } 
@OnClick(R.id.main_love_current_track_button) public void onLoveCurrentTrackButtonClick(){   Track track=WAILSettings.getNowScrobblingTrack(getActivity())    if (track != null) {     Toast.makeText(getActivity(),getString(R.string.main_track_loved),Toast.LENGTH_SHORT).show()      loveCurrentTrackButton.hide()      Intent intent=new Intent(getActivity(),WAILService.class)      LovedTracksDBHelper.getInstance(getActivity()).add(track)      intent.setAction(WAILService.INTENT_ACTION_HANDLE_LOVED_TRACKS)      getActivity().startService(intent)    } } 
@OnClick(R.id.main_ignore_player_button) public void onIgnoreScrobblingPlayerClick(){   String label=WAILSettings.getNowScrobblingPlayerLabel(getActivity())    final String packageName=WAILSettings.getNowScrobblingPlayerPackageName(getActivity())    final String nowScrobblingPlayer=label != null ? label : packageName    new MaterialDialog.Builder(getActivity()).theme(Theme.DARK).title(String.format(getString(R.string.main_confirm_ignoring_player),nowScrobblingPlayer)).positiveText("Ok").negativeText(R.string.dialog_cancel).callback(new MaterialDialog.ButtonCallback(){     @Override public void onPositive(    MaterialDialog dialog){       dbHelper.add(packageName)        WAILSettings.setNowScrobblingTrack(getActivity(),null)        WAILSettings.setNowScrobblingPlayerPackageName(getActivity(),null)        WAILSettings.setNowScrobblingPlayerLabel(getActivity(),null)        WAILSettings.setLastCapturedTrackInfo(getActivity(),null)        updateLocalInfo()      }     @Override public void onNegative(    MaterialDialog dialog){       dialog.dismiss()      }   } ).build().show()  } 
@Override public void onPositive(MaterialDialog dialog){   dbHelper.add(packageName)    WAILSettings.setNowScrobblingTrack(getActivity(),null)    WAILSettings.setNowScrobblingPlayerPackageName(getActivity(),null)    WAILSettings.setNowScrobblingPlayerLabel(getActivity(),null)    WAILSettings.setLastCapturedTrackInfo(getActivity(),null)    updateLocalInfo()  } 
@Override public void onNegative(MaterialDialog dialog){   dialog.dismiss()  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    loadTrackWordForms()  } 
@Override public void onActivityCreated(Bundle savedInstanceState){   super.onActivityCreated(savedInstanceState)    ActionBar actionBar=((AppCompatActivity)getActivity()).getSupportActionBar()    if (actionBar != null) {     actionBar.setTitle(getString(R.string.main_ab_title))    } } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_main,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    dbHelper=IgnoredPlayersDBHelper.getInstance(getActivity())    ButterKnife.inject(this,view)    final Activity activity=getActivity()    pullToRefreshLayout.setColorSchemeResources(R.color.primary)    pullToRefreshLayout.setOnRefreshListener(new PullToRefreshListener())    if (WAILSettings.isShowFeedbackRequest(activity)) {     ViewUtil.setVisibility(feedbackPleaseView,true)    }   loveCurrentTrackButton.attachToScrollView(scrollView)    loveCurrentTrackButton.show(false)  } 
@Override public void onStart(){   super.onStart()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"started",null,1L).build())  } 
@Override public void onResume(){   super.onResume()    try {     if (!WAILSettings.isAuthorized(getActivity()))     return    }  catch (  Exception e) {   }   updateLocalInfo()    LocalBroadcastManager.getInstance(getActivity()).registerReceiver(tracksChangedBroadcastReceiver,new IntentFilter(TracksDBHelper.INTENT_TRACKS_CHANGED))    AsyncTaskExecutor.executeConcurrently(new AsyncTask<Object,Object,Object>(){     @Override protected void onPreExecute(){       super.onPreExecute()        updateTracksCountFromLastfm()      }     @Override protected Object doInBackground(    Object... params){       ThreadUtil.sleepIfRequired(SystemClock.elapsedRealtime(),650)        return null      }     @Override protected void onPostExecute(    Object o){       super.onPostExecute(o)        try {         final Context context=getActivity()          if (isRemoving() || isDetached() || context.isRestricted())         return          final long updateTimeStamp=WAILSettings.getLastfmUserInfoUpdateTimestamp(context)          if (!pullToRefreshLayout.isRefreshing() && System.currentTimeMillis() - updateTimeStamp > 180000) {           refreshDataFromLastfm()          }       }  catch (      Exception e) {         Loggi.e("Exception in delayed refresh in MainFragment: " + e.getMessage())        }     }   } )  } 
@Override protected void onPreExecute(){   super.onPreExecute()    updateTracksCountFromLastfm()  } 
@Override protected Object doInBackground(Object... params){   ThreadUtil.sleepIfRequired(SystemClock.elapsedRealtime(),650)    return null  } 
@Override protected void onPostExecute(Object o){   super.onPostExecute(o)    try {     final Context context=getActivity()      if (isRemoving() || isDetached() || context.isRestricted())     return      final long updateTimeStamp=WAILSettings.getLastfmUserInfoUpdateTimestamp(context)      if (!pullToRefreshLayout.isRefreshing() && System.currentTimeMillis() - updateTimeStamp > 180000) {       refreshDataFromLastfm()      }   }  catch (  Exception e) {     Loggi.e("Exception in delayed refresh in MainFragment: " + e.getMessage())    } } 
@Override public void onPause(){   super.onPause()    LocalBroadcastManager.getInstance(getActivity()).unregisterReceiver(tracksChangedBroadcastReceiver)  } 
@Override public void onStop(){   super.onStop()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"stopped",null,0L).build())  } 
private void refreshDataFromLastfm(){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Object,Object,LFUserResponseModel>(){     NetworkException networkException      LFApiException lfApiException      @Override protected void onPreExecute(){       super.onPreExecute()        try {         pullToRefreshLayout.setRefreshing(true)        }  catch (      Exception e) {       }     }     @Override protected LFUserResponseModel doInBackground(    Object... params){       final long startTime=SystemClock.elapsedRealtime()        LFUserResponseModel userModel=null        try {         final String response=LFUserApi.getInfo(WAILSettings.getLastfmSessionKey(getActivity()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),WAILSettings.getLastfmUserName(getActivity()))          userModel=LFUserResponseModel.parseFromJSON(response)          WAILSettings.setLastfmUserInfo(getActivity(),response)          WAILSettings.setLastfmUserName(getActivity(),userModel.getName())          WAILSettings.setLastfmUserRegistered(getActivity(),userModel.getRegistered().getText())          WAILSettings.setLastfmUserInfoUpdateTimestamp(getActivity(),System.currentTimeMillis())        }  catch (      Exception e) {         EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed: " + e.getMessage(),0L).build())          if (e instanceof NetworkException) {           networkException=(NetworkException)e          }  else         if (e instanceof LFApiException) {           lfApiException=(LFApiException)e          }       }       ThreadUtil.sleepIfRequired(startTime,1900)        return userModel      }     @Override protected void onPostExecute(    LFUserResponseModel userModel){       super.onPostExecute(userModel)        try {         pullToRefreshLayout.setRefreshing(false)          updateTracksCountFromLastfm()          String toast=null          if (networkException != null) {           toast=getString(R.string.main_refresh_info_from_lastfm_network_error)          }  else         if (lfApiException != null) {           toast=getString(R.string.main_refresh_info_from_lastfm_api_error,lfApiException.getMessage())            EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed with LFApiException: " + lfApiException.getMessage(),0L).build())          }         if (toast != null) {           Toast.makeText(getActivity(),toast,Toast.LENGTH_LONG).show()          }       }  catch (      Exception e) {         try {           final Context context=getActivity()            if (isDetached() || isRemoving() || context == null)           return            Toast.makeText(context,R.string.main_refresh_info_from_lastfm_unknown_error,Toast.LENGTH_LONG).show()            EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed with unknown error",0L).build())          }  catch (        Exception e1) {         }       }       redrawLastUpdateTime()      }   } )  } 
@Override protected void onPreExecute(){   super.onPreExecute()    try {     pullToRefreshLayout.setRefreshing(true)    }  catch (  Exception e) {   } } 
@Override protected LFUserResponseModel doInBackground(Object... params){   final long startTime=SystemClock.elapsedRealtime()    LFUserResponseModel userModel=null    try {     final String response=LFUserApi.getInfo(WAILSettings.getLastfmSessionKey(getActivity()),WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),WAILSettings.getLastfmUserName(getActivity()))      userModel=LFUserResponseModel.parseFromJSON(response)      WAILSettings.setLastfmUserInfo(getActivity(),response)      WAILSettings.setLastfmUserName(getActivity(),userModel.getName())      WAILSettings.setLastfmUserRegistered(getActivity(),userModel.getRegistered().getText())      WAILSettings.setLastfmUserInfoUpdateTimestamp(getActivity(),System.currentTimeMillis())    }  catch (  Exception e) {     EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed: " + e.getMessage(),0L).build())      if (e instanceof NetworkException) {       networkException=(NetworkException)e      }  else     if (e instanceof LFApiException) {       lfApiException=(LFApiException)e      }   }   ThreadUtil.sleepIfRequired(startTime,1900)    return userModel  } 
@Override protected void onPostExecute(LFUserResponseModel userModel){   super.onPostExecute(userModel)    try {     pullToRefreshLayout.setRefreshing(false)      updateTracksCountFromLastfm()      String toast=null      if (networkException != null) {       toast=getString(R.string.main_refresh_info_from_lastfm_network_error)      }  else     if (lfApiException != null) {       toast=getString(R.string.main_refresh_info_from_lastfm_api_error,lfApiException.getMessage())        EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed with LFApiException: " + lfApiException.getMessage(),0L).build())      }     if (toast != null) {       Toast.makeText(getActivity(),toast,Toast.LENGTH_LONG).show()      }   }  catch (  Exception e) {     try {       final Context context=getActivity()        if (isDetached() || isRemoving() || context == null)       return        Toast.makeText(context,R.string.main_refresh_info_from_lastfm_unknown_error,Toast.LENGTH_LONG).show()        EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"refreshDataFromLastfm","failed with unknown error",0L).build())      }  catch (    Exception e1) {     }   }   redrawLastUpdateTime()  } 
private void loadTrackWordForms(){   trackWordForms=getResources().getStringArray(R.array.word_form_track)  } 
private void updateLocalInfo(){   updateTracksTodayCount()    redrawLastUpdateTime()    updateNowScrobblingTrack()  } 
private void updateTracksTodayCount(){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Integer>(){     @Override protected Integer doInBackground(    Void... params){       try {         final Calendar currentDate=Calendar.getInstance()          int tracksTodayCount=0          Cursor tracksCursor=TracksDBHelper.getInstance(getActivity().getApplicationContext()).getAllDesc()          if (tracksCursor.moveToFirst()) {           do {             Track track=TracksDBHelper.parseFromCursor(tracksCursor)              final Calendar trackCaptureDate=Calendar.getInstance()              trackCaptureDate.setTimeInMillis(track.getTimestamp())              if (trackCaptureDate.get(Calendar.YEAR) == currentDate.get(Calendar.YEAR) && trackCaptureDate.get(Calendar.MONTH) == currentDate.get(Calendar.MONTH) && trackCaptureDate.get(Calendar.DAY_OF_MONTH) == currentDate.get(Calendar.DAY_OF_MONTH)) {               tracksTodayCount++              }           }  while (tracksCursor.moveToNext())          }         tracksCursor.close()          return tracksTodayCount        }  catch (      Exception e) {         return -1        }     }     @Override protected void onPostExecute(    Integer tracksTodayCount){       if (!isDetached()) {         try {           tracksTodayCountTextView.setText(String.valueOf(tracksTodayCount))            tracksTodayCountLabelTextView.setText(WordFormUtil.getWordForm(tracksTodayCount,trackWordForms) + " " + getString(R.string.main_today))          }  catch (        Exception e) {           Loggi.e("MainFragment updateTracksTodayCount() exception: " + e.getMessage())          }       }     }   } )  } 
@Override protected Integer doInBackground(Void... params){   try {     final Calendar currentDate=Calendar.getInstance()      int tracksTodayCount=0      Cursor tracksCursor=TracksDBHelper.getInstance(getActivity().getApplicationContext()).getAllDesc()      if (tracksCursor.moveToFirst()) {       do {         Track track=TracksDBHelper.parseFromCursor(tracksCursor)          final Calendar trackCaptureDate=Calendar.getInstance()          trackCaptureDate.setTimeInMillis(track.getTimestamp())          if (trackCaptureDate.get(Calendar.YEAR) == currentDate.get(Calendar.YEAR) && trackCaptureDate.get(Calendar.MONTH) == currentDate.get(Calendar.MONTH) && trackCaptureDate.get(Calendar.DAY_OF_MONTH) == currentDate.get(Calendar.DAY_OF_MONTH)) {           tracksTodayCount++          }       }  while (tracksCursor.moveToNext())      }     tracksCursor.close()      return tracksTodayCount    }  catch (  Exception e) {     return -1    } } 
@Override protected void onPostExecute(Integer tracksTodayCount){   if (!isDetached()) {     try {       tracksTodayCountTextView.setText(String.valueOf(tracksTodayCount))        tracksTodayCountLabelTextView.setText(WordFormUtil.getWordForm(tracksTodayCount,trackWordForms) + " " + getString(R.string.main_today))      }  catch (    Exception e) {       Loggi.e("MainFragment updateTracksTodayCount() exception: " + e.getMessage())      }   } } 
private void updateTracksCountFromLastfm(){   final LFUserResponseModel userModel=WAILSettings.getLastfmUserInfo(getActivity())    if (userModel == null || userModel.getPlayCount() == -1) {     tracksTotalCountOnLastfmTextView.setVisibility(View.GONE)      tracksTotalCountOnLastfmLabelTextView.setVisibility(View.GONE)      tracksTotalCountOnLastfmLabelUnknownTextView.setVisibility(View.VISIBLE)      tracksTotalCountOnLastfmLabelUnknownTextView.setText(R.string.main_tracks_on_last_fm_unknown)    }  else {     tracksTotalCountOnLastfmTextView.setVisibility(View.VISIBLE)      tracksTotalCountOnLastfmLabelTextView.setVisibility(View.VISIBLE)      tracksTotalCountOnLastfmLabelUnknownTextView.setVisibility(View.GONE)      tracksTotalCountOnLastfmTextView.setText(String.valueOf(userModel.getPlayCount()))      tracksTotalCountOnLastfmLabelTextView.setText(WordFormUtil.getWordForm(userModel.getPlayCount(),trackWordForms) + " " + getString(R.string.main_tracks_on_last_fm))    } } 
private void updateNowScrobblingTrack(){   Track nowScrobblingTrack=WAILSettings.getNowScrobblingTrack(getActivity())    String label=WAILSettings.getNowScrobblingPlayerLabel(getActivity())    String packageName=WAILSettings.getNowScrobblingPlayerPackageName(getActivity())    final String nowScrobblingPlayer=label != null ? label : packageName    if (nowScrobblingTrack != null) {     nowScrobblingTrackTextView.setText(getString(R.string.main_now_scrobbling_label,nowScrobblingTrack.getArtist() + " - " + nowScrobblingTrack.getTrack()))      nowScrobblingPlayerTextView.setText(String.format(getString(R.string.main_scrobbling_from_player_label),nowScrobblingPlayer))      if (loveCurrentTrackButton.getVisibility() != View.VISIBLE) {       loveCurrentTrackButton.setVisibility(View.VISIBLE)      }     loveCurrentTrackButton.show()      ignorePlayerButton.setVisibility(View.VISIBLE)    }  else {     nowScrobblingTrackTextView.setText(getString(R.string.main_now_scrobbling_label,getString(R.string.main_now_scrobbling_nothing)))      nowScrobblingPlayerTextView.setText("")      loveCurrentTrackButton.hide()      ignorePlayerButton.setVisibility(View.GONE)    } } 
private void redrawLastUpdateTime(){   try {     final long lastUpdateTime=WAILSettings.getLastfmUserInfoUpdateTimestamp(getActivity())      if (lastUpdateTime == -1) {       lastfmUserInfoUpdateTimeTextView.setText("")        return      }     final Calendar lastUpdateDate=Calendar.getInstance()      lastUpdateDate.setTimeInMillis(lastUpdateTime)      final String text      final long timeDiff=System.currentTimeMillis() - lastUpdateTime      if (timeDiff < 86400000) {       SimpleDateFormat dateFormat=new SimpleDateFormat("HH:mm",Locale.getDefault())        text=getString(R.string.main_updated_today_at,dateFormat.format(lastUpdateDate.getTime()))      }  else     if (timeDiff >= 86400000 && timeDiff <= 172800000) {       SimpleDateFormat dateFormat=new SimpleDateFormat("HH:mm",Locale.getDefault())        text=getString(R.string.main_updated_yesterday_at,dateFormat.format(lastUpdateDate.getTime()))      }  else {       SimpleDateFormat dateFormat=new SimpleDateFormat("yyyy.MM.dd at HH:mm",Locale.getDefault())        text=getString(R.string.main_updated_common,dateFormat.format(lastUpdateDate.getTime()))      }     lastfmUserInfoUpdateTimeTextView.setText(text)    }  catch (  Exception e) {     lastfmUserInfoUpdateTimeTextView.setText("")    } } 
@Override public void onRefresh(){   Toast.makeText(getActivity(),getString(R.string.main_refreshing),Toast.LENGTH_SHORT).show()    refreshDataFromLastfm()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_MAIN_FRAGMENT,"pullToRefresh",null,1L).build())  } 
@OnClick(R.id.settings_ignored_players) public void onIgnoredPlayersClick(){   startActivity(new Intent(getActivity(),SettingsIgnoredPlayersActivity.class))  } 
@OnClick(R.id.settings_select_language_menu_item) public void onSelectLanguageClick(){   startActivity(new Intent(getActivity(),SettingsSelectLanguageActivity.class))  } 
@OnClick(R.id.settings_disable_scrobbling_over_mobile_network) public void onDisableScrobblingOverMobileChanged(){   SwitchCompat switchView=(SwitchCompat)getActivity().findViewById(R.id.settings_disable_scrobbling_over_mobile_network_switch)    onDisableScrobblingOverMobileChanged(switchView.isChecked())    switchView.setChecked(!switchView.isChecked())  } 
@OnCheckedChanged(R.id.settings_disable_scrobbling_over_mobile_network_switch) public void onDisableScrobblingOverMobileChanged(boolean isChecked){   if (isChecked == WAILSettings.isEnableScrobblingOverMobileNetwork(getActivity())) {     return    }   WAILSettings.setDisableScrobblingOverMobileNetwork(getActivity(),isChecked)    final String toast=isChecked ? getString(R.string.settings_scrobbling_over_mobile_network_enabled_toast) : getString(R.string.settings_scrobbling_over_mobile_network_disabled_toast)    Toast.makeText(getActivity(),toast,Toast.LENGTH_SHORT).show()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"Scrobbling over mobile network enabled: " + isChecked,null,isChecked ? 1L : 0L).build())  } 
@OnClick(R.id.settings_lastfm_update_nowplaying) public void onLastfmUpdateNowPlayingChanged(){   SwitchCompat switchView=(SwitchCompat)getActivity().findViewById(R.id.settings_lastfm_update_nowplaying_switch)    onLastfmUpdateNowPlayingChanged(switchView.isChecked())    switchView.setChecked(!switchView.isChecked())  } 
@OnCheckedChanged(R.id.settings_lastfm_update_nowplaying_switch) public void onLastfmUpdateNowPlayingChanged(boolean isChecked){   if (isChecked == WAILSettings.isLastfmNowplayingUpdateEnabled(getActivity())) {     return    }   WAILSettings.setLastfmNowplayingUpdateEnabled(getActivity(),isChecked)    final String toast=isChecked ? getString(R.string.settings_lastfm_update_nowplaying_enabled_toast) : getString(R.string.settings_lastfm_update_nowplaying_disabled_toast)    Toast.makeText(getActivity(),toast,Toast.LENGTH_SHORT).show()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"lastFmUpdateNowPlaying enabled: " + isChecked,null,isChecked ? 1L : 0L).build())  } 
@OnClick(R.id.settings_theme) public void onThemeChanged(){   SwitchCompat switchView=(SwitchCompat)getActivity().findViewById(R.id.settings_theme_switch)    onThemeChanged(switchView.isChecked())    switchView.setChecked(!switchView.isChecked())  } 
@OnCheckedChanged(R.id.settings_theme_switch) public void onThemeChanged(boolean isChecked){   if (isChecked == (WAILSettings.getTheme(getActivity()) == WAILSettings.Theme.DARK)) {     return    }   WAILSettings.setTheme(getActivity(),isChecked ? WAILSettings.Theme.DARK : WAILSettings.Theme.LIGHT)    ((BaseActivity)getActivity()).setTheme()    ((BaseActivity)getActivity()).restart()  } 
@OnClick(R.id.settings_sound_notifications) public void onSoundNotificationSettingClick(){   startActivity(new Intent(getActivity(),SettingsSoundNotificationsActivity.class))  } 
@OnClick(R.id.settings_status_bar_notifications) public void onStatusBarNotificationSettingClick(){   startActivity(new Intent(getActivity(),SettingsStatusBarNotificationsActivity.class))  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setHasOptionsMenu(true)    ((AppCompatActivity)getActivity()).getSupportActionBar().setTitle(R.string.settings_actionbar_title)  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_main_settings,container,false)  } 
@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){   super.onCreateOptionsMenu(menu,inflater)    inflater.inflate(R.menu.main_settings,menu)    SwitchCompat isWailEnabledSwitch=(SwitchCompat)MenuItemCompat.getActionView(menu.findItem(R.id.main_settings_menu_is_wail_enabled))    isWailEnabledSwitch.setChecked(WAILSettings.isEnabled(getActivity()))    isWailEnabledSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){     @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){       WAILSettings.setEnabled(getActivity(),isChecked)        final Toast toast=Toast.makeText(getActivity(),"",Toast.LENGTH_SHORT)        toast.setGravity(Gravity.TOP | Gravity.END,0,(int)DisplayUnitsConverter.dpToPx(getActivity(),60))        if (isChecked) {         setUIStateWailEnabled()          toast.setText(R.string.settings_wail_enabled_toast)        }  else {         setUIStateWailDisabled()          toast.setText(R.string.settings_wail_disabled_toast)        }       toast.show()        EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"isWailEnabled changed, enabled: " + isChecked,null,isChecked ? 1L : 0L).build())      }   } )  } 
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){   WAILSettings.setEnabled(getActivity(),isChecked)    final Toast toast=Toast.makeText(getActivity(),"",Toast.LENGTH_SHORT)    toast.setGravity(Gravity.TOP | Gravity.END,0,(int)DisplayUnitsConverter.dpToPx(getActivity(),60))    if (isChecked) {     setUIStateWailEnabled()      toast.setText(R.string.settings_wail_enabled_toast)    }  else {     setUIStateWailDisabled()      toast.setText(R.string.settings_wail_disabled_toast)    }   toast.show()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"isWailEnabled changed, enabled: " + isChecked,null,isChecked ? 1L : 0L).build())  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)    if (WAILSettings.isEnabled(getActivity())) {     setUIStateWailEnabled()    }  else {     setUIStateWailDisabled()    }   String lang=WAILSettings.getLanguage(getActivity())    if (lang == null) {     lang=getResources().getStringArray(R.array.settings_select_language_languages)[0]    }   languageMenuItemDescription.setText(lang)    refreshMinTrackDurationInPercents()    refreshMinTrackDurationInSeconds()    isScrobblingOverMobileNetworkDisabledSwitch.setChecked(WAILSettings.isEnableScrobblingOverMobileNetwork(getActivity()))    isLastfmUpdateNowplayingEnabledSwitch.setChecked(WAILSettings.isLastfmNowplayingUpdateEnabled(getActivity()))    logoutDescription.setText(WAILSettings.getLastfmUserName(getActivity()))    themeSwitch.setChecked(WAILSettings.getTheme(getActivity()) == WAILSettings.Theme.DARK)    try {     buildVersionDescTextView.setText(getActivity().getPackageManager().getPackageInfo(getActivity().getPackageName(),0).versionName)    }  catch (  Exception e) {     buildVersionDescTextView.setText("unknown")      EasyTracker.getInstance(getActivity()).send(MapBuilder.createException("Can not set build version in settings: " + e.getMessage(),false).build())    } } 
@Override public void onStart(){   super.onStart()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"started",null,1L).build())  } 
@Override public void onStop(){   super.onStop()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"stopped",null,0L).build())  } 
void setUIStateWailEnabled(){   ViewUtil.setEnabledForAllChildrenRecursively((ViewGroup)settingContainer,true)  } 
void setUIStateWailDisabled(){   ViewUtil.setEnabledForAllChildrenRecursively((ViewGroup)settingContainer,false)  } 
@OnClick(R.id.settings_min_track_duration_in_percents) void showMinTrackDurationInPercentsEditDialog(){   final DialogFragmentWithSeekBar dialogFragmentWithSeekBar=DialogFragmentWithSeekBar.newInstance(getString(R.string.settings_min_track_elapsed_time_in_percent_dialog_title),WAILSettings.getMinTrackDurationInPercents(getActivity()))    dialogFragmentWithSeekBar.setListener(this)    dialogFragmentWithSeekBar.show(getFragmentManager(),"minTrackDurationInPercentsDialog")  } 
@OnClick(R.id.settings_min_track_duration_in_seconds) void showMinTrackDurationInSecondsEditDialog(){   final DialogFragmentWithNumberPicker minTrackDurationInSecondsDialog=DialogFragmentWithNumberPicker.newInstance(getString(R.string.settings_min_track_elapsed_time_in_seconds_dialog_title),15,180,WAILSettings.getMinTrackDurationInSeconds(getActivity()))    minTrackDurationInSecondsDialog.setListener(this)    minTrackDurationInSecondsDialog.show(getFragmentManager(),"minTrackDurationInSecondsDialog")  } 
private void refreshMinTrackDurationInSeconds(){   final int minTrackDurationInSeconds=WAILSettings.getMinTrackDurationInSeconds(getActivity())    minDurationInSecondsDescription.setText(getString(R.string.settings_min_track_elapsed_time_in_seconds_desc,minTrackDurationInSeconds + " " + WordFormUtil.getWordForm(minTrackDurationInSeconds,getResources().getStringArray(R.array.word_forms_second))))  } 
private void refreshMinTrackDurationInPercents(){   minDurationInPercentsDescription.setText(getString(R.string.settings_min_track_elapsed_time_in_percent_desc,WAILSettings.getMinTrackDurationInPercents(getActivity())))  } 
@OnClick(R.id.settings_logout_menu_item) public void logout(){   new MaterialDialog.Builder(getActivity()).theme(Theme.DARK).title(R.string.setting_logout_warning).positiveText("Ok").negativeText(R.string.dialog_cancel).callback(new MaterialDialog.ButtonCallback(){     @Override public void onPositive(    MaterialDialog dialog){       WAILSettings.clearAllSettings(getActivity())        AppDBManager.getInstance(getActivity()).clearAll()        LocaleUtil.updateLanguage(getActivity(),null)        startActivity(new Intent(getActivity(),MainActivity.class))        getActivity().finish()      }     @Override public void onNegative(    MaterialDialog dialog){       dialog.dismiss()      }   } ).build().show()  } 
@Override public void onPositive(MaterialDialog dialog){   WAILSettings.clearAllSettings(getActivity())    AppDBManager.getInstance(getActivity()).clearAll()    LocaleUtil.updateLanguage(getActivity(),null)    startActivity(new Intent(getActivity(),MainActivity.class))    getActivity().finish()  } 
@Override public void onNegative(MaterialDialog dialog){   dialog.dismiss()  } 
@OnClick(R.id.settings_email_to_developers) public void emailToTheDeveloper(){   try {     final Intent emailIntent=new Intent(Intent.ACTION_SEND)      String emailsString=getString(R.string.settings_developers_emails)      String[] emails=emailsString.substring(0,emailsString.indexOf('(') - 1).split(",")      emailIntent.putExtra(Intent.EXTRA_EMAIL,emails)      emailIntent.putExtra(Intent.EXTRA_SUBJECT,getString(R.string.settings_email_to_the_developer_subj) + " " + buildVersionDescTextView.getText().toString())      emailIntent.setType("message/rfc822")      startActivity(Intent.createChooser(emailIntent,getString(R.string.settings_email_dialog_title)))      EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_FRAGMENT,"emailToTheDeveloperClicked",null,1L).build())    }  catch (  Exception e) {     EasyTracker.getInstance(getActivity()).send(MapBuilder.createException("Can not send email to the developer: " + e,false).build())    } } 
@Override public void onDismiss(){   refreshMinTrackDurationInPercents()    refreshMinTrackDurationInSeconds()  } 
@Override public void onReceive(Context context,Intent intent){   reloadTracksAsync()  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setHasOptionsMenu(true)    ((AppCompatActivity)getActivity()).getSupportActionBar().setTitle(getString(R.string.tracks_actionbar_title))    tracksListAdapter=new TracksListAdapter(tracksListDataProvider)  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_tracks_list,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)    setUIStateLoading()    tracksListView.setAdapter(tracksListAdapter)    tracksListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){     @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){       Track track=(Track)parent.getAdapter().getItem(position)        TrackActionsDialog.newInstance(track).show(getFragmentManager(),"trackActionsDialog")      }   } )  } 
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){   Track track=(Track)parent.getAdapter().getItem(position)    TrackActionsDialog.newInstance(track).show(getFragmentManager(),"trackActionsDialog")  } 
private void setUIStateLoading(){   ViewUtil.setVisibility(tracksListLoading,true)    ViewUtil.setVisibility(tracksListEmpty,false)    ViewUtil.setVisibility(tracksListContainer,false)  } 
private void setUIStateEmpty(String emptyText){   emptyTextView.setText(emptyText)    ViewUtil.setVisibility(tracksListLoading,false)    ViewUtil.setVisibility(tracksListEmpty,true)    ViewUtil.setVisibility(tracksListContainer,false)  } 
private void setUIStateShowTracks(){   ViewUtil.setVisibility(tracksListLoading,false)    ViewUtil.setVisibility(tracksListEmpty,false)    ViewUtil.setVisibility(tracksListContainer,true)  } 
@Override public void onStart(){   super.onStart()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_TRACKS_LIST_FRAGMENT,"started",null,1L).build())  } 
@Override public void onResume(){   super.onResume()    subscribeForDBUpdates()    reloadTracksAsync()  } 
@Override public void onPause(){   super.onPause()    unsubscribeFromDBUpdates()  } 
@Override public void onStop(){   super.onStop()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_TRACKS_LIST_FRAGMENT,"stopped",null,0L).build())  } 
private void subscribeForDBUpdates(){   LocalBroadcastManager.getInstance(getActivity()).registerReceiver(tracksChangedBroadcastReceiver,new IntentFilter(TracksDBHelper.INTENT_TRACKS_CHANGED))  } 
private void unsubscribeFromDBUpdates(){   LocalBroadcastManager.getInstance(getActivity()).unregisterReceiver(tracksChangedBroadcastReceiver)  } 
@Override public void onCreateOptionsMenu(Menu menu,MenuInflater inflater){   super.onCreateOptionsMenu(menu,inflater)    inflater.inflate(R.menu.main_tracks,menu)    tracksSearchHandler.setSearchItem(menu.findItem(R.id.main_tracks_ab_search))  } 
private void reloadTracksAsync(){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Cursor>(){     @Override protected void onPreExecute(){       super.onPreExecute()        try {         setUIStateLoading()        }  catch (      Exception e) {         Loggi.e("TracksListFragment.reloadTracksAsync().onPreExecute()" + e)        }     }     @Override protected Cursor doInBackground(    Void... params){       try {         return TracksDBHelper.getInstance(getActivity()).getAllDesc()        }  catch (      Exception e) {         return null        }     }     @Override protected void onPostExecute(    Cursor tracksCursor){       super.onPostExecute(tracksCursor)        if (!isDetached()) {         try {           if (tracksCursor == null || tracksCursor.getCount() == 0) {             setUIStateEmpty(getString(R.string.tracks_list_empty_motivation_text))            }  else {             setUIStateShowTracks()            }           tracksListDataProvider.setDataSource(tracksCursor)          }  catch (        Exception e) {           Loggi.e("TracksListFragment reloadTracksAsync() exception: " + e.getMessage())          }       }     }   } )  } 
@Override protected void onPreExecute(){   super.onPreExecute()    try {     setUIStateLoading()    }  catch (  Exception e) {     Loggi.e("TracksListFragment.reloadTracksAsync().onPreExecute()" + e)    } } 
@Override protected Cursor doInBackground(Void... params){   try {     return TracksDBHelper.getInstance(getActivity()).getAllDesc()    }  catch (  Exception e) {     return null    } } 
@Override protected void onPostExecute(Cursor tracksCursor){   super.onPostExecute(tracksCursor)    if (!isDetached()) {     try {       if (tracksCursor == null || tracksCursor.getCount() == 0) {         setUIStateEmpty(getString(R.string.tracks_list_empty_motivation_text))        }  else {         setUIStateShowTracks()        }       tracksListDataProvider.setDataSource(tracksCursor)      }  catch (    Exception e) {       Loggi.e("TracksListFragment reloadTracksAsync() exception: " + e.getMessage())      }   } } 
public void setListener(Listener listener){   this.listener=listener  } 
public void setDataSource(Cursor tracksCursor){   if (this.tracksCursor != null) {     this.tracksCursor.close()    }   this.tracksCursor=tracksCursor    tracksList=null    notifyOnDataSourceChanged()  } 
public void setDataSource(List<Track> tracksList){   if (this.tracksCursor != null) {     this.tracksCursor.close()    }   this.tracksList=tracksList    tracksCursor=null    notifyOnDataSourceChanged()  } 
public int getCount(){   if (tracksCursor != null) {     return tracksCursor.getCount()    }  else   if (tracksList != null) {     return tracksList.size()    }  else {     return 0    } } 
public Track getAtPos(int pos){   if (tracksCursor != null) {     tracksCursor.moveToPosition(pos)      return TracksDBHelper.parseFromCursor(tracksCursor)    }  else   if (tracksList != null) {     return tracksList.get(pos)    }   return null  } 
private void notifyOnDataSourceChanged(){   if (listener != null) {     listener.onDataSourceChanged()    } } 
void onDataSourceChanged()  
public TrackViewHolder(View convertView){   ButterKnife.inject(this,convertView)  } 
public TracksListAdapter(TracksListDataProvider tracksListDataProvider){   this.mTracksListDataProvider=tracksListDataProvider    this.mTracksListDataProvider.setListener(this)    mTrackStateColors=loadTrackStateColors()  } 
private int[] loadTrackStateColors(){   int[] colors=new int[5]    colors[0]=getResources().getColor(R.color.track_state_waiting_for_scrobble)    colors[1]=getResources().getColor(R.color.track_state_scrobbling)    colors[2]=getResources().getColor(R.color.track_state_error)    colors[3]=getResources().getColor(R.color.track_state_scrobble_success)    colors[4]=getResources().getColor(R.color.track_state_unknown)    return colors  } 
@Override public int getCount(){   return mTracksListDataProvider.getCount()  } 
@Override public Track getItem(int position){   return mTracksListDataProvider.getAtPos(position)  } 
@Override public long getItemId(int position){   return mTracksListDataProvider.getAtPos(position).hashCode()  } 
@Override public View getView(int position,View convertView,ViewGroup parent){   final TrackViewHolder trackViewHolder    if (convertView == null) {     convertView=LayoutInflater.from(getActivity()).inflate(R.layout.track_list_item,parent,false)      trackViewHolder=new TrackViewHolder(convertView)      convertView.setTag(trackViewHolder)    }  else {     trackViewHolder=(TrackViewHolder)convertView.getTag()    }   drawTrackView(convertView,trackViewHolder,position)    return convertView  } 
private void drawTrackView(View convertView,TrackViewHolder trackViewHolder,int position){   final Track track=mTracksListDataProvider.getAtPos(position)    trackViewHolder.trackTextView.setText(track.getTrack())    String artistAndAlbum    if (!TextUtils.isEmpty(track.getArtist())) {     artistAndAlbum=track.getArtist()      if (!TextUtils.isEmpty(track.getAlbum())) {       artistAndAlbum+="  " + track.getAlbum()      }   }  else   if (!TextUtils.isEmpty(track.getAlbum())) {     artistAndAlbum=track.getAlbum()    }  else {     artistAndAlbum=getString(R.string.track_artist_and_album_no_data)    }   trackViewHolder.artistAndAlbumTextView.setText(artistAndAlbum)  switch (track.getState()) { case Track.STATE_WAITING_FOR_SCROBBLE:     trackViewHolder.statusTextView.setText(R.string.track_status_waiting_for_scrobble)    trackViewHolder.statusTextView.setTextColor(mTrackStateColors[0])  break  case Track.STATE_SCROBBLING: trackViewHolder.statusTextView.setText(R.string.track_status_scrobbling)  trackViewHolder.statusTextView.setTextColor(mTrackStateColors[1])  break  case Track.STATE_SCROBBLE_ERROR: trackViewHolder.statusTextView.setText(R.string.track_status_scrobble_error)  trackViewHolder.statusTextView.setTextColor(mTrackStateColors[2])  break  case Track.STATE_SCROBBLE_SUCCESS: trackViewHolder.statusTextView.setText(R.string.track_status_scrobble_success)  trackViewHolder.statusTextView.setTextColor(mTrackStateColors[3])  break  default : trackViewHolder.statusTextView.setText(R.string.track_status_unknown)  trackViewHolder.statusTextView.setTextColor(mTrackStateColors[4])  break  } Calendar calendar=Calendar.getInstance()  calendar.setTimeInMillis(track.getTimestamp())  final String dateText=mDateFormatWithYear.format(calendar.getTime())  trackViewHolder.dateTextView.setText(dateText)  } 
@Override public void onDataSourceChanged(){   notifyDataSetChanged()  } 
public void setSearchItem(MenuItem menuItem){   searchViewText=(SearchView)MenuItemCompat.getActionView(menuItem).findViewById(R.id.main_tracks_ab_search)    searchViewText.setOnQueryTextListener(this)  } 
@Override public boolean onQueryTextSubmit(String s){   searchAsync(s)    return true  } 
@Override public boolean onQueryTextChange(String s){   searchAsync(s)    return true  } 
public void searchAsync(String text){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<String,Void,List<Track>>(){     private String text      @Override protected void onPreExecute(){       super.onPreExecute()        try {         unsubscribeFromDBUpdates()          setUIStateLoading()        }  catch (      Exception e) {         Loggi.e("TracksListFragment.TracksSearchHandler.searchAsync().onPreExecute() " + e)        }     }     @Override protected List<Track> doInBackground(    String... params){       try {         text=params[0].toLowerCase(Locale.getDefault())          Cursor cursor=TracksDBHelper.getInstance(getActivity()).getAllDesc()          final List<Track> tracks=new ArrayList<Track>()          if (cursor.moveToFirst()) {           do {             Track track=TracksDBHelper.parseFromCursor(cursor)              if (track.getTrack() != null && track.getTrack().toLowerCase(Locale.getDefault()).contains(text)) {               tracks.add(track)              }  else             if (track.getArtist() != null && track.getArtist().toLowerCase(Locale.getDefault()).contains(text)) {               tracks.add(track)              }  else             if (track.getAlbum() != null && track.getAlbum().toLowerCase(Locale.getDefault()).contains(text)) {               tracks.add(track)              }           }  while (cursor.moveToNext())          }         return tracks        }  catch (      Exception e) {         return null        }     }     @Override protected void onPostExecute(    List<Track> tracks){       super.onPostExecute(tracks)        try {         if (tracks == null) {           Toast.makeText(getActivity(),R.string.tracks_search_error_toast,Toast.LENGTH_LONG).show()          }  else         if (tracks.size() == 0) {           setUIStateEmpty(getString(R.string.tracks_search_no_results,text))          }  else {           setUIStateShowTracks()            tracksListDataProvider.setDataSource(tracks)            tracksListView.smoothScrollToPosition(0)          }       }  catch (      Exception e) {         Loggi.e("TracksListFragment.TracksSearchHandler.onPostExecute() " + e)        }     }   } ,text)  } 
@Override protected void onPreExecute(){   super.onPreExecute()    try {     unsubscribeFromDBUpdates()      setUIStateLoading()    }  catch (  Exception e) {     Loggi.e("TracksListFragment.TracksSearchHandler.searchAsync().onPreExecute() " + e)    } } 
@Override protected List<Track> doInBackground(String... params){   try {     text=params[0].toLowerCase(Locale.getDefault())      Cursor cursor=TracksDBHelper.getInstance(getActivity()).getAllDesc()      final List<Track> tracks=new ArrayList<Track>()      if (cursor.moveToFirst()) {       do {         Track track=TracksDBHelper.parseFromCursor(cursor)          if (track.getTrack() != null && track.getTrack().toLowerCase(Locale.getDefault()).contains(text)) {           tracks.add(track)          }  else         if (track.getArtist() != null && track.getArtist().toLowerCase(Locale.getDefault()).contains(text)) {           tracks.add(track)          }  else         if (track.getAlbum() != null && track.getAlbum().toLowerCase(Locale.getDefault()).contains(text)) {           tracks.add(track)          }       }  while (cursor.moveToNext())      }     return tracks    }  catch (  Exception e) {     return null    } } 
@Override protected void onPostExecute(List<Track> tracks){   super.onPostExecute(tracks)    try {     if (tracks == null) {       Toast.makeText(getActivity(),R.string.tracks_search_error_toast,Toast.LENGTH_LONG).show()      }  else     if (tracks.size() == 0) {       setUIStateEmpty(getString(R.string.tracks_search_no_results,text))      }  else {       setUIStateShowTracks()        tracksListDataProvider.setDataSource(tracks)        tracksListView.smoothScrollToPosition(0)      }   }  catch (  Exception e) {     Loggi.e("TracksListFragment.TracksSearchHandler.onPostExecute() " + e)    } } 
@OnClick(R.id.non_authorized_sign_in_button) public void onSignInButtonClick(){   getToken()    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_CATEGORY,"signInClicked",null,1L).build())  } 
@OnClick(R.id.non_authorized_sign_up_button) public void onSignUpButtonClick(){   startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse("https://www.last.fm/join")))    EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_CATEGORY,"signUpClicked",null,2L).build())  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_non_authorized,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)  } 
@Override public void onResume(){   super.onResume()    if (WAILSettings.getKeyLastfmToken(getActivity()) != null) {     getSessionKey()    } } 
private AlertDialog getProgressDialog(){   if (progressDialog == null) {     View view=getActivity().getLayoutInflater().inflate(R.layout.fragment_progress_dialog,null)      ((TextView)view.findViewById(R.id.progress_dialog_message)).setText(getString(R.string.lastfm_logging_progress_dialog_message))      progressDialog=new AlertDialog.Builder(getActivity()).setView(view).setCancelable(false).create()    }   return progressDialog  } 
private void getToken(){   AsyncTask<Void,Void,String> task=new AsyncTask<Void,Void,String>(){     private Exception exception      @Override protected void onPreExecute(){       getProgressDialog().show()      }     @Override protected String doInBackground(    Void... params){       try {         return LFAuthApi.getToken(WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret()).getToken()        }  catch (      Exception e) {         exception=e          return null        }     }     @Override protected void onPostExecute(    String token){       getProgressDialog().dismiss()        if (exception == null) {         WAILSettings.setKeyLastfmToken(getActivity(),token)          Intent intent=new Intent(Intent.ACTION_VIEW)          intent.setData(Uri.parse(String.format(LFApiCommon.AUTHORIZATION_URL,WAILSettings.getLastfmApiKey(),token)))          startActivity(intent)        }  else {         handleException(exception)        }     }   }     task.execute()  } 
@Override protected void onPreExecute(){   getProgressDialog().show()  } 
@Override protected String doInBackground(Void... params){   try {     return LFAuthApi.getToken(WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret()).getToken()    }  catch (  Exception e) {     exception=e      return null    } } 
@Override protected void onPostExecute(String token){   getProgressDialog().dismiss()    if (exception == null) {     WAILSettings.setKeyLastfmToken(getActivity(),token)      Intent intent=new Intent(Intent.ACTION_VIEW)      intent.setData(Uri.parse(String.format(LFApiCommon.AUTHORIZATION_URL,WAILSettings.getLastfmApiKey(),token)))      startActivity(intent)    }  else {     handleException(exception)    } } 
private void getSessionKey(){   new AsyncTask<Void,Void,Void>(){     private Exception exception      @Override protected void onPreExecute(){       getProgressDialog().show()      }     @Override protected Void doInBackground(    Void... params){       try {         LFSessionResponseModel sessionModel=LFAuthApi.getSession(WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),WAILSettings.getKeyLastfmToken(getActivity()))          WAILSettings.setLastfmSessionKey(getActivity(),sessionModel.getKey())          WAILSettings.setLastfmUserName(getActivity(),sessionModel.getName())          WAILSettings.setEnabled(getActivity(),true)        }  catch (      NetworkException e) {         exception=e        }       return null      }     @Override protected void onPostExecute(    Void aVoid){       getProgressDialog().dismiss()        WAILSettings.setKeyLastfmToken(getActivity(),null)        if (exception == null) {         getActivity().setResult(Activity.RESULT_OK)          getActivity().finish()        }  else {         handleException(exception)        }     }   } .execute()  } 
@Override protected void onPreExecute(){   getProgressDialog().show()  } 
@Override protected Void doInBackground(Void... params){   try {     LFSessionResponseModel sessionModel=LFAuthApi.getSession(WAILSettings.getLastfmApiKey(),WAILSettings.getLastfmSecret(),WAILSettings.getKeyLastfmToken(getActivity()))      WAILSettings.setLastfmSessionKey(getActivity(),sessionModel.getKey())      WAILSettings.setLastfmUserName(getActivity(),sessionModel.getName())      WAILSettings.setEnabled(getActivity(),true)    }  catch (  NetworkException e) {     exception=e    }   return null  } 
@Override protected void onPostExecute(Void aVoid){   getProgressDialog().dismiss()    WAILSettings.setKeyLastfmToken(getActivity(),null)    if (exception == null) {     getActivity().setResult(Activity.RESULT_OK)      getActivity().finish()    }  else {     handleException(exception)    } } 
private void handleException(Exception exception){   if (exception instanceof NetworkException) {     Toast.makeText(getActivity(),getString(R.string.lastfm_logging_network_error),Toast.LENGTH_LONG).show()    }  else   if (exception instanceof LFApiException) {     LFApiException lfApiException=(LFApiException)exception      if (LFApiException.ERROR_TOKEN_EXPIRED.equals(lfApiException.getError())) {       Toast.makeText(getActivity(),getString(R.string.lastfm_logging_api_error_15),Toast.LENGTH_LONG).show()      }  else     if (LFApiException.ERROR_NOT_AUTHORIZED_TOKEN.equals(lfApiException.getError())) {       Toast.makeText(getActivity(),getString(R.string.lastfm_logging_api_error_14),Toast.LENGTH_LONG).show()      }  else     if (LFApiException.ERROR_SERVICE_OFFLINE.equals(lfApiException.getError())) {       Toast.makeText(getActivity(),getString(R.string.lastfm_api_error_11),Toast.LENGTH_LONG).show()      }  else {       Toast.makeText(getActivity(),getString(R.string.lastfm_logging_api_error_unknown),Toast.LENGTH_LONG).show()      }   } } 
@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_settings_ignored_players,container)  } 
@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    dbHelper=IgnoredPlayersDBHelper.getInstance(getActivity())    packageManager=getActivity().getPackageManager()    ButterKnife.inject(this,view)    List<ApplicationInfo> players=dbHelper.getAll()    if (players.size() == 0) {     noPlayersContainer.setVisibility(View.VISIBLE)    }  else {     ArrayAdapter<ApplicationInfo> adapter=new ArrayAdapter<ApplicationInfo>(getActivity(),R.layout.settings_ignored_players_item_layout,players){       @Override public View getView(      int position,      View view,      ViewGroup parent){         ViewHolder holder          View rowView=view          if (rowView == null) {           LayoutInflater inflater=getActivity().getLayoutInflater()            rowView=inflater.inflate(R.layout.settings_ignored_players_item_layout,parent,false)            holder=new ViewHolder()            holder.textView=(TextView)rowView.findViewById(R.id.settings_ignored_players_list_view_text)            holder.imageView=(ImageView)rowView.findViewById(R.id.settings_ignored_players_list_view_image)            rowView.setTag(holder)          }  else {           holder=(ViewHolder)rowView.getTag()          }         holder.textView.setText(packageManager.getApplicationLabel(getItem(position)))          holder.imageView.setImageDrawable(packageManager.getApplicationIcon(getItem(position)))          return rowView        }     }       listView.setAdapter(adapter)      listView.setOnItemClickListener(this)    } } 
@Override public View getView(int position,View view,ViewGroup parent){   ViewHolder holder    View rowView=view    if (rowView == null) {     LayoutInflater inflater=getActivity().getLayoutInflater()      rowView=inflater.inflate(R.layout.settings_ignored_players_item_layout,parent,false)      holder=new ViewHolder()      holder.textView=(TextView)rowView.findViewById(R.id.settings_ignored_players_list_view_text)      holder.imageView=(ImageView)rowView.findViewById(R.id.settings_ignored_players_list_view_image)      rowView.setTag(holder)    }  else {     holder=(ViewHolder)rowView.getTag()    }   holder.textView.setText(packageManager.getApplicationLabel(getItem(position)))    holder.imageView.setImageDrawable(packageManager.getApplicationIcon(getItem(position)))    return rowView  } 
@OnItemClick(R.id.settings_ignored_players_list_view) public void onItemClick(final AdapterView<?> adapterView,View view,int i,long l){   final ApplicationInfo applicationInfo=(ApplicationInfo)adapterView.getAdapter().getItem(i)    AlertDialog.Builder builder=new AlertDialog.Builder(getActivity())    View titleView=View.inflate(getActivity(),R.layout.dialog_fragment_title,null)    ((TextView)titleView.findViewById(R.id.dialog_fragment_title_text_view)).setText(String.format(getString(R.string.settings_confirm_unignoring_player),packageManager.getApplicationLabel(applicationInfo)))    builder.setCustomTitle(titleView).setPositiveButton("Ok",new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialog,    int which){       dbHelper.delete(applicationInfo.packageName)        getActivity().startService(new Intent(getActivity(),WAILService.class).setAction(WAILService.INTENT_ACTION_HANDLE_PREVIOUSLY_IGNORED_TRACK))        onViewCreated(getView(),null)      }   } ).setNegativeButton(getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){     public void onClick(    DialogInterface dialog,    int id){       dialog.dismiss()      }   } ).show()  } 
@Override public void onClick(DialogInterface dialog,int which){   dbHelper.delete(applicationInfo.packageName)    getActivity().startService(new Intent(getActivity(),WAILService.class).setAction(WAILService.INTENT_ACTION_HANDLE_PREVIOUSLY_IGNORED_TRACK))    onViewCreated(getView(),null)  } 
public void onClick(DialogInterface dialog,int id){   dialog.dismiss()  } 
private static String[] markCurrentLanguageAsSelected(Context context,String[] languages){   try {     final String currentLanguage=WAILSettings.getLanguage(context)      boolean languageWasSelected=false      for (int i=0  i < languages.length  i++) {       final String lang=languages[i]        if (currentLanguage.equalsIgnoreCase(lang)) {         languages[i]=context.getString(R.string.settings_select_language_current_lang,lang)          languageWasSelected=true          break        }     }     if (!languageWasSelected) {       languages[0]=context.getString(R.string.settings_select_language_current_lang,languages[0])      }     return languages    }  catch (  Exception e) {     Loggi.e(e.toString())      return languages    } } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_settings_select_language,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)    languages=markCurrentLanguageAsSelected(getActivity(),getResources().getStringArray(R.array.settings_select_language_languages))    BaseAdapter adapter=new ArrayAdapter<>(getActivity(),R.layout.settings_select_language_item,languages)    languagesList.setAdapter(adapter)  } 
@OnItemClick(R.id.settings_select_language_list_view) public void onItemClick(AdapterView<?> adapterView,View view,int i,long l){ switch (i) { case 0:     LocaleUtil.updateLanguage(getActivity(),Locale.getDefault().getDisplayLanguage())    break  default : String language=languages[i]  if (language.contains("(")) { language=language.substring(0,language.indexOf("(") - 1)  } LocaleUtil.updateLanguage(getActivity(),language)  break  } EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_SELECT_LANGUAGE,"languageChangedTo",i == 0 ? "default" : languages[i],0L).build())  getActivity().finish()  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_settings_sound_notifications,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)    final Activity activity=getActivity()    trackMarkedAsScrobbledSoundSwitch.setChecked(WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(activity))    trackSkippedSoundSwitch.setChecked(WAILSettings.isSoundNotificationTrackSkippedEnabled(activity))  } 
@OnCheckedChanged(R.id.settings_sound_notifications_track_marked_as_scrobbled_switch) public void onTrackMarkedAsScrobbledChanged(boolean isChecked){   final Activity activity=getActivity()    if (isChecked == WAILSettings.isSoundNotificationTrackMarkedAsScrobbledEnabled(activity)) {     return    }   WAILSettings.setSoundNotificationTrackMarkedAsScrobbledEnabled(activity,isChecked)    EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_SOUND_NOTIFICATIONS,"trackMarkedAsScrobbledSoundSwitch",isChecked ? "enabled" : "disabled",isChecked ? 1L : 0L).build())  } 
@OnCheckedChanged(R.id.settings_sound_notifications_track_skipped_switch) public void onTrackSkippedChanged(boolean isChecked){   final Activity activity=getActivity()    if (isChecked == WAILSettings.isSoundNotificationTrackSkippedEnabled(activity)) {     return    }   WAILSettings.setSoundNotificationTrackSkippedEnabled(activity,isChecked)    EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_SOUND_NOTIFICATIONS,"trackSkippedSoundSwitch",isChecked ? "enabled" : "disabled",isChecked ? 1L : 0L).build())  } 
@OnClick(R.id.settings_sound_notifications_track_marked_as_scrobbled) public void tryToPlayTrackMarkedAsScrobbledSound(){   Activity activity=getActivity()    EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_SOUND_NOTIFICATIONS,"playTrackMarkedAsScrobbledSound",null,1L).build())    try {     SoundNotificationsManager.getInstance(activity).playTrackMarkedAsScrobbledSound(true)    }  catch (  Exception e) {     Loggi.e("SettingsSoundNotificationsFragment.tryToPlayTrackMarkedAsScrobbledSound() exception: " + e)      Toast.makeText(activity,R.string.settings_sound_notifications_toast_can_not_play_sound,Toast.LENGTH_LONG).show()    } } 
@OnClick(R.id.settings_sound_notifications_track_skipped) public void tryToPlayTrackSkippedSound(){   Activity activity=getActivity()    EasyTracker.getInstance(activity).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_SOUND_NOTIFICATIONS,"playTrackSkippedSound",null,1L).build())    try {     SoundNotificationsManager.getInstance(activity).playTrackSkippedSound(true)    }  catch (  Exception e) {     Loggi.e("SettingsSoundNotificationsFragment.tryToPlayTrackSkippedSound() exception: " + e)      Toast.makeText(activity,R.string.settings_sound_notifications_toast_can_not_play_sound,Toast.LENGTH_LONG).show()    } } 
@OnClick(R.id.settings_status_bar_notifications_track_now_scrobbling) public void onStatusBarNotificationClick(){   View switchView=getActivity().findViewById(R.id.settings_status_bar_notifications_track_now_scrobbling_switch)    onStatusBarNotificationSwitchChanged(((SwitchCompat)switchView).isChecked())    ((SwitchCompat)switchView).setChecked(!((SwitchCompat)switchView).isChecked())  } 
@OnCheckedChanged(R.id.settings_status_bar_notifications_track_now_scrobbling_switch) public void onStatusBarNotificationSwitchChanged(boolean isChecked){   if (isChecked == WAILSettings.isStatusBarNotificationTrackScrobblingEnabled(getActivity())) {     return    }   WAILSettings.setStatusBarNotificationTrackScrobblingEnabled(getActivity(),isChecked)    if (isChecked) {     Track track=WAILSettings.getNowScrobblingTrack(getActivity())      if (track != null) {       StatusBarNotificationsManager.getInstance(getActivity()).showTrackScrobblingStatusBarNotification(track)      }     setMinPriorityEnabled(true)    }  else {     StatusBarNotificationsManager.getInstance(getActivity()).cancelAllNotifications()      setMinPriorityEnabled(false)    }   EasyTracker.getInstance(getActivity()).send(MapBuilder.createEvent(GA_EVENT_SETTINGS_STATUS_BAR_NOTIFICATIONS,"nowPlayingStatusBarNotifications",isChecked ? "enabled" : "disabled",isChecked ? 1L : 0L).build())  } 
@OnClick(R.id.settings_status_bar_notifications_min_priority) public void onStatusBarNotificationMinPriorityClick(){   View switchView=getActivity().findViewById(R.id.settings_status_bar_notifications_min_priority_switch)    onStatusBarNotificationMinPrioritySwitchChanged(((SwitchCompat)switchView).isChecked())    ((SwitchCompat)switchView).setChecked(!((SwitchCompat)switchView).isChecked())  } 
@OnCheckedChanged(R.id.settings_status_bar_notifications_min_priority_switch) public void onStatusBarNotificationMinPrioritySwitchChanged(boolean isChecked){   if (isChecked == WAILSettings.isStatusBarNotificationMinPriority(getActivity())) {     return    }   WAILSettings.setStatusBarNotificationMinPriority(getActivity(),isChecked)  } 
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){   return inflater.inflate(R.layout.fragment_settings_status_bar_notifications,container,false)  } 
@Override public void onViewCreated(View view,Bundle savedInstanceState){   super.onViewCreated(view,savedInstanceState)    ButterKnife.inject(this,view)    boolean statusBarNotificationTrackScrobblingEnabled=WAILSettings.isStatusBarNotificationTrackScrobblingEnabled(getActivity())    trackNowScrobblingStatusBarNotificationsSwitch.setChecked(statusBarNotificationTrackScrobblingEnabled)    trackNowScrobblingStatusBarNotificationsMinPriority.setChecked(WAILSettings.isStatusBarNotificationMinPriority(getActivity()))    if (!statusBarNotificationTrackScrobblingEnabled) {     setMinPriorityEnabled(false)    } } 
private void setMinPriorityEnabled(boolean enabled){   ViewUtil.setEnabledForAllChildrenRecursively((ViewGroup)statusBarNotificationsMinPriority,enabled)    statusBarNotificationsMinPriority.setEnabled(enabled)  } 
public ScrimInsetsFrameLayout(Context context){   super(context)    init(context,null,0)  } 
public ScrimInsetsFrameLayout(Context context,AttributeSet attrs){   super(context,attrs)    init(context,attrs,0)  } 
public ScrimInsetsFrameLayout(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)    init(context,attrs,defStyle)  } 
private void init(Context context,AttributeSet attrs,int defStyle){   final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.ScrimInsetsView,defStyle,0)    if (a == null) {     return    }   mInsetForeground=a.getDrawable(R.styleable.ScrimInsetsView_insetForeground)    a.recycle()    setWillNotDraw(true)  } 
@Override protected boolean fitSystemWindows(Rect insets){   mInsets=new Rect(insets)    setWillNotDraw(mInsetForeground == null)    ViewCompat.postInvalidateOnAnimation(this)    if (mOnInsetsCallback != null) {     mOnInsetsCallback.onInsetsChanged(insets)    }   return true  } 
@Override public void draw(Canvas canvas){   super.draw(canvas)    int width=getWidth()    int height=getHeight()    if (mInsets != null && mInsetForeground != null) {     int sc=canvas.save()      canvas.translate(getScrollX(),getScrollY())      mTempRect.set(0,0,width,mInsets.top)      mInsetForeground.setBounds(mTempRect)      mInsetForeground.draw(canvas)      mTempRect.set(0,height - mInsets.bottom,width,height)      mInsetForeground.setBounds(mTempRect)      mInsetForeground.draw(canvas)      mTempRect.set(0,mInsets.top,mInsets.left,height - mInsets.bottom)      mInsetForeground.setBounds(mTempRect)      mInsetForeground.draw(canvas)      mTempRect.set(width - mInsets.right,mInsets.top,width,height - mInsets.bottom)      mInsetForeground.setBounds(mTempRect)      mInsetForeground.draw(canvas)      canvas.restoreToCount(sc)    } } 
@Override protected void onAttachedToWindow(){   super.onAttachedToWindow()    if (mInsetForeground != null) {     mInsetForeground.setCallback(this)    } } 
@Override protected void onDetachedFromWindow(){   super.onDetachedFromWindow()    if (mInsetForeground != null) {     mInsetForeground.setCallback(null)    } } 
/**   * Allows the calling container to specify a callback for custom processing when insets change (i.e. when {@link #fitSystemWindows(android.graphics.Rect)} is called. This is useful for setting padding on UI elements based onUI chrome insets (e.g. a Google Map or a ListView). When using with ListView or GridView, remember to set clipToPadding to false.  */ public void setOnInsetsCallback(OnInsetsCallback onInsetsCallback){   mOnInsetsCallback=onInsetsCallback  } 
public void onInsetsChanged(Rect insets)  
void onSoftKeyboardOpened(int keyboardHeightInPx)  
void onSoftKeyboardClosed()  
public SoftKeyboardStateHelper(View activityRootView){   this(activityRootView,false)  } 
public SoftKeyboardStateHelper(View activityRootView,boolean isSoftKeyboardOpened){   this.activityRootView=activityRootView    this.isSoftKeyboardOpened=isSoftKeyboardOpened    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(this)  } 
@Override public void onGlobalLayout(){   final Rect r=new Rect()    activityRootView.getWindowVisibleDisplayFrame(r)    final int heightDiff=activityRootView.getRootView().getHeight() - (r.bottom - r.top)    if (!isSoftKeyboardOpened && heightDiff > 100) {     isSoftKeyboardOpened=true      notifyOnSoftKeyboardOpened(heightDiff)    }  else   if (isSoftKeyboardOpened && heightDiff < 100) {     isSoftKeyboardOpened=false      notifyOnSoftKeyboardClosed()    } } 
public void setIsSoftKeyboardOpened(boolean isSoftKeyboardOpened){   this.isSoftKeyboardOpened=isSoftKeyboardOpened  } 
public boolean isSoftKeyboardOpened(){   return isSoftKeyboardOpened  } 
/**   * Default value is zero (0)  * @return  */ public int getLastSoftKeyboardHeightInPx(){   return lastSoftKeyboardHeightInPx  } 
public void addSoftKeyboardStateListener(SoftKeyboardStateListener listener){   listeners.add(listener)  } 
public void removeSoftKeyboardStateListener(SoftKeyboardStateListener listener){   listeners.remove(listener)  } 
private void notifyOnSoftKeyboardOpened(int keyboardHeightInPx){   this.lastSoftKeyboardHeightInPx=keyboardHeightInPx    for (  SoftKeyboardStateListener listener : listeners) {     if (listener != null) {       listener.onSoftKeyboardOpened(keyboardHeightInPx)      }   } } 
private void notifyOnSoftKeyboardClosed(){   for (  SoftKeyboardStateListener listener : listeners) {     if (listener != null) {       listener.onSoftKeyboardClosed()      }   } } 
public TypefaceTextView(final Context context){   this(context,null)  } 
public TypefaceTextView(final Context context,final AttributeSet attrs){   this(context,attrs,0)  } 
public TypefaceTextView(final Context context,final AttributeSet attrs,final int defStyle){   super(context,attrs,defStyle)    if (!isInEditMode()) {     init(context,attrs)    } } 
private void init(final Context context,final AttributeSet attrs){   if (mTypefaces == null) {     mTypefaces=new HashMap<String,Typeface>()    }   final TypedArray array=context.obtainStyledAttributes(attrs,styleable.TypefaceTextView)    if (array != null) {     final String typefaceAssetPath=array.getString(styleable.TypefaceTextView_typefaceFromAssets)      if (typefaceAssetPath != null) {       setTypefaceFromAssets(typefaceAssetPath)      }  else {       setTypefaceFromAssets("fonts/Roboto-Regular.ttf")      }     array.recycle()    } } 
public void setTypefaceFromAssets(String typefaceAssetPath){   final Typeface typeface    if (mTypefaces.containsKey(typefaceAssetPath)) {     typeface=mTypefaces.get(typefaceAssetPath)    }  else {     AssetManager assets=getContext().getAssets()      typeface=Typeface.createFromAsset(assets,typefaceAssetPath)      mTypefaces.put(typefaceAssetPath,typeface)    }   setTypeface(typeface)  } 
private AsyncTaskExecutor(){ } 
/**   * Concurrently executes AsyncTask on any Android version  * @param task to execute  * @param params for task  * @return executing AsyncTask  */ @SuppressLint("NewApi") public static <Params,Progress,Result>AsyncTask<Params,Progress,Result> executeConcurrently(AsyncTask<Params,Progress,Result> task,Params... params){   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {     task.executeOnExecutor(concurrentExecutor,params)    }  else {     task.execute(params)    }   return task  } 
@Override public Thread newThread(Runnable r){   return new Thread(r,"AsyncTask #" + count.getAndIncrement())  } 
private IntentUtil(){ } 
public static long getLongOrIntExtra(Intent intent,long defaultValue,String... possibleExtraNames){   if (intent == null || possibleExtraNames == null || possibleExtraNames.length == 0)   return defaultValue    Bundle extras=intent.getExtras()    if (extras == null || extras.isEmpty())   return defaultValue    for (  String possibleExtraName : possibleExtraNames) {     if (extras.containsKey(possibleExtraName)) {       Object object=extras.get(possibleExtraName)        if (object instanceof Long) {         return (Long)object        }  else       if (object instanceof Integer) {         return (Integer)object        }  else       if (object instanceof Short) {         return (Short)object        }     }   }   return defaultValue  } 
public static Boolean getBoolOrNumberAsBoolExtra(Intent intent,Boolean defaultValue,String... possibleExtraNames){   if (intent == null || possibleExtraNames == null || possibleExtraNames.length == 0)   return defaultValue    Bundle extras=intent.getExtras()    if (extras == null || extras.isEmpty())   return defaultValue    for (  String possibleExtraName : possibleExtraNames) {     if (extras.containsKey(possibleExtraName)) {       Object object=extras.get(possibleExtraName)        if (object instanceof Boolean) {         return (Boolean)object        }  else       if (object instanceof Integer) {         return (Integer)object > 0        }  else       if (object instanceof Long) {         return (Long)object > 0        }  else       if (object instanceof Short) {         return (Short)object > 0        }  else       if (object instanceof Byte) {         return (Byte)object > 0        }     }   }   return defaultValue  } 
public static String getIntentAsString(Intent intent){   if (intent == null)   return "null intent"    StringBuilder stringBuilder=new StringBuilder()    stringBuilder.append("Intent action: ").append(intent.getAction())    if (intent.getExtras() == null || intent.getExtras().isEmpty()) {     stringBuilder.append(", no extras")    }  else {     stringBuilder.append(", extras: ")      for (    String key : intent.getExtras().keySet()) {       stringBuilder.append("(" + key + ", "+ intent.getExtras().get(key)+ ")").append(", ")      }   }   return stringBuilder.toString()  } 
private static String lang(String originalLangName){   return originalLangName == null ? null : originalLangName.substring(0,2).toLowerCase(Locale.US)  } 
public static void updateLanguage(Context context,String newLanguage){   Configuration configuration=new Configuration()    String language=WAILSettings.getLanguage(context)    String lang=lang(language)    String newLang=lang(newLanguage)    if (TextUtils.isEmpty(language) && newLanguage == null) {     configuration.locale=Locale.getDefault()    }  else   if (newLanguage != null) {     configuration.locale=new Locale(newLang)      WAILSettings.setLanguage(context,newLanguage)    }  else   if (!TextUtils.isEmpty(language)) {     configuration.locale=new Locale(lang)    }   context.getResources().updateConfiguration(configuration,null)    if (newLang != null && !newLang.equals(lang)) {     Intent intent=context.getPackageManager().getLaunchIntentForPackage(context.getPackageName())      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)      context.startActivity(intent)    } } 
private Loggi(){ } 
public static void d(String message){   if (isEnabled) {     Log.d(TAG,message)    } } 
public static void v(String message){   if (isEnabled) {     Log.v(TAG,message)    } } 
public static void i(String message){   if (isEnabled) {     Log.i(TAG,message)    } } 
public static void w(String message){   if (isEnabled) {     Log.w(TAG,message)    } } 
public static void e(String message){   if (isEnabled) {     Log.e(TAG,message)    } } 
private NetworkUtil(){ } 
public static boolean isAvailable(Context context){   final ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE)    if (connectivityManager == null) {     return false    }   final NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo()    return networkInfo != null && networkInfo.isConnectedOrConnecting()  } 
public static boolean isMobileNetwork(Context context){   if (!isAvailable(context)) {     return false    }   final ConnectivityManager connectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE)    final NetworkInfo networkInfo=connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE)    return networkInfo != null && networkInfo.isConnectedOrConnecting()  } 
private SleepIfRequiredAsyncTask(long actionStartTime,long actionMinDurationInMillis,Runnable executeInBackground,Runnable executeAfterSleep){   this.actionStartTime=actionStartTime    this.actionMinDurationInMillis=actionMinDurationInMillis    this.executeInBackground=executeInBackground    this.executeAfterSleep=executeAfterSleep  } 
/**   * @param actionStartTime from SystemClock.elapsedRealTime()  * @param actionMinDurationInMillis minimal duration of the action  * @param executeAfterSleep runnable to execute in main ui thread after sleep  * @return  */ public static SleepIfRequiredAsyncTask newInstance(long actionStartTime,long actionMinDurationInMillis,Runnable executeAfterSleep){   return new SleepIfRequiredAsyncTask(actionStartTime,actionMinDurationInMillis,null,executeAfterSleep)  } 
/**   * @param actionStartTime from SystemClock.elapsedRealTime()  * @param actionMinDurationInMillis minimal duration of the action  * @param executeInBackground runnable to execute in background thread  * @param executeAfterSleep runnable to execute in main ui thread after sleep  * @return  */ public static SleepIfRequiredAsyncTask newInstance(long actionStartTime,long actionMinDurationInMillis,Runnable executeInBackground,Runnable executeAfterSleep){   return new SleepIfRequiredAsyncTask(actionStartTime,actionMinDurationInMillis,executeInBackground,executeAfterSleep)  } 
/**   * @param actionMinDurationInMillis minimal duration of the action  * @param executeInBackground runnable to execute in background thread  * @param executeAfterSleep runnable to execute in main ui thread after sleep  * @return  */ public static SleepIfRequiredAsyncTask newInstance(long actionMinDurationInMillis,Runnable executeInBackground,Runnable executeAfterSleep){   return new SleepIfRequiredAsyncTask(SystemClock.elapsedRealtime(),actionMinDurationInMillis,executeInBackground,executeAfterSleep)  } 
@Override protected Void doInBackground(Void... params){   if (executeInBackground != null) {     executeInBackground.run()    }   ThreadUtil.sleepIfRequired(actionStartTime,actionMinDurationInMillis)    return null  } 
@Override protected void onPostExecute(Void aVoid){   if (executeAfterSleep != null) {     executeAfterSleep.run()    } } 
private StackTraceUtil(){ } 
public static String getStackTrace(Exception e){   StringWriter stringWriter=new StringWriter()    PrintWriter printWriter=new PrintWriter(stringWriter)    e.printStackTrace(printWriter)    String stackTrace=stringWriter.toString()    try {     stringWriter.close()    }  catch (  Exception e1) {   }   try {     printWriter.close()    }  catch (  Exception e2) {   }   return stackTrace  } 
private ThreadUtil(){ } 
/**   * If action happens faster then required it will call sleep for the thread Usefully for better user experience from UI  * @param startTimeInMillis please use SystemClock.elapsedRealtime() to prevent bug when user changing datetime in system  * @param minDurationInMillis action's minimal required duration in millis  */ public static void sleepIfRequired(long startTimeInMillis,long minDurationInMillis){   final long realDurationInMillis=SystemClock.elapsedRealtime() - startTimeInMillis    if (realDurationInMillis < minDurationInMillis - 100) {     SystemClock.sleep(minDurationInMillis - realDurationInMillis)    } } 
/**   * Returning needed word form  * @param count of objects  * @param wordForms array with 3 elements of word to return  * @return needed word formExample: wordForms = {"", "", ""} count = 1    -> return "" count = 2..4 -> return "" count = 5... -> return ""  */ public static String getWordForm(final long count,String[] wordForms){   final long countAbs=Math.abs(count)    if (wordForms.length == 1) {     return wordForms[0]    }  else   if (wordForms.length == 2) {     return getWordFormFor2WordForms(countAbs,wordForms)    }  else   if (wordForms.length >= 3) {     return getWordFormFor3WordForms(countAbs,wordForms)    }  else {     return null    } } 
private static String getWordFormFor2WordForms(final long countAbs,String[] wordForms){   if (countAbs == 1) {     return wordForms[0]    }  else {     return wordForms[1]    } } 
private static String getWordFormFor3WordForms(final long countAbs,String[] wordForms){   if (countAbs == 1) {     return wordForms[0]    }  else   if (countAbs > 1 & countAbs < 5) {     return wordForms[1]    }  else   if (countAbs > 20) {     if (countAbs > 100) {       long tempCount=countAbs % 100        if (tempCount < 20) {         return getWordFormFor3WordForms(tempCount,wordForms)        }  else {         return getWordFormFor3WordForms(countAbs % 10,wordForms)        }     }  else {       return getWordFormFor3WordForms(countAbs % 10,wordForms)      }   }  else {     return wordForms[2]    } } 
@Override public void onCreate(){   LocaleUtil.updateLanguage(this,null)    super.onCreate()    Loggi.w("WAILApp onCreate()")    updateSupportedPlayersDB()  } 
@Override public void onConfigurationChanged(Configuration newConfig){   super.onConfigurationChanged(newConfig)    if (isActivityVisible()) {     LocaleUtil.updateLanguage(this,WAILSettings.getLanguage(this))    } } 
public static boolean isActivityVisible(){   return activityVisible  } 
public static void activityResumed(){   activityVisible=true  } 
public static void activityPaused(){   activityVisible=false  } 
private void updateSupportedPlayersDB(){   AsyncTaskExecutor.executeConcurrently(new AsyncTask<Void,Void,Void>(){     @Override protected Void doInBackground(    Void... params){       try {         final long startTime=SystemClock.elapsedRealtime()          PlayersDBHelper.getInstance(getApplicationContext()).updateSupportedPlayers()          final long updateDurationMillis=SystemClock.elapsedRealtime() - startTime          Loggi.i("Supported players db update duration: " + updateDurationMillis + "ms")          EasyTracker.getInstance(WAILApp.this).send(MapBuilder.createTiming("WAILApp",updateDurationMillis,"updateSupportedPlayersDB",null).build())        }  catch (      Exception e) {         Loggi.e("Can not update players db!!!")          EasyTracker.getInstance(WAILApp.this).send(MapBuilder.createException("Can not update supported players db!",true).build())        }       return null      }     @Override protected void onPostExecute(    Void aVoid){       super.onPostExecute(aVoid)        Context context=getApplicationContext()        if (context == null)       return        startService(new Intent(context,WAILService.class))      }   } )  } 
@Override protected Void doInBackground(Void... params){   try {     final long startTime=SystemClock.elapsedRealtime()      PlayersDBHelper.getInstance(getApplicationContext()).updateSupportedPlayers()      final long updateDurationMillis=SystemClock.elapsedRealtime() - startTime      Loggi.i("Supported players db update duration: " + updateDurationMillis + "ms")      EasyTracker.getInstance(WAILApp.this).send(MapBuilder.createTiming("WAILApp",updateDurationMillis,"updateSupportedPlayersDB",null).build())    }  catch (  Exception e) {     Loggi.e("Can not update players db!!!")      EasyTracker.getInstance(WAILApp.this).send(MapBuilder.createException("Can not update supported players db!",true).build())    }   return null  } 
@Override protected void onPostExecute(Void aVoid){   super.onPostExecute(aVoid)    Context context=getApplicationContext()    if (context == null)   return    startService(new Intent(context,WAILService.class))  } 
@Override public void onPrepareCurrentItemLeaveScreen(View current){   View descriptionLayout=current.findViewById(com.daimajia.slider.library.R.id.description_layout)    if (descriptionLayout != null) {     current.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.INVISIBLE)    }   Log.e(TAG,"onPrepareCurrentItemLeaveScreen called")  } 
@Override public void onPrepareNextItemShowInScreen(View next){   View descriptionLayout=next.findViewById(com.daimajia.slider.library.R.id.description_layout)    if (descriptionLayout != null) {     next.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.INVISIBLE)    }   Log.e(TAG,"onPrepareNextItemShowInScreen called")  } 
@Override public void onCurrentItemDisappear(View view){   Log.e(TAG,"onCurrentItemDisappear called")  } 
@Override public void onNextItemAppear(View view){   View descriptionLayout=view.findViewById(com.daimajia.slider.library.R.id.description_layout)    if (descriptionLayout != null) {     view.findViewById(com.daimajia.slider.library.R.id.description_layout).setVisibility(View.VISIBLE)      new StandUpAnimator().animate(descriptionLayout)    }   Log.e(TAG,"onCurrentItemDisappear called")  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    setContentView(R.layout.activity_main)    mDemoSlider=(SliderLayout)findViewById(R.id.slider)    HashMap<String,String> url_maps=new HashMap<String,String>()    url_maps.put("Hannibal","http://static2.hypable.com/wp-content/uploads/2013/12/hannibal-season-2-release-date.jpg")    url_maps.put("Big Bang Theory","http://tvfiles.alphacoders.com/100/hdclearart-10.png")    url_maps.put("House of Cards","http://cdn3.nflximg.net/images/3093/2043093.jpg")    url_maps.put("Game of Thrones","http://images.boomsbeat.com/data/images/full/19640/game-of-thrones-season-4-jpg.jpg")    HashMap<String,Integer> file_maps=new HashMap<String,Integer>()    file_maps.put("Hannibal",R.drawable.hannibal)    file_maps.put("Big Bang Theory",R.drawable.bigbang)    file_maps.put("House of Cards",R.drawable.house)    file_maps.put("Game of Thrones",R.drawable.game_of_thrones)    for (  String name : file_maps.keySet()) {     TextSliderView textSliderView=new TextSliderView(this)      textSliderView.description(name).image(file_maps.get(name)).setScaleType(BaseSliderView.ScaleType.Fit).setOnSliderClickListener(this)      textSliderView.bundle(new Bundle())      textSliderView.getBundle().putString("extra",name)      mDemoSlider.addSlider(textSliderView)    }   mDemoSlider.setPresetTransformer(SliderLayout.Transformer.Accordion)    mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom)    mDemoSlider.setCustomAnimation(new DescriptionAnimation())    mDemoSlider.setDuration(4000)    mDemoSlider.addOnPageChangeListener(this)    ListView l=(ListView)findViewById(R.id.transformers)    l.setAdapter(new TransformerAdapter(this))    l.setOnItemClickListener(new AdapterView.OnItemClickListener(){     @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){       mDemoSlider.setPresetTransformer(((TextView)view).getText().toString())        Toast.makeText(MainActivity.this,((TextView)view).getText().toString(),Toast.LENGTH_SHORT).show()      }   } )  } 
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){   mDemoSlider.setPresetTransformer(((TextView)view).getText().toString())    Toast.makeText(MainActivity.this,((TextView)view).getText().toString(),Toast.LENGTH_SHORT).show()  } 
@Override protected void onStop(){   mDemoSlider.stopAutoCycle()    super.onStop()  } 
@Override public void onSliderClick(BaseSliderView slider){   Toast.makeText(this,slider.getBundle().get("extra") + "",Toast.LENGTH_SHORT).show()  } 
@Override public boolean onCreateOptionsMenu(Menu menu){   MenuInflater menuInflater=getMenuInflater()    menuInflater.inflate(R.menu.main,menu)    return super.onCreateOptionsMenu(menu)  } 
@Override public boolean onOptionsItemSelected(MenuItem item){ switch (item.getItemId()) { case R.id.action_custom_indicator:     mDemoSlider.setCustomIndicator((PagerIndicator)findViewById(R.id.custom_indicator))    break  case R.id.action_custom_child_animation: mDemoSlider.setCustomAnimation(new ChildAnimationExample())  break  case R.id.action_restore_default: mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom)  mDemoSlider.setCustomAnimation(new DescriptionAnimation())  break  case R.id.action_github: Intent browserIntent=new Intent(Intent.ACTION_VIEW,Uri.parse("https://github.com/daimajia/AndroidImageSlider"))  startActivity(browserIntent)  break  } return super.onOptionsItemSelected(item)  } 
@Override public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels){ } 
@Override public void onPageSelected(int position){   Log.d("Slider Demo","Page Changed: " + position)  } 
@Override public void onPageScrollStateChanged(int state){ } 
public TransformerAdapter(Context context){   mContext=context  } 
@Override public int getCount(){   return SliderLayout.Transformer.values().length  } 
@Override public Object getItem(int position){   return SliderLayout.Transformer.values()[position].toString()  } 
@Override public long getItemId(int position){   return position  } 
@Override public View getView(int position,View convertView,ViewGroup parent){   TextView t=(TextView)LayoutInflater.from(mContext).inflate(R.layout.item,null)    t.setText(getItem(position).toString())    return t  } 
/**   * When the current item prepare to start leaving the screen.  * @param current  */ public void onPrepareCurrentItemLeaveScreen(View current)  
/**   * The next item which will be shown in ViewPager/  * @param next  */ public void onPrepareNextItemShowInScreen(View next)  
/**   * Current item totally disappear from screen.  * @param view  */ public void onCurrentItemDisappear(View view)  
/**   * Next item totally show in screen.  * @param view  */ public void onNextItemAppear(View view)  
@Override public void onPrepareCurrentItemLeaveScreen(View current){   View descriptionLayout=current.findViewById(R.id.description_layout)    if (descriptionLayout != null) {     current.findViewById(R.id.description_layout).setVisibility(View.INVISIBLE)    } } 
/**   * When next item is coming to show, let's hide the description layout.  * @param next  */ @Override public void onPrepareNextItemShowInScreen(View next){   View descriptionLayout=next.findViewById(R.id.description_layout)    if (descriptionLayout != null) {     next.findViewById(R.id.description_layout).setVisibility(View.INVISIBLE)    } } 
@Override public void onCurrentItemDisappear(View view){ } 
/**   * When next item show in ViewPagerEx, let's make an animation to show the description layout.  * @param view  */ @Override public void onNextItemAppear(View view){   View descriptionLayout=view.findViewById(R.id.description_layout)    if (descriptionLayout != null) {     float layoutY=ViewHelper.getY(descriptionLayout)      view.findViewById(R.id.description_layout).setVisibility(View.VISIBLE)      ValueAnimator animator=ObjectAnimator.ofFloat(descriptionLayout,"y",layoutY + descriptionLayout.getHeight(),layoutY).setDuration(500)      animator.start()    } } 
public PagerIndicator(Context context){   this(context,null)  } 
public PagerIndicator(Context context,AttributeSet attrs){   super(context,attrs)    mContext=context    final TypedArray attributes=context.obtainStyledAttributes(attrs,R.styleable.PagerIndicator,0,0)    int visibility=attributes.getInt(R.styleable.PagerIndicator_visibility,IndicatorVisibility.Visible.ordinal())    for (  IndicatorVisibility v : IndicatorVisibility.values()) {     if (v.ordinal() == visibility) {       mVisibility=v        break      }   }   int shape=attributes.getInt(R.styleable.PagerIndicator_shape,Shape.Oval.ordinal())    for (  Shape s : Shape.values()) {     if (s.ordinal() == shape) {       mIndicatorShape=s        break      }   }   mUserSetSelectedIndicatorResId=attributes.getResourceId(R.styleable.PagerIndicator_selected_drawable,0)    mUserSetUnSelectedIndicatorResId=attributes.getResourceId(R.styleable.PagerIndicator_unselected_drawable,0)    mDefaultSelectedColor=attributes.getColor(R.styleable.PagerIndicator_selected_color,Color.rgb(255,255,255))    mDefaultUnSelectedColor=attributes.getColor(R.styleable.PagerIndicator_unselected_color,Color.argb(33,255,255,255))    mDefaultSelectedWidth=attributes.getDimension(R.styleable.PagerIndicator_selected_width,(int)pxFromDp(6))    mDefaultSelectedHeight=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_height,(int)pxFromDp(6))    mDefaultUnSelectedWidth=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_width,(int)pxFromDp(6))    mDefaultUnSelectedHeight=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_height,(int)pxFromDp(6))    mSelectedGradientDrawable=new GradientDrawable()    mUnSelectedGradientDrawable=new GradientDrawable()    mPadding_left=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_left,(int)pxFromDp(3))    mPadding_right=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_right,(int)pxFromDp(3))    mPadding_top=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_top,(int)pxFromDp(0))    mPadding_bottom=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_padding_bottom,(int)pxFromDp(0))    mSelectedPadding_Left=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_left,(int)mPadding_left)    mSelectedPadding_Right=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_right,(int)mPadding_right)    mSelectedPadding_Top=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_top,(int)mPadding_top)    mSelectedPadding_Bottom=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_selected_padding_bottom,(int)mPadding_bottom)    mUnSelectedPadding_Left=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_left,(int)mPadding_left)    mUnSelectedPadding_Right=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_right,(int)mPadding_right)    mUnSelectedPadding_Top=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_top,(int)mPadding_top)    mUnSelectedPadding_Bottom=attributes.getDimensionPixelSize(R.styleable.PagerIndicator_unselected_padding_bottom,(int)mPadding_bottom)    mSelectedLayerDrawable=new LayerDrawable(new Drawable[]{mSelectedGradientDrawable})    mUnSelectedLayerDrawable=new LayerDrawable(new Drawable[]{mUnSelectedGradientDrawable})    setIndicatorStyleResource(mUserSetSelectedIndicatorResId,mUserSetUnSelectedIndicatorResId)    setDefaultIndicatorShape(mIndicatorShape)    setDefaultSelectedIndicatorSize(mDefaultSelectedWidth,mDefaultSelectedHeight,Unit.Px)    setDefaultUnselectedIndicatorSize(mDefaultUnSelectedWidth,mDefaultUnSelectedHeight,Unit.Px)    setDefaultIndicatorColor(mDefaultSelectedColor,mDefaultUnSelectedColor)    setIndicatorVisibility(mVisibility)    attributes.recycle()  } 
/**   * if you are using the default indicator, this method will help you to set the shape of indicator, there are two kind of shapes you  can set, oval and rect.  * @param shape  */ public void setDefaultIndicatorShape(Shape shape){   if (mUserSetSelectedIndicatorResId == 0) {     if (shape == Shape.Oval) {       mSelectedGradientDrawable.setShape(GradientDrawable.OVAL)      }  else {       mSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE)      }   }   if (mUserSetUnSelectedIndicatorResId == 0) {     if (shape == Shape.Oval) {       mUnSelectedGradientDrawable.setShape(GradientDrawable.OVAL)      }  else {       mUnSelectedGradientDrawable.setShape(GradientDrawable.RECTANGLE)      }   }   resetDrawable()  } 
/**   * Set Indicator style.  * @param selected page selected drawable  * @param unselected page unselected drawable  */ public void setIndicatorStyleResource(int selected,int unselected){   mUserSetSelectedIndicatorResId=selected    mUserSetUnSelectedIndicatorResId=unselected    if (selected == 0) {     mSelectedDrawable=mSelectedLayerDrawable    }  else {     mSelectedDrawable=mContext.getResources().getDrawable(mUserSetSelectedIndicatorResId)    }   if (unselected == 0) {     mUnselectedDrawable=mUnSelectedLayerDrawable    }  else {     mUnselectedDrawable=mContext.getResources().getDrawable(mUserSetUnSelectedIndicatorResId)    }   resetDrawable()  } 
/**   * if you are using the default indicator , this method will help you to set the selected status and the unselected status color.  * @param selectedColor  * @param unselectedColor  */ public void setDefaultIndicatorColor(int selectedColor,int unselectedColor){   if (mUserSetSelectedIndicatorResId == 0) {     mSelectedGradientDrawable.setColor(selectedColor)    }   if (mUserSetUnSelectedIndicatorResId == 0) {     mUnSelectedGradientDrawable.setColor(unselectedColor)    }   resetDrawable()  } 
public void setDefaultSelectedIndicatorSize(float width,float height,Unit unit){   if (mUserSetSelectedIndicatorResId == 0) {     float w=width      float h=height      if (unit == Unit.DP) {       w=pxFromDp(width)        h=pxFromDp(height)      }     mSelectedGradientDrawable.setSize((int)w,(int)h)      resetDrawable()    } } 
public void setDefaultUnselectedIndicatorSize(float width,float height,Unit unit){   if (mUserSetUnSelectedIndicatorResId == 0) {     float w=width      float h=height      if (unit == Unit.DP) {       w=pxFromDp(width)        h=pxFromDp(height)      }     mUnSelectedGradientDrawable.setSize((int)w,(int)h)      resetDrawable()    } } 
public void setDefaultIndicatorSize(float width,float height,Unit unit){   setDefaultSelectedIndicatorSize(width,height,unit)    setDefaultUnselectedIndicatorSize(width,height,unit)  } 
private float dpFromPx(float px){   return px / this.getContext().getResources().getDisplayMetrics().density  } 
private float pxFromDp(float dp){   return dp * this.getContext().getResources().getDisplayMetrics().density  } 
/**   * set the visibility of indicator.  * @param visibility  */ public void setIndicatorVisibility(IndicatorVisibility visibility){   if (visibility == IndicatorVisibility.Visible) {     setVisibility(View.VISIBLE)    }  else {     setVisibility(View.INVISIBLE)    }   resetDrawable()  } 
/**   * clear self means unregister the dataset observer and remove all the child views(indicators).  */ public void destroySelf(){   if (mPager == null || mPager.getAdapter() == null) {     return    }   InfinitePagerAdapter wrapper=(InfinitePagerAdapter)mPager.getAdapter()    PagerAdapter adapter=wrapper.getRealAdapter()    if (adapter != null) {     adapter.unregisterDataSetObserver(dataChangeObserver)    }   removeAllViews()  } 
/**   * bind indicator with viewpagerEx.  * @param pager  */ public void setViewPager(ViewPagerEx pager){   if (pager.getAdapter() == null) {     throw new IllegalStateException("Viewpager does not have adapter instance")    }   mPager=pager    mPager.addOnPageChangeListener(this)    ((InfinitePagerAdapter)mPager.getAdapter()).getRealAdapter().registerDataSetObserver(dataChangeObserver)  } 
private void resetDrawable(){   for (  View i : mIndicators) {     if (mPreviousSelectedIndicator != null && mPreviousSelectedIndicator.equals(i)) {       ((ImageView)i).setImageDrawable(mSelectedDrawable)      }  else {       ((ImageView)i).setImageDrawable(mUnselectedDrawable)      }   } } 
/**   * redraw the indicators.  */ public void redraw(){   mItemCount=getShouldDrawCount()    mPreviousSelectedIndicator=null    for (  View i : mIndicators) {     removeView(i)    }   for (int i=0  i < mItemCount  i++) {     ImageView indicator=new ImageView(mContext)      indicator.setImageDrawable(mUnselectedDrawable)      indicator.setPadding((int)mUnSelectedPadding_Left,(int)mUnSelectedPadding_Top,(int)mUnSelectedPadding_Right,(int)mUnSelectedPadding_Bottom)      addView(indicator)      mIndicators.add(indicator)    }   setItemAsSelected(mPreviousSelectedPosition)  } 
/**   * since we used a adapter wrapper, so we can't getCount directly from wrapper.  * @return  */ private int getShouldDrawCount(){   if (mPager.getAdapter() instanceof InfinitePagerAdapter) {     return ((InfinitePagerAdapter)mPager.getAdapter()).getRealCount()    }  else {     return mPager.getAdapter().getCount()    } } 
private void setItemAsSelected(int position){   if (mPreviousSelectedIndicator != null) {     mPreviousSelectedIndicator.setImageDrawable(mUnselectedDrawable)      mPreviousSelectedIndicator.setPadding((int)mUnSelectedPadding_Left,(int)mUnSelectedPadding_Top,(int)mUnSelectedPadding_Right,(int)mUnSelectedPadding_Bottom)    }   ImageView currentSelected=(ImageView)getChildAt(position + 1)    if (currentSelected != null) {     currentSelected.setImageDrawable(mSelectedDrawable)      currentSelected.setPadding((int)mSelectedPadding_Left,(int)mSelectedPadding_Top,(int)mSelectedPadding_Right,(int)mSelectedPadding_Bottom)      mPreviousSelectedIndicator=currentSelected    }   mPreviousSelectedPosition=position  } 
@Override public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels){ } 
public IndicatorVisibility getIndicatorVisibility(){   return mVisibility  } 
@Override public void onPageSelected(int position){   if (mItemCount == 0) {     return    }   setItemAsSelected(position - 1)  } 
@Override public void onPageScrollStateChanged(int state){ } 
public int getSelectedIndicatorResId(){   return mUserSetSelectedIndicatorResId  } 
public int getUnSelectedIndicatorResId(){   return mUserSetUnSelectedIndicatorResId  } 
public SliderAdapter(Context context){   mContext=context    mImageContents=new ArrayList<BaseSliderView>()  } 
public <T extends BaseSliderView>void addSlider(T slider){   slider.setOnImageLoadListener(this)    mImageContents.add(slider)    notifyDataSetChanged()  } 
public BaseSliderView getSliderView(int position){   if (position < 0 || position >= mImageContents.size()) {     return null    }  else {     return mImageContents.get(position)    } } 
@Override public int getItemPosition(Object object){   return POSITION_NONE  } 
public <T extends BaseSliderView>void removeSlider(T slider){   if (mImageContents.contains(slider)) {     mImageContents.remove(slider)      notifyDataSetChanged()    } } 
public void removeSliderAt(int position){   if (mImageContents.size() > position) {     mImageContents.remove(position)      notifyDataSetChanged()    } } 
public void removeAllSliders(){   mImageContents.clear()    notifyDataSetChanged()  } 
@Override public int getCount(){   return mImageContents.size()  } 
@Override public boolean isViewFromObject(View view,Object object){   return view == object  } 
@Override public void destroyItem(ViewGroup container,int position,Object object){   container.removeView((View)object)  } 
@Override public Object instantiateItem(ViewGroup container,int position){   BaseSliderView b=mImageContents.get(position)    View v=b.getView()    container.addView(v)    return v  } 
@Override public void onStart(BaseSliderView target){ } 
/**   * When image download error, then remove.  * @param result  * @param target  */ @Override public void onEnd(boolean result,BaseSliderView target){   if (target.isErrorDisappear() == false || result == true) {     return    }   for (  BaseSliderView slider : mImageContents) {     if (slider.equals(target)) {       removeSlider(target)        break      }   } } 
/**   * {@link com.daimajia.slider.library.Indicators.PagerIndicator} shape, rect or oval.  */ public SliderLayout(Context context){   this(context,null)  } 
public SliderLayout(Context context,AttributeSet attrs){   this(context,attrs,R.attr.SliderStyle)  } 
public SliderLayout(Context context,AttributeSet attrs,int defStyle){   super(context,attrs,defStyle)    mContext=context    LayoutInflater.from(context).inflate(R.layout.slider_layout,this,true)    final TypedArray attributes=context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout,defStyle,0)    mTransformerSpan=attributes.getInteger(R.styleable.SliderLayout_pager_animation_span,1100)    mTransformerId=attributes.getInt(R.styleable.SliderLayout_pager_animation,Transformer.Default.ordinal())    mAutoCycle=attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true)    int visibility=attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0)    for (  PagerIndicator.IndicatorVisibility v : PagerIndicator.IndicatorVisibility.values()) {     if (v.ordinal() == visibility) {       mIndicatorVisibility=v        break      }   }   mSliderAdapter=new SliderAdapter(mContext)    PagerAdapter wrappedAdapter=new InfinitePagerAdapter(mSliderAdapter)    mViewPager=(InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager)    mViewPager.setAdapter(wrappedAdapter)    mViewPager.setOnTouchListener(new OnTouchListener(){     @Override public boolean onTouch(    View v,    MotionEvent event){       int action=event.getAction()  switch (action) { case MotionEvent.ACTION_UP:         recoverCycle()        break    }   return false  } } )  attributes.recycle()  setPresetIndicator(PresetIndicators.Center_Bottom)  setPresetTransformer(mTransformerId)  setSliderTransformDuration(mTransformerSpan,null)  setIndicatorVisibility(mIndicatorVisibility)  if (mAutoCycle) { startAutoCycle()  } } 
@Override public boolean onTouch(View v,MotionEvent event){   int action=event.getAction()  switch (action) { case MotionEvent.ACTION_UP:     recoverCycle()    break  } return false  } 
public void addOnPageChangeListener(ViewPagerEx.OnPageChangeListener onPageChangeListener){   if (onPageChangeListener != null) {     mViewPager.addOnPageChangeListener(onPageChangeListener)    } } 
public void removeOnPageChangeListener(ViewPagerEx.OnPageChangeListener onPageChangeListener){   mViewPager.removeOnPageChangeListener(onPageChangeListener)  } 
public void setCustomIndicator(PagerIndicator indicator){   if (mIndicator != null) {     mIndicator.destroySelf()    }   mIndicator=indicator    mIndicator.setIndicatorVisibility(mIndicatorVisibility)    mIndicator.setViewPager(mViewPager)    mIndicator.redraw()  } 
public <T extends BaseSliderView>void addSlider(T imageContent){   mSliderAdapter.addSlider(imageContent)  } 
public void startAutoCycle(){   startAutoCycle(mSliderDuration,mSliderDuration,mAutoRecover)  } 
/**   * start auto cycle.  * @param delay delay time  * @param duration animation duration time.  * @param autoRecover if recover after user touches the slider.  */ public void startAutoCycle(long delay,long duration,boolean autoRecover){   if (mCycleTimer != null)   mCycleTimer.cancel()    if (mCycleTask != null)   mCycleTask.cancel()    if (mResumingTask != null)   mResumingTask.cancel()    if (mResumingTimer != null)   mResumingTimer.cancel()    mSliderDuration=duration    mCycleTimer=new Timer()    mAutoRecover=autoRecover    mCycleTask=new TimerTask(){     @Override public void run(){       mh.sendEmptyMessage(0)      }   }     mCycleTimer.schedule(mCycleTask,delay,mSliderDuration)    mCycling=true    mAutoCycle=true  } 
@Override public void run(){   mh.sendEmptyMessage(0)  } 
/**   * pause auto cycle.  */ private void pauseAutoCycle(){   if (mCycling) {     mCycleTimer.cancel()      mCycleTask.cancel()      mCycling=false    }  else {     if (mResumingTimer != null && mResumingTask != null) {       recoverCycle()      }   } } 
/**   * set the duration between two slider changes. the duration value must >= 500  * @param duration  */ public void setDuration(long duration){   if (duration >= 500) {     mSliderDuration=duration      if (mAutoCycle && mCycling) {       startAutoCycle()      }   } } 
/**   * stop the auto circle  */ public void stopAutoCycle(){   if (mCycleTask != null) {     mCycleTask.cancel()    }   if (mCycleTimer != null) {     mCycleTimer.cancel()    }   if (mResumingTimer != null) {     mResumingTimer.cancel()    }   if (mResumingTask != null) {     mResumingTask.cancel()    }   mAutoCycle=false    mCycling=false  } 
/**   * when paused cycle, this method can weak it up.  */ private void recoverCycle(){   if (!mAutoRecover || !mAutoCycle) {     return    }   if (!mCycling) {     if (mResumingTask != null && mResumingTimer != null) {       mResumingTimer.cancel()        mResumingTask.cancel()      }     mResumingTimer=new Timer()      mResumingTask=new TimerTask(){       @Override public void run(){         startAutoCycle()        }     }       mResumingTimer.schedule(mResumingTask,6000)    } } 
@Override public void run(){   startAutoCycle()  } 
@Override public boolean onInterceptTouchEvent(MotionEvent ev){   int action=ev.getAction()  switch (action) { case MotionEvent.ACTION_DOWN:     pauseAutoCycle()    break  } return false  } 
/**   * set ViewPager transformer.  * @param reverseDrawingOrder  * @param transformer  */ public void setPagerTransformer(boolean reverseDrawingOrder,BaseTransformer transformer){   mViewPagerTransformer=transformer    mViewPagerTransformer.setCustomAnimationInterface(mCustomAnimation)    mViewPager.setPageTransformer(reverseDrawingOrder,mViewPagerTransformer)  } 
/**   * set the duration between two slider changes.  * @param period  * @param interpolator  */ public void setSliderTransformDuration(int period,Interpolator interpolator){   try {     Field mScroller=ViewPagerEx.class.getDeclaredField("mScroller")      mScroller.setAccessible(true)      FixedSpeedScroller scroller=new FixedSpeedScroller(mViewPager.getContext(),interpolator,period)      mScroller.set(mViewPager,scroller)    }  catch (  Exception e) {   } } 
private void Transformer(String s){   name=s  } 
public String toString(){   return name  } 
public boolean equals(String other){   return (other == null) ? false : name.equals(other)  } 
/**   * set a preset viewpager transformer by id.  * @param transformerId  */ public void setPresetTransformer(int transformerId){   for (  Transformer t : Transformer.values()) {     if (t.ordinal() == transformerId) {       setPresetTransformer(t)        break      }   } } 
/**   * set preset PagerTransformer via the name of transforemer.  * @param transformerName  */ public void setPresetTransformer(String transformerName){   for (  Transformer t : Transformer.values()) {     if (t.equals(transformerName)) {       setPresetTransformer(t)        return      }   } } 
/**   * Inject your custom animation into PageTransformer, you can know more details in {@link com.daimajia.slider.library.Animations.BaseAnimationInterface}, and you can see a example in  {@link com.daimajia.slider.library.Animations.DescriptionAnimation}  * @param animation  */ public void setCustomAnimation(BaseAnimationInterface animation){   mCustomAnimation=animation    if (mViewPagerTransformer != null) {     mViewPagerTransformer.setCustomAnimationInterface(mCustomAnimation)    } } 
/**   * pretty much right? enjoy it. :-D  * @param ts  */ public void setPresetTransformer(Transformer ts){   BaseTransformer t=null  switch (ts) { case Default:     t=new DefaultTransformer()    break  case Accordion: t=new AccordionTransformer()  break  case Background2Foreground: t=new BackgroundToForegroundTransformer()  break  case CubeIn: t=new CubeInTransformer()  break  case DepthPage: t=new DepthPageTransformer()  break  case Fade: t=new FadeTransformer()  break  case FlipHorizontal: t=new FlipHorizontalTransformer()  break  case FlipPage: t=new FlipPageViewTransformer()  break  case Foreground2Background: t=new ForegroundToBackgroundTransformer()  break  case RotateDown: t=new RotateDownTransformer()  break  case RotateUp: t=new RotateUpTransformer()  break  case Stack: t=new StackTransformer()  break  case Tablet: t=new TabletTransformer()  break  case ZoomIn: t=new ZoomInTransformer()  break  case ZoomOutSlide: t=new ZoomOutSlideTransformer()  break  case ZoomOut: t=new ZoomOutTransformer()  break  } setPagerTransformer(true,t)  } 
/**   * Set the visibility of the indicators.  * @param visibility  */ public void setIndicatorVisibility(PagerIndicator.IndicatorVisibility visibility){   if (mIndicator == null) {     return    }   mIndicator.setIndicatorVisibility(visibility)  } 
public PagerIndicator.IndicatorVisibility getIndicatorVisibility(){   if (mIndicator == null) {     return mIndicator.getIndicatorVisibility()    }   return PagerIndicator.IndicatorVisibility.Invisible  } 
/**   * get the  {@link com.daimajia.slider.library.Indicators.PagerIndicator} instance.You can manipulate the properties of the indicator.  * @return  */ public PagerIndicator getPagerIndicator(){   return mIndicator  } 
void Center_Bottom(){ } 
private void PresetIndicators(String name,int id){   this.name=name    this.id=id  } 
public String toString(){   return name  } 
public int getResourceId(){   return id  } 
public void setPresetIndicator(PresetIndicators presetIndicator){   PagerIndicator pagerIndicator=(PagerIndicator)findViewById(presetIndicator.getResourceId())    setCustomIndicator(pagerIndicator)  } 
private InfinitePagerAdapter getWrapperAdapter(){   PagerAdapter adapter=mViewPager.getAdapter()    if (adapter != null) {     return (InfinitePagerAdapter)adapter    }  else {     return null    } } 
private SliderAdapter getRealAdapter(){   PagerAdapter adapter=mViewPager.getAdapter()    if (adapter != null) {     return ((InfinitePagerAdapter)adapter).getRealAdapter()    }   return null  } 
/**   * get the current item position  * @return  */ public int getCurrentPosition(){   if (getRealAdapter() == null)   throw new IllegalStateException("You did not set a slider adapter")    return mViewPager.getCurrentItem() % getRealAdapter().getCount()  } 
/**   * get current slider.  * @return  */ public BaseSliderView getCurrentSlider(){   if (getRealAdapter() == null)   throw new IllegalStateException("You did not set a slider adapter")    int count=getRealAdapter().getCount()    int realCount=mViewPager.getCurrentItem() % count    return getRealAdapter().getSliderView(realCount)  } 
/**   * remove  the slider at the position. Notice: It's a not perfect method, a very small bug still exists.  */ public void removeSliderAt(int position){   if (getRealAdapter() != null) {     getRealAdapter().removeSliderAt(position)      mViewPager.setCurrentItem(mViewPager.getCurrentItem(),false)    } } 
/**   * remove all the sliders. Notice: It's a not perfect method, a very small bug still exists.  */ public void removeAllSliders(){   if (getRealAdapter() != null) {     int count=getRealAdapter().getCount()      getRealAdapter().removeAllSliders()      mViewPager.setCurrentItem(mViewPager.getCurrentItem() + count,false)    } } 
/**   * set current slider  * @param position  */ public void setCurrentPosition(int position,boolean smooth){   if (getRealAdapter() == null)   throw new IllegalStateException("You did not set a slider adapter")    if (position >= getRealAdapter().getCount()) {     throw new IllegalStateException("Item position is not exist")    }   int p=mViewPager.getCurrentItem() % getRealAdapter().getCount()    int n=(position - p) + mViewPager.getCurrentItem()    mViewPager.setCurrentItem(n,smooth)  } 
public void setCurrentPosition(int position){   setCurrentPosition(position,true)  } 
/**   * move to prev slide.  */ public void movePrevPosition(boolean smooth){   if (getRealAdapter() == null)   throw new IllegalStateException("You did not set a slider adapter")    mViewPager.setCurrentItem(mViewPager.getCurrentItem() - 1,smooth)  } 
public void movePrevPosition(){   movePrevPosition(true)  } 
/**   * move to next slide.  */ public void moveNextPosition(boolean smooth){   if (getRealAdapter() == null)   throw new IllegalStateException("You did not set a slider adapter")    mViewPager.setCurrentItem(mViewPager.getCurrentItem() + 1,smooth)  } 
public void moveNextPosition(){   moveNextPosition(true)  } 
protected BaseSliderView(Context context){   mContext=context  } 
/**   * the placeholder image when loading image from url or file.  * @param resId Image resource id  * @return  */ public BaseSliderView empty(int resId){   mEmptyPlaceHolderRes=resId    return this  } 
/**   * determine whether remove the image which failed to download or load from file  * @param disappear  * @return  */ public BaseSliderView errorDisappear(boolean disappear){   mErrorDisappear=disappear    return this  } 
/**   * if you set errorDisappear false, this will set a error placeholder image.  * @param resId image resource id  * @return  */ public BaseSliderView error(int resId){   mErrorPlaceHolderRes=resId    return this  } 
/**   * the description of a slider image.  * @param description  * @return  */ public BaseSliderView description(String description){   mDescription=description    return this  } 
/**   * set a url as a image that preparing to load  * @param url  * @return  */ public BaseSliderView image(String url){   if (mFile != null || mRes != 0) {     throw new IllegalStateException("Call multi image function," + "you only have permission to call it once")    }   mUrl=url    return this  } 
/**   * set a file as a image that will to load  * @param file  * @return  */ public BaseSliderView image(File file){   if (mUrl != null || mRes != 0) {     throw new IllegalStateException("Call multi image function," + "you only have permission to call it once")    }   mFile=file    return this  } 
public BaseSliderView image(int res){   if (mUrl != null || mFile != null) {     throw new IllegalStateException("Call multi image function," + "you only have permission to call it once")    }   mRes=res    return this  } 
/**   * lets users add a bundle of additional information  * @param bundle  * @return  */ public BaseSliderView bundle(Bundle bundle){   mBundle=bundle    return this  } 
public String getUrl(){   return mUrl  } 
public boolean isErrorDisappear(){   return mErrorDisappear  } 
public int getEmpty(){   return mEmptyPlaceHolderRes  } 
public int getError(){   return mErrorPlaceHolderRes  } 
public String getDescription(){   return mDescription  } 
public Context getContext(){   return mContext  } 
/**   * set a slider image click listener  * @param l  * @return  */ public BaseSliderView setOnSliderClickListener(OnSliderClickListener l){   mOnSliderClickListener=l    return this  } 
/**   * When you want to implement your own slider view, please call this method in the end in `getView()` method  * @param v the whole view  * @param targetImageView where to place image  */ protected void bindEventAndShow(final View v,ImageView targetImageView){   final BaseSliderView me=this    v.setOnClickListener(new View.OnClickListener(){     @Override public void onClick(    View v){       if (mOnSliderClickListener != null) {         mOnSliderClickListener.onSliderClick(me)        }     }   } )    if (targetImageView == null)   return    if (mLoadListener != null) {     mLoadListener.onStart(me)    }   Picasso p=(mPicasso != null) ? mPicasso : Picasso.with(mContext)    RequestCreator rq=null    if (mUrl != null) {     rq=p.load(mUrl)    }  else   if (mFile != null) {     rq=p.load(mFile)    }  else   if (mRes != 0) {     rq=p.load(mRes)    }  else {     return    }   if (rq == null) {     return    }   if (getEmpty() != 0) {     rq.placeholder(getEmpty())    }   if (getError() != 0) {     rq.error(getError())    } switch (mScaleType) { case Fit:     rq.fit()    break  case CenterCrop: rq.fit().centerCrop()  break  case CenterInside: rq.fit().centerInside()  break  } rq.into(targetImageView,new Callback(){ @Override public void onSuccess(){ if (v.findViewById(R.id.loading_bar) != null) { v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE)  } } @Override public void onError(){ if (mLoadListener != null) { mLoadListener.onEnd(false,me)  } if (v.findViewById(R.id.loading_bar) != null) { v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE)  } } } )  } 
@Override public void onClick(View v){   if (mOnSliderClickListener != null) {     mOnSliderClickListener.onSliderClick(me)    } } 
@Override public void onSuccess(){   if (v.findViewById(R.id.loading_bar) != null) {     v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE)    } } 
@Override public void onError(){   if (mLoadListener != null) {     mLoadListener.onEnd(false,me)    }   if (v.findViewById(R.id.loading_bar) != null) {     v.findViewById(R.id.loading_bar).setVisibility(View.INVISIBLE)    } } 
public BaseSliderView setScaleType(ScaleType type){   mScaleType=type    return this  } 
public ScaleType getScaleType(){   return mScaleType  } 
/**   * the extended class have to implement getView(), which is called by the adapter, every extended class response to render their own view.  * @return  */ public abstract View getView()  
/**   * set a listener to get a message , if load error.  * @param l  */ public void setOnImageLoadListener(ImageLoadListener l){   mLoadListener=l  } 
public void onSliderClick(BaseSliderView slider)  
/**   * when you have some extra information, please put it in this bundle.  * @return  */ public Bundle getBundle(){   return mBundle  } 
public void onStart(BaseSliderView target)  
public void onEnd(boolean result,BaseSliderView target)  
/**   * Get the last instance set via setPicasso(), or null if no user provided instance was set  * @return The current user-provided Picasso instance, or null if none  */ public Picasso getPicasso(){   return mPicasso  } 
/**   * Provide a Picasso instance to use when loading pictures, this is useful if you have a particular HTTP cache you would like to share.  * @param picasso The Picasso instance to use, may be null to let the system use the defaultinstance  */ public void setPicasso(Picasso picasso){   mPicasso=picasso  } 
public DefaultSliderView(Context context){   super(context)  } 
@Override public View getView(){   View v=LayoutInflater.from(getContext()).inflate(R.layout.render_type_default,null)    ImageView target=(ImageView)v.findViewById(R.id.daimajia_slider_image)    bindEventAndShow(v,target)    return v  } 
public TextSliderView(Context context){   super(context)  } 
@Override public View getView(){   View v=LayoutInflater.from(getContext()).inflate(R.layout.render_type_text,null)    ImageView target=(ImageView)v.findViewById(R.id.daimajia_slider_image)    TextView description=(TextView)v.findViewById(R.id.description)    description.setText(getDescription())    bindEventAndShow(v,target)    return v  } 
@Override protected void onTransform(View view,float position){   ViewHelper.setPivotX(view,position < 0 ? 0 : view.getWidth())    ViewHelper.setScaleX(view,position < 0 ? 1f + position : 1f - position)  } 
@Override protected void onTransform(View view,float position){   final float height=view.getHeight()    final float width=view.getWidth()    final float scale=min(position < 0 ? 1f : Math.abs(1f - position),0.5f)    ViewHelper.setScaleX(view,scale)    ViewHelper.setScaleY(view,scale)    ViewHelper.setPivotX(view,width * 0.5f)    ViewHelper.setPivotY(view,height * 0.5f)    ViewHelper.setTranslationX(view,position < 0 ? width * position : -width * position * 0.25f)  } 
private static final float min(float val,float min){   return val < min ? min : val  } 
/**   * Called each  {@link #transformPage(View,float)}.  * @param view  * @param position  */ protected abstract void onTransform(View view,float position)  
@Override public void transformPage(View view,float position){   onPreTransform(view,position)    onTransform(view,position)    onPostTransform(view,position)  } 
/**   * If the position offset of a fragment is less than negative one or greater than one, returning true will set the visibility of the fragment to  {@link View#GONE}. Returning false will force the fragment to  {@link View#VISIBLE}.  * @return  */ protected boolean hideOffscreenPages(){   return true  } 
/**   * Indicates if the default animations of the view pager should be used.  * @return  */ protected boolean isPagingEnabled(){   return false  } 
/**   * Called each  {@link #transformPage(View,float)} before {{@link #onTransform(View,float)} is called.  * @param view  * @param position  */ protected void onPreTransform(View view,float position){   final float width=view.getWidth()    ViewHelper.setRotationX(view,0)    ViewHelper.setRotationY(view,0)    ViewHelper.setRotation(view,0)    ViewHelper.setScaleX(view,1)    ViewHelper.setScaleY(view,1)    ViewHelper.setPivotX(view,0)    ViewHelper.setPivotY(view,0)    ViewHelper.setTranslationY(view,0)    ViewHelper.setTranslationX(view,isPagingEnabled() ? 0f : -width * position)    if (hideOffscreenPages()) {     ViewHelper.setAlpha(view,position <= -1f || position >= 1f ? 0f : 1f)    }  else {     ViewHelper.setAlpha(view,1f)    }   if (mCustomAnimationInterface != null) {     if (h.containsKey(view) == false || h.get(view).size() == 1) {       if (position > -1 && position < 1) {         if (h.get(view) == null) {           h.put(view,new ArrayList<Float>())          }         h.get(view).add(position)          if (h.get(view).size() == 2) {           float zero=h.get(view).get(0)            float cha=h.get(view).get(1) - h.get(view).get(0)            if (zero > 0) {             if (cha > -1 && cha < 0) {               mCustomAnimationInterface.onPrepareNextItemShowInScreen(view)              }  else {               mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view)              }           }  else {             if (cha > -1 && cha < 0) {               mCustomAnimationInterface.onPrepareCurrentItemLeaveScreen(view)              }  else {               mCustomAnimationInterface.onPrepareNextItemShowInScreen(view)              }           }         }       }     }   } } 
/**   * Called each  {@link #transformPage(View,float)} call after {@link #onTransform(View,float)} is finished.  * @param view  * @param position  */ protected void onPostTransform(View view,float position){   if (mCustomAnimationInterface != null) {     if (position == -1 || position == 1) {       mCustomAnimationInterface.onCurrentItemDisappear(view)        isApp=true      }  else     if (position == 0) {       mCustomAnimationInterface.onNextItemAppear(view)        isDis=true      }     if (isApp && isDis) {       h.clear()        isApp=false        isDis=false      }   } } 
public void setCustomAnimationInterface(BaseAnimationInterface animationInterface){   mCustomAnimationInterface=animationInterface  } 
@Override protected void onTransform(View view,float position){   ViewHelper.setPivotX(view,position > 0 ? 0 : view.getWidth())    ViewHelper.setPivotY(view,0)    ViewHelper.setRotation(view,-90f * position)  } 
@Override public boolean isPagingEnabled(){   return true  } 
@Override protected void onTransform(View view,float position){ } 
@Override public boolean isPagingEnabled(){   return true  } 
@Override protected void onTransform(View view,float position){   if (position <= 0f) {     ViewHelper.setTranslationX(view,0f)      ViewHelper.setScaleX(view,1f)      ViewHelper.setScaleY(view,1f)    }  else   if (position <= 1f) {     final float scaleFactor=MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position))      ViewHelper.setAlpha(view,1 - position)      ViewHelper.setPivotY(view,0.5f * view.getHeight())      ViewHelper.setTranslationX(view,view.getWidth() * -position)      ViewHelper.setScaleX(view,scaleFactor)      ViewHelper.setScaleY(view,scaleFactor)    } } 
@Override protected boolean isPagingEnabled(){   return true  } 
@Override protected void onTransform(View view,float position){   if (position < -1 || position > 1) {     ViewHelper.setAlpha(view,0.6f)    }  else   if (position <= 0 || position <= 1) {     float alpha=(position <= 0) ? position + 1 : 1 - position      ViewHelper.setAlpha(view,alpha)    }  else   if (position == 0) {     ViewHelper.setAlpha(view,1)    } } 
@Override protected void onTransform(View view,float position){   final float rotation=180f * position    ViewHelper.setAlpha(view,rotation > 90f || rotation < -90f ? 0 : 1)    ViewHelper.setPivotY(view,view.getHeight() * 0.5f)    ViewHelper.setPivotX(view,view.getWidth() * 0.5f)    ViewHelper.setRotationY(view,rotation)  } 
@Override protected void onTransform(View view,float position){   float percentage=1 - Math.abs(position)    if (Build.VERSION.SDK_INT >= 13) {     view.setCameraDistance(12000)    }   setVisibility(view,position)    setTranslation(view)    setSize(view,position,percentage)    setRotation(view,position,percentage)  } 
private void setVisibility(View page,float position){   if (position < 0.5 && position > -0.5) {     page.setVisibility(View.VISIBLE)    }  else {     page.setVisibility(View.INVISIBLE)    } } 
private void setTranslation(View view){   ViewPagerEx viewPager=(ViewPagerEx)view.getParent()    int scroll=viewPager.getScrollX() - view.getLeft()    ViewHelper.setTranslationX(view,scroll)  } 
private void setSize(View view,float position,float percentage){   ViewHelper.setScaleX(view,(position != 0 && position != 1) ? percentage : 1)    ViewHelper.setScaleY(view,(position != 0 && position != 1) ? percentage : 1)  } 
private void setRotation(View view,float position,float percentage){   if (position > 0) {     ViewHelper.setRotationY(view,-180 * (percentage + 1))    }  else {     ViewHelper.setRotationY(view,180 * (percentage + 1))    } } 
@Override protected void onTransform(View view,float position){   final float height=view.getHeight()    final float width=view.getWidth()    final float scale=min(position > 0 ? 1f : Math.abs(1f + position),0.5f)    ViewHelper.setScaleX(view,scale)    ViewHelper.setScaleY(view,scale)    ViewHelper.setPivotX(view,width * 0.5f)    ViewHelper.setPivotY(view,height * 0.5f)    ViewHelper.setTranslationX(view,position > 0 ? width * position : -width * position * 0.25f)  } 
private static final float min(float val,float min){   return val < min ? min : val  } 
@Override protected void onTransform(View view,float position){   final float width=view.getWidth()    final float height=view.getHeight()    final float rotation=ROT_MOD * position * -1.25f    ViewHelper.setPivotX(view,width * 0.5f)    ViewHelper.setPivotY(view,height)    ViewHelper.setRotation(view,rotation)  } 
@Override protected boolean isPagingEnabled(){   return true  } 
@Override protected void onTransform(View view,float position){   final float width=view.getWidth()    final float rotation=ROT_MOD * position    ViewHelper.setPivotX(view,width * 0.5f)    ViewHelper.setPivotY(view,0f)    ViewHelper.setTranslationX(view,0f)    ViewHelper.setRotation(view,rotation)  } 
@Override protected boolean isPagingEnabled(){   return true  } 
@Override protected void onTransform(View view,float position){   ViewHelper.setTranslationX(view,position < 0 ? 0f : -view.getWidth() * position)  } 
@Override protected void onTransform(View view,float position){   final float rotation=(position < 0 ? 30f : -30f) * Math.abs(position)    ViewHelper.setTranslationX(view,getOffsetXForRotation(rotation,view.getWidth(),view.getHeight()))    ViewHelper.setPivotX(view,view.getWidth() * 0.5f)    ViewHelper.setPivotY(view,0)    ViewHelper.setRotationY(view,rotation)  } 
protected static final float getOffsetXForRotation(float degrees,int width,int height){   OFFSET_MATRIX.reset()    OFFSET_CAMERA.save()    OFFSET_CAMERA.rotateY(Math.abs(degrees))    OFFSET_CAMERA.getMatrix(OFFSET_MATRIX)    OFFSET_CAMERA.restore()    OFFSET_MATRIX.preTranslate(-width * 0.5f,-height * 0.5f)    OFFSET_MATRIX.postTranslate(width * 0.5f,height * 0.5f)    OFFSET_TEMP_FLOAT[0]=width    OFFSET_TEMP_FLOAT[1]=height    OFFSET_MATRIX.mapPoints(OFFSET_TEMP_FLOAT)    return (width - OFFSET_TEMP_FLOAT[0]) * (degrees > 0.0f ? 1.0f : -1.0f)  } 
@Override protected void onTransform(View view,float position){   final float scale=position < 0 ? position + 1f : Math.abs(1f - position)    ViewHelper.setScaleX(view,scale)    ViewHelper.setScaleY(view,scale)    ViewHelper.setPivotX(view,view.getWidth() * 0.5f)    ViewHelper.setPivotY(view,view.getHeight() * 0.5f)    ViewHelper.setAlpha(view,position < -1f || position > 1f ? 0f : 1f - (scale - 1f))  } 
@Override protected void onTransform(View view,float position){   if (position >= -1 || position <= 1) {     final float height=view.getHeight()      final float scaleFactor=Math.max(MIN_SCALE,1 - Math.abs(position))      final float vertMargin=height * (1 - scaleFactor) / 2      final float horzMargin=view.getWidth() * (1 - scaleFactor) / 2      ViewHelper.setPivotY(view,0.5f * height)      if (position < 0) {       ViewHelper.setTranslationX(view,horzMargin - vertMargin / 2)      }  else {       ViewHelper.setTranslationX(view,-horzMargin + vertMargin / 2)      }     ViewHelper.setScaleX(view,scaleFactor)      ViewHelper.setScaleY(view,scaleFactor)      ViewHelper.setAlpha(view,MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA))    } } 
@Override protected void onTransform(View view,float position){   final float scale=1f + Math.abs(position)    ViewHelper.setScaleX(view,scale)    ViewHelper.setScaleY(view,scale)    ViewHelper.setPivotX(view,view.getWidth() * 0.5f)    ViewHelper.setPivotY(view,view.getWidth() * 0.5f)    ViewHelper.setAlpha(view,position < -1f || position > 1f ? 0f : 1f - (scale - 1f))    if (position < -0.9) {     ViewHelper.setTranslationX(view,view.getWidth() * position)    } } 
public FixedSpeedScroller(Context context){   super(context)  } 
public FixedSpeedScroller(Context context,Interpolator interpolator){   super(context,interpolator)  } 
public FixedSpeedScroller(Context context,Interpolator interpolator,int period){   this(context,interpolator)    mDuration=period  } 
@Override public void startScroll(int startX,int startY,int dx,int dy,int duration){   super.startScroll(startX,startY,dx,dy,mDuration)  } 
@Override public void startScroll(int startX,int startY,int dx,int dy){   super.startScroll(startX,startY,dx,dy,mDuration)  } 
public InfinitePagerAdapter(SliderAdapter adapter){   this.adapter=adapter  } 
public SliderAdapter getRealAdapter(){   return this.adapter  } 
@Override public int getCount(){   return Integer.MAX_VALUE  } 
/**   * @return the {@link #getCount()} result of the wrapped adapter  */ public int getRealCount(){   return adapter.getCount()  } 
@Override public Object instantiateItem(ViewGroup container,int position){   if (getRealCount() == 0) {     return null    }   int virtualPosition=position % getRealCount()    debug("instantiateItem: real position: " + position)    debug("instantiateItem: virtual position: " + virtualPosition)    return adapter.instantiateItem(container,virtualPosition)  } 
@Override public void destroyItem(ViewGroup container,int position,Object object){   if (getRealCount() == 0) {     return    }   int virtualPosition=position % getRealCount()    debug("destroyItem: real position: " + position)    debug("destroyItem: virtual position: " + virtualPosition)    adapter.destroyItem(container,virtualPosition,object)  } 
@Override public void finishUpdate(ViewGroup container){   adapter.finishUpdate(container)  } 
@Override public boolean isViewFromObject(View view,Object object){   return adapter.isViewFromObject(view,object)  } 
@Override public void restoreState(Parcelable bundle,ClassLoader classLoader){   adapter.restoreState(bundle,classLoader)  } 
@Override public Parcelable saveState(){   return adapter.saveState()  } 
@Override public void startUpdate(ViewGroup container){   adapter.startUpdate(container)  } 
private void debug(String message){   if (DEBUG) {     Log.d(TAG,message)    } } 
public InfiniteViewPager(Context context){   super(context)  } 
public InfiniteViewPager(Context context,AttributeSet attrs){   super(context,attrs)  } 
@Override public void setAdapter(PagerAdapter adapter){   super.setAdapter(adapter)  } 
@Override public int compare(ItemInfo lhs,ItemInfo rhs){   return lhs.position - rhs.position  } 
public float getInterpolation(float t){   t-=1.0f    return t * t * t* t* t + 1.0f  } 
public void run(){   setScrollState(SCROLL_STATE_IDLE)    populate()  } 
/**   * This method will be invoked when the current page is scrolled, either as part of a programmatically initiated smooth scroll or a user initiated touch scroll.  * @param position Position index of the first page currently being displayed.Page position+1 will be visible if positionOffset is nonzero.  * @param positionOffset Value from [0, 1) indicating the offset from the page at position.  * @param positionOffsetPixels Value in pixels indicating the offset from position.  */ public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels)  
/**   * This method will be invoked when a new page becomes selected. Animation is not necessarily complete.  * @param position Position index of the new selected page.  */ public void onPageSelected(int position)  
/**   * Called when the scroll state changes. Useful for discovering when the user begins dragging, when the pager is automatically settling to the current page, or when it is fully stopped/idle.  * @param state The new scroll state.  * @see ViewPagerEx#SCROLL_STATE_IDLE  * @see ViewPagerEx#SCROLL_STATE_DRAGGING  * @see ViewPagerEx#SCROLL_STATE_SETTLING  */ public void onPageScrollStateChanged(int state)  
@Override public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels){ } 
@Override public void onPageSelected(int position){ } 
@Override public void onPageScrollStateChanged(int state){ } 
private void triggerOnPageChangeEvent(int position){   for (  OnPageChangeListener eachListener : mOnPageChangeListeners) {     if (eachListener != null) {       InfinitePagerAdapter infiniteAdapter=(InfinitePagerAdapter)mAdapter        if (infiniteAdapter.getRealCount() == 0) {         return        }       int n=position % infiniteAdapter.getRealCount()        eachListener.onPageSelected(n)      }   }   if (mInternalPageChangeListener != null) {     mInternalPageChangeListener.onPageSelected(position)    } } 
/**   * Apply a property transformation to the given page.  * @param page Apply the transformation to this page  * @param position Position of page relative to the current front-and-centerposition of the pager. 0 is front and center. 1 is one full page position to the right, and -1 is one page position to the left.  */ public void transformPage(View page,float position)  
public void onAdapterChanged(PagerAdapter oldAdapter,PagerAdapter newAdapter)  
public ViewPagerEx(Context context){   super(context)    initViewPager()  } 
public ViewPagerEx(Context context,AttributeSet attrs){   super(context,attrs)    initViewPager()  } 
void initViewPager(){   setWillNotDraw(false)    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS)    setFocusable(true)    final Context context=getContext()    mScroller=new Scroller(context,sInterpolator)    final ViewConfiguration configuration=ViewConfiguration.get(context)    final float density=context.getResources().getDisplayMetrics().density    mTouchSlop=ViewConfigurationCompat.getScaledPagingTouchSlop(configuration)    mMinimumVelocity=(int)(MIN_FLING_VELOCITY * density)    mMaximumVelocity=configuration.getScaledMaximumFlingVelocity()    mLeftEdge=new EdgeEffectCompat(context)    mRightEdge=new EdgeEffectCompat(context)    mFlingDistance=(int)(MIN_DISTANCE_FOR_FLING * density)    mCloseEnough=(int)(CLOSE_ENOUGH * density)    mDefaultGutterSize=(int)(DEFAULT_GUTTER_SIZE * density)    ViewCompat.setAccessibilityDelegate(this,new MyAccessibilityDelegate())    if (ViewCompat.getImportantForAccessibility(this) == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {     ViewCompat.setImportantForAccessibility(this,ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES)    } } 
@Override protected void onDetachedFromWindow(){   removeCallbacks(mEndScrollRunnable)    super.onDetachedFromWindow()  } 
private void setScrollState(int newState){   if (mScrollState == newState) {     return    }   mScrollState=newState    if (mPageTransformer != null) {     enableLayers(newState != SCROLL_STATE_IDLE)    }   for (  OnPageChangeListener eachListener : mOnPageChangeListeners) {     if (eachListener != null) {       eachListener.onPageScrollStateChanged(newState)      }   } } 
/**   * Set a PagerAdapter that will supply views for this pager as needed.  * @param adapter Adapter to use  */ public void setAdapter(PagerAdapter adapter){   if (mAdapter != null) {     mAdapter.unregisterDataSetObserver(mObserver)      mAdapter.startUpdate(this)      for (int i=0  i < mItems.size()  i++) {       final ItemInfo ii=mItems.get(i)        mAdapter.destroyItem(this,ii.position,ii.object)      }     mAdapter.finishUpdate(this)      mItems.clear()      removeNonDecorViews()      mCurItem=0      scrollTo(0,0)    }   final PagerAdapter oldAdapter=mAdapter    mAdapter=adapter    mExpectedAdapterCount=0    if (mAdapter != null) {     if (mObserver == null) {       mObserver=new PagerObserver()      }     mAdapter.registerDataSetObserver(mObserver)      mPopulatePending=false      final boolean wasFirstLayout=mFirstLayout      mFirstLayout=true      mExpectedAdapterCount=mAdapter.getCount()      if (mRestoredCurItem >= 0) {       mAdapter.restoreState(mRestoredAdapterState,mRestoredClassLoader)        setCurrentItemInternal(mRestoredCurItem,false,true)        mRestoredCurItem=-1        mRestoredAdapterState=null        mRestoredClassLoader=null      }  else     if (!wasFirstLayout) {       populate()      }  else {       requestLayout()      }   }   if (mAdapterChangeListener != null && oldAdapter != adapter) {     mAdapterChangeListener.onAdapterChanged(oldAdapter,adapter)    } } 
private void removeNonDecorViews(){   for (int i=0  i < getChildCount()  i++) {     final View child=getChildAt(i)      final LayoutParams lp=(LayoutParams)child.getLayoutParams()      if (!lp.isDecor) {       removeViewAt(i)        i--      }   } } 
/**   * Retrieve the current adapter supplying pages.  * @return The currently registered PagerAdapter  */ public PagerAdapter getAdapter(){   return mAdapter  } 
void setOnAdapterChangeListener(OnAdapterChangeListener listener){   mAdapterChangeListener=listener  } 
private int getClientWidth(){   return getMeasuredWidth() - getPaddingLeft() - getPaddingRight()  } 
/**   * Set the currently selected page. If the ViewPager has already been through its first layout with its current adapter there will be a smooth animated transition between the current item and the specified item.  * @param item Item index to select  */ public void setCurrentItem(int item){   mPopulatePending=false    setCurrentItemInternal(item,!mFirstLayout,false)  } 
/**   * Set the currently selected page.  * @param item Item index to select  * @param smoothScroll True to smoothly scroll to the new item, false to transition immediately  */ public void setCurrentItem(int item,boolean smoothScroll){   mPopulatePending=false    setCurrentItemInternal(item,smoothScroll,false)  } 
public int getCurrentItem(){   return mCurItem  } 
void setCurrentItemInternal(int item,boolean smoothScroll,boolean always){   setCurrentItemInternal(item,smoothScroll,always,0)  } 
void setCurrentItemInternal(int item,boolean smoothScroll,boolean always,int velocity){   if (mAdapter == null || mAdapter.getCount() <= 0) {     setScrollingCacheEnabled(false)      return    }   if (!always && mCurItem == item && mItems.size() != 0) {     setScrollingCacheEnabled(false)      return    }   if (item < 0) {     item=0    }  else   if (item >= mAdapter.getCount()) {     item=mAdapter.getCount() - 1    }   final int pageLimit=mOffscreenPageLimit    if (item > (mCurItem + pageLimit) || item < (mCurItem - pageLimit)) {     for (int i=0  i < mItems.size()  i++) {       mItems.get(i).scrolling=true      }   }   final boolean dispatchSelected=mCurItem != item    if (mFirstLayout) {     mCurItem=item      triggerOnPageChangeEvent(item)      requestLayout()    }  else {     populate(item)      scrollToItem(item,smoothScroll,velocity,dispatchSelected)    } } 
private void scrollToItem(int item,boolean smoothScroll,int velocity,boolean dispatchSelected){   final ItemInfo curInfo=infoForPosition(item)    int destX=0    if (curInfo != null) {     final int width=getClientWidth()      destX=(int)(width * Math.max(mFirstOffset,Math.min(curInfo.offset,mLastOffset)))    }   if (smoothScroll) {     smoothScrollTo(destX,0,velocity)      if (dispatchSelected) {       triggerOnPageChangeEvent(item)      }   }  else {     if (dispatchSelected) {       triggerOnPageChangeEvent(item)      }     completeScroll(false)      scrollTo(destX,0)      pageScrolled(destX)    } } 
/**   * Add a listener that will be invoked whenever the page changes or is incrementally scrolled. See  {@link OnPageChangeListener}.  * @param listener Listener to add  */ public void addOnPageChangeListener(OnPageChangeListener listener){   if (!mOnPageChangeListeners.contains(listener)) {     mOnPageChangeListeners.add(listener)    } } 
/**   * Remove a listener that was added with addOnPageChangeListener See  {@link OnPageChangeListener}.  * @param listener Listener to remove  */ public void removeOnPageChangeListener(OnPageChangeListener listener){   mOnPageChangeListeners.remove(listener)  } 
/**   * Set a  {@link PageTransformer} that will be called for each attached page wheneverthe scroll position is changed. This allows the application to apply custom property transformations to each page, overriding the default sliding look and feel. <p><em>Note:</em> Prior to Android 3.0 the property animation APIs did not exist. As a result, setting a PageTransformer prior to Android 3.0 (API 11) will have no effect.</p>  * @param reverseDrawingOrder true if the supplied PageTransformer requires page viewsto be drawn from last to first instead of first to last.  * @param transformer PageTransformer that will modify each page's animation properties  */ public void setPageTransformer(boolean reverseDrawingOrder,PageTransformer transformer){   final boolean hasTransformer=transformer != null    final boolean needsPopulate=hasTransformer != (mPageTransformer != null)    mPageTransformer=transformer    setChildrenDrawingOrderEnabledCompat(hasTransformer)    if (hasTransformer) {     mDrawingOrder=reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD    }  else {     mDrawingOrder=DRAW_ORDER_DEFAULT    }   if (needsPopulate)   populate()  } 
void setChildrenDrawingOrderEnabledCompat(boolean enable){   if (Build.VERSION.SDK_INT >= 7) {     if (mSetChildrenDrawingOrderEnabled == null) {       try {         mSetChildrenDrawingOrderEnabled=ViewGroup.class.getDeclaredMethod("setChildrenDrawingOrderEnabled",new Class[]{Boolean.TYPE})        }  catch (      NoSuchMethodException e) {         Log.e(TAG,"Can't find setChildrenDrawingOrderEnabled",e)        }     }     try {       mSetChildrenDrawingOrderEnabled.invoke(this,enable)      }  catch (    Exception e) {       Log.e(TAG,"Error changing children drawing order",e)      }   } } 
@Override protected int getChildDrawingOrder(int childCount,int i){   final int index=mDrawingOrder == DRAW_ORDER_REVERSE ? childCount - 1 - i : i    final int result=((LayoutParams)mDrawingOrderedChildren.get(index).getLayoutParams()).childIndex    return result  } 
/**   * Set a separate OnPageChangeListener for internal use by the support library.  * @param listener Listener to set  * @return The old listener that was set, if any.  */ OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){   OnPageChangeListener oldListener=mInternalPageChangeListener    mInternalPageChangeListener=listener    return oldListener  } 
/**   * Returns the number of pages that will be retained to either side of the current page in the view hierarchy in an idle state. Defaults to 1.  * @return How many pages will be kept offscreen on either side  * @see #setOffscreenPageLimit(int)  */ public int getOffscreenPageLimit(){   return mOffscreenPageLimit  } 
/**   * Set the number of pages that should be retained to either side of the current page in the view hierarchy in an idle state. Pages beyond this limit will be recreated from the adapter when needed. <p>This is offered as an optimization. If you know in advance the number of pages you will need to support or have lazy-loading mechanisms in place on your pages, tweaking this setting can have benefits in perceived smoothness of paging animations and interaction. If you have a small number of pages (3-4) that you can keep active all at once, less time will be spent in layout for newly created view subtrees as the user pages back and forth.</p> <p>You should keep this limit low, especially if your pages have complex layouts. This setting defaults to 1.</p>  * @param limit How many pages will be kept offscreen in an idle state.  */ public void setOffscreenPageLimit(int limit){   if (limit < DEFAULT_OFFSCREEN_PAGES) {     Log.w(TAG,"Requested offscreen page limit " + limit + " too small  defaulting to "+ DEFAULT_OFFSCREEN_PAGES)      limit=DEFAULT_OFFSCREEN_PAGES    }   if (limit != mOffscreenPageLimit) {     mOffscreenPageLimit=limit      populate()    } } 
/**   * Set the margin between pages.  * @param marginPixels Distance between adjacent pages in pixels  * @see #getPageMargin()  * @see #setPageMarginDrawable(Drawable)  * @see #setPageMarginDrawable(int)  */ public void setPageMargin(int marginPixels){   final int oldMargin=mPageMargin    mPageMargin=marginPixels    final int width=getWidth()    recomputeScrollPosition(width,width,marginPixels,oldMargin)    requestLayout()  } 
/**   * Return the margin between pages.  * @return The size of the margin in pixels  */ public int getPageMargin(){   return mPageMargin  } 
/**   * Set a drawable that will be used to fill the margin between pages.  * @param d Drawable to display between pages  */ public void setPageMarginDrawable(Drawable d){   mMarginDrawable=d    if (d != null)   refreshDrawableState()    setWillNotDraw(d == null)    invalidate()  } 
/**   * Set a drawable that will be used to fill the margin between pages.  * @param resId Resource ID of a drawable to display between pages  */ public void setPageMarginDrawable(int resId){   setPageMarginDrawable(getContext().getResources().getDrawable(resId))  } 
@Override protected boolean verifyDrawable(Drawable who){   return super.verifyDrawable(who) || who == mMarginDrawable  } 
@Override protected void drawableStateChanged(){   super.drawableStateChanged()    final Drawable d=mMarginDrawable    if (d != null && d.isStateful()) {     d.setState(getDrawableState())    } } 
float distanceInfluenceForSnapDuration(float f){   f-=0.5f    f*=0.3f * Math.PI / 2.0f    return (float)Math.sin(f)  } 
/**   * Like  {@link View#scrollBy}, but scroll smoothly instead of immediately.  * @param x the number of pixels to scroll by on the X axis  * @param y the number of pixels to scroll by on the Y axis  */ void smoothScrollTo(int x,int y){   smoothScrollTo(x,y,0)  } 
/**   * Like  {@link View#scrollBy}, but scroll smoothly instead of immediately.  * @param x the number of pixels to scroll by on the X axis  * @param y the number of pixels to scroll by on the Y axis  * @param velocity the velocity associated with a fling, if applicable. (0 otherwise)  */ void smoothScrollTo(int x,int y,int velocity){   if (getChildCount() == 0) {     setScrollingCacheEnabled(false)      return    }   int sx=getScrollX()    int sy=getScrollY()    int dx=x - sx    int dy=y - sy    if (dx == 0 && dy == 0) {     completeScroll(false)      populate()      setScrollState(SCROLL_STATE_IDLE)      return    }   setScrollingCacheEnabled(true)    setScrollState(SCROLL_STATE_SETTLING)    final int width=getClientWidth()    final int halfWidth=width / 2    final float distanceRatio=Math.min(1f,1.0f * Math.abs(dx) / width)    final float distance=halfWidth + halfWidth * distanceInfluenceForSnapDuration(distanceRatio)    int duration=0    velocity=Math.abs(velocity)    if (velocity > 0) {     duration=4 * Math.round(1000 * Math.abs(distance / velocity))    }  else {     final float pageWidth=width * mAdapter.getPageWidth(mCurItem)      final float pageDelta=(float)Math.abs(dx) / (pageWidth + mPageMargin)      duration=(int)((pageDelta + 1) * 100)    }   duration=Math.min(duration,MAX_SETTLE_DURATION)    mScroller.startScroll(sx,sy,dx,dy,duration)    ViewCompat.postInvalidateOnAnimation(this)  } 
ItemInfo addNewItem(int position,int index){   ItemInfo ii=new ItemInfo()    ii.position=position    ii.object=mAdapter.instantiateItem(this,position)    ii.widthFactor=mAdapter.getPageWidth(position)    if (index < 0 || index >= mItems.size()) {     mItems.add(ii)    }  else {     mItems.add(index,ii)    }   return ii  } 
void dataSetChanged(){   final int adapterCount=mAdapter.getCount()    mExpectedAdapterCount=adapterCount    boolean needPopulate=mItems.size() < mOffscreenPageLimit * 2 + 1 && mItems.size() < adapterCount    int newCurrItem=mCurItem    boolean isUpdating=false    for (int i=0  i < mItems.size()  i++) {     final ItemInfo ii=mItems.get(i)      final int newPos=mAdapter.getItemPosition(ii.object)      if (newPos == PagerAdapter.POSITION_UNCHANGED) {       continue      }     if (newPos == PagerAdapter.POSITION_NONE) {       mItems.remove(i)        i--        if (!isUpdating) {         mAdapter.startUpdate(this)          isUpdating=true        }       mAdapter.destroyItem(this,ii.position,ii.object)        needPopulate=true        if (mCurItem == ii.position) {         newCurrItem=Math.max(0,Math.min(mCurItem,adapterCount - 1))          needPopulate=true        }       continue      }     if (ii.position != newPos) {       if (ii.position == mCurItem) {         newCurrItem=newPos        }       ii.position=newPos        needPopulate=true      }   }   if (isUpdating) {     mAdapter.finishUpdate(this)    }   Collections.sort(mItems,COMPARATOR)    if (needPopulate) {     final int childCount=getChildCount()      for (int i=0  i < childCount  i++) {       final View child=getChildAt(i)        final LayoutParams lp=(LayoutParams)child.getLayoutParams()        if (!lp.isDecor) {         lp.widthFactor=0.f        }     }     setCurrentItemInternal(newCurrItem,false,true)      requestLayout()    } } 
void populate(){   populate(mCurItem)  } 
void populate(int newCurrentItem){   ItemInfo oldCurInfo=null    int focusDirection=View.FOCUS_FORWARD    if (mCurItem != newCurrentItem) {     focusDirection=mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT      oldCurInfo=infoForPosition(mCurItem)      mCurItem=newCurrentItem    }   if (mAdapter == null) {     sortChildDrawingOrder()      return    }   if (mPopulatePending) {     if (DEBUG)     Log.i(TAG,"populate is pending, skipping for now...")      sortChildDrawingOrder()      return    }   if (getWindowToken() == null) {     return    }   mAdapter.startUpdate(this)    final int pageLimit=mOffscreenPageLimit    final int startPos=Math.max(0,mCurItem - pageLimit)    final int N=mAdapter.getCount()    final int endPos=Math.min(N - 1,mCurItem + pageLimit)    if (N != mExpectedAdapterCount) {     String resName      try {       resName=getResources().getResourceName(getId())      }  catch (    Resources.NotFoundException e) {       resName=Integer.toHexString(getId())      }     throw new IllegalStateException("The application's PagerAdapter changed the adapter's" + " contents without calling PagerAdapter#notifyDataSetChanged!" + " Expected adapter item count: " + mExpectedAdapterCount + ", found: "+ N+ " Pager id: "+ resName+ " Pager class: "+ getClass()+ " Problematic adapter: "+ mAdapter.getClass())    }   int curIndex=-1    ItemInfo curItem=null    for (curIndex=0  curIndex < mItems.size()  curIndex++) {     final ItemInfo ii=mItems.get(curIndex)      if (ii.position >= mCurItem) {       if (ii.position == mCurItem)       curItem=ii        break      }   }   if (curItem == null && N > 0) {     curItem=addNewItem(mCurItem,curIndex)    }   if (curItem != null) {     float extraWidthLeft=0.f      int itemIndex=curIndex - 1      ItemInfo ii=itemIndex >= 0 ? mItems.get(itemIndex) : null      final int clientWidth=getClientWidth()      final float leftWidthNeeded=clientWidth <= 0 ? 0 : 2.f - curItem.widthFactor + (float)getPaddingLeft() / (float)clientWidth      for (int pos=mCurItem - 1  pos >= 0  pos--) {       if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {         if (ii == null) {           break          }         if (pos == ii.position && !ii.scrolling) {           mItems.remove(itemIndex)            mAdapter.destroyItem(this,pos,ii.object)            if (DEBUG) {             Log.i(TAG,"populate() - destroyItem() with pos: " + pos + " view: "+ ((View)ii.object))            }           itemIndex--            curIndex--            ii=itemIndex >= 0 ? mItems.get(itemIndex) : null          }       }  else       if (ii != null && pos == ii.position) {         extraWidthLeft+=ii.widthFactor          itemIndex--          ii=itemIndex >= 0 ? mItems.get(itemIndex) : null        }  else {         ii=addNewItem(pos,itemIndex + 1)          extraWidthLeft+=ii.widthFactor          curIndex++          ii=itemIndex >= 0 ? mItems.get(itemIndex) : null        }     }     float extraWidthRight=curItem.widthFactor      itemIndex=curIndex + 1      if (extraWidthRight < 2.f) {       ii=itemIndex < mItems.size() ? mItems.get(itemIndex) : null        final float rightWidthNeeded=clientWidth <= 0 ? 0 : (float)getPaddingRight() / (float)clientWidth + 2.f        for (int pos=mCurItem + 1  pos < N  pos++) {         if (extraWidthRight >= rightWidthNeeded && pos > endPos) {           if (ii == null) {             break            }           if (pos == ii.position && !ii.scrolling) {             mItems.remove(itemIndex)              mAdapter.destroyItem(this,pos,ii.object)              if (DEBUG) {               Log.i(TAG,"populate() - destroyItem() with pos: " + pos + " view: "+ ((View)ii.object))              }             ii=itemIndex < mItems.size() ? mItems.get(itemIndex) : null            }         }  else         if (ii != null && pos == ii.position) {           extraWidthRight+=ii.widthFactor            itemIndex++            ii=itemIndex < mItems.size() ? mItems.get(itemIndex) : null          }  else {           ii=addNewItem(pos,itemIndex)            itemIndex++            extraWidthRight+=ii.widthFactor            ii=itemIndex < mItems.size() ? mItems.get(itemIndex) : null          }       }     }     calculatePageOffsets(curItem,curIndex,oldCurInfo)    }   if (DEBUG) {     Log.i(TAG,"Current page list:")      for (int i=0  i < mItems.size()  i++) {       Log.i(TAG,"#" + i + ": page "+ mItems.get(i).position)      }   }   mAdapter.setPrimaryItem(this,mCurItem,curItem != null ? curItem.object : null)    mAdapter.finishUpdate(this)    final int childCount=getChildCount()    for (int i=0  i < childCount  i++) {     final View child=getChildAt(i)      final LayoutParams lp=(LayoutParams)child.getLayoutParams()      lp.childIndex=i      if (!lp.isDecor && lp.widthFactor == 0.f) {       final ItemInfo ii=infoForChild(child)        if (ii != null) {         lp.widthFactor=ii.widthFactor          lp.position=ii.position        }     }   }   sortChildDrawingOrder()    if (hasFocus()) {     View currentFocused=findFocus()      ItemInfo ii=currentFocused != null ? infoForAnyChild(currentFocused) : null      if (ii == null || ii.position != mCurItem) {       for (int i=0  i < getChildCount()  i++) {         View child=getChildAt(i)          ii=infoForChild(child)          if (ii != null && ii.position == mCurItem) {           if (child.requestFocus(focusDirection)) {             break            }         }       }     }   } } 
private void sortChildDrawingOrder(){   if (mDrawingOrder != DRAW_ORDER_DEFAULT) {     if (mDrawingOrderedChildren == null) {       mDrawingOrderedChildren=new ArrayList<View>()      }  else {       mDrawingOrderedChildren.clear()      }     final int childCount=getChildCount()      for (int i=0  i < childCount  i++) {       final View child=getChildAt(i)        mDrawingOrderedChildren.add(child)      }     Collections.sort(mDrawingOrderedChildren,sPositionComparator)    } } 
private void calculatePageOffsets(ItemInfo curItem,int curIndex,ItemInfo oldCurInfo){   final int N=mAdapter.getCount()    final int width=getClientWidth()    final float marginOffset=width > 0 ? (float)mPageMargin / width : 0    if (oldCurInfo != null) {     final int oldCurPosition=oldCurInfo.position      if (oldCurPosition < curItem.position) {       int itemIndex=0        ItemInfo ii=null        float offset=oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset        for (int pos=oldCurPosition + 1  pos <= curItem.position && itemIndex < mItems.size()  pos++) {         ii=mItems.get(itemIndex)          while (pos > ii.position && itemIndex < mItems.size() - 1) {           itemIndex++            ii=mItems.get(itemIndex)          }         while (pos < ii.position) {           offset+=mAdapter.getPageWidth(pos) + marginOffset            pos++          }         ii.offset=offset          offset+=ii.widthFactor + marginOffset        }     }  else     if (oldCurPosition > curItem.position) {       int itemIndex=mItems.size() - 1        ItemInfo ii=null        float offset=oldCurInfo.offset        for (int pos=oldCurPosition - 1  pos >= curItem.position && itemIndex >= 0  pos--) {         ii=mItems.get(itemIndex)          while (pos < ii.position && itemIndex > 0) {           itemIndex--            ii=mItems.get(itemIndex)          }         while (pos > ii.position) {           offset-=mAdapter.getPageWidth(pos) + marginOffset            pos--          }         offset-=ii.widthFactor + marginOffset          ii.offset=offset        }     }   }   final int itemCount=mItems.size()    float offset=curItem.offset    int pos=curItem.position - 1    mFirstOffset=curItem.position == 0 ? curItem.offset : -Float.MAX_VALUE    mLastOffset=curItem.position == N - 1 ? curItem.offset + curItem.widthFactor - 1 : Float.MAX_VALUE    for (int i=curIndex - 1  i >= 0  i--, pos--) {     final ItemInfo ii=mItems.get(i)      while (pos > ii.position) {       offset-=mAdapter.getPageWidth(pos--) + marginOffset      }     offset-=ii.widthFactor + marginOffset      ii.offset=offset      if (ii.position == 0)     mFirstOffset=offset    }   offset=curItem.offset + curItem.widthFactor + marginOffset    pos=curItem.position + 1    for (int i=curIndex + 1  i < itemCount  i++, pos++) {     final ItemInfo ii=mItems.get(i)      while (pos < ii.position) {       offset+=mAdapter.getPageWidth(pos++) + marginOffset      }     if (ii.position == N - 1) {       mLastOffset=offset + ii.widthFactor - 1      }     ii.offset=offset      offset+=ii.widthFactor + marginOffset    }   mNeedCalculatePageOffsets=false  } 
public SavedState(Parcelable superState){   super(superState)  } 
@Override public void writeToParcel(Parcel out,int flags){   super.writeToParcel(out,flags)    out.writeInt(position)    out.writeParcelable(adapterState,flags)  } 
@Override public String toString(){   return "FragmentPager.SavedState{" + Integer.toHexString(System.identityHashCode(this)) + " position="+ position+ "}"  } 
@Override public SavedState createFromParcel(Parcel in,ClassLoader loader){   return new SavedState(in,loader)  } 
@Override public SavedState[] newArray(int size){   return new SavedState[size]  } 
SavedState(Parcel in,ClassLoader loader){   super(in)    if (loader == null) {     loader=getClass().getClassLoader()    }   position=in.readInt()    adapterState=in.readParcelable(loader)    this.loader=loader  } 
@Override public Parcelable onSaveInstanceState(){   Parcelable superState=super.onSaveInstanceState()    SavedState ss=new SavedState(superState)    ss.position=mCurItem    if (mAdapter != null) {     ss.adapterState=mAdapter.saveState()    }   return ss  } 
@Override public void onRestoreInstanceState(Parcelable state){   if (!(state instanceof SavedState)) {     super.onRestoreInstanceState(state)      return    }   SavedState ss=(SavedState)state    super.onRestoreInstanceState(ss.getSuperState())    if (mAdapter != null) {     mAdapter.restoreState(ss.adapterState,ss.loader)      setCurrentItemInternal(ss.position,false,true)    }  else {     mRestoredCurItem=ss.position      mRestoredAdapterState=ss.adapterState      mRestoredClassLoader=ss.loader    } } 
@Override public void addView(View child,int index,ViewGroup.LayoutParams params){   if (!checkLayoutParams(params)) {     params=generateLayoutParams(params)    }   final LayoutParams lp=(LayoutParams)params    lp.isDecor|=child instanceof Decor    if (mInLayout) {     if (lp != null && lp.isDecor) {       throw new IllegalStateException("Cannot add pager decor view during layout")      }     lp.needsMeasure=true      addViewInLayout(child,index,params)    }  else {     super.addView(child,index,params)    }   if (USE_CACHE) {     if (child.getVisibility() != GONE) {       child.setDrawingCacheEnabled(mScrollingCacheEnabled)      }  else {       child.setDrawingCacheEnabled(false)      }   } } 
@Override public void removeView(View view){   if (mInLayout) {     removeViewInLayout(view)    }  else {     super.removeView(view)    } } 
ItemInfo infoForChild(View child){   for (int i=0  i < mItems.size()  i++) {     ItemInfo ii=mItems.get(i)      if (mAdapter.isViewFromObject(child,ii.object)) {       return ii      }   }   return null  } 
ItemInfo infoForAnyChild(View child){   ViewParent parent    while ((parent=child.getParent()) != this) {     if (parent == null || !(parent instanceof View)) {       return null      }     child=(View)parent    }   return infoForChild(child)  } 
ItemInfo infoForPosition(int position){   for (int i=0  i < mItems.size()  i++) {     ItemInfo ii=mItems.get(i)      if (ii.position == position) {       return ii      }   }   return null  } 
@Override protected void onAttachedToWindow(){   super.onAttachedToWindow()    mFirstLayout=true  } 
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){   setMeasuredDimension(getDefaultSize(0,widthMeasureSpec),getDefaultSize(0,heightMeasureSpec))    final int measuredWidth=getMeasuredWidth()    final int maxGutterSize=measuredWidth / 10    mGutterSize=Math.min(maxGutterSize,mDefaultGutterSize)    int childWidthSize=measuredWidth - getPaddingLeft() - getPaddingRight()    int childHeightSize=getMeasuredHeight() - getPaddingTop() - getPaddingBottom()    int size=getChildCount()    for (int i=0  i < size  ++i) {     final View child=getChildAt(i)      if (child.getVisibility() != GONE) {       final LayoutParams lp=(LayoutParams)child.getLayoutParams()        if (lp != null && lp.isDecor) {         final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK          final int vgrav=lp.gravity & Gravity.VERTICAL_GRAVITY_MASK          int widthMode=MeasureSpec.AT_MOST          int heightMode=MeasureSpec.AT_MOST          boolean consumeVertical=vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM          boolean consumeHorizontal=hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT          if (consumeVertical) {           widthMode=MeasureSpec.EXACTLY          }  else         if (consumeHorizontal) {           heightMode=MeasureSpec.EXACTLY          }         int widthSize=childWidthSize          int heightSize=childHeightSize          if (lp.width != LayoutParams.WRAP_CONTENT) {           widthMode=MeasureSpec.EXACTLY            if (lp.width != LayoutParams.FILL_PARENT) {             widthSize=lp.width            }         }         if (lp.height != LayoutParams.WRAP_CONTENT) {           heightMode=MeasureSpec.EXACTLY            if (lp.height != LayoutParams.FILL_PARENT) {             heightSize=lp.height            }         }         final int widthSpec=MeasureSpec.makeMeasureSpec(widthSize,widthMode)          final int heightSpec=MeasureSpec.makeMeasureSpec(heightSize,heightMode)          child.measure(widthSpec,heightSpec)          if (consumeVertical) {           childHeightSize-=child.getMeasuredHeight()          }  else         if (consumeHorizontal) {           childWidthSize-=child.getMeasuredWidth()          }       }     }   }   mChildWidthMeasureSpec=MeasureSpec.makeMeasureSpec(childWidthSize,MeasureSpec.EXACTLY)    mChildHeightMeasureSpec=MeasureSpec.makeMeasureSpec(childHeightSize,MeasureSpec.EXACTLY)    mInLayout=true    populate()    mInLayout=false    size=getChildCount()    for (int i=0  i < size  ++i) {     final View child=getChildAt(i)      if (child.getVisibility() != GONE) {       if (DEBUG)       Log.v(TAG,"Measuring #" + i + " "+ child+ ": "+ mChildWidthMeasureSpec)        final LayoutParams lp=(LayoutParams)child.getLayoutParams()        if (lp == null || !lp.isDecor) {         final int widthSpec=MeasureSpec.makeMeasureSpec((int)(childWidthSize * lp.widthFactor),MeasureSpec.EXACTLY)          child.measure(widthSpec,mChildHeightMeasureSpec)        }     }   } } 
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){   super.onSizeChanged(w,h,oldw,oldh)    if (w != oldw) {     recomputeScrollPosition(w,oldw,mPageMargin,mPageMargin)    } } 
private void recomputeScrollPosition(int width,int oldWidth,int margin,int oldMargin){   if (oldWidth > 0 && !mItems.isEmpty()) {     final int widthWithMargin=width - getPaddingLeft() - getPaddingRight() + margin      final int oldWidthWithMargin=oldWidth - getPaddingLeft() - getPaddingRight() + oldMargin      final int xpos=getScrollX()      final float pageOffset=(float)xpos / oldWidthWithMargin      final int newOffsetPixels=(int)(pageOffset * widthWithMargin)      scrollTo(newOffsetPixels,getScrollY())      if (!mScroller.isFinished()) {       final int newDuration=mScroller.getDuration() - mScroller.timePassed()        ItemInfo targetInfo=infoForPosition(mCurItem)        mScroller.startScroll(newOffsetPixels,0,(int)(targetInfo.offset * width),0,newDuration)      }   }  else {     final ItemInfo ii=infoForPosition(mCurItem)      final float scrollOffset=ii != null ? Math.min(ii.offset,mLastOffset) : 0      final int scrollPos=(int)(scrollOffset * (width - getPaddingLeft() - getPaddingRight()))      if (scrollPos != getScrollX()) {       completeScroll(false)        scrollTo(scrollPos,getScrollY())      }   } } 
@Override protected void onLayout(boolean changed,int l,int t,int r,int b){   final int count=getChildCount()    int width=r - l    int height=b - t    int paddingLeft=getPaddingLeft()    int paddingTop=getPaddingTop()    int paddingRight=getPaddingRight()    int paddingBottom=getPaddingBottom()    final int scrollX=getScrollX()    int decorCount=0    for (int i=0  i < count  i++) {     final View child=getChildAt(i)      if (child.getVisibility() != GONE) {       final LayoutParams lp=(LayoutParams)child.getLayoutParams()        int childLeft=0        int childTop=0        if (lp.isDecor) {         final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK          final int vgrav=lp.gravity & Gravity.VERTICAL_GRAVITY_MASK  switch (hgrav) { default :           childLeft=paddingLeft          break  case Gravity.LEFT:       childLeft=paddingLeft      paddingLeft+=child.getMeasuredWidth()    break  case Gravity.CENTER_HORIZONTAL: childLeft=Math.max((width - child.getMeasuredWidth()) / 2,paddingLeft)  break  case Gravity.RIGHT: childLeft=width - paddingRight - child.getMeasuredWidth()  paddingRight+=child.getMeasuredWidth()  break  } switch (vgrav) { default : childTop=paddingTop  break  case Gravity.TOP: childTop=paddingTop  paddingTop+=child.getMeasuredHeight()  break  case Gravity.CENTER_VERTICAL: childTop=Math.max((height - child.getMeasuredHeight()) / 2,paddingTop)  break  case Gravity.BOTTOM: childTop=height - paddingBottom - child.getMeasuredHeight()  paddingBottom+=child.getMeasuredHeight()  break  } childLeft+=scrollX  child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + child.getMeasuredHeight())  decorCount++  } } } final int childWidth=width - paddingLeft - paddingRight  for (int i=0  i < count  i++) { final View child=getChildAt(i)  if (child.getVisibility() != GONE) { final LayoutParams lp=(LayoutParams)child.getLayoutParams()  ItemInfo ii  if (!lp.isDecor && (ii=infoForChild(child)) != null) { int loff=(int)(childWidth * ii.offset)  int childLeft=paddingLeft + loff  int childTop=paddingTop  if (lp.needsMeasure) { lp.needsMeasure=false  final int widthSpec=MeasureSpec.makeMeasureSpec((int)(childWidth * lp.widthFactor),MeasureSpec.EXACTLY)  final int heightSpec=MeasureSpec.makeMeasureSpec((int)(height - paddingTop - paddingBottom),MeasureSpec.EXACTLY)  child.measure(widthSpec,heightSpec)  } if (DEBUG) Log.v(TAG,"Positioning #" + i + " "+ child+ " f="+ ii.object+ ":"+ childLeft+ ","+ childTop+ " "+ child.getMeasuredWidth()+ "x"+ child.getMeasuredHeight())  child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + child.getMeasuredHeight())  } } } mTopPageBounds=paddingTop  mBottomPageBounds=height - paddingBottom  mDecorChildCount=decorCount  if (mFirstLayout) { scrollToItem(mCurItem,false,0,false)  } mFirstLayout=false  } 
@Override public void computeScroll(){   if (!mScroller.isFinished() && mScroller.computeScrollOffset()) {     int oldX=getScrollX()      int oldY=getScrollY()      int x=mScroller.getCurrX()      int y=mScroller.getCurrY()      if (oldX != x || oldY != y) {       scrollTo(x,y)        if (!pageScrolled(x)) {         mScroller.abortAnimation()          scrollTo(0,y)        }     }     ViewCompat.postInvalidateOnAnimation(this)      return    }   completeScroll(true)  } 
private boolean pageScrolled(int xpos){   if (mItems.size() == 0) {     mCalledSuper=false      onPageScrolled(0,0,0)      if (!mCalledSuper) {       throw new IllegalStateException("onPageScrolled did not call superclass implementation")      }     return false    }   final ItemInfo ii=infoForCurrentScrollPosition()    final int width=getClientWidth()    final int widthWithMargin=width + mPageMargin    final float marginOffset=(float)mPageMargin / width    final int currentPage=ii.position    final float pageOffset=(((float)xpos / width) - ii.offset) / (ii.widthFactor + marginOffset)    final int offsetPixels=(int)(pageOffset * widthWithMargin)    mCalledSuper=false    onPageScrolled(currentPage,pageOffset,offsetPixels)    if (!mCalledSuper) {     throw new IllegalStateException("onPageScrolled did not call superclass implementation")    }   return true  } 
/**   * This method will be invoked when the current page is scrolled, either as part of a programmatically initiated smooth scroll or a user initiated touch scroll. If you override this method you must call through to the superclass implementation (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled returns.  * @param position Position index of the first page currently being displayed.Page position+1 will be visible if positionOffset is nonzero.  * @param offset Value from [0, 1) indicating the offset from the page at position.  * @param offsetPixels Value in pixels indicating the offset from position.  */ protected void onPageScrolled(int position,float offset,int offsetPixels){   if (mDecorChildCount > 0) {     final int scrollX=getScrollX()      int paddingLeft=getPaddingLeft()      int paddingRight=getPaddingRight()      final int width=getWidth()      final int childCount=getChildCount()      for (int i=0  i < childCount  i++) {       final View child=getChildAt(i)        final LayoutParams lp=(LayoutParams)child.getLayoutParams()        if (!lp.isDecor)       continue        final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK        int childLeft=0  switch (hgrav) { default :         childLeft=paddingLeft        break  case Gravity.LEFT:     childLeft=paddingLeft    paddingLeft+=child.getWidth()  break  case Gravity.CENTER_HORIZONTAL: childLeft=Math.max((width - child.getMeasuredWidth()) / 2,paddingLeft)  break  case Gravity.RIGHT: childLeft=width - paddingRight - child.getMeasuredWidth()  paddingRight+=child.getMeasuredWidth()  break  } childLeft+=scrollX  final int childOffset=childLeft - child.getLeft()  if (childOffset != 0) { child.offsetLeftAndRight(childOffset)  } } } for (OnPageChangeListener eachListener : mOnPageChangeListeners) { if (eachListener != null) { eachListener.onPageScrolled(position,offset,offsetPixels)  } } if (mInternalPageChangeListener != null) { mInternalPageChangeListener.onPageScrolled(position,offset,offsetPixels)  } if (mPageTransformer != null) { final int scrollX=getScrollX()  final int childCount=getChildCount()  for (int i=0  i < childCount  i++) { final View child=getChildAt(i)  final LayoutParams lp=(LayoutParams)child.getLayoutParams()  if (lp.isDecor) continue  final float transformPos=(float)(child.getLeft() - scrollX) / getClientWidth()  mPageTransformer.transformPage(child,transformPos)  } } mCalledSuper=true  } 
private void completeScroll(boolean postEvents){   boolean needPopulate=mScrollState == SCROLL_STATE_SETTLING    if (needPopulate) {     setScrollingCacheEnabled(false)      mScroller.abortAnimation()      int oldX=getScrollX()      int oldY=getScrollY()      int x=mScroller.getCurrX()      int y=mScroller.getCurrY()      if (oldX != x || oldY != y) {       scrollTo(x,y)      }   }   mPopulatePending=false    for (int i=0  i < mItems.size()  i++) {     ItemInfo ii=mItems.get(i)      if (ii.scrolling) {       needPopulate=true        ii.scrolling=false      }   }   if (needPopulate) {     if (postEvents) {       ViewCompat.postOnAnimation(this,mEndScrollRunnable)      }  else {       mEndScrollRunnable.run()      }   } } 
private boolean isGutterDrag(float x,float dx){   return (x < mGutterSize && dx > 0) || (x > getWidth() - mGutterSize && dx < 0)  } 
private void enableLayers(boolean enable){   final int childCount=getChildCount()    for (int i=0  i < childCount  i++) {     final int layerType=enable ? ViewCompat.LAYER_TYPE_HARDWARE : ViewCompat.LAYER_TYPE_NONE      ViewCompat.setLayerType(getChildAt(i),layerType,null)    } } 
@Override public boolean onInterceptTouchEvent(MotionEvent ev){   final int action=ev.getAction() & MotionEventCompat.ACTION_MASK    if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {     if (DEBUG)     Log.v(TAG,"Intercept done!")      mIsBeingDragged=false      mIsUnableToDrag=false      mActivePointerId=INVALID_POINTER      if (mVelocityTracker != null) {       mVelocityTracker.recycle()        mVelocityTracker=null      }     return false    }   if (action != MotionEvent.ACTION_DOWN) {     if (mIsBeingDragged) {       if (DEBUG)       Log.v(TAG,"Intercept returning true!")        return true      }     if (mIsUnableToDrag) {       if (DEBUG)       Log.v(TAG,"Intercept returning false!")        return false      }   } switch (action) { case MotionEvent.ACTION_MOVE: {       final int activePointerId=mActivePointerId        if (activePointerId == INVALID_POINTER) {         break        }       final int pointerIndex=MotionEventCompat.findPointerIndex(ev,activePointerId)        final float x=MotionEventCompat.getX(ev,pointerIndex)        final float dx=x - mLastMotionX        final float xDiff=Math.abs(dx)        final float y=MotionEventCompat.getY(ev,pointerIndex)        final float yDiff=Math.abs(y - mInitialMotionY)        if (DEBUG)       Log.v(TAG,"Moved x to " + x + ","+ y+ " diff="+ xDiff+ ","+ yDiff)        if (dx != 0 && !isGutterDrag(mLastMotionX,dx) && canScroll(this,false,(int)dx,(int)x,(int)y)) {         mLastMotionX=x          mLastMotionY=y          mIsUnableToDrag=true          return false        }       if (xDiff > mTouchSlop && xDiff * 0.5f > yDiff) {         if (DEBUG)         Log.v(TAG,"Starting drag!")          mIsBeingDragged=true          requestParentDisallowInterceptTouchEvent(true)          setScrollState(SCROLL_STATE_DRAGGING)          mLastMotionX=dx > 0 ? mInitialMotionX + mTouchSlop : mInitialMotionX - mTouchSlop          mLastMotionY=y          setScrollingCacheEnabled(true)        }  else       if (yDiff > mTouchSlop) {         if (DEBUG)         Log.v(TAG,"Starting unable to drag!")          mIsUnableToDrag=true        }       if (mIsBeingDragged) {         if (performDrag(x)) {           ViewCompat.postInvalidateOnAnimation(this)          }       }       break      } case MotionEvent.ACTION_DOWN: {     mLastMotionX=mInitialMotionX=ev.getX()      mLastMotionY=mInitialMotionY=ev.getY()      mActivePointerId=MotionEventCompat.getPointerId(ev,0)      mIsUnableToDrag=false      mScroller.computeScrollOffset()      if (mScrollState == SCROLL_STATE_SETTLING && Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) > mCloseEnough) {       mScroller.abortAnimation()        mPopulatePending=false        populate()        mIsBeingDragged=true        requestParentDisallowInterceptTouchEvent(true)        setScrollState(SCROLL_STATE_DRAGGING)      }  else {       completeScroll(false)        mIsBeingDragged=false      }     if (DEBUG)     Log.v(TAG,"Down at " + mLastMotionX + ","+ mLastMotionY+ " mIsBeingDragged="+ mIsBeingDragged+ "mIsUnableToDrag="+ mIsUnableToDrag)      break    } case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(ev)  break  } if (mVelocityTracker == null) { mVelocityTracker=VelocityTracker.obtain()  } mVelocityTracker.addMovement(ev)  return mIsBeingDragged  } 
@Override public boolean onTouchEvent(MotionEvent ev){   if (mFakeDragging) {     return true    }   if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {     return false    }   if (mAdapter == null || mAdapter.getCount() == 0) {     return false    }   if (mVelocityTracker == null) {     mVelocityTracker=VelocityTracker.obtain()    }   mVelocityTracker.addMovement(ev)    final int action=ev.getAction()    boolean needsInvalidate=false  switch (action & MotionEventCompat.ACTION_MASK) { case MotionEvent.ACTION_DOWN: {       mScroller.abortAnimation()        mPopulatePending=false        populate()        mLastMotionX=mInitialMotionX=ev.getX()        mLastMotionY=mInitialMotionY=ev.getY()        mActivePointerId=MotionEventCompat.getPointerId(ev,0)        break      } case MotionEvent.ACTION_MOVE:   if (!mIsBeingDragged) {     final int pointerIndex=MotionEventCompat.findPointerIndex(ev,mActivePointerId)      final float x=MotionEventCompat.getX(ev,pointerIndex)      final float xDiff=Math.abs(x - mLastMotionX)      final float y=MotionEventCompat.getY(ev,pointerIndex)      final float yDiff=Math.abs(y - mLastMotionY)      if (DEBUG)     Log.v(TAG,"Moved x to " + x + ","+ y+ " diff="+ xDiff+ ","+ yDiff)      if (xDiff > mTouchSlop && xDiff > yDiff) {       if (DEBUG)       Log.v(TAG,"Starting drag!")        mIsBeingDragged=true        requestParentDisallowInterceptTouchEvent(true)        mLastMotionX=x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop : mInitialMotionX - mTouchSlop        mLastMotionY=y        setScrollState(SCROLL_STATE_DRAGGING)        setScrollingCacheEnabled(true)        ViewParent parent=getParent()        if (parent != null) {         parent.requestDisallowInterceptTouchEvent(true)        }     }   } if (mIsBeingDragged) {   final int activePointerIndex=MotionEventCompat.findPointerIndex(ev,mActivePointerId)    final float x=MotionEventCompat.getX(ev,activePointerIndex)    needsInvalidate|=performDrag(x)  } break  case MotionEvent.ACTION_UP: if (mIsBeingDragged) { final VelocityTracker velocityTracker=mVelocityTracker  velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity)  int initialVelocity=(int)VelocityTrackerCompat.getXVelocity(velocityTracker,mActivePointerId)  mPopulatePending=true  final int width=getClientWidth()  final int scrollX=getScrollX()  final ItemInfo ii=infoForCurrentScrollPosition()  final int currentPage=ii.position  final float pageOffset=(((float)scrollX / width) - ii.offset) / ii.widthFactor  final int activePointerIndex=MotionEventCompat.findPointerIndex(ev,mActivePointerId)  final float x=MotionEventCompat.getX(ev,activePointerIndex)  final int totalDelta=(int)(x - mInitialMotionX)  int nextPage=determineTargetPage(currentPage,pageOffset,initialVelocity,totalDelta)  setCurrentItemInternal(nextPage,true,true,initialVelocity)  mActivePointerId=INVALID_POINTER  endDrag()  needsInvalidate=mLeftEdge.onRelease() | mRightEdge.onRelease()  } break  case MotionEvent.ACTION_CANCEL: if (mIsBeingDragged) { scrollToItem(mCurItem,true,0,false)  mActivePointerId=INVALID_POINTER  endDrag()  needsInvalidate=mLeftEdge.onRelease() | mRightEdge.onRelease()  } break  case MotionEventCompat.ACTION_POINTER_DOWN: { final int index=MotionEventCompat.getActionIndex(ev)  final float x=MotionEventCompat.getX(ev,index)  mLastMotionX=x  mActivePointerId=MotionEventCompat.getPointerId(ev,index)  break  } case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(ev)  mLastMotionX=MotionEventCompat.getX(ev,MotionEventCompat.findPointerIndex(ev,mActivePointerId))  break  } if (needsInvalidate) { ViewCompat.postInvalidateOnAnimation(this)  } return true  } 
private void requestParentDisallowInterceptTouchEvent(boolean disallowIntercept){   final ViewParent parent=getParent()    if (parent != null) {     parent.requestDisallowInterceptTouchEvent(disallowIntercept)    } } 
private boolean performDrag(float x){   boolean needsInvalidate=false    final float deltaX=mLastMotionX - x    mLastMotionX=x    float oldScrollX=getScrollX()    float scrollX=oldScrollX + deltaX    final int width=getClientWidth()    float leftBound=width * mFirstOffset    float rightBound=width * mLastOffset    boolean leftAbsolute=true    boolean rightAbsolute=true    final ItemInfo firstItem=mItems.get(0)    final ItemInfo lastItem=mItems.get(mItems.size() - 1)    if (firstItem.position != 0) {     leftAbsolute=false      leftBound=firstItem.offset * width    }   if (lastItem.position != mAdapter.getCount() - 1) {     rightAbsolute=false      rightBound=lastItem.offset * width    }   if (scrollX < leftBound) {     if (leftAbsolute) {       float over=leftBound - scrollX        needsInvalidate=mLeftEdge.onPull(Math.abs(over) / width)      }     scrollX=leftBound    }  else   if (scrollX > rightBound) {     if (rightAbsolute) {       float over=scrollX - rightBound        needsInvalidate=mRightEdge.onPull(Math.abs(over) / width)      }     scrollX=rightBound    }   mLastMotionX+=scrollX - (int)scrollX    scrollTo((int)scrollX,getScrollY())    pageScrolled((int)scrollX)    return needsInvalidate  } 
/**   * @return Info about the page at the current scroll position.This can be synthetic for a missing middle page  the 'object' field can be null.  */ private ItemInfo infoForCurrentScrollPosition(){   final int width=getClientWidth()    final float scrollOffset=width > 0 ? (float)getScrollX() / width : 0    final float marginOffset=width > 0 ? (float)mPageMargin / width : 0    int lastPos=-1    float lastOffset=0.f    float lastWidth=0.f    boolean first=true    ItemInfo lastItem=null    for (int i=0  i < mItems.size()  i++) {     ItemInfo ii=mItems.get(i)      float offset      if (!first && ii.position != lastPos + 1) {       ii=mTempItem        ii.offset=lastOffset + lastWidth + marginOffset        ii.position=lastPos + 1        ii.widthFactor=mAdapter.getPageWidth(ii.position)        i--      }     offset=ii.offset      final float leftBound=offset      final float rightBound=offset + ii.widthFactor + marginOffset      if (first || scrollOffset >= leftBound) {       if (scrollOffset < rightBound || i == mItems.size() - 1) {         return ii        }     }  else {       return lastItem      }     first=false      lastPos=ii.position      lastOffset=offset      lastWidth=ii.widthFactor      lastItem=ii    }   return lastItem  } 
private int determineTargetPage(int currentPage,float pageOffset,int velocity,int deltaX){   int targetPage    if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {     targetPage=velocity > 0 ? currentPage : currentPage + 1    }  else {     final float truncator=currentPage >= mCurItem ? 0.4f : 0.6f      targetPage=(int)(currentPage + pageOffset + truncator)    }   if (mItems.size() > 0) {     final ItemInfo firstItem=mItems.get(0)      final ItemInfo lastItem=mItems.get(mItems.size() - 1)      targetPage=Math.max(firstItem.position,Math.min(targetPage,lastItem.position))    }   return targetPage  } 
@Override public void draw(Canvas canvas){   super.draw(canvas)    boolean needsInvalidate=false    final int overScrollMode=ViewCompat.getOverScrollMode(this)    if (overScrollMode == ViewCompat.OVER_SCROLL_ALWAYS || (overScrollMode == ViewCompat.OVER_SCROLL_IF_CONTENT_SCROLLS && mAdapter != null && mAdapter.getCount() > 1)) {     if (!mLeftEdge.isFinished()) {       final int restoreCount=canvas.save()        final int height=getHeight() - getPaddingTop() - getPaddingBottom()        final int width=getWidth()        canvas.rotate(270)        canvas.translate(-height + getPaddingTop(),mFirstOffset * width)        mLeftEdge.setSize(height,width)        needsInvalidate|=mLeftEdge.draw(canvas)        canvas.restoreToCount(restoreCount)      }     if (!mRightEdge.isFinished()) {       final int restoreCount=canvas.save()        final int width=getWidth()        final int height=getHeight() - getPaddingTop() - getPaddingBottom()        canvas.rotate(90)        canvas.translate(-getPaddingTop(),-(mLastOffset + 1) * width)        mRightEdge.setSize(height,width)        needsInvalidate|=mRightEdge.draw(canvas)        canvas.restoreToCount(restoreCount)      }   }  else {     mLeftEdge.finish()      mRightEdge.finish()    }   if (needsInvalidate) {     ViewCompat.postInvalidateOnAnimation(this)    } } 
@Override protected void onDraw(Canvas canvas){   super.onDraw(canvas)    if (mPageMargin > 0 && mMarginDrawable != null && mItems.size() > 0 && mAdapter != null) {     final int scrollX=getScrollX()      final int width=getWidth()      final float marginOffset=(float)mPageMargin / width      int itemIndex=0      ItemInfo ii=mItems.get(0)      float offset=ii.offset      final int itemCount=mItems.size()      final int firstPos=ii.position      final int lastPos=mItems.get(itemCount - 1).position      for (int pos=firstPos  pos < lastPos  pos++) {       while (pos > ii.position && itemIndex < itemCount) {         ii=mItems.get(++itemIndex)        }       float drawAt        if (pos == ii.position) {         drawAt=(ii.offset + ii.widthFactor) * width          offset=ii.offset + ii.widthFactor + marginOffset        }  else {         float widthFactor=mAdapter.getPageWidth(pos)          drawAt=(offset + widthFactor) * width          offset+=widthFactor + marginOffset        }       if (drawAt + mPageMargin > scrollX) {         mMarginDrawable.setBounds((int)drawAt,mTopPageBounds,(int)(drawAt + mPageMargin + 0.5f),mBottomPageBounds)          mMarginDrawable.draw(canvas)        }       if (drawAt > scrollX + width) {         break        }     }   } } 
/**   * Start a fake drag of the pager. <p>A fake drag can be useful if you want to synchronize the motion of the ViewPager with the touch scrolling of another view, while still letting the ViewPager control the snapping motion and fling behavior. (e.g. parallax-scrolling tabs.) Call  {@link #fakeDragBy(float)} to simulate the actual drag motion. Call{@link #endFakeDrag()} to complete the fake drag and fling as necessary.<p>During a fake drag the ViewPager will ignore all touch events. If a real drag is already in progress, this method will return false.  * @return true if the fake drag began successfully, false if it could not be started.  * @see #fakeDragBy(float)  * @see #endFakeDrag()  */ public boolean beginFakeDrag(){   if (mIsBeingDragged) {     return false    }   mFakeDragging=true    setScrollState(SCROLL_STATE_DRAGGING)    mInitialMotionX=mLastMotionX=0    if (mVelocityTracker == null) {     mVelocityTracker=VelocityTracker.obtain()    }  else {     mVelocityTracker.clear()    }   final long time=SystemClock.uptimeMillis()    final MotionEvent ev=MotionEvent.obtain(time,time,MotionEvent.ACTION_DOWN,0,0,0)    mVelocityTracker.addMovement(ev)    ev.recycle()    mFakeDragBeginTime=time    return true  } 
/**   * End a fake drag of the pager.  * @see #beginFakeDrag()  * @see #fakeDragBy(float)  */ public void endFakeDrag(){   if (!mFakeDragging) {     throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.")    }   final VelocityTracker velocityTracker=mVelocityTracker    velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity)    int initialVelocity=(int)VelocityTrackerCompat.getXVelocity(velocityTracker,mActivePointerId)    mPopulatePending=true    final int width=getClientWidth()    final int scrollX=getScrollX()    final ItemInfo ii=infoForCurrentScrollPosition()    final int currentPage=ii.position    final float pageOffset=(((float)scrollX / width) - ii.offset) / ii.widthFactor    final int totalDelta=(int)(mLastMotionX - mInitialMotionX)    int nextPage=determineTargetPage(currentPage,pageOffset,initialVelocity,totalDelta)    setCurrentItemInternal(nextPage,true,true,initialVelocity)    endDrag()    mFakeDragging=false  } 
/**   * Fake drag by an offset in pixels. You must have called  {@link #beginFakeDrag()} first.  * @param xOffset Offset in pixels to drag by.  * @see #beginFakeDrag()  * @see #endFakeDrag()  */ public void fakeDragBy(float xOffset){   if (!mFakeDragging) {     throw new IllegalStateException("No fake drag in progress. Call beginFakeDrag first.")    }   mLastMotionX+=xOffset    float oldScrollX=getScrollX()    float scrollX=oldScrollX - xOffset    final int width=getClientWidth()    float leftBound=width * mFirstOffset    float rightBound=width * mLastOffset    final ItemInfo firstItem=mItems.get(0)    final ItemInfo lastItem=mItems.get(mItems.size() - 1)    if (firstItem.position != 0) {     leftBound=firstItem.offset * width    }   if (lastItem.position != mAdapter.getCount() - 1) {     rightBound=lastItem.offset * width    }   if (scrollX < leftBound) {     scrollX=leftBound    }  else   if (scrollX > rightBound) {     scrollX=rightBound    }   mLastMotionX+=scrollX - (int)scrollX    scrollTo((int)scrollX,getScrollY())    pageScrolled((int)scrollX)    final long time=SystemClock.uptimeMillis()    final MotionEvent ev=MotionEvent.obtain(mFakeDragBeginTime,time,MotionEvent.ACTION_MOVE,mLastMotionX,0,0)    mVelocityTracker.addMovement(ev)    ev.recycle()  } 
/**   * Returns true if a fake drag is in progress.  * @return true if currently in a fake drag, false otherwise.  * @see #beginFakeDrag()  * @see #fakeDragBy(float)  * @see #endFakeDrag()  */ public boolean isFakeDragging(){   return mFakeDragging  } 
private void onSecondaryPointerUp(MotionEvent ev){   final int pointerIndex=MotionEventCompat.getActionIndex(ev)    final int pointerId=MotionEventCompat.getPointerId(ev,pointerIndex)    if (pointerId == mActivePointerId) {     final int newPointerIndex=pointerIndex == 0 ? 1 : 0      mLastMotionX=MotionEventCompat.getX(ev,newPointerIndex)      mActivePointerId=MotionEventCompat.getPointerId(ev,newPointerIndex)      if (mVelocityTracker != null) {       mVelocityTracker.clear()      }   } } 
private void endDrag(){   mIsBeingDragged=false    mIsUnableToDrag=false    if (mVelocityTracker != null) {     mVelocityTracker.recycle()      mVelocityTracker=null    } } 
private void setScrollingCacheEnabled(boolean enabled){   if (mScrollingCacheEnabled != enabled) {     mScrollingCacheEnabled=enabled      if (USE_CACHE) {       final int size=getChildCount()        for (int i=0  i < size  ++i) {         final View child=getChildAt(i)          if (child.getVisibility() != GONE) {           child.setDrawingCacheEnabled(enabled)          }       }     }   } } 
public boolean canScrollHorizontally(int direction){   if (mAdapter == null) {     return false    }   final int width=getClientWidth()    final int scrollX=getScrollX()    if (direction < 0) {     return (scrollX > (int)(width * mFirstOffset))    }  else   if (direction > 0) {     return (scrollX < (int)(width * mLastOffset))    }  else {     return false    } } 
/**   * Tests scrollability within child views of v given a delta of dx.  * @param v View to test for horizontal scrollability  * @param checkV Whether the view v passed should itself be checked for scrollability (true),or just its children (false).  * @param dx Delta scrolled in pixels  * @param x X coordinate of the active touch point  * @param y Y coordinate of the active touch point  * @return true if child views of v can be scrolled by delta of dx.  */ protected boolean canScroll(View v,boolean checkV,int dx,int x,int y){   if (v instanceof ViewGroup) {     final ViewGroup group=(ViewGroup)v      final int scrollX=v.getScrollX()      final int scrollY=v.getScrollY()      final int count=group.getChildCount()      for (int i=count - 1  i >= 0  i--) {       final View child=group.getChildAt(i)        if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child,true,dx,x + scrollX - child.getLeft(),y + scrollY - child.getTop())) {         return true        }     }   }   return checkV && ViewCompat.canScrollHorizontally(v,-dx)  } 
@Override public boolean dispatchKeyEvent(KeyEvent event){   return super.dispatchKeyEvent(event) || executeKeyEvent(event)  } 
/**   * You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.  * @param event The key event to execute.  * @return Return true if the event was handled, else false.  */ public boolean executeKeyEvent(KeyEvent event){   boolean handled=false    if (event.getAction() == KeyEvent.ACTION_DOWN) { switch (event.getKeyCode()) { case KeyEvent.KEYCODE_DPAD_LEFT:       handled=arrowScroll(FOCUS_LEFT)      break  case KeyEvent.KEYCODE_DPAD_RIGHT:   handled=arrowScroll(FOCUS_RIGHT)  break  case KeyEvent.KEYCODE_TAB: if (Build.VERSION.SDK_INT >= 11) { if (KeyEventCompat.hasNoModifiers(event)) {   handled=arrowScroll(FOCUS_FORWARD)  }  else if (KeyEventCompat.hasModifiers(event,KeyEvent.META_SHIFT_ON)) {   handled=arrowScroll(FOCUS_BACKWARD)  } } break  } } return handled  } 
public boolean arrowScroll(int direction){   View currentFocused=findFocus()    if (currentFocused == this) {     currentFocused=null    }  else   if (currentFocused != null) {     boolean isChild=false      for (ViewParent parent=currentFocused.getParent()  parent instanceof ViewGroup  parent=parent.getParent()) {       if (parent == this) {         isChild=true          break        }     }     if (!isChild) {       final StringBuilder sb=new StringBuilder()        sb.append(currentFocused.getClass().getSimpleName())        for (ViewParent parent=currentFocused.getParent()  parent instanceof ViewGroup  parent=parent.getParent()) {         sb.append(" => ").append(parent.getClass().getSimpleName())        }       Log.e(TAG,"arrowScroll tried to find focus based on non-child " + "current focused view " + sb.toString())        currentFocused=null      }   }   boolean handled=false    View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction)    if (nextFocused != null && nextFocused != currentFocused) {     if (direction == View.FOCUS_LEFT) {       final int nextLeft=getChildRectInPagerCoordinates(mTempRect,nextFocused).left        final int currLeft=getChildRectInPagerCoordinates(mTempRect,currentFocused).left        if (currentFocused != null && nextLeft >= currLeft) {         handled=pageLeft()        }  else {         handled=nextFocused.requestFocus()        }     }  else     if (direction == View.FOCUS_RIGHT) {       final int nextLeft=getChildRectInPagerCoordinates(mTempRect,nextFocused).left        final int currLeft=getChildRectInPagerCoordinates(mTempRect,currentFocused).left        if (currentFocused != null && nextLeft <= currLeft) {         handled=pageRight()        }  else {         handled=nextFocused.requestFocus()        }     }   }  else   if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {     handled=pageLeft()    }  else   if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {     handled=pageRight()    }   if (handled) {     playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction))    }   return handled  } 
private Rect getChildRectInPagerCoordinates(Rect outRect,View child){   if (outRect == null) {     outRect=new Rect()    }   if (child == null) {     outRect.set(0,0,0,0)      return outRect    }   outRect.left=child.getLeft()    outRect.right=child.getRight()    outRect.top=child.getTop()    outRect.bottom=child.getBottom()    ViewParent parent=child.getParent()    while (parent instanceof ViewGroup && parent != this) {     final ViewGroup group=(ViewGroup)parent      outRect.left+=group.getLeft()      outRect.right+=group.getRight()      outRect.top+=group.getTop()      outRect.bottom+=group.getBottom()      parent=group.getParent()    }   return outRect  } 
boolean pageLeft(){   if (mCurItem > 0) {     setCurrentItem(mCurItem - 1,true)      return true    }   return false  } 
boolean pageRight(){   if (mAdapter != null && mCurItem < (mAdapter.getCount() - 1)) {     setCurrentItem(mCurItem + 1,true)      return true    }   return false  } 
/**   * We only want the current page that is being shown to be focusable.  */ @Override public void addFocusables(ArrayList<View> views,int direction,int focusableMode){   final int focusableCount=views.size()    final int descendantFocusability=getDescendantFocusability()    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {     for (int i=0  i < getChildCount()  i++) {       final View child=getChildAt(i)        if (child.getVisibility() == VISIBLE) {         ItemInfo ii=infoForChild(child)          if (ii != null && ii.position == mCurItem) {           child.addFocusables(views,direction,focusableMode)          }       }     }   }   if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {     if (!isFocusable()) {       return      }     if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {       return      }     if (views != null) {       views.add(this)      }   } } 
/**   * We only want the current page that is being shown to be touchable.  */ @Override public void addTouchables(ArrayList<View> views){   for (int i=0  i < getChildCount()  i++) {     final View child=getChildAt(i)      if (child.getVisibility() == VISIBLE) {       ItemInfo ii=infoForChild(child)        if (ii != null && ii.position == mCurItem) {         child.addTouchables(views)        }     }   } } 
/**   * We only want the current page that is being shown to be focusable.  */ @Override protected boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){   int index    int increment    int end    int count=getChildCount()    if ((direction & FOCUS_FORWARD) != 0) {     index=0      increment=1      end=count    }  else {     index=count - 1      increment=-1      end=-1    }   for (int i=index  i != end  i+=increment) {     View child=getChildAt(i)      if (child.getVisibility() == VISIBLE) {       ItemInfo ii=infoForChild(child)        if (ii != null && ii.position == mCurItem) {         if (child.requestFocus(direction,previouslyFocusedRect)) {           return true          }       }     }   }   return false  } 
@Override public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event){   if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED) {     return super.dispatchPopulateAccessibilityEvent(event)    }   final int childCount=getChildCount()    for (int i=0  i < childCount  i++) {     final View child=getChildAt(i)      if (child.getVisibility() == VISIBLE) {       final ItemInfo ii=infoForChild(child)        if (ii != null && ii.position == mCurItem && child.dispatchPopulateAccessibilityEvent(event)) {         return true        }     }   }   return false  } 
@Override protected ViewGroup.LayoutParams generateDefaultLayoutParams(){   return new LayoutParams()  } 
@Override protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p){   return generateDefaultLayoutParams()  } 
@Override protected boolean checkLayoutParams(ViewGroup.LayoutParams p){   return p instanceof LayoutParams && super.checkLayoutParams(p)  } 
@Override public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs){   return new LayoutParams(getContext(),attrs)  } 
@Override public void onInitializeAccessibilityEvent(View host,AccessibilityEvent event){   super.onInitializeAccessibilityEvent(host,event)    event.setClassName(ViewPagerEx.class.getName())    final AccessibilityRecordCompat recordCompat=AccessibilityRecordCompat.obtain()    recordCompat.setScrollable(canScroll())    if (event.getEventType() == AccessibilityEventCompat.TYPE_VIEW_SCROLLED && mAdapter != null) {     recordCompat.setItemCount(mAdapter.getCount())      recordCompat.setFromIndex(mCurItem)      recordCompat.setToIndex(mCurItem)    } } 
@Override public void onInitializeAccessibilityNodeInfo(View host,AccessibilityNodeInfoCompat info){   super.onInitializeAccessibilityNodeInfo(host,info)    info.setClassName(ViewPagerEx.class.getName())    info.setScrollable(canScroll())    if (canScrollHorizontally(1)) {     info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD)    }   if (canScrollHorizontally(-1)) {     info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD)    } } 
@Override public boolean performAccessibilityAction(View host,int action,Bundle args){   if (super.performAccessibilityAction(host,action,args)) {     return true    } switch (action) { case AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD: {       if (canScrollHorizontally(1)) {         setCurrentItem(mCurItem + 1)          return true        }     }   return false  case AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD: {   if (canScrollHorizontally(-1)) {     setCurrentItem(mCurItem - 1)      return true    } } return false  } return false  } 
private boolean canScroll(){   return (mAdapter != null) && (mAdapter.getCount() > 1)  } 
@Override public void onChanged(){   dataSetChanged()  } 
@Override public void onInvalidated(){   dataSetChanged()  } 
public LayoutParams(){   super(FILL_PARENT,FILL_PARENT)  } 
public LayoutParams(Context context,AttributeSet attrs){   super(context,attrs)    final TypedArray a=context.obtainStyledAttributes(attrs,LAYOUT_ATTRS)    gravity=a.getInteger(0,Gravity.TOP)    a.recycle()  } 
@Override public int compare(View lhs,View rhs){   final LayoutParams llp=(LayoutParams)lhs.getLayoutParams()    final LayoutParams rlp=(LayoutParams)rhs.getLayoutParams()    if (llp.isDecor != rlp.isDecor) {     return llp.isDecor ? 1 : -1    }   return llp.position - rlp.position  } 
@Override public AppComponent createComponent(){   return DaggerTestComponent.builder().testModule(new TestModule()).build()  } 
public static TestComponent component(){   return (TestComponent)App.component()  } 
@Override public void installLeakCanary(){ } 
public static PassStore getPassStore(){   return component().passStore()  } 
public static void reset(){   setComponent(DaggerTestComponent.builder().testModule(new TestModule()).build())  } 
@Before public void setUp() throws Exception {   MockitoAnnotations.initMocks(this)  } 
@Test public void testShouldFailForBrokenPass(){   try {     final InputStream inputStream=InstrumentationRegistry.getInstrumentation().getContext().getResources().getAssets().open("passes/broken/fail.pkpass")      final InputStreamWithSource inputStreamWithSource=new InputStreamWithSource("none",inputStream)      final InputStreamUnzipControllerSpec spec=new InputStreamUnzipControllerSpec(inputStreamWithSource,InstrumentationRegistry.getInstrumentation().getTargetContext(),passStore,successCallback,failCallback)      UnzipPassController.INSTANCE.processInputStream(spec)      verify(successCallback,never()).call(any(String.class))      verify(failCallback).fail(any(String.class))    }  catch (  Exception e) {     fail("should be able to load file")    } } 
/**   * Constructor  * @stable ICU 3.4  */ public CharsetDetector(){ } 
/**   * Set the declared encoding for charset detection. The declared encoding of an input text is an encoding obtained from an http header or xml declaration or similar source that can be provided as additional information to the charset detector.   A match between a declared encoding and a possible detected encoding will raise the quality of that detected encoding by a small delta, and will also appear as a "reason" for the match. <p/> A declared encoding that is incompatible with the input data being analyzed will not be added to the list of possible encodings.  * @param encoding The declared encoding   * @stable ICU 3.4  */ public CharsetDetector setDeclaredEncoding(String encoding){   fDeclaredEncoding=encoding    return this  } 
/**   * Set the input text (byte) data whose charset is to be detected.  * @param in the input text of unknown encoding  * @return This CharsetDetector  * @stable ICU 3.4  */ public CharsetDetector setText(byte[] in){   fRawInput=in    fRawLength=in.length    return this  } 
/**   * Set the input text (byte) data whose charset is to be detected. <p/> The input stream that supplies the character data must have markSupported() == true  the charset detection process will read a small amount of data, then return the stream to its original position via the InputStream.reset() operation.  The exact amount that will be read depends on the characteristics of the data itself.  * @param in the input text of unknown encoding  * @return This CharsetDetector  * @stable ICU 3.4  */ public CharsetDetector setText(InputStream in) throws IOException {   fInputStream=in    fInputStream.mark(kBufSize)    fRawInput=new byte[kBufSize]    fRawLength=0    int remainingLength=kBufSize    while (remainingLength > 0) {     int bytesRead=fInputStream.read(fRawInput,fRawLength,remainingLength)      if (bytesRead <= 0) {       break      }     fRawLength+=bytesRead      remainingLength-=bytesRead    }   fInputStream.reset()    return this  } 
/**   * Return the charset that best matches the supplied input data. Note though, that because the detection  only looks at the start of the input data, there is a possibility that the returned charset will fail to handle the full set of input data. <p/> Raise an exception if  <ul> <li>no charset appears to match the data.</li> <li>no input text has been provided</li> </ul>  * @return a CharsetMatch object representing the best matching charset, or<code>null</code> if there are no matches.  * @stable ICU 3.4  */ public CharsetMatch detect(){   CharsetMatch matches[]=detectAll()    if (matches == null || matches.length == 0) {     return null    }   return matches[0]  } 
/**   * Return an array of all charsets that appear to be plausible matches with the input data.  The array is ordered with the best quality match first. <p/> Raise an exception if  <ul> <li>no charsets appear to match the input data.</li> <li>no input text has been provided</li> </ul>  * @return An array of CharsetMatch objects representing possibly matching charsets.  * @stable ICU 3.4  */ public CharsetMatch[] detectAll(){   ArrayList<CharsetMatch> matches=new ArrayList<CharsetMatch>()    MungeInput()    for (int i=0  i < ALL_CS_RECOGNIZERS.size()  i++) {     CSRecognizerInfo rcinfo=ALL_CS_RECOGNIZERS.get(i)      boolean active=(fEnabledRecognizers != null) ? fEnabledRecognizers[i] : rcinfo.isDefaultEnabled      if (active) {       CharsetMatch m=rcinfo.recognizer.match(this)        if (m != null) {         matches.add(m)        }     }   }   Collections.sort(matches)    Collections.reverse(matches)    CharsetMatch[] resultArray=new CharsetMatch[matches.size()]    resultArray=matches.toArray(resultArray)    return resultArray  } 
/**   * Autodetect the charset of an inputStream, and return a Java Reader to access the converted input data. <p/> This is a convenience method that is equivalent to <code>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getReader() </code> <p/> For the input stream that supplies the character data, markSupported() must be true  the  charset detection will read a small amount of data, then return the stream to its original position via the InputStream.reset() operation.  The exact amount that will be read depends on the characteristics of the data itself. <p/> Raise an exception if no charsets appear to match the input data.  * @param in The source of the byte data in the unknown charset.  * @param declaredEncoding  A declared encoding for the data, if available,or null or an navigation_drawer_header string if none is available.  * @stable ICU 3.4  */ public Reader getReader(InputStream in,String declaredEncoding){   fDeclaredEncoding=declaredEncoding    try {     setText(in)      CharsetMatch match=detect()      if (match == null) {       return null      }     return match.getReader()    }  catch (  IOException e) {     return null    } } 
/**   * Autodetect the charset of an inputStream, and return a String containing the converted input data. <p/> This is a convenience method that is equivalent to <code>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getString() </code> <p/> Raise an exception if no charsets appear to match the input data.  * @param in The source of the byte data in the unknown charset.  * @param declaredEncoding  A declared encoding for the data, if available,or null or an navigation_drawer_header string if none is available.  * @stable ICU 3.4  */ public String getString(byte[] in,String declaredEncoding){   fDeclaredEncoding=declaredEncoding    try {     setText(in)      CharsetMatch match=detect()      if (match == null) {       return null      }     return match.getString(-1)    }  catch (  IOException e) {     return null    } } 
/**   * Get the names of all charsets supported by <code>CharsetDetector</code> class. <p> <b>Note:</b> Multiple different charset encodings in a same family may use a single shared name in this implementation. For example, this method returns an array including "ISO-8859-1" (ISO Latin 1), but not including "windows-1252" (Windows Latin 1). However, actual detection result could be "windows-1252" when the input data matches Latin 1 code points with any points only available in "windows-1252".  * @return an array of the names of all charsets supported by<code>CharsetDetector</code> class.  * @stable ICU 3.4  */ public static String[] getAllDetectableCharsets(){   String[] allCharsetNames=new String[ALL_CS_RECOGNIZERS.size()]    for (int i=0  i < allCharsetNames.length  i++) {     allCharsetNames[i]=ALL_CS_RECOGNIZERS.get(i).recognizer.getName()    }   return allCharsetNames  } 
/**   * Test whether or not input filtering is enabled.  * @return <code>true</code> if input text will be filtered.  * @see #enableInputFilter  * @stable ICU 3.4  */ public boolean inputFilterEnabled(){   return fStripTags  } 
/**   * Enable filtering of input text. If filtering is enabled, text within angle brackets ("<" and ">") will be removed before detection.  * @param filter <code>true</code> to enable input text filtering.  * @return The previous setting.  * @stable ICU 3.4  */ public boolean enableInputFilter(boolean filter){   boolean previous=fStripTags    fStripTags=filter    return previous  } 
private void MungeInput(){   int srci=0    int dsti=0    byte b    boolean inMarkup=false    int openTags=0    int badTags=0    if (fStripTags) {     for (srci=0  srci < fRawLength && dsti < fInputBytes.length  srci++) {       b=fRawInput[srci]        if (b == (byte)'<') {         if (inMarkup) {           badTags++          }         inMarkup=true          openTags++        }       if (!inMarkup) {         fInputBytes[dsti++]=b        }       if (b == (byte)'>') {         inMarkup=false        }     }     fInputLen=dsti    }   if (openTags < 5 || openTags / 5 < badTags || (fInputLen < 100 && fRawLength > 600)) {     int limit=fRawLength      if (limit > kBufSize) {       limit=kBufSize      }     for (srci=0  srci < limit  srci++) {       fInputBytes[srci]=fRawInput[srci]      }     fInputLen=srci    }   Arrays.fill(fByteStats,(short)0)    for (srci=0  srci < fInputLen  srci++) {     int val=fInputBytes[srci] & 0x00ff      fByteStats[val]++    }   fC1Bytes=false    for (int i=0x80  i <= 0x9F  i+=1) {     if (fByteStats[i] != 0) {       fC1Bytes=true        break      }   } } 
CSRecognizerInfo(CharsetRecognizer recognizer,boolean isDefaultEnabled){   this.recognizer=recognizer    this.isDefaultEnabled=isDefaultEnabled  } 
/**   * Get the names of charsets that can be recognized by this CharsetDetector instance.  * @return an array of the names of charsets that can be recognized by this CharsetDetectorinstance.  * @internal  * @deprecated This API is ICU internal only.  */ @Deprecated public String[] getDetectableCharsets(){   List<String> csnames=new ArrayList<String>(ALL_CS_RECOGNIZERS.size())    for (int i=0  i < ALL_CS_RECOGNIZERS.size()  i++) {     CSRecognizerInfo rcinfo=ALL_CS_RECOGNIZERS.get(i)      boolean active=(fEnabledRecognizers == null) ? rcinfo.isDefaultEnabled : fEnabledRecognizers[i]      if (active) {       csnames.add(rcinfo.recognizer.getName())      }   }   return csnames.toArray(new String[csnames.size()])  } 
/**   * Enable or disable individual charset encoding. A name of charset encoding must be included in the names returned by {@link #getAllDetectableCharsets()}.  * @param encoding the name of charset encoding.  * @param enabled <code>true</code> to enable, or <code>false</code> to disable thecharset encoding.  * @return A reference to this <code>CharsetDetector</code>.  * @throws IllegalArgumentException when the name of charset encoding isnot supported.  * @internal  * @deprecated This API is ICU internal only.  */ @Deprecated public CharsetDetector setDetectableCharset(String encoding,boolean enabled){   int modIdx=-1    boolean isDefaultVal=false    for (int i=0  i < ALL_CS_RECOGNIZERS.size()  i++) {     CSRecognizerInfo csrinfo=ALL_CS_RECOGNIZERS.get(i)      if (csrinfo.recognizer.getName().equals(encoding)) {       modIdx=i        isDefaultVal=(csrinfo.isDefaultEnabled == enabled)        break      }   }   if (modIdx < 0) {     throw new IllegalArgumentException("Invalid encoding: " + "\"" + encoding + "\"")    }   if (fEnabledRecognizers == null && !isDefaultVal) {     fEnabledRecognizers=new boolean[ALL_CS_RECOGNIZERS.size()]      for (int i=0  i < ALL_CS_RECOGNIZERS.size()  i++) {       fEnabledRecognizers[i]=ALL_CS_RECOGNIZERS.get(i).isDefaultEnabled      }   }   if (fEnabledRecognizers != null) {     fEnabledRecognizers[modIdx]=enabled    }   return this  } 
/**   * Create a java.io.Reader for reading the Unicode character data corresponding to the original byte data supplied to the Charset detect operation. <p/> CAUTION:  if the source of the byte data was an InputStream, a Reader can be created for only one matching char set using this method.  If more  than one charset needs to be tried, the caller will need to reset the InputStream and create InputStreamReaders itself, based on the charset name.  * @return the Reader for the Unicode character data.  * @stable ICU 3.4  */ public Reader getReader(){   InputStream inputStream=fInputStream    if (inputStream == null) {     inputStream=new ByteArrayInputStream(fRawInput,0,fRawLength)    }   try {     inputStream.reset()      return new InputStreamReader(inputStream,getName())    }  catch (  IOException e) {     return null    } } 
/**   * Create a Java String from Unicode character data corresponding to the original byte data supplied to the Charset detect operation.  * @return a String created from the converted input data.  * @stable ICU 3.4  */ public String getString() throws java.io.IOException {   return getString(-1)  } 
/**   * Create a Java String from Unicode character data corresponding to the original byte data supplied to the Charset detect operation. The length of the returned string is limited to the specified size  the string will be trunctated to this length if necessary.  A limit value of zero or less is ignored, and treated as no limit.  * @param maxLength The maximium length of the String to be created when thesource of the data is an input stream, or -1 for unlimited length.  * @return a String created from the converted input data.  * @stable ICU 3.4  */ public String getString(int maxLength) throws java.io.IOException {   String result=null    if (fInputStream != null) {     StringBuilder sb=new StringBuilder()      char[] buffer=new char[1024]      Reader reader=getReader()      int max=maxLength < 0 ? Integer.MAX_VALUE : maxLength      int bytesRead=0      while ((bytesRead=reader.read(buffer,0,Math.min(max,1024))) >= 0) {       sb.append(buffer,0,bytesRead)        max-=bytesRead      }     reader.close()      return sb.toString()    }  else {     String name=getName()      int startSuffix=name.indexOf("_rtl") < 0 ? name.indexOf("_ltr") : name.indexOf("_rtl")      if (startSuffix > 0) {       name=name.substring(0,startSuffix)      }     result=new String(fRawInput,name)    }   return result  } 
/**   * Get an indication of the confidence in the charset detected. Confidence values range from 0-100, with larger numbers indicating a better match of the input data to the characteristics of the charset.  * @return the confidence in the charset match  * @stable ICU 3.4  */ public int getConfidence(){   return fConfidence  } 
/**   * Get the name of the detected charset.   The name will be one that can be used with other APIs on the platform that accept charset names.  It is the "Canonical name" as defined by the class java.nio.charset.Charset  for charsets that are registered with the IANA charset registry, this is the MIME-preferred registerd name.  * @see java.nio.charset.Charset  * @see java.io.InputStreamReader  * @return The name of the charset.  * @stable ICU 3.4  */ public String getName(){   return fCharsetName  } 
/**   * Get the ISO code for the language of the detected charset.    * @return The ISO code for the language or <code>null</code> if the language cannot be determined.  * @stable ICU 3.4  */ public String getLanguage(){   return fLang  } 
/**   * Compare to other CharsetMatch objects. Comparison is based on the match confidence value, which  allows CharsetDetector.detectAll() to order its results.   * @param other the CharsetMatch object to compare against.  * @return  a negative integer, zero, or a positive integer as the confidence level of this CharsetMatch is less than, equal to, or greater than that of the argument.  * @throws ClassCastException if the argument is not a CharsetMatch.  * @stable ICU 4.4  */ public int compareTo(CharsetMatch other){   int compareResult=0    if (this.fConfidence > other.fConfidence) {     compareResult=1    }  else   if (this.fConfidence < other.fConfidence) {     compareResult=-1    }   return compareResult  } 
CharsetMatch(CharsetDetector det,CharsetRecognizer rec,int conf){   fConfidence=conf    if (det.fInputStream == null) {     fRawInput=det.fRawInput      fRawLength=det.fRawLength    }   fInputStream=det.fInputStream    fCharsetName=rec.getName()    fLang=rec.getLanguage()  } 
CharsetMatch(CharsetDetector det,CharsetRecognizer rec,int conf,String csName,String lang){   fConfidence=conf    if (det.fInputStream == null) {     fRawInput=det.fRawInput      fRawLength=det.fRawLength    }   fInputStream=det.fInputStream    fCharsetName=csName    fLang=lang  } 
/**   * Get the IANA name of this charset.  * @return the charset name.  */ abstract String getName()  
/**   * Get the ISO language code for this charset.  * @return the language code, or <code>null</code> if the language cannot be determined.  */ public String getLanguage(){   return null  } 
/**   * Test the match of this charset with the input text data which is obtained via the CharsetDetector object.  * @param det  The CharsetDetector, which contains the input textto be checked for being in this charset.  * @return     A CharsetMatch object containing details of matchwith this charset, or null if there was no match.  */ abstract CharsetMatch match(CharsetDetector det)  
/**   * Matching function shared among the 2022 detectors JP, CN and KR Counts up the number of legal an unrecognized escape sequences in the sample of text, and computes a score based on the total number & the proportion that fit the encoding.  * @param text the byte buffer containing text to analyse  * @param textLen  the size of the text in the byte.  * @param escapeSequences the byte escape sequences to test for.  * @return match quality, in the range of 0-100.  */ int match(byte[] text,int textLen,byte[][] escapeSequences){   int i, j    int escN    int hits=0    int misses=0    int shifts=0    int quality    scanInput:   for (i=0  i < textLen  i++) {     if (text[i] == 0x1b) {       checkEscapes:       for (escN=0  escN < escapeSequences.length  escN++) {         byte[] seq=escapeSequences[escN]          if ((textLen - i) < seq.length) {           continue checkEscapes          }         for (j=1  j < seq.length  j++) {           if (seq[j] != text[i + j]) {             continue checkEscapes            }         }         hits++          i+=seq.length - 1          continue scanInput        }       misses++      }     if (text[i] == 0x0e || text[i] == 0x0f) {       shifts++      }   }   if (hits == 0) {     return 0    }   quality=(100 * hits - 100 * misses) / (hits + misses)    if (hits + shifts < 5) {     quality-=(5 - (hits + shifts)) * 10    }   if (quality < 0) {     quality=0    }   return quality  } 
String getName(){   return "ISO-2022-JP"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det.fInputBytes,det.fInputLen,escapeSequences)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
String getName(){   return "ISO-2022-KR"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det.fInputBytes,det.fInputLen,escapeSequences)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
String getName(){   return "ISO-2022-CN"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det.fInputBytes,det.fInputLen,escapeSequences)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
/**   * Get the IANA name of this charset.  * @return the charset name.  */ abstract String getName()  
/**   * Test the match of this charset with the input text data which is obtained via the CharsetDetector object.  * @param det  The CharsetDetector, which contains the input textto be checked for being in this charset.  * @return     Two values packed into one int  (Damn java, anyhow)<br/> bits 0-7:  the match confidence, ranging from 0-100 <br/> bits 8-15: The match reason, an enum-like value.  */ int match(CharsetDetector det,int[] commonChars){   @SuppressWarnings("unused") int singleByteCharCount=0    int doubleByteCharCount=0    int commonCharCount=0    int badCharCount=0    int totalCharCount=0    int confidence=0    iteratedChar iter=new iteratedChar()    detectBlock: {     for (iter.reset()  nextChar(iter,det)  ) {       totalCharCount++        if (iter.error) {         badCharCount++        }  else {         long cv=iter.charValue & 0xFFFFFFFFL          if (cv <= 0xff) {           singleByteCharCount++          }  else {           doubleByteCharCount++            if (commonChars != null) {             if (Arrays.binarySearch(commonChars,(int)cv) >= 0) {               commonCharCount++              }           }         }       }       if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {         break detectBlock        }     }     if (doubleByteCharCount <= 10 && badCharCount == 0) {       if (doubleByteCharCount == 0 && totalCharCount < 10) {         confidence=0        }  else {         confidence=10        }       break detectBlock      }     if (doubleByteCharCount < 20 * badCharCount) {       confidence=0        break detectBlock      }     if (commonChars == null) {       confidence=30 + doubleByteCharCount - 20 * badCharCount        if (confidence > 100) {         confidence=100        }     }  else {       double maxVal=Math.log((float)doubleByteCharCount / 4)        double scaleFactor=90.0 / maxVal        confidence=(int)(Math.log(commonCharCount + 1) * scaleFactor + 10)        confidence=Math.min(confidence,100)      }   }   return confidence  } 
void reset(){   charValue=0    index=-1    nextIndex=0    error=false    done=false  } 
int nextByte(CharsetDetector det){   if (nextIndex >= det.fRawLength) {     done=true      return -1    }   int byteValue=(int)det.fRawInput[nextIndex++] & 0x00ff    return byteValue  } 
/**   * Get the next character (however many bytes it is) from the input data Subclasses for specific charset encodings must implement this function to get characters according to the rules of their encoding scheme. This function is not a method of class iteratedChar only because that would require a lot of extra derived classes, which is awkward.  * @param it  The iteratedChar "struct" into which the returned char is placed.  * @param det The charset detector, which is needed to get at the input byte databeing iterated over.  * @return    True if a character was returned, false at end of input.  */ abstract boolean nextChar(iteratedChar it,CharsetDetector det)  
boolean nextChar(iteratedChar it,CharsetDetector det){   it.index=it.nextIndex    it.error=false    int firstByte    firstByte=it.charValue=it.nextByte(det)    if (firstByte < 0) {     return false    }   if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf)) {     return true    }   int secondByte=it.nextByte(det)    if (secondByte < 0) {     return false    }   it.charValue=(firstByte << 8) | secondByte    if (!((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {     it.error=true    }   return true  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det,commonChars)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
String getName(){   return "Shift_JIS"  } 
public String getLanguage(){   return "ja"  } 
boolean nextChar(iteratedChar it,CharsetDetector det){   it.index=it.nextIndex    it.error=false    int firstByte    firstByte=it.charValue=it.nextByte(det)    if (firstByte < 0) {     return false    }   if (firstByte <= 0x7f || firstByte == 0xff) {     return true    }   int secondByte=it.nextByte(det)    if (secondByte < 0) {     return false    }   it.charValue=(it.charValue << 8) | secondByte    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff) {     it.error=true    }   return true  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det,commonChars)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
String getName(){   return "Big5"  } 
public String getLanguage(){   return "zh"  } 
boolean nextChar(iteratedChar it,CharsetDetector det){   it.index=it.nextIndex    it.error=false    int firstByte=0    int secondByte=0    int thirdByte=0    buildChar: {     firstByte=it.charValue=it.nextByte(det)      if (firstByte < 0) {       it.done=true        break buildChar      }     if (firstByte <= 0x8d) {       break buildChar      }     secondByte=it.nextByte(det)      it.charValue=(it.charValue << 8) | secondByte      if (firstByte >= 0xA1 && firstByte <= 0xfe) {       if (secondByte < 0xa1) {         it.error=true        }       break buildChar      }     if (firstByte == 0x8e) {       if (secondByte < 0xa1) {         it.error=true        }       break buildChar      }     if (firstByte == 0x8f) {       thirdByte=it.nextByte(det)        it.charValue=(it.charValue << 8) | thirdByte        if (thirdByte < 0xa1) {         it.error=true        }     }   }   return (it.done == false)  } 
String getName(){   return "EUC-JP"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det,commonChars)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getLanguage(){   return "ja"  } 
String getName(){   return "EUC-KR"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det,commonChars)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getLanguage(){   return "ko"  } 
boolean nextChar(iteratedChar it,CharsetDetector det){   it.index=it.nextIndex    it.error=false    int firstByte=0    int secondByte=0    int thirdByte=0    int fourthByte=0    buildChar: {     firstByte=it.charValue=it.nextByte(det)      if (firstByte < 0) {       it.done=true        break buildChar      }     if (firstByte <= 0x80) {       break buildChar      }     secondByte=it.nextByte(det)      it.charValue=(it.charValue << 8) | secondByte      if (firstByte >= 0x81 && firstByte <= 0xFE) {       if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >= 80 && secondByte <= 0xFE)) {         break buildChar        }       if (secondByte >= 0x30 && secondByte <= 0x39) {         thirdByte=it.nextByte(det)          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {           fourthByte=it.nextByte(det)            if (fourthByte >= 0x30 && fourthByte <= 0x39) {             it.charValue=(it.charValue << 16) | (thirdByte << 8) | fourthByte              break buildChar            }         }       }       it.error=true        break buildChar      }   }   return (it.done == false)  } 
String getName(){   return "GB18030"  } 
CharsetMatch match(CharsetDetector det){   int confidence=match(det,commonChars)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getLanguage(){   return "zh"  } 
abstract String getName()  
public NGramParser(int[] theNgramList,byte[] theByteMap){   ngramList=theNgramList    byteMap=theByteMap    ngram=0    ngramCount=hitCount=0  } 
private static int search(int[] table,int value){   int index=0    if (table[index + 32] <= value) {     index+=32    }   if (table[index + 16] <= value) {     index+=16    }   if (table[index + 8] <= value) {     index+=8    }   if (table[index + 4] <= value) {     index+=4    }   if (table[index + 2] <= value) {     index+=2    }   if (table[index + 1] <= value) {     index+=1    }   if (table[index] > value) {     index-=1    }   if (index < 0 || table[index] != value) {     return -1    }   return index  } 
private void lookup(int thisNgram){   ngramCount+=1    if (search(ngramList,thisNgram) >= 0) {     hitCount+=1    } } 
protected void addByte(int b){   ngram=((ngram << 8) + (b & 0xFF)) & N_GRAM_MASK    lookup(ngram)  } 
private int nextByte(CharsetDetector det){   if (byteIndex >= det.fInputLen) {     return -1    }   return det.fInputBytes[byteIndex++] & 0xFF  } 
protected void parseCharacters(CharsetDetector det){   int b    boolean ignoreSpace=false    while ((b=nextByte(det)) >= 0) {     byte mb=byteMap[b]      if (mb != 0) {       if (!(mb == spaceChar && ignoreSpace)) {         addByte(mb)        }       ignoreSpace=(mb == spaceChar)      }   } } 
public int parse(CharsetDetector det){   return parse(det,(byte)0x20)  } 
public int parse(CharsetDetector det,byte spaceCh){   this.spaceChar=spaceCh    parseCharacters(det)    addByte(spaceChar)    double rawPercent=(double)hitCount / (double)ngramCount    if (rawPercent > 0.33) {     return 98    }   return (int)(rawPercent * 300.0)  } 
public NGramParser_IBM420(int[] theNgramList,byte[] theByteMap){   super(theNgramList,theByteMap)  } 
private byte isLamAlef(byte b){   if (b == (byte)0xb2 || b == (byte)0xb3) {     return (byte)0x47    }  else   if (b == (byte)0xb4 || b == (byte)0xb5) {     return (byte)0x49    }  else   if (b == (byte)0xb8 || b == (byte)0xb9) {     return (byte)0x56    }  else   return (byte)0x00  } 
private int nextByte(CharsetDetector det){   if (byteIndex >= det.fInputLen || det.fInputBytes[byteIndex] == 0) {     return -1    }   int next    alef=isLamAlef(det.fInputBytes[byteIndex])    if (alef != (byte)0x00)   next=0xB1 & 0xFF   else   next=unshapeMap[det.fInputBytes[byteIndex] & 0xFF] & 0xFF    byteIndex++    return next  } 
protected void parseCharacters(CharsetDetector det){   int b    boolean ignoreSpace=false    while ((b=nextByte(det)) >= 0) {     byte mb=byteMap[b]      if (mb != 0) {       if (!(mb == spaceChar && ignoreSpace)) {         addByte(mb)        }       ignoreSpace=(mb == spaceChar)      }     if (alef != (byte)0x00) {       mb=byteMap[alef & 0xFF]        if (mb != 0) {         if (!(mb == spaceChar && ignoreSpace)) {           addByte(mb)          }         ignoreSpace=(mb == spaceChar)        }     }   } } 
int match(CharsetDetector det,int[] ngrams,byte[] byteMap){   return match(det,ngrams,byteMap,(byte)0x20)  } 
int match(CharsetDetector det,int[] ngrams,byte[] byteMap,byte spaceChar){   NGramParser parser=new NGramParser(ngrams,byteMap)    return parser.parse(det,spaceChar)  } 
int matchIBM420(CharsetDetector det,int[] ngrams,byte[] byteMap,byte spaceChar){   NGramParser_IBM420 parser=new NGramParser_IBM420(ngrams,byteMap)    return parser.parse(det,spaceChar)  } 
NGramsPlusLang(String la,int[] ng){   fLang=la    fNGrams=ng  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1252" : "ISO-8859-1"    int bestConfidenceSoFar=-1    String lang=null    for (  NGramsPlusLang ngl : ngrams_8859_1) {     int confidence=match(det,ngl.fNGrams,byteMap)      if (confidence > bestConfidenceSoFar) {       bestConfidenceSoFar=confidence        lang=ngl.fLang      }   }   return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det,this,bestConfidenceSoFar,name,lang)  } 
public String getName(){   return "ISO-8859-1"  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1250" : "ISO-8859-2"    int bestConfidenceSoFar=-1    String lang=null    for (  NGramsPlusLang ngl : ngrams_8859_2) {     int confidence=match(det,ngl.fNGrams,byteMap)      if (confidence > bestConfidenceSoFar) {       bestConfidenceSoFar=confidence        lang=ngl.fLang      }   }   return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det,this,bestConfidenceSoFar,name,lang)  } 
public String getName(){   return "ISO-8859-2"  } 
public String getName(){   return "ISO-8859-5"  } 
public String getLanguage(){   return "ru"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "ISO-8859-6"  } 
public String getLanguage(){   return "ar"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "ISO-8859-7"  } 
public String getLanguage(){   return "el"  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1253" : "ISO-8859-7"    int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence,name,"el")  } 
public String getName(){   return "ISO-8859-8"  } 
public String getName(){   return "ISO-8859-8-I"  } 
public String getLanguage(){   return "he"  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1255" : "ISO-8859-8-I"    int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence,name,"he")  } 
public String getLanguage(){   return "he"  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1255" : "ISO-8859-8"    int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence,name,"he")  } 
public String getName(){   return "ISO-8859-9"  } 
public String getLanguage(){   return "tr"  } 
public CharsetMatch match(CharsetDetector det){   String name=det.fC1Bytes ? "windows-1254" : "ISO-8859-9"    int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence,name,"tr")  } 
public String getName(){   return "windows-1251"  } 
public String getLanguage(){   return "ru"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "windows-1256"  } 
public String getLanguage(){   return "ar"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "KOI8-R"  } 
public String getLanguage(){   return "ru"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getLanguage(){   return "he"  } 
public String getName(){   return "IBM424_rtl"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap,(byte)0x40)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "IBM424_ltr"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=match(det,ngrams,byteMap,(byte)0x40)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getLanguage(){   return "ar"  } 
public String getName(){   return "IBM420_rtl"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=matchIBM420(det,ngrams,byteMap,(byte)0x40)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
public String getName(){   return "IBM420_ltr"  } 
public CharsetMatch match(CharsetDetector det){   int confidence=matchIBM420(det,ngrams,byteMap,(byte)0x40)    return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
abstract String getName()  
abstract CharsetMatch match(CharsetDetector det)  
static int codeUnit16FromBytes(byte hi,byte lo){   return ((hi & 0xff) << 8) | (lo & 0xff)  } 
static int adjustConfidence(int codeUnit,int confidence){   if (codeUnit == 0) {     confidence-=10    }  else   if ((codeUnit >= 0x20 && codeUnit <= 0xff) || codeUnit == 0x0a) {     confidence+=10    }   if (confidence < 0) {     confidence=0    }  else   if (confidence > 100) {     confidence=100    }   return confidence  } 
String getName(){   return "UTF-16BE"  } 
CharsetMatch match(CharsetDetector det){   byte[] input=det.fRawInput    int confidence=10    int bytesToCheck=Math.min(input.length,30)    for (int charIndex=0  charIndex < bytesToCheck - 1  charIndex+=2) {     int codeUnit=codeUnit16FromBytes(input[charIndex],input[charIndex + 1])      if (charIndex == 0 && codeUnit == 0xFEFF) {       confidence=100        break      }     confidence=adjustConfidence(codeUnit,confidence)      if (confidence == 0 || confidence == 100) {       break      }   }   if (bytesToCheck < 4 && confidence < 100) {     confidence=0    }   if (confidence > 0) {     return new CharsetMatch(det,this,confidence)    }   return null  } 
String getName(){   return "UTF-16LE"  } 
CharsetMatch match(CharsetDetector det){   byte[] input=det.fRawInput    int confidence=10    int bytesToCheck=Math.min(input.length,30)    for (int charIndex=0  charIndex < bytesToCheck - 1  charIndex+=2) {     int codeUnit=codeUnit16FromBytes(input[charIndex + 1],input[charIndex])      if (charIndex == 0 && codeUnit == 0xFEFF) {       confidence=100        break      }     confidence=adjustConfidence(codeUnit,confidence)      if (confidence == 0 || confidence == 100) {       break      }   }   if (bytesToCheck < 4 && confidence < 100) {     confidence=0    }   if (confidence > 0) {     return new CharsetMatch(det,this,confidence)    }   return null  } 
abstract int getChar(byte[] input,int index)  
abstract String getName()  
CharsetMatch match(CharsetDetector det){   byte[] input=det.fRawInput    int limit=(det.fRawLength / 4) * 4    int numValid=0    int numInvalid=0    boolean hasBOM=false    int confidence=0    if (limit == 0) {     return null    }   if (getChar(input,0) == 0x0000FEFF) {     hasBOM=true    }   for (int i=0  i < limit  i+=4) {     int ch=getChar(input,i)      if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {       numInvalid+=1      }  else {       numValid+=1      }   }   if (hasBOM && numInvalid == 0) {     confidence=100    }  else   if (hasBOM && numValid > numInvalid * 10) {     confidence=80    }  else   if (numValid > 3 && numInvalid == 0) {     confidence=100    }  else   if (numValid > 0 && numInvalid == 0) {     confidence=80    }  else   if (numValid > numInvalid * 10) {     confidence=25    }   return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
int getChar(byte[] input,int index){   return (input[index + 0] & 0xFF) << 24 | (input[index + 1] & 0xFF) << 16 | (input[index + 2] & 0xFF) << 8 | (input[index + 3] & 0xFF)  } 
String getName(){   return "UTF-32BE"  } 
int getChar(byte[] input,int index){   return (input[index + 3] & 0xFF) << 24 | (input[index + 2] & 0xFF) << 16 | (input[index + 1] & 0xFF) << 8 | (input[index + 0] & 0xFF)  } 
String getName(){   return "UTF-32LE"  } 
String getName(){   return "UTF-8"  } 
CharsetMatch match(CharsetDetector det){   boolean hasBOM=false    int numValid=0    int numInvalid=0    byte input[]=det.fRawInput    int i    int trailBytes=0    int confidence    if (det.fRawLength >= 3 && (input[0] & 0xFF) == 0xef && (input[1] & 0xFF) == 0xbb && (input[2] & 0xFF) == 0xbf) {     hasBOM=true    }   for (i=0  i < det.fRawLength  i++) {     int b=input[i]      if ((b & 0x80) == 0) {       continue      }     if ((b & 0x0e0) == 0x0c0) {       trailBytes=1      }  else     if ((b & 0x0f0) == 0x0e0) {       trailBytes=2      }  else     if ((b & 0x0f8) == 0xf0) {       trailBytes=3      }  else {       numInvalid++        continue      }     for (    ) {       i++        if (i >= det.fRawLength) {         break        }       b=input[i]        if ((b & 0xc0) != 0x080) {         numInvalid++          break        }       if (--trailBytes == 0) {         numValid++          break        }     }   }   confidence=0    if (hasBOM && numInvalid == 0) {     confidence=100    }  else   if (hasBOM && numValid > numInvalid * 10) {     confidence=80    }  else   if (numValid > 3 && numInvalid == 0) {     confidence=100    }  else   if (numValid > 0 && numInvalid == 0) {     confidence=80    }  else   if (numValid == 0 && numInvalid == 0) {     confidence=15    }  else   if (numValid > numInvalid * 10) {     confidence=25    }   return confidence == 0 ? null : new CharsetMatch(det,this,confidence)  } 
@Override public void onCreate(){   super.onCreate()    component=createComponent()    AppCompatDelegate.setCompatVectorFromResourcesEnabled(true)    installLeakCanary()    AndroidThreeTen.init(this)    initTraceDroid()    AppCompatDelegate.setDefaultNightMode(component.settings().getNightMode())  } 
public void installLeakCanary(){   LeakCanary.install(this)  } 
public AppComponent createComponent(){   return DaggerAppComponent.builder().appModule(new AppModule(this)).trackerModule(new TrackerModule(this)).build()  } 
private void initTraceDroid(){   TraceDroid.init(this)    Log.setTAG("PassAndroid")  } 
public static AppComponent component(){   return component  } 
@VisibleForTesting public static void setComponent(AppComponent newComponent){   component=newComponent  } 
@Override public void onReceive(Context context,Intent intent){   String rawReferrerString=intent.getStringExtra("referrer")    if (rawReferrerString != null) {     final Intent newIntent=new Intent(context,PassImportActivity.class)      newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)      newIntent.setData(Uri.parse(rawReferrerString))      context.startActivity(newIntent)    } } 
public String translate(String key){   if (containsKey(key)) {     return get(key)    }   return key  } 
public void loadFromFile(final File file){   final String content=readFileAsStringGuessEncoding(file)    loadFromString(content)  } 
@VisibleForTesting public void loadFromString(final String inputString){   if (inputString == null) {     return    }   for (  String pair : inputString.split("\" ")) {     final String[] kv=pair.split("\" ?= ?\"")      if (kv.length == 2) {       put(removeLeadingClutter(kv[0]),kv[1])      }   } } 
private static String removeLeadingClutter(String s){   if (s.startsWith("\"") || s.startsWith("\n") || s.startsWith("\r")|| s.startsWith(" ")) {     return removeLeadingClutter(s.substring(1))    }  else {     return s    } } 
@Nullable public static String readFileAsStringGuessEncoding(final @NonNull File file){   try {     final byte[] fileData=new byte[(int)file.length()]      final DataInputStream dataInputStream=new DataInputStream(new FileInputStream(file))      dataInputStream.readFully(fileData)      dataInputStream.close()      if (fileData[0] == (byte)0xEF && fileData[1] == (byte)0xBB && fileData[2] == (byte)0xBF) {       final byte[] crop=new byte[fileData.length - 3]        System.arraycopy(fileData,3,crop,0,crop.length)        return new String(crop,"utf-8")      }     final CharsetMatch match=new CharsetDetector().setText(fileData).detect()      if (match != null)     try {       return new String(fileData,match.getName())      }  catch (    UnsupportedEncodingException ignored) {     }     return new String(fileData)    }  catch (  Throwable e) {     App.component().tracker().trackException("problem_reading_translation",e,false)      e.printStackTrace()      return null    } } 
public FileBackedPassClassifier(final File backed_file,final PassStore passStore,final Moshi moshi){   super(loadMap(backed_file,moshi),passStore)    this.backed_file=backed_file    adapter=getAdapter(moshi)  } 
private static JsonAdapter<Map> getAdapter(Moshi moshi){   return moshi.adapter(Map.class)  } 
@SuppressWarnings("unchecked") private static Map<String,String> loadMap(final File backed_file,final Moshi moshi){   if (backed_file.exists()) {     try {       return (Map<String,String>)getAdapter(moshi).fromJson(Okio.buffer(Okio.source(backed_file)))      }  catch (    IOException e) {       e.printStackTrace()      }   }   return new HashMap<>()  } 
@SuppressWarnings("ResultOfMethodCallIgnored") private BufferedSink getBufferedSinkFromMaybeCreatedFile(){   try {     if (!backed_file.exists()) {       final File parentFile=backed_file.getParentFile()        if (!parentFile.exists()) {         parentFile.mkdirs()        }       backed_file.createNewFile()      }     return Okio.buffer(Okio.sink(backed_file))    }  catch (  IOException e) {     e.printStackTrace()      return null    } } 
@Override public void processDataChange(){   super.processDataChange()    if (adapter != null) {     final BufferedSink buffer=getBufferedSinkFromMaybeCreatedFile()      if (buffer != null) {       try {         adapter.toJson(buffer,getTopicByIdMap())          buffer.close()        }  catch (      IOException e) {         e.printStackTrace()        }     }   } } 
void trackException(String s,Throwable e,boolean fatal)  
void trackException(String s,boolean fatal)  
void trackEvent(@Nullable String category,@Nullable String action,@Nullable String label,@Nullable Long val)  
/**   * @param activity {@link Activity} invoking the integration  */ public BarCodeIntentIntegrator(Activity activity){   this.activity=activity    this.fragment=null    initializeConfiguration()  } 
public BarCodeIntentIntegrator(Fragment fragment){   this.activity=fragment.getActivity()    this.fragment=fragment    initializeConfiguration()  } 
private void initializeConfiguration(){   title=DEFAULT_TITLE    message=DEFAULT_MESSAGE    buttonYes=DEFAULT_YES    buttonNo=DEFAULT_NO    targetApplications=TARGET_ALL_KNOWN  } 
public String getTitle(){   return title  } 
public void setTitle(String title){   this.title=title  } 
public void setTitleByID(int titleID){   title=activity.getString(titleID)  } 
public String getMessage(){   return message  } 
public void setMessage(String message){   this.message=message  } 
public void setMessageByID(int messageID){   message=activity.getString(messageID)  } 
public String getButtonYes(){   return buttonYes  } 
public void setButtonYes(String buttonYes){   this.buttonYes=buttonYes  } 
public void setButtonYesByID(int buttonYesID){   buttonYes=activity.getString(buttonYesID)  } 
public String getButtonNo(){   return buttonNo  } 
public void setButtonNo(String buttonNo){   this.buttonNo=buttonNo  } 
public void setButtonNoByID(int buttonNoID){   buttonNo=activity.getString(buttonNoID)  } 
public Collection<String> getTargetApplications(){   return targetApplications  } 
public final void setTargetApplications(List<String> targetApplications){   if (targetApplications.isEmpty()) {     throw new IllegalArgumentException("No target applications")    }   this.targetApplications=targetApplications  } 
public void setSingleTargetApplication(String targetApplication){   this.targetApplications=Collections.singletonList(targetApplication)  } 
public Map<String,?> getMoreExtras(){   return moreExtras  } 
public final void addExtra(String key,Object value){   moreExtras.put(key,value)  } 
/**   * Initiates a scan for all known barcode types with the default camera.  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise.  */ public final AlertDialog initiateScan(){   return initiateScan(ALL_CODE_TYPES,-1)  } 
/**   * Initiates a scan for all known barcode types with the specified camera.  * @param cameraId camera ID of the camera to use. A negative value means "no preference".  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise.  */ public final AlertDialog initiateScan(int cameraId){   return initiateScan(ALL_CODE_TYPES,cameraId)  } 
/**   * Initiates a scan, using the default camera, only for a certain set of barcode types, given as strings corresponding to their names in ZXing's  {@code BarcodeFormat} class like "UPC_A". You can supply constantslike  {@link #PRODUCT_CODE_TYPES} for example.  * @param desiredBarcodeFormats names of {@code BarcodeFormat}s to scan for  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise.  */ public final AlertDialog initiateScan(Collection<String> desiredBarcodeFormats){   return initiateScan(desiredBarcodeFormats,-1)  } 
/**   * Initiates a scan, using the specified camera, only for a certain set of barcode types, given as strings corresponding to their names in ZXing's  {@code BarcodeFormat} class like "UPC_A". You can supply constantslike  {@link #PRODUCT_CODE_TYPES} for example.  * @param desiredBarcodeFormats names of {@code BarcodeFormat}s to scan for  * @param cameraId              camera ID of the camera to use. A negative value means "no preference".  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise  */ public final AlertDialog initiateScan(Collection<String> desiredBarcodeFormats,int cameraId){   Intent intentScan=new Intent(BS_PACKAGE + ".SCAN")    intentScan.addCategory(Intent.CATEGORY_DEFAULT)    if (desiredBarcodeFormats != null) {     StringBuilder joinedByComma=new StringBuilder()      for (    String format : desiredBarcodeFormats) {       if (joinedByComma.length() > 0) {         joinedByComma.append(',')        }       joinedByComma.append(format)      }     intentScan.putExtra("SCAN_FORMATS",joinedByComma.toString())    }   if (cameraId >= 0) {     intentScan.putExtra("SCAN_CAMERA_ID",cameraId)    }   String targetAppPackage=findTargetAppPackage(intentScan)    if (targetAppPackage == null) {     return showDownloadDialog()    }   intentScan.setPackage(targetAppPackage)    intentScan.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)    intentScan.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET)    attachMoreExtras(intentScan)    startActivityForResult(intentScan,REQUEST_CODE)    return null  } 
/**   * Start an activity. This method is defined to allow different methods of activity starting for newer versions of Android and for compatibility library.  * @param intent Intent to start.  * @param code   Request code for the activity  * @see android.app.Activity#startActivityForResult(Intent,int)  * @see android.app.Fragment#startActivityForResult(Intent,int)  */ protected void startActivityForResult(Intent intent,int code){   if (fragment == null) {     activity.startActivityForResult(intent,code)    }  else {     fragment.startActivityForResult(intent,code)    } } 
private String findTargetAppPackage(Intent intent){   PackageManager pm=activity.getPackageManager()    List<ResolveInfo> availableApps=pm.queryIntentActivities(intent,PackageManager.MATCH_DEFAULT_ONLY)    if (availableApps != null) {     for (    String targetApp : targetApplications) {       if (contains(availableApps,targetApp)) {         return targetApp        }     }   }   return null  } 
private static boolean contains(Iterable<ResolveInfo> availableApps,String targetApp){   for (  ResolveInfo availableApp : availableApps) {     String packageName=availableApp.activityInfo.packageName      if (targetApp.equals(packageName)) {       return true      }   }   return false  } 
private AlertDialog showDownloadDialog(){   AlertDialog.Builder downloadDialog=new AlertDialog.Builder(activity)    downloadDialog.setTitle(title)    downloadDialog.setMessage(message)    downloadDialog.setPositiveButton(buttonYes,new DialogInterface.OnClickListener(){     @Override public void onClick(    DialogInterface dialogInterface,    int i){       String packageName        if (targetApplications.contains(BS_PACKAGE)) {         packageName=BS_PACKAGE        }  else {         packageName=targetApplications.get(0)        }       Uri uri=Uri.parse("market://details?id=" + packageName)        Intent intent=new Intent(Intent.ACTION_VIEW,uri)        try {         if (fragment == null) {           activity.startActivity(intent)          }  else {           fragment.startActivity(intent)          }       }  catch (      ActivityNotFoundException anfe) {         Log.w(TAG,"Google Play is not installed  cannot install " + packageName)        }     }   } )    downloadDialog.setNegativeButton(buttonNo,null)    downloadDialog.setCancelable(true)    return downloadDialog.show()  } 
@Override public void onClick(DialogInterface dialogInterface,int i){   String packageName    if (targetApplications.contains(BS_PACKAGE)) {     packageName=BS_PACKAGE    }  else {     packageName=targetApplications.get(0)    }   Uri uri=Uri.parse("market://details?id=" + packageName)    Intent intent=new Intent(Intent.ACTION_VIEW,uri)    try {     if (fragment == null) {       activity.startActivity(intent)      }  else {       fragment.startActivity(intent)      }   }  catch (  ActivityNotFoundException anfe) {     Log.w(TAG,"Google Play is not installed  cannot install " + packageName)    } } 
/**   * Defaults to type "TEXT_TYPE".  * @param text the text string to encode as a barcode  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise  * @see #shareText(CharSequence,CharSequence)  */ public final AlertDialog shareText(CharSequence text){   return shareText(text,"TEXT_TYPE")  } 
/**   * Shares the given text by encoding it as a barcode, such that another user can scan the text off the screen of the device.  * @param text the text string to encode as a barcode  * @param type type of data to encode. See {@code com.google.zxing.client.android.Contents.Type} constants.  * @return the {@link AlertDialog} that was shown to the user prompting them to download the appif a prompt was needed, or null otherwise  */ public final AlertDialog shareText(CharSequence text,CharSequence type){   Intent intent=new Intent()    intent.addCategory(Intent.CATEGORY_DEFAULT)    intent.setAction(BS_PACKAGE + ".ENCODE")    intent.putExtra("ENCODE_TYPE",type)    intent.putExtra("ENCODE_DATA",text)    String targetAppPackage=findTargetAppPackage(intent)    if (targetAppPackage == null) {     return showDownloadDialog()    }   intent.setPackage(targetAppPackage)    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET)    attachMoreExtras(intent)    if (fragment == null) {     activity.startActivity(intent)    }  else {     fragment.startActivity(intent)    }   return null  } 
private static List<String> list(String... values){   return Collections.unmodifiableList(Arrays.asList(values))  } 
private void attachMoreExtras(Intent intent){   for (  Map.Entry<String,Object> entry : moreExtras.entrySet()) {     String key=entry.getKey()      Object value=entry.getValue()      if (value instanceof Integer) {       intent.putExtra(key,(Integer)value)      }  else     if (value instanceof Long) {       intent.putExtra(key,(Long)value)      }  else     if (value instanceof Boolean) {       intent.putExtra(key,(Boolean)value)      }  else     if (value instanceof Double) {       intent.putExtra(key,(Double)value)      }  else     if (value instanceof Float) {       intent.putExtra(key,(Float)value)      }  else     if (value instanceof Bundle) {       intent.putExtra(key,(Bundle)value)      }  else {       intent.putExtra(key,value.toString())      }   } } 
public MyShyFABBehavior(){ } 
public MyShyFABBehavior(Context context,AttributeSet attrs){   super(context,attrs)  } 
@Override public boolean layoutDependsOn(CoordinatorLayout parent,FloatingActionsMenu child,View dependency){   return dependency instanceof Snackbar.SnackbarLayout || dependency instanceof AppBarLayout  } 
@Override public boolean onDependentViewChanged(CoordinatorLayout parent,FloatingActionsMenu child,View dependency){   if (dependency instanceof Snackbar.SnackbarLayout) {     updateFabTranslationForSnackbar(child,dependency)    }   if (dependency instanceof AppBarLayout) {     final CoordinatorLayout.LayoutParams lp=(CoordinatorLayout.LayoutParams)child.getLayoutParams()      final int fabBottomMargin=lp.bottomMargin      final int distanceToScroll      if (child.isExpanded()) {       distanceToScroll=child.getHeight() + fabBottomMargin      }  else {       distanceToScroll=(int)(child.getContext().getResources().getDimension(R.dimen.fab_size_normal) + 2 * fabBottomMargin)      }     final float ratio=ViewCompat.getY(dependency) / getToolbarHeight(dependency.getContext())      ViewCompat.setTranslationY(child,-distanceToScroll * ratio)    }   return false  } 
@Override public void onDependentViewRemoved(final CoordinatorLayout parent,final FloatingActionsMenu child,final View dependency){   super.onDependentViewRemoved(parent,child,dependency)    onDependentViewChanged(parent,child,dependency)  } 
private void updateFabTranslationForSnackbar(FloatingActionsMenu child,View dependency){   final float translationY=ViewCompat.getTranslationY(dependency) - dependency.getHeight()    final float translationYClipped=Math.min(0,translationY)    ViewCompat.setTranslationY(child,translationYClipped)  } 
private int getToolbarHeight(Context context){   final TypedArray styledAttributes=context.getTheme().obtainStyledAttributes(new int[]{R.attr.actionBarSize})    int toolbarHeight=(int)styledAttributes.getDimension(0,0)    styledAttributes.recycle()    return toolbarHeight  } 
@Override protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    final String url=new URLRewriteController(getTracker()).getUrlByUri(getIntent().getData())    if (url == null) {     new AlertDialog.Builder(this).setTitle("Workaround failed").setMessage("The URL PassAndroid tried to work around failed :-( some companies just send PassBooks to Apple Devices - this was an attempt to workaround this." + "Unfortunately it failed - perhaps there where changes on the serverside - you can open the site with your browser now - to see it in PassAndroid in future again it would help if you can send me the pass").setPositiveButton("Browser",new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialog,      int which){         getTracker().trackException("URLRewrite with invalid activity",false)          final Intent intent=new Intent(URLRewriteActivity.this,OpenIphoneWebView.class)          intent.setData(getIntent().getData())          startActivity(intent)        }     } ).setNeutralButton("send",new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialog,      int which){         Intent intent=new Intent(Intent.ACTION_SEND)          intent.putExtra(Intent.EXTRA_SUBJECT,"PassAndroid: URLRewrite Problem")          intent.putExtra(Intent.EXTRA_EMAIL,new String[]{"ligi@ligi.de"})          intent.putExtra(Intent.EXTRA_TEXT,getIntent().getData().toString())          intent.setType("text/plain")          startActivity(Intent.createChooser(intent,"How to send Link?"))          finish()        }     } ).setNegativeButton("cancel",new DialogInterface.OnClickListener(){       @Override public void onClick(      DialogInterface dialog,      int which){         URLRewriteActivity.this.finish()        }     } ).show()      return    }   final Intent intent=new Intent(this,PassImportActivity.class)    intent.setData(Uri.parse(url))    startActivity(intent)    finish()  } 
@Override public void onClick(DialogInterface dialog,int which){   getTracker().trackException("URLRewrite with invalid activity",false)    final Intent intent=new Intent(URLRewriteActivity.this,OpenIphoneWebView.class)    intent.setData(getIntent().getData())    startActivity(intent)  } 
@Override public void onClick(DialogInterface dialog,int which){   Intent intent=new Intent(Intent.ACTION_SEND)    intent.putExtra(Intent.EXTRA_SUBJECT,"PassAndroid: URLRewrite Problem")    intent.putExtra(Intent.EXTRA_EMAIL,new String[]{"ligi@ligi.de"})    intent.putExtra(Intent.EXTRA_TEXT,getIntent().getData().toString())    intent.setType("text/plain")    startActivity(Intent.createChooser(intent,"How to send Link?"))    finish()  } 
@Override public void onClick(DialogInterface dialog,int which){   URLRewriteActivity.this.finish()  } 
@Override public void trackException(String s,Throwable e,boolean fatal){   if (fatal) {     Log.w("Fatal Exception " + s + " "+ e)    }  else {     Log.w("Not Fatal Exception " + s + " "+ e)    } } 
@Override public void trackException(String s,boolean fatal){   if (fatal) {     Log.w("Fatal Exception " + s)    }  else {     Log.w("Not Fatal Exception " + s)    } } 
@Override public void trackEvent(String category,String action,String label,Long val){ } 
public TrackerModule(App app){   this.app=app  } 
@Singleton @Provides public Tracker provideTracker(){   return new NotTracker()  } 
public static boolean init(Context context){   return false  } 
public static void startFullscreenMap(Context context){ } 
public AnalyticsTracker(Context ctx){   this.ctx=ctx    final GoogleAnalytics analytics=GoogleAnalytics.getInstance(ctx)    tracker=analytics.newTracker(R.xml.analytics)    tracker.enableAutoActivityTracking(true)  } 
@Override public void trackException(String s,Throwable e,boolean fatal){   final String description=new StandardExceptionParser(ctx,null).getDescription(Thread.currentThread().getName(),e)    final Map<String,String> exceptionMap=new HitBuilders.ExceptionBuilder().setDescription(s + " " + description).setFatal(fatal).build()    tracker.send(exceptionMap)  } 
@Override public void trackException(String s,boolean fatal){   tracker.send(new HitBuilders.ExceptionBuilder().setDescription(s).setFatal(fatal).build())  } 
@Override public void trackEvent(@Nullable String category,@Nullable String action,@Nullable String label,@Nullable Long val){   final HitBuilders.EventBuilder eventMapBuilder=new HitBuilders.EventBuilder()    if (category != null) {     eventMapBuilder.setCategory(category)    }   if (action != null) {     eventMapBuilder.setAction(action)    }   if (label != null) {     eventMapBuilder.setLabel(label)    }   if (val != null) {     eventMapBuilder.setValue(val)    }   try {     tracker.send(eventMapBuilder.build())    }  catch (  ConcurrentModificationException ignored) {   } } 
public TrackerModule(App app){   this.app=app  } 
@Singleton @Provides Tracker provideTracker(){   return new AnalyticsTracker(app)  } 
/**   * Send to the first 10 devices (You can modify this to send to any number of devices or a specific device)  * @param message The message to send  */ public void sendMessage(@Named("message") String message) throws IOException {   if (message == null || message.trim().length() == 0) {     log.warning("Not sending message because it is empty")      return    }   if (message.length() > 1000) {     message=message.substring(0,1000) + "[...]"    }   Sender sender=new Sender(API_KEY)    Message msg=new Message.Builder().addData("message",message).build()    List<RegistrationRecord> records=ofy().load().type(RegistrationRecord.class).limit(10).list()    for (  RegistrationRecord record : records) {     Result result=sender.send(msg,record.getRegId(),5)      if (result.getMessageId() != null) {       log.info("Message sent to " + record.getRegId())        String canonicalRegId=result.getCanonicalRegistrationId()        if (canonicalRegId != null) {         log.info("Registration Id changed for " + record.getRegId() + " updating to "+ canonicalRegId)          record.setRegId(canonicalRegId)          ofy().save().entity(record).now()        }     }  else {       String error=result.getErrorCodeName()        if (error.equals(Constants.ERROR_NOT_REGISTERED)) {         log.warning("Registration Id " + record.getRegId() + " no longer registered with GCM, removing from datastore")          ofy().delete().entity(record).now()        }  else {         log.warning("Error when sending message : " + error)        }     }   } } 
public static Objectify ofy(){   return ObjectifyService.ofy()  } 
public static ObjectifyFactory factory(){   return ObjectifyService.factory()  } 
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {   response.sendRedirect("market://details?id=org.ligi.passandroid&refferer=" + request.getParameter("url"))  } 
/**   * Register a device to the backend  * @param regId The Google Cloud Messaging registration Id to add  */ @ApiMethod(name="register") public void registerDevice(@Named("regId") String regId){   if (findRecord(regId) != null) {     log.info("Device " + regId + " already registered, skipping register")      return    }   RegistrationRecord record=new RegistrationRecord()    record.setRegId(regId)    ofy().save().entity(record).now()  } 
/**   * Unregister a device from the backend  * @param regId The Google Cloud Messaging registration Id to remove  */ @ApiMethod(name="unregister") public void unregisterDevice(@Named("regId") String regId){   RegistrationRecord record=findRecord(regId)    if (record == null) {     log.info("Device " + regId + " not registered, skipping unregister")      return    }   ofy().delete().entity(record).now()  } 
/**   * Return a collection of registered devices  * @param count The number of devices to list  * @return a list of Google Cloud Messaging registration Ids  */ @ApiMethod(name="listDevices") public CollectionResponse<RegistrationRecord> listDevices(@Named("count") int count){   List<RegistrationRecord> records=ofy().load().type(RegistrationRecord.class).limit(count).list()    return CollectionResponse.<RegistrationRecord>builder().setItems(records).build()  } 
private RegistrationRecord findRecord(String regId){   return ofy().load().type(RegistrationRecord.class).filter("regId",regId).first().now()  } 
public RegistrationRecord(){ } 
public String getRegId(){   return regId  } 
public void setRegId(String regId){   this.regId=regId  } 
int getResult()  
@Override public int getResult(){   return RESULT  } 
@Override public void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState)    Log.i(TAG,"onCreate")    setContentView(R.layout.main)    button=(Button)findViewById(R.id.button_main)    textView=(TextView)findViewById(R.id.textview_hello)    button.setOnClickListener(new ButtonClickListener())    computer=new DummyComputer()  } 
public void setComputer(Computer computer){   this.computer=computer  } 
@Override public void onClick(View v){   if (computer != null) {     textView.setText(String.valueOf(computer.getResult()))    }  else {     textView.setText(R.string.text_no_computer)    }   DateTime dt=new DateTime()    DateTimeFormatter fmt=DateTimeFormat.forPattern("MMMM, yyyy")    String dateString=fmt.print(dt)    Toast.makeText(HelloAndroidActivity.this,dateString,Toast.LENGTH_LONG).show()  } 
public EspressoSampleTest(){   super(HelloAndroidActivity.class)  } 
@Override protected void setUp() throws Exception {   super.setUp()    getActivity()  } 
@Override protected void tearDown() throws Exception {   super.tearDown()  } 
public void testClick(){   onView(withId(R.id.button_main)).check(matches(withText("Click !")))    onView(withId(R.id.button_main)).perform(click())    onView(withId(R.id.textview_hello)).check(matches(withText("42")))  } 
@Test public void shouldHaveApplicationName() throws Exception {   HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    String appName=activityUnderTest.getResources().getString(R.string.app_name)    assertThat(appName,equalTo("sonar-android-sample"))  } 
@Test public void shouldNotUseNullComputer() throws Exception {   HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    activityUnderTest.setComputer(null)    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertThat(textViewHelloString,equalTo("-"))  } 
@Test public void shouldUseDummyComputer() throws Exception {   final int EXPECTED_RESULT=42    HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertThat(textViewHelloString,equalTo(String.valueOf(EXPECTED_RESULT)))  } 
@Test public void shouldUseCustomComputerUsingEasyMock() throws Exception {   final int EXPECTED_RESULT=1    HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    Computer mockComputer=EasyMock.createMock(Computer.class)    EasyMock.expect(mockComputer.getResult()).andReturn(EXPECTED_RESULT)    activityUnderTest.setComputer(mockComputer)    EasyMock.replay(mockComputer)    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    EasyMock.verify(mockComputer)    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertThat(textViewHelloString,equalTo(String.valueOf(EXPECTED_RESULT)))  } 
@Test public void shouldUseCustomComputerUsingMockito() throws Exception {   final int EXPECTED_RESULT=1    HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    Computer mockComputer=Mockito.mock(Computer.class)    Mockito.when(mockComputer.getResult()).thenReturn(EXPECTED_RESULT)    activityUnderTest.setComputer(mockComputer)    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    Mockito.verify(mockComputer,Mockito.times(1)).getResult()    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertThat(textViewHelloString,equalTo(String.valueOf(EXPECTED_RESULT)))  } 
@BoundBox(boundClass=HelloAndroidActivity.class,maxSuperClass=FragmentActivity.class) @Test public void shouldUseCustomComputerUsingMockitoAndBoundBox() throws Exception {   final int EXPECTED_RESULT=1    HelloAndroidActivity activityUnderTest=Robolectric.buildActivity(HelloAndroidActivity.class).create().get()    BoundBoxOfHelloAndroidActivity boundBoxOfHelloAndroidActivity=new BoundBoxOfHelloAndroidActivity(activityUnderTest)    Computer mockComputer=Mockito.mock(Computer.class)    Mockito.when(mockComputer.getResult()).thenReturn(EXPECTED_RESULT)    boundBoxOfHelloAndroidActivity.setComputer(mockComputer)    boundBoxOfHelloAndroidActivity.boundBox_getButton().performClick()    Mockito.verify(mockComputer,Mockito.times(1)).getResult()    String textViewHelloString=boundBoxOfHelloAndroidActivity.boundBox_getTextView().getText().toString()    assertThat(textViewHelloString,equalTo(String.valueOf(EXPECTED_RESULT)))  } 
public HelloAndroidActivityBoundBoxTest(){   super(HelloAndroidActivity.class)  } 
@Override public void setUp() throws Exception {   boundBoxOfHelloAndroidActivity=new BoundBoxOfHelloAndroidActivity(getActivity())  } 
@UiThreadTest public void testCompute() throws Exception {   boundBoxOfHelloAndroidActivity.boundBox_getButton().performClick()    assertTrue(boundBoxOfHelloAndroidActivity.boundBox_getTextView().getText().equals("42"))  } 
public HelloAndroidActivityFestAndroidTest(){   super(HelloAndroidActivity.class)  } 
@Override public void setUp() throws Exception {   solo=new Solo(getInstrumentation(),getActivity())    textView=(TextView)getActivity().findViewById(R.id.textview_hello)  } 
public void testCompute() throws Exception {   solo.clickOnButton("Click !")    org.fest.assertions.api.ANDROID.assertThat(textView).containsText("42")  } 
@Override public void tearDown() throws Exception {   solo.finishOpenedActivities()  } 
public HelloAndroidActivityRobotiumTest(){   super(HelloAndroidActivity.class)  } 
@Override public void setUp() throws Exception {   solo=new Solo(getInstrumentation(),getActivity())  } 
public void testCompute() throws Exception {   solo.clickOnButton("Click !")    Assert.assertTrue(solo.searchText("42"))  } 
@Override public void tearDown() throws Exception {   solo.finishOpenedActivities()  } 
public HelloAndroidActivitySpoonTest(){   super(HelloAndroidActivity.class)  } 
@Override public void setUp() throws Exception {   solo=new Solo(getInstrumentation(),getActivity())    textView=(TextView)getActivity().findViewById(R.id.textview_hello)  } 
public void testCompute() throws Exception {   Spoon.screenshot(getActivity(),"initial_state")    solo.clickOnButton("Click !")    Spoon.screenshot(getActivity(),"button_clicked")    assertEquals("42",textView.getText().toString())  } 
@Override public void tearDown() throws Exception {   solo.finishOpenedActivities()  } 
public HelloAndroidActivityTest(){   super(HelloAndroidActivity.class)  } 
public void testActivity_not_null(){   assertNotNull(getActivity())  } 
@UiThreadTest public void testActivity_shouldUseCustomComputerUsingEasyMock() throws Exception {   final int EXPECTED_RESULT=1    HelloAndroidActivity activityUnderTest=getActivity()    Computer mockComputer=EasyMock.createMock(DummyComputer.class)    EasyMock.expect(mockComputer.getResult()).andReturn(EXPECTED_RESULT)    activityUnderTest.setComputer(mockComputer)    EasyMock.replay(mockComputer)    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    EasyMock.verify(mockComputer)    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertEquals(textViewHelloString,String.valueOf(EXPECTED_RESULT))  } 
@UiThreadTest public void testActivity_shouldUseCustomComputerUsingMockito() throws Exception {   final int EXPECTED_RESULT=1    HelloAndroidActivity activityUnderTest=getActivity()    Computer mockComputer=Mockito.mock(Computer.class)    Mockito.when(mockComputer.getResult()).thenReturn(EXPECTED_RESULT)    activityUnderTest.setComputer(mockComputer)    Button button=(Button)activityUnderTest.findViewById(R.id.button_main)    button.performClick()    Mockito.verify(mockComputer,Mockito.times(1)).getResult()    TextView textViewHello=(TextView)activityUnderTest.findViewById(R.id.textview_hello)    String textViewHelloString=textViewHello.getText().toString()    assertEquals(textViewHelloString,String.valueOf(EXPECTED_RESULT))  } 
private void takeScreenshot(String name){   getUiDevice().waitForIdle()    Screenshots.poseForScreenshotNamed(currentTestName + "_" + currentScreenshotIndex+++ "_"+ name)  } 
private void setCurrentTestName(String testName){   this.currentScreenshotIndex=0    this.currentTestName=testName    takeScreenshot("start")  } 
@Override protected void setUp() throws Exception {   super.setUp()    unlockEmulator()  } 
@Override protected void tearDown() throws Exception {   takeScreenshot("end")    getUiDevice().pressHome()    super.tearDown()  } 
@LargeTest @FlakyTest(tolerance=TEST_TOLERANCE) public void testSettingsApp() throws UiObjectNotFoundException {   setCurrentTestName("testSettingsApp")    startAppOnEmulator("Settings")    takeScreenshot("open")    UiObject settingsValidation=new UiObject(new UiSelector().packageName("com.android.settings"))    assertTrue("Unable to detect Settings",settingsValidation.exists())  } 
@LargeTest @FlakyTest(tolerance=TEST_TOLERANCE) public void testCalculatorApp() throws UiObjectNotFoundException {   setCurrentTestName("testCalculatorApp")    startAppOnEmulator("Calculator")    takeScreenshot("open")    UiObject deleteButton    deleteButton=new UiObject(new UiSelector().text("DELETE"))    deleteButton.waitForExists(CALCULATOR_UPDATE_TIMEOUT)    if (!deleteButton.exists()) {     deleteButton=new UiObject(new UiSelector().text("CLR"))    }   deleteButton.waitForExists(CALCULATOR_UPDATE_TIMEOUT)    deleteButton.click()    takeScreenshot("after_clear")    new UiObject(new UiSelector().text("7")).click()    takeScreenshot("after_7")    new UiObject(new UiSelector().text("+")).click()    takeScreenshot("after_plus")    new UiObject(new UiSelector().text("5")).click()    takeScreenshot("after_5")    new UiObject(new UiSelector().text("=")).click()    takeScreenshot("after_equal")    assertTrue(new UiObject(new UiSelector().text("12")).waitForExists(CALCULATOR_UPDATE_TIMEOUT))  } 
private void startAppOnEmulator(String appName) throws UiObjectNotFoundException {   getUiDevice().pressHome()    new UiObject(new UiSelector().description("Apps"))    UiObject allAppsButton=new UiObject(new UiSelector().description("Apps"))    allAppsButton.clickAndWaitForNewWindow()    UiObject appsTab=new UiObject(new UiSelector().text("Apps"))    appsTab.click()    UiScrollable appViews=new UiScrollable(new UiSelector().scrollable(true))    appViews.setAsHorizontalList()    appViews.setMaxSearchSwipes(MAX_SEARCH_SWIPES_IN_APP_MENU)    UiObject settingsApp=appViews.getChildByText(new UiSelector().className(android.widget.TextView.class.getName()),appName)    settingsApp.waitForExists(TIMEOUT_DURING_APP_SEARCH)    settingsApp.clickAndWaitForNewWindow()  } 
private void unlockEmulator(){   getUiDevice().pressKeyCode(KeyEvent.KEYCODE_SOFT_LEFT)    getUiDevice().pressKeyCode(KeyEvent.KEYCODE_SOFT_RIGHT)    getUiDevice().pressKeyCode(KeyEvent.KEYCODE_MENU)    getUiDevice().pressKeyCode(KeyEvent.KEYCODE_MENU)  } 
